
build/application/firmware.elf:     file format elf32-littlearm
build/application/firmware.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x000162f5

Program Header:
0x70000001 off    0x0001f59c vaddr 0x0001f59c paddr 0x0001f59c align 2**2
         filesz 0x00000008 memsz 0x00000008 flags r--
    LOAD off    0x00010000 vaddr 0x00010000 paddr 0x00010000 align 2**16
         filesz 0x0000f5a4 memsz 0x0000f5a4 flags r-x
    LOAD off    0x00020000 vaddr 0x10000000 paddr 0x0001f5a4 align 2**16
         filesz 0x000006bc memsz 0x000006bc flags rw-
    LOAD off    0x000206c0 vaddr 0x100006c0 paddr 0x100006c0 align 2**16
         filesz 0x00000000 memsz 0x00002d44 flags rw-
private flags = 5000400: [Version5 EABI] [hard-float ABI]

Sections:
Idx Name             Size      VMA       LMA       File off  Algn  Flags
  0 .text            0000f59c  00010000  00010000  00010000  2**4  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data            000006bc  10000000  0001f5a4  00020000  2**2  CONTENTS, ALLOC, LOAD, DATA
  2 .data_RAM2       00000000  20000000  20000000  000206bc  2**2  CONTENTS
  3 .bss             00002d44  100006c0  100006c0  000206c0  2**3  ALLOC
  4 .ARM.exidx       00000008  0001f59c  0001f59c  0001f59c  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .uninit_RESERVED 00000000  10000000  10000000  000206bc  2**2  CONTENTS
  6 .noinit_RAM2     00000000  20000000  20000000  000206bc  2**2  CONTENTS
  7 .noinit          00000000  10003404  10003404  000206bc  2**2  CONTENTS
  8 .ARM.attributes  00000030  00000000  00000000  000206bc  2**0  CONTENTS, READONLY
  9 .comment         0000007e  00000000  00000000  000206ec  2**0  CONTENTS, READONLY
 10 .debug_info      00061127  00000000  00000000  0002076a  2**0  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev    0000656f  00000000  00000000  00081891  2**0  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges   00001480  00000000  00000000  00087e00  2**0  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges    000013a0  00000000  00000000  00089280  2**0  CONTENTS, READONLY, DEBUGGING
 14 .debug_line      0000a40f  00000000  00000000  0008a620  2**0  CONTENTS, READONLY, DEBUGGING
 15 .debug_str       0001b143  00000000  00000000  00094a2f  2**0  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame     00005044  00000000  00000000  000afb74  2**2  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
10000000 l    d  .data	00000000 .data
20000000 l    d  .data_RAM2	00000000 .data_RAM2
100006c0 l    d  .bss	00000000 .bss
0001f59c l    d  .ARM.exidx	00000000 .ARM.exidx
10000000 l    d  .uninit_RESERVED	00000000 .uninit_RESERVED
20000000 l    d  .noinit_RAM2	00000000 .noinit_RAM2
10003404 l    d  .noinit	00000000 .noinit
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 interrupt.cpp
00016560 l     F .text	0000002c NVIC_EnableIRQ
0001658c l     F .text	00000054 NVIC_SetPriority
00010000 l     O .text	000000e4 kInterruptVectorTable
0001e36c l     O .text	0000000e InterruptLookupHandler::file
0001e37c l     O .text	0000001e InterruptLookupHandler::__PRETTY_FUNCTION__
0001022c l       .text	00000000 handler2_address_const
00000000 l    df *ABS*	00000000 startup.cpp
1000054c l     O .data	00000008 (anonymous namespace)::system_timer
10000554 l     O .data	00000004 (anonymous namespace)::system_controller
10000558 l     O .data	0000000c (anonymous namespace)::timer0
00016110 l     F .text	00000040 (anonymous namespace)::Lpc40xxUptime()
10002fd4 l     O .bss	00000060 idle_task_tcb
10003034 l     O .bss	00000140 idle_task_stack
0001e080 l     O .text	0000000c LowLevelInit()::file
0001e100 l     O .text	00000014 LowLevelInit()::__PRETTY_FUNCTION__
000102fc l     O .text	00000004 kCrpWord
00016474 l     F .text	000000dc __static_initialization_and_destruction_0(int, int)
00016550 l     F .text	0000000e _GLOBAL__sub_I_UptimeRTOS
00000000 l    df *ABS*	00000000 /home/osboxes/SJSU-Dev2/tools/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/thumb/v7e-m/fpv4-sp/hard/crti.o
00000000 l    df *ABS*	00000000 /home/osboxes/SJSU-Dev2/tools/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/thumb/v7e-m/fpv4-sp/hard/crtn.o
00000000 l    df *ABS*	00000000 crtstuff.c
0001032c l     F .text	00000000 __do_global_dtors_aux
100006c0 l       .bss	00000001 completed.9929
00010350 l     F .text	00000000 frame_dummy
100006c4 l       .bss	00000018 object.9934
0001030c l     O .text	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 MP3Decoder.cpp
100006e0 l     O .bss	00000008 (anonymous namespace)::uptime
00010430 l     F .text	00000030 (anonymous namespace)::DefaultUptime()
10000790 l     O .bss	00000018 MP3_Decoder::scan_files(char*)::fno
00010f94 l     F .text	00000194 __static_initialization_and_destruction_0(int, int)
00011128 l     F .text	00000028 _GLOBAL__sub_I_data_trans
00000000 l    df *ABS*	00000000 main1.cpp
0001d938 l     O .text	00000049 Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::__PRETTY_FUNCTION__
0001d9e0 l     O .text	0000005c Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__
0001d984 l     O .text	0000005a Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__
0001da3c l     O .text	0000003a Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::__PRETTY_FUNCTION__
0001da78 l     O .text	0000003e Timer::Initialize(unsigned long, void (*)(), long)::__PRETTY_FUNCTION__
0001d81c l     O .text	0000001c Gpio::ValidPortCheck()::__PRETTY_FUNCTION__
0001d838 l     O .text	00000039 Gpio::SetInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__
0001d7e0 l     O .text	0000003b Gpio::ClearInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__
0001d910 l     O .text	00000025 OnBoardLed::On(unsigned char)::__PRETTY_FUNCTION__
0001d8e8 l     O .text	00000026 OnBoardLed::Off(unsigned char)::__PRETTY_FUNCTION__
0001d8a0 l     O .text	00000047 OnBoardLed::Set(unsigned char, OnBoardLedInterface::LightState)::__PRETTY_FUNCTION__
0001d874 l     O .text	00000029 OnBoardLed::Toggle(unsigned char)::__PRETTY_FUNCTION__
000150d0 l     F .text	00000144 __static_initialization_and_destruction_0(int, int)
00015214 l     F .text	00000028 _GLOBAL__sub_I_mp3
00000000 l    df *ABS*	00000000 diskio.cpp
0001f410 l     O .text	00000031 Sd::Mount(SdInterface::CardInfo_t*)::__PRETTY_FUNCTION__
0001f444 l     O .text	0000003c Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::__PRETTY_FUNCTION__
0001f480 l     O .text	00000034 Sd::DeleteBlock(unsigned long, unsigned long)::__PRETTY_FUNCTION__
0001f4b4 l     O .text	00000069 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::__PRETTY_FUNCTION__
10003384 l     O .bss	00000068 (anonymous namespace)::sd_card
100033ec l     O .bss	00000001 (anonymous namespace)::initialized
00019d44 l     F .text	00000050 __static_initialization_and_destruction_0(int, int)
00019d94 l     F .text	00000028 _GLOBAL__sub_I_disk_status
00000000 l    df *ABS*	00000000 LabSPI.cpp
00000000 l    df *ABS*	00000000 LabGPIO.cpp
00000000 l    df *ABS*	00000000 newlib.cpp
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 tasks.c
1000327c l     O .bss	00000064 pxReadyTasksLists
100032e0 l     O .bss	00000014 xDelayedTaskList1
100032f4 l     O .bss	00000014 xDelayedTaskList2
10003308 l     O .bss	00000004 pxDelayedTaskList
1000330c l     O .bss	00000004 pxOverflowDelayedTaskList
10003310 l     O .bss	00000014 xPendingReadyList
10003324 l     O .bss	00000014 xTasksWaitingTermination
10003338 l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
1000333c l     O .bss	00000014 xSuspendedTaskList
10003350 l     O .bss	00000004 uxCurrentNumberOfTasks
10003354 l     O .bss	00000004 xTickCount
10003358 l     O .bss	00000004 uxTopReadyPriority
1000335c l     O .bss	00000004 xSchedulerRunning
10003360 l     O .bss	00000004 uxPendedTicks
10003364 l     O .bss	00000004 xYieldPending
10003368 l     O .bss	00000004 xNumOfOverflows
1000336c l     O .bss	00000004 uxTaskNumber
10003370 l     O .bss	00000004 xNextTaskUnblockTime
10003374 l     O .bss	00000004 xIdleTaskHandle
10003378 l     O .bss	00000004 uxSchedulerSuspended
1000337c l     O .bss	00000004 ulTaskSwitchedInTime
10003380 l     O .bss	00000004 ulTotalRunTime
00016b44 l     F .text	000000f2 prvInitialiseNewTask
00016c38 l     F .text	000000dc prvAddNewTaskToReadyList
00017108 l     F .text	0000007c prvInitialiseTaskLists
000171dc l     F .text	0000003a prvDeleteTCB
00017218 l     F .text	00000040 prvResetNextTaskUnblockTime
000170fc l     F .text	0000000c prvIdleTask
00017184 l     F .text	00000058 prvCheckTasksWaitingTermination
00000000 l    df *ABS*	00000000 port.c
10000650 l     O .data	00000004 uxCriticalNesting
000172b8 l     F .text	00000026 prvTaskExitError
00017300 l       .text	00000000 pxCurrentTCBConst2
00017308 l     F .text	00000024 prvPortStartFirstTask
00017488 l     F .text	00000010 vPortEnableVFP
00017440 l       .text	00000000 pxCurrentTCBConst
00000000 l    df *ABS*	00000000 heap_3.c
00000000 l    df *ABS*	00000000 printf.cpp
000174e0 l     F .text	00000044 _out_buffer(char, void*, unsigned int, unsigned int)
00017524 l     F .text	00000030 _out_null(char, void*, unsigned int, unsigned int)
00017554 l     F .text	00000044 _out_char(char, void*, unsigned int, unsigned int)
00017598 l     F .text	00000044 _strlen(char const*)
000175dc l     F .text	00000044 _is_digit(char)
00017620 l     F .text	00000060 _atoi(char const**)
00017680 l     F .text	0000025c _ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)
000178dc l     F .text	000000e4 _ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)
000179c0 l     F .text	000000f4 _ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)
0001e3cc l     O .text	00000028 _ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)::pow10
00017ab4 l     F .text	00000438 _ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)
00017eec l     F .text	000008f4 _vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)
00000000 l    df *ABS*	00000000 ff.c
100033f0 l     O .bss	00000004 FatFs
100033f4 l     O .bss	00000002 Fsid
00019dbc l     F .text	0000004c ld_word
00019e08 l     F .text	0000005c ld_dword
00019e64 l     F .text	00000054 st_word
00019eb8 l     F .text	0000006c st_dword
00019f24 l     F .text	00000054 mem_cpy
00019f78 l     F .text	00000048 mem_set
00019fc0 l     F .text	00000064 mem_cmp
0001a024 l     F .text	0000004c chk_chr
0001a070 l     F .text	00000060 dbc_1st
0001a0d0 l     F .text	00000078 dbc_2nd
0001a148 l     F .text	00000098 sync_window
0001a1e0 l     F .text	0000007c move_window
0001a25c l     F .text	000000fc sync_fs
0001a358 l     F .text	00000054 clst2sect
0001a3ac l     F .text	00000164 get_fat
0001a510 l     F .text	000001fc put_fat
0001a70c l     F .text	000000f0 remove_chain
0001a7fc l     F .text	000001c4 create_chain
0001a9c0 l     F .text	000000ac dir_clear
0001aa6c l     F .text	00000110 dir_sdi
0001ab7c l     F .text	00000144 dir_next
0001acc0 l     F .text	000000b8 dir_alloc
0001ad78 l     F .text	00000058 ld_clust
0001add0 l     F .text	00000058 st_clust
0001ae28 l     F .text	000000f4 dir_read
0001af1c l     F .text	000000d8 dir_find
0001aff4 l     F .text	00000088 dir_register
0001b07c l     F .text	000000ec get_fileinfo
0001b168 l     F .text	000001a4 create_name
0001b30c l     F .text	00000110 follow_path
0001b41c l     F .text	000000a8 get_ldnumber
0001b4c4 l     F .text	000000c4 check_fs
0001b588 l     F .text	000004dc find_volume
0001ba64 l     F .text	0000008c validate
00000000 l    df *ABS*	00000000 pure.cc
00000000 l    df *ABS*	00000000 eh_terminate.cc
00000000 l    df *ABS*	00000000 sf_round.c
00000000 l    df *ABS*	00000000 _arm_truncdfsf2.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 abort.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 nano-mallocr.c
00000000 l    df *ABS*	00000000 nano-mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 signal.c
00000000 l    df *ABS*	00000000 signalr.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 lib_a-strlen.o
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 findfp.c
00000000 l    df *ABS*	00000000 eh_term_handler.cc
00000000 l    df *ABS*	00000000 impure.c
1000065c l     O .data	00000060 impure_data
00000000 l    df *ABS*	00000000 reent.c
000116f0  w    F .text	0000003e Lpc40xxSystemController::GetPeripheralFrequency() const
100026f8 g     O .bss	00000003 S3
0001685c g     F .text	00000038 putchar
000165e0  w    F .text	0000006c Pwm0IrqHandler
0001d4b8  w    O .text	00000009 Gpio::SetInterruptEdge(GpioInterface::Edge)::file
00010218 g     F .text	0000001c HardFaultHandler
0001cb40 g     F .text	00000010 strcpy
00016774 g     F .text	00000024 _getpid
00016820 g     F .text	0000003c _putchar
000165e0  w    F .text	0000006c EepromIrqHandler
000165e0  w    F .text	0000006c Timer2IrqHandler
10000538  w    O .data	00000014 uart0
00016960 g     F .text	0000002c GetStackDepth()
0001d4d0  w    O .text	00000010 OnBoardLed::On(unsigned char)::file
0001f320  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
000115b8  w    F .text	00000024 Lpc40xxSystemController::Lpc40xxSystemController()
0001d48c  w    O .text	00000004 Timer::kTimerIrq
000173ac g     F .text	00000028 vPortExitCritical
0001f358  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
0001cb18 g     F .text	00000024 _kill_r
0001010c g       .text	00000000 bss_section_table_end
000187e0 g     F .text	0000004c printf
100004e4  w    O .data	00000004 SystemTimer::sys_tick
000165e0  w    F .text	0000006c I2c1IrqHandler
00014c60  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)2>()
100004e8  w    O .data	00000010 Uart::uart
0001f388  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00010000 g       *ABS*	00000000 __vectors_start__
0001080c  w    F .text	00000090 Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)
0001cb62 g     F .text	00000002 __malloc_unlock
00010460  w    F .text	00000044 Milliseconds()
100004cc  w    O .data	00000018 LabGPIO::ports
10000788 g     O .bss	00000003 SW1
00011854  w    F .text	00000110 Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)
00013c6c  w    F .text	00000094 Ssd1306::Ssd1306()
00013074  w    F .text	00000034 SspInterface::SspInterface()
000165e0  w    F .text	0000006c BusFaultHandler
10003174 g     O .bss	00000100 stack_trace
1000004c  w    O .data	00000004 Pin::pin_map
0001595c  w    F .text	000000e4 Uart::Initialize(unsigned long)
20000000 g       *ABS*	00000000 __base_RAM2
10000784 g     O .bss	00000003 SW2
00013c6c  w    F .text	00000094 Ssd1306::Ssd1306()
0001f5a4 g       .ARM.exidx	00000000 __exidx_end
00012bf8  w    F .text	0000007c Gpio::ClearEdgeRising()
00011b3c  w    F .text	00000030 Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)
100008bc g     O .bss	000011d8 mp3
0001d4ac  w    O .text	00000009 Gpio::ValidPortCheck()::file
0001458c  w    F .text	0000006c OledTerminal::OledTerminal()
10003278 g     O .bss	00000004 pxCurrentTCB
00011b6c  w    F .text	00000034 PinInterface::PinInterface()
0001549c g     F .text	00000034 LabGPIO::EnableInterrupts()
0001691c g     F .text	0000001c __cyg_profile_func_exit
000199dc  w    F .text	00000048 Sd::Crc7Add(unsigned char, unsigned char)
000188f4  w    F .text	000000a0 Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)
00014ef0  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()
10003400 g     O .bss	00000004 errno
0001f5a4 g       .ARM.exidx	00000000 _etext
10000044  w    O .data	00000004 Lpc40xxSystemController::system_controller
000115dc  w    F .text	00000090 Lpc40xxSystemController::SetClockFrequency(unsigned char)
0001233c  w    F .text	00000030 unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)
000116dc  w    F .text	00000014 Lpc40xxSystemController::GetSystemFrequency() const
00015f20  w    F .text	000001f0 Uart::GenerateUartCalibration(float)
10000014  w    O .data	00000018 Gpio::gpio_port
0001236c  w    F .text	000000f8 Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)
0001621c  w    F .text	000000bc LowLevelInit()
000165e0  w    F .text	0000006c LcdIrqHandler
0001f3b0  w    O .text	00000007 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file
00080000 g       *ABS*	00000000 __top_MFlash512
000107a0  w    F .text	0000006c Ssp::Transfer(unsigned short)
10000780 g     O .bss	00000003 SW3
00015bc0  w    F .text	000000f8 Uart::Receive(unsigned long)
000117f4  w    F .text	00000030 Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)
00014534  w    F .text	00000058 OledTerminal::Clear()
000105c0  w    F .text	00000030 Delay(unsigned long long)
0001e070  w    O .text	00000010 Uart::kPowerbit
000165e0  w    F .text	0000006c I2c2IrqHandler
10002fd0  w    O .bss	00000004 SystemTimer::system_timer_isr
00012ac0  w    F .text	00000040 Gpio::DetachInterrupt()
000165e0  w    F .text	0000006c CanIrqHandler
00012e60  w    F .text	0000009c OnBoardLed::Set(unsigned char, OnBoardLedInterface::LightState)
00017330 g     F .text	00000054 xPortStartScheduler
000120a8  w    F .text	00000074 Pin::EnableDac(bool)
00015370 g     F .text	00000050 LabGPIO::ReadBool()
000161f0 g     F .text	0000002c vPortSetupTimerInterrupt
00014400  w    F .text	00000048 OledTerminal::SetCursor(unsigned int, unsigned int)
00011dd8  w    F .text	0000007c Pin::SetAsAnalogMode(bool)
00017448 g     F .text	00000040 xPortSysTickHandler
00011ad4  w    F .text	00000068 Lpc40xxSystemController::SetCpuClockDivider(unsigned char)
00019c1c g     F .text	00000068 disk_initialize
00019a94  w    F .text	000000fc Sd::GetCrc16(unsigned char*, unsigned short)
0001c5c0 g     F .text	00000000 .hidden __aeabi_uldivmod
10003404 g       .noinit	00000000 _noinit
00016894 g     F .text	00000060 puts
000174be g     F .text	00000022 vPortFree
10000564 g     O .data	000000e4 dynamic_isr_vector_table
000127e0  w    F .text	0000002c Gpio::GetPin()
00011240 g     F .text	000000a0 LabSPI::SetPinMode()
00012888  w    F .text	0000005c Gpio::SetInterruptRoutine(void (*)())
000124a0  w    F .text	00000034 GpioInterface::GpioInterface()
00013074  w    F .text	00000034 SspInterface::SspInterface()
000165e0  w    F .text	0000006c RitIrqHandler
000165e0  w    F .text	0000006c Uart2IrqHandler
0001211c  w    F .text	00000064 Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)
0001d464  w    O .text	00000016 Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::file
0001f340  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00010b14 g     F .text	0000009c MP3_Decoder::WriteRegister(unsigned char, unsigned short)
0001c918 g     F .text	00000010 malloc
000135f4  w    F .text	00000160 Ssp::GetPeripheralMode()
00014f90  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()
0001c4c0 g     F .text	00000060 roundf
0001cab8 g     F .text	00000050 _raise_r
000104d0  w    F .text	0000002c Wait(unsigned long long)::{lambda()#1}::_FUN()
000106fc  w    F .text	0000002c int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)
000130a8  w    F .text	00000038 PinInterface::PinInterface(PinInterface const&)
1000076c g     O .bss	00000003 XCS
10010000 g       *ABS*	00000000 __top_RAM
0001e06c  w    O .text	00000004 Uart::kRxUartPortFunction
000173e0 g     F .text	00000066 xPortPendSVHandler
0001887c g     F .text	00000044 vsnprintf
000104fc  w    F .text	000000c4 Wait(unsigned long long)
000188c0  w    F .text	00000034 SdInterface::SdInterface()
00012464  w    F .text	0000003c Timer::GetTimer()
10000000 g       *ABS*	00000000 __base_RamLoc64
000153c0 g     F .text	000000dc LabGPIO::GPIOInterruptHandler()
00016938 g     F .text	00000028 GetStackTrace()
1000064c g     O .data	00000004 out
000169d2 g     F .text	0000003e vListInsertEnd
10000048  w    O .data	00000004 Lpc40xxSystemController::speed_in_hertz
0001f390  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
0001f378  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
0001cb3c g     F .text	00000004 _getpid_r
00019b90 g     F .text	0000008c disk_status
10001ef4 g     O .bss	00000800 buff
00000000 g       *ABS*	00000000 __base_MFlash512
0001d5c0  w    O .text	0000004c vtable for Ssp
10010000 g       *ABS*	00000000 StackTop
00010c28 g     F .text	0000006c MP3_Decoder::HardReset()
00018da4  w    F .text	00000064 Sd::WaitToReadBlock()
0001d510  w    O .text	00000003 Ssp::kPinSelect
00010920  w    F .text	00000038 Graphics::Clear()
00013d58  w    F .text	00000068 Ssd1306::AvailableColors()
0001c5f0 g     F .text	000002cc .hidden __udivmoddi4
000165e0  w    F .text	0000006c I2sIrqHandler
0001ca98 g     F .text	00000020 _sbrk_r
000100fc g       .text	00000000 bss_section_table
000144e4  w    F .text	00000050 OledTerminal::ClearRow(unsigned int)
10001a94 g     O .bss	00000230 tester
00010300 g       .text	00000000 __CRP_WORD_END__
20008000 g       *ABS*	00000000 __top_RAM2
0001c3a0 g     F .text	0000004c f_closedir
000162f4 g     F .text	00000030 ResetIsr
000169c2 g     F .text	00000010 vListInitialiseItem
0001d568  w    O .text	0000002c vtable for Ssd1306
00018d60  w    F .text	00000044 Sd::ToBool(bool)
00019d0c g     F .text	00000038 disk_ioctl
0001d60c  w    O .text	00000028 vtable for SspInterface
000165e0  w    F .text	0000006c PendSVHandler
10000078  w    O .data	00000400 font8x8_basic
10001eec g     O .bss	00000004 br
00013358  w    F .text	00000030 unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)
0001570c  w    F .text	00000034 SystemTimer::SetIsrFunction(void (*)())
00010f50  w    F .text	00000044 bool bit::Read<unsigned long>(unsigned long, unsigned long)
00010728  w    F .text	00000078 Ssp::IsTransferRegBusy()
000165e0  w    F .text	0000006c UsageFaultHandler
20000000 g       *ABS*	00000000 __user_heap_base
000140c8  w    F .text	0000008c Graphics::Graphics(PixelDisplayInterface*)
0001f59c g       .text	00000000 __exidx_start
00011fc0  w    F .text	00000074 Pin::EnableI2cHighCurrentDrive(bool)
000165e0  w    F .text	0000006c Uart4IrqHandler
000128e4  w    F .text	00000054 Gpio::ClearInterruptRoutine()
00011f44  w    F .text	0000007c Pin::EnableI2cHighSpeedMode(bool)
000101fc g     F .text	00000018 InitFpu()
00011e54  w    F .text	0000007c Pin::EnableDigitalFilter(bool)
00012d60  w    F .text	00000080 OnBoardLed::On(unsigned char)
00013d00  w    F .text	0000002c Ssd1306::GetWidth()
0001c8d0 g     F .text	00000048 __libc_init_array
000165e0 g     F .text	0000006c InterruptLookupHandler
00011824  w    F .text	00000030 Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)
000116c4  w    F .text	00000018 Lpc40xxSystemController::GetPeripheralClockDivider() const
10000000  w    O .data	00000004 Uptime
0001d6a0  w    O .text	00000048 vtable for GpioInterface
00015a8c  w    F .text	000000e8 Uart::Send(unsigned char)
0001c8c0 g     F .text	0000000e abort
10002700 g     O .bss	00000003 S1
000165e0  w    F .text	0000006c BodIrqHandler
000167c8 g     F .text	00000058 _sbrk
0001749c g     F .text	00000022 pvPortMalloc
00012ffc  w    F .text	00000078 OnBoardLed::GetStates()
00013940  w    F .text	00000184 Ssp::GetClock()
000145f8  w    F .text	0000006c MP3_Decoder::MP3_Decoder()
10000728 g     O .bss	00000040 data_trans
00010300 g     F .text	00000000 _init
0001010c g       .text	00000000 section_table_end
00015030  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()
0001698c g     F .text	00000036 vListInitialise
0001c4b4 g     F .text	0000000a std::terminate()
0001c520 g     F .text	0000009e .hidden __aeabi_d2f
00012c74  w    F .text	0000007c Gpio::ClearEdgeFalling()
000165e0  w    F .text	0000006c SysTickHandler
000100e4 g       .text	00000000 section_table_start
10003404 g       .bss	00000000 _ebss
00014054  w    F .text	00000074 Ssd1306::Update()
00012b7c  w    F .text	0000007c Gpio::SetEdgeFalling()
0001f350  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
000165e0  w    F .text	0000006c RtcIrqHandler
00012770  w    F .text	00000070 Gpio::Read()
000140c8  w    F .text	0000008c Graphics::Graphics(PixelDisplayInterface*)
00016324  w    F .text	000000a8 Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})
eff7036e g       *ABS*	00000000 ValidUserCodeChecksum
000165e0  w    F .text	0000006c Uart0IrqHandler
000166a8 g     F .text	00000078 GetRegistersFromStack
00014cd8  w    F .text	0000003c unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)
00010958  w    F .text	0000004c OledTerminal::Initialize()
00010d68 g     F .text	00000038 MP3_Decoder::waitDREQ()
00010c94 g     F .text	000000d4 MP3_Decoder::SoftReset()
000108e8  w    F .text	00000038 Graphics::Update()
000103bc  w    F .text	00000074 LabSPI::LabSPI(unsigned char)
0001d75c  w    O .text	0000003c vtable for PinInterface
000165e0  w    F .text	0000006c UsbIrqHandler
000165e0  w    F .text	0000006c AdcIrqHandler
00015b74  w    F .text	0000004c Uart::Receive(unsigned long)::{lambda()#1}::operator()() const
10000478 g     O .data	00000054 led
0001566c  w    F .text	00000030 SetUptimeFunction(unsigned long long (*)())
0001036c  w    F .text	00000050 LabGPIO::LabGPIO(unsigned char, unsigned char)
0001f53c g     O .text	00000020 __sf_fake_stderr
00013ac4  w    F .text	00000094 PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)
0001f020  w    O .text	00000100 Sd::kCrcTable8
0001c4a4 g     F .text	00000010 std::get_terminate()
00015e28  w    F .text	00000074 Uart::FractionalEstimate(float, float)
00012968  w    F .text	00000088 Gpio::SetInterruptEdge(GpioInterface::Edge)
000165e0  w    F .text	0000006c EnetIrqHandler
000165e0  w    F .text	0000006c DmaIrqHandler
0001010c g     F .text	00000090 InitDataSection()
0001664c g     F .text	0000005c RegisterIsr(IRQn, void (*)(), bool, long)
0001523c g     F .text	00000058 LabGPIO::SetAsInput()
00000000 g       *ABS*	00000000 __base_Flash
000165e0  w    F .text	0000006c Eint1IrqHandler
1000002c  w    O .data	0000000c Ssp::ssp_registers
000165e0  w    F .text	0000006c SvcHandler
000142a8  w    F .text	00000158 OledTerminal::printf(char const*, ...)
000165e0  w    F .text	0000006c GpioIrqHandler
0001c948 g     F .text	0000009c _free_r
0001f3a0  w    O .text	00000007 Sd::DeleteBlock(unsigned long, unsigned long)::file
000165e0  w    F .text	0000006c SdioIrqHandler
10010000 g       *ABS*	00000000 __top_RamLoc64
100006c0 g       .bss	00000000 _bss
10000768 g     O .bss	00000003 DREQ
0001f338  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
0001c260 g     F .text	00000060 f_close
000165e0  w    F .text	0000006c Pll1IrqHandler
000165e0  w    F .text	0000006c MemManageHandler
00013be8  w    F .text	00000028 PixelDisplayInterface::Disable()
00016db0 g     F .text	00000014 vTaskSuspendAll
00015294 g     F .text	00000054 LabGPIO::SetAsOutput()
0001c494 g     F .text	00000006 __cxa_pure_virtual
00014250  w    F .text	00000058 Graphics::DrawPixel(unsigned long, unsigned long)
000145f8  w    F .text	0000006c MP3_Decoder::MP3_Decoder()
000165e0  w    F .text	0000006c Pwm1IrqHandler
00016a10 g     F .text	0000004a uxListRemove
00012938  w    F .text	00000030 unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)
000165e0  w    F .text	0000006c Timer0IrqHandler
000163cc  w    F .text	000000a8 Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})
0001bec4 g     F .text	0000027c f_read
00013d2c  w    F .text	0000002c Ssd1306::GetHeight()
00080000 g       *ABS*	00000000 __top_Flash
00015e9c  w    F .text	00000084 Uart::IsDecmial(float)
00013754  w    F .text	000001ec Ssp::SetClock(bool, bool, unsigned char, unsigned char)
00014448  w    F .text	0000009c OledTerminal::Update()
0001c3ec g     F .text	000000a8 f_readdir
00016a5a g     F .text	0000005c xTaskCreateStatic
10003404 g       .noinit	00000000 _end_noinit
0001569c  w    F .text	0000003c SystemTimer::DisableTimer()
0001941c  w    F .text	00000120 Sd::DeleteBlock(unsigned long, unsigned long)
00017034 g     F .text	000000c8 vTaskSwitchContext
00014d88  w    F .text	00000054 unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)
00012de0  w    F .text	00000080 OnBoardLed::Off(unsigned char)
00011ba0  w    F .text	00000058 Pin::Pin(unsigned char, unsigned char)
00010da0 g     F .text	00000104 MP3_Decoder::scan_files(char*)
000133b8  w    F .text	00000030 unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)
0001f360  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
0001e068  w    O .text	00000004 Uart::kTxUartPortFunction
00014154  w    F .text	000000fc Graphics::DrawCharacter(long, long, char, bool)
000165e0  w    F .text	0000006c Uart3IrqHandler
000115a0  w    F .text	00000018 SystemControllerInterface::SystemControllerInterface()
0001f398  w    O .text	00000007 Sd::DeleteBlock(unsigned long, unsigned long)::file
10001ef2 g     O .bss	00000002 byte_count
20000000 g       *ABS*	00000000 __base_RamPeriph32
00013fc0  w    F .text	00000094 Ssd1306::DrawPixel(long, long, PixelDisplayInterface::Color_t)
000161bc g     F .text	00000034 vApplicationGetIdleTaskMemory
1000077c g     O .bss	00000003 XRESET
0001d4c4  w    O .text	00000009 Gpio::ClearInterruptEdge(GpioInterface::Edge)::file
10003274 g     O .bss	00000004 stack_depth
0001268c  w    F .text	0000006c Gpio::Toggle()
0001f370  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
0001f120  w    O .text	00000200 Sd::kCrcTable16
100007bc  w    O .bss	00000100 Gpio::interrupthandlers
0001c8bc  w    F .text	00000002 .hidden __aeabi_ldiv0
000165e0  w    F .text	0000006c Timer1IrqHandler
10002708 g     O .bss	000007c8 tt
00013b58  w    F .text	00000068 PixelDisplayInterface::Color_t::Color_t()
00015db4  w    F .text	00000074 Uart::DividerEstimate(float, float)
000105f0  w    F .text	00000064 Gpio::SetHigh()
0001d634  w    O .text	00000024 vtable for OnBoardLed
00015cb8  w    F .text	000000fc Uart::FindClosestFractional(float)
00014884 g     F .text	00000220 play(void*)
00013134  w    F .text	000000e4 Ssp::Ssp(Ssp::Peripheral)
000100e4 g       .text	00000000 data_section_table
00011c70  w    F .text	00000080 Pin::SetMode(PinInterface::Mode)
0001d41c  w    O .text	00000016 Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file
00018e08  w    F .text	00000050 Sd::WaitWhileBusy()
0001cb60 g     F .text	00000002 __malloc_lock
000157dc  w    F .text	00000094 SystemTimer::SetTickFrequency(unsigned long)
0001470c g     F .text	00000088 SW2ISR()
0001f55c g     O .text	00000020 __sf_fake_stdin
00014ddc  w    F .text	00000074 unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)
000102fc g       .text	00000000 __CRP_WORD_START__
0001d490  w    O .text	00000010 Timer::kTimerIsr
00013dc0  w    F .text	000000f0 Ssd1306::InitializationPanel()
00012a78  w    F .text	00000048 Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)
000165e0  w    F .text	0000006c Uart1IrqHandler
00012550  w    F .text	0000007c Gpio::SetAsInput()
000168f4 g     F .text	00000028 __cyg_profile_func_enter
0001c938 g     F .text	00000010 memset
00014aa4 g     F .text	00000144 main
000188f4  w    F .text	000000a0 Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)
10000050  w    O .data	00000028 Gpio::interrupt
00015870  w    F .text	00000020 Timer::DoNothingIsr()
000165e0  w    F .text	0000006c QeiIrqHandler
0001c140 g     F .text	00000120 f_sync
20000000 g       *ABS*	00000000 heap
000165e0  w    F .text	0000006c Ssp2IrqHandler
00012180  w    F .text	0000002c Pin::GetPort() const
00019270  w    F .text	000001ac Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)
00011ba0  w    F .text	00000058 Pin::Pin(unsigned char, unsigned char)
0001c520 g     F .text	0000009e .hidden __truncdfsf2
00010320 g       .text	00000000 __init_array_end
000172e0 g     F .text	00000026 vPortSVCHandler
00016720 g     F .text	0000003c FirmwareStdOut(int)
10002ed0  w    O .bss	00000100 LabGPIO::isr_map
0001c9e4 g     F .text	000000b4 _malloc_r
000109a4 g     F .text	000000e8 MP3_Decoder::initialize()
0001f3b8  w    O .text	0000002c vtable for Sd
000129f0  w    F .text	00000088 Gpio::ClearInterruptEdge(GpioInterface::Edge)
000165e0  w    F .text	0000006c Ssp1IrqHandler
00014be8  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)0>()
0001baf0 g     F .text	0000009c f_mount
0001d55c  w    O .text	0000000c Ssp::kPowerBit
0001c2c0 g     F .text	000000e0 f_opendir
000121ac  w    F .text	0000002c Pin::GetPin() const
00015890  w    F .text	000000cc Uart::SetBaudRate(unsigned long)
10001cc4 g     O .bss	00000228 dir
0001e08c  w    O .text	0000003c vtable for Uart
00012648  w    F .text	00000044 Gpio::SetDirection(GpioInterface::Direction)
000125cc  w    F .text	0000007c Gpio::SetAsOutput()
0001f380  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00011964  w    F .text	00000170 Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)
0001458c  w    F .text	0000006c OledTerminal::OledTerminal()
00010654  w    F .text	00000064 Gpio::SetLow()
0001d798  w    O .text	00000024 vtable for Lpc40xxSystemController
00018e58  w    F .text	00000418 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)
0001f3a8  w    O .text	00000007 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file
0001d404  w    O .text	00000016 Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::file
00011420 g     F .text	00000080 LabSPI::Transfer(unsigned char)
000162d8 g     F .text	0000001a SystemInit
00012208  w    F .text	00000134 Timer::Initialize(unsigned long, void (*)(), long)
00011730  w    F .text	00000030 Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)
20008000 g       *ABS*	00000000 heap_end
00013218  w    F .text	000000e4 Ssp::Initialize()
0001d6e8  w    O .text	00000038 vtable for Timer
000130a8  w    F .text	00000038 PinInterface::PinInterface(PinInterface const&)
10000004  w    O .data	00000010 Timer::tim_register
000165e0  w    F .text	0000006c Ssp0IrqHandler
0001036c  w    F .text	00000050 LabGPIO::LabGPIO(unsigned char, unsigned char)
00010320 g     F .text	00000000 _fini
100026fc g     O .bss	00000003 S2
000165e0  w    F .text	0000006c UsbactivityIrqHandler
000106b8  w    F .text	00000044 Gpio::Set(GpioInterface::State)
000165e0  w    F .text	0000006c Pll0IrqHandler
00016dc4 g     F .text	00000118 xTaskResumeAll
000130e0  w    F .text	00000054 Pin::Pin(Pin const&)
000100fc g       .text	00000000 data_section_table_end
000165e0  w    F .text	0000006c CanactivityIrqHandler
0001882c g     F .text	00000050 sprintf
00016d14 g     F .text	0000009c vTaskStartScheduler
000103bc  w    F .text	00000074 LabSPI::LabSPI(unsigned char)
000165e0  w    F .text	0000006c NmiHandler
00013b58  w    F .text	00000068 PixelDisplayInterface::Color_t::Color_t()
10000770 g     O .bss	00000003 CS_SD
00013c10  w    F .text	00000028 PixelDisplayInterface::Update()
0001d514  w    O .text	00000048 Ssp::kSspPinMatrix
00013f34  w    F .text	00000054 Ssd1306::SetHorizontalAddressMode()
000126f8  w    F .text	00000078 Gpio::ReadState()
0001f348  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
10000658 g     O .data	00000004 _impure_ptr
00010ea4  w    F .text	000000ac Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})
10000000 g       .uninit_RESERVED	00000000 _end_uninit_RESERVED
00019a24  w    F .text	00000070 Sd::GetCrc7(unsigned char*, unsigned char)
00013eb0  w    F .text	00000084 Ssd1306::Initialize()
000165e0  w    F .text	0000006c McpwmIrqHandler
0001030c g       .text	00000000 __preinit_array_end
000165e0  w    F .text	0000006c WdtIrqHandler
000104a4  w    F .text	0000002c Wait(unsigned long long)::{lambda()#1}::operator()() const
0001953c  w    F .text	000004a0 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)
000115b8  w    F .text	00000024 Lpc40xxSystemController::Lpc40xxSystemController()
0001d720  w    O .text	0000003c vtable for Pin
00013f88  w    F .text	00000038 Ssd1306::Clear()
10000000 g       .data	00000000 _data
00014664 g     F .text	000000a8 SW3ISR()
00011d64  w    F .text	00000074 Pin::SetAsActiveLow(bool)
000117c4  w    F .text	00000030 Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)
00012b00  w    F .text	0000007c Gpio::SetEdgeRising()
0001f328  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
000121d8  w    F .text	00000030 unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)
00013bc0  w    F .text	00000028 PixelDisplayInterface::Enable()
100007ac  w    O .bss	00000010 Timer::user_timer_isr
0001d434  w    O .text	00000016 Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file
10000774 g     O .bss	00000003 SD_Detect
100006e8  w    O .bss	00000040 Timer::match
0001d500  w    O .text	00000010 OnBoardLed::Toggle(unsigned char)::file
0001532c g     F .text	00000044 LabGPIO::SetLow()
00015a40  w    F .text	0000004c Uart::Send(unsigned char)::{lambda()#1}::operator()() const
00016edc g     F .text	00000158 xTaskIncrementTick
00010a8c g     F .text	00000088 MP3_Decoder::ReadRegister(unsigned char)
00012f7c  w    F .text	00000080 OnBoardLed::SetAll(unsigned char)
0001d594  w    O .text	0000002c vtable for PixelDisplayInterface
00012cf0  w    F .text	00000070 OnBoardLed::Initialize()
00018a44  w    F .text	0000031c Sd::Mount(SdInterface::CardInfo_t*)
10000654 g     O .data	00000004 __cxxabiv1::__terminate_handler
0001d7bc  w    O .text	00000024 vtable for SystemControllerInterface
0001d658  w    O .text	00000048 vtable for Gpio
100006bc g       .data	00000000 _edata
0001d47c  w    O .text	00000010 Timer::kPowerbit
00014c24  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)1>()
00011cf0  w    F .text	00000074 Pin::EnableHysteresis(bool)
000124a0  w    F .text	00000034 GpioInterface::GpioInterface()
00013ac4  w    F .text	00000094 PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)
000165e0  w    F .text	0000006c DebugMonHandler
0001280c  w    F .text	0000007c Gpio::ValidPortCheck()
10000778 g     O .bss	00000003 XDCS
00016ab6 g     F .text	0000008e xTaskCreate
000165e0  w    F .text	0000006c Eint2IrqHandler
20008000 g       *ABS*	00000000 __top_RamPeriph32
00013134  w    F .text	000000e4 Ssp::Ssp(Ssp::Peripheral)
000165e0  w    F .text	0000006c Timer3IrqHandler
1000078c g     O .bss	00000003 SW0
0001bb8c g     F .text	00000338 f_open
00019cc8 g     F .text	00000044 disk_write
000152e8 g     F .text	00000044 LabGPIO::SetHigh()
00013c38  w    F .text	00000034 PixelDisplayInterface::PixelDisplayInterface()
10000000 g       *ABS*	00000000 __base_RAM
000165e0  w    F .text	0000006c Eint3IrqHandler
0001c49a g     F .text	00000008 __cxxabiv1::__terminate(void (*)())
00016190  w    F .text	0000002c unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])
00016798 g     F .text	00000030 _kill
000165e0  w    F .text	0000006c I2c0IrqHandler
000130e0  w    F .text	00000054 Pin::Pin(Pin const&)
0001d4a0  w    O .text	0000000a Timer::Initialize(unsigned long, void (*)(), long)::file
000156d8  w    F .text	00000034 SystemTimer::SystemTimerHandler()
0001f330  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
0001f57c g     O .text	00000020 __sf_fake_stdout
100026f4 g     O .bss	00000001 fres
000114a0  w    F .text	00000100 debug::PrintBacktrace(bool, void*)
0001030c g       .text	00000000 __init_array_start
0001c8bc  w    F .text	00000002 .hidden __aeabi_idiv0
0001f3e4  w    O .text	0000002c vtable for SdInterface
00010bb0 g     F .text	00000078 MP3_Decoder::DataWrite(unsigned char*, unsigned char, unsigned long)
00018994  w    F .text	000000b0 Sd::Initialize()
00011150 g     F .text	00000064 LabSPI::SSPnPower()
0001675c g     F .text	00000018 _exit
00011ed0  w    F .text	00000074 Pin::EnableFastMode(bool)
00014e50  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()
000165e0  w    F .text	0000006c Eint0IrqHandler
00015740  w    F .text	0000009c SystemTimer::StartTimer()
00014794 g     F .text	000000f0 timerScanISR()
00013388  w    F .text	00000030 unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)
0001cb50 g     F .text	00000010 strlen
00019c84 g     F .text	00000044 disk_read
00017258 g     F .text	00000060 pxPortInitialiseStack
10002704 g     O .bss	00000003 S0
00012efc  w    F .text	00000080 OnBoardLed::Toggle(unsigned char)
0001019c g     F .text	00000060 InitBssSection()
000111b4 g     F .text	0000008c LabSPI::SetClocks(unsigned char)
100033fc g     O .bss	00000004 __malloc_sbrk_start
000124d4  w    F .text	0000007c Gpio::Gpio(unsigned char, unsigned char)
00016150 g     F .text	00000040 UptimeRTOS
00013c38  w    F .text	00000034 PixelDisplayInterface::PixelDisplayInterface()
00012034  w    F .text	00000074 Pin::SetAsOpenDrain(bool)
0001089c  w    F .text	0000004c Graphics::Initialize()
00017384 g     F .text	00000028 vPortEnterCritical
0001e0c8  w    O .text	00000038 vtable for SystemTimer
000165e0  w    F .text	0000006c SpiIrqHandler
0001f368  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
0001d4f0  w    O .text	00000010 OnBoardLed::Set(unsigned char, OnBoardLedInterface::LightState)::file
100033f8 g     O .bss	00000004 __malloc_free_list
000132fc  w    F .text	0000005c Ssp::SetSpiMasterDefault()
100004f8  w    O .data	00000040 Uart::pairs
000115a0  w    F .text	00000018 SystemControllerInterface::SystemControllerInterface()
00011760  w    F .text	00000030 Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)
10001ef0 g     O .bss	00000001 chunk_count
000188c0  w    F .text	00000034 SdInterface::SdInterface()
000112e0 g     F .text	00000140 LabSPI::Initialize(unsigned char, LabSPI::FrameModes, unsigned char)
0001030c g       .text	00000000 __preinit_array_start
000154d0 g     F .text	0000019c LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)
10000648  w    O .data	00000004 heap_position
0001d44c  w    O .text	00000016 Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::file
00011790  w    F .text	00000034 Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)
100007a8  w    O .bss	00000004 guard variable for Timer::match
000133e8  w    F .text	0000020c Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)
00011bf8  w    F .text	00000078 Pin::SetPinFunction(unsigned char)
00014d14  w    F .text	00000074 unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)
00011b6c  w    F .text	00000034 PinInterface::PinInterface()
0001d4e0  w    O .text	00000010 OnBoardLed::Off(unsigned char)::file
0001166c  w    F .text	00000058 Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)
000124d4  w    F .text	0000007c Gpio::Gpio(unsigned char, unsigned char)
00014c9c  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)3>()
0001cb08 g     F .text	00000010 raise
0001c928 g     F .text	00000010 free
10000038  w    O .data	0000000c LabSPI::SSP_n



Disassembly of section .text:

00010000 <kInterruptVectorTable>:
   10000:	00 00 01 10 f5 62 01 00 e1 65 01 00 19 02 01 00     .....b...e......
   10010:	e1 65 01 00 e1 65 01 00 e1 65 01 00 6e 03 f7 ef     .e...e...e..n...
	...
   1002c:	e1 72 01 00 e1 65 01 00 00 00 00 00 e1 73 01 00     .r...e.......s..
   1003c:	e1 65 01 00 e1 65 01 00 e1 65 01 00 e1 65 01 00     .e...e...e...e..
   1004c:	e1 65 01 00 e1 65 01 00 e1 65 01 00 e1 65 01 00     .e...e...e...e..
   1005c:	e1 65 01 00 e1 65 01 00 e1 65 01 00 e1 65 01 00     .e...e...e...e..
   1006c:	e1 65 01 00 e1 65 01 00 00 00 00 00 e1 65 01 00     .e...e.......e..
   1007c:	e1 65 01 00 e1 65 01 00 e1 65 01 00 e1 65 01 00     .e...e...e...e..
   1008c:	e1 65 01 00 e1 65 01 00 e1 65 01 00 e1 65 01 00     .e...e...e...e..
   1009c:	e1 65 01 00 e1 65 01 00 e1 65 01 00 e1 65 01 00     .e...e...e...e..
   100ac:	e1 65 01 00 e1 65 01 00 e1 65 01 00 e1 65 01 00     .e...e...e...e..
   100bc:	e1 65 01 00 e1 65 01 00 e1 65 01 00 e1 65 01 00     .e...e...e...e..
   100cc:	e1 65 01 00 e1 65 01 00 e1 65 01 00 e1 65 01 00     .e...e...e...e..
   100dc:	e1 65 01 00 e1 65 01 00                             .e...e..

000100e4 <data_section_table>:
   100e4:	0001f5a4 	.word	0x0001f5a4
   100e8:	10000000 	.word	0x10000000
   100ec:	000006bc 	.word	0x000006bc
   100f0:	0001f5a4 	.word	0x0001f5a4
   100f4:	20000000 	.word	0x20000000
   100f8:	00000000 	.word	0x00000000

000100fc <bss_section_table>:
   100fc:	100006c0 	.word	0x100006c0
   10100:	00002d44 	.word	0x00002d44
   10104:	20000000 	.word	0x20000000
   10108:	00000000 	.word	0x00000000

0001010c <InitDataSection()>:
SJ2_IGNORE_STACK_TRACE(void SystemInit());

// Functions to carry out the initialization of RW and BSS data sections.
SJ2_SECTION(".after_vectors")
void InitDataSection()
{
   1010c:	b086      	sub	sp, #24
  for (int i = 0; &data_section_table[i] < &data_section_table_end; i++)
   1010e:	2300      	movs	r3, #0
   10110:	9305      	str	r3, [sp, #20]
   10112:	9a05      	ldr	r2, [sp, #20]
   10114:	4613      	mov	r3, r2
   10116:	005b      	lsls	r3, r3, #1
   10118:	4413      	add	r3, r2
   1011a:	009b      	lsls	r3, r3, #2
   1011c:	4a1d      	ldr	r2, [pc, #116]	; (10194 <InitDataSection()+0x88>)
   1011e:	4413      	add	r3, r2
   10120:	4a1d      	ldr	r2, [pc, #116]	; (10198 <InitDataSection()+0x8c>)
   10122:	4293      	cmp	r3, r2
   10124:	d233      	bcs.n	1018e <InitDataSection()+0x82>
  {
    uint32_t * rom_location = data_section_table[i].rom_location;
   10126:	491b      	ldr	r1, [pc, #108]	; (10194 <InitDataSection()+0x88>)
   10128:	9a05      	ldr	r2, [sp, #20]
   1012a:	4613      	mov	r3, r2
   1012c:	005b      	lsls	r3, r3, #1
   1012e:	4413      	add	r3, r2
   10130:	009b      	lsls	r3, r3, #2
   10132:	440b      	add	r3, r1
   10134:	681b      	ldr	r3, [r3, #0]
   10136:	9303      	str	r3, [sp, #12]
    uint32_t * ram_location = data_section_table[i].ram_location;
   10138:	4916      	ldr	r1, [pc, #88]	; (10194 <InitDataSection()+0x88>)
   1013a:	9a05      	ldr	r2, [sp, #20]
   1013c:	4613      	mov	r3, r2
   1013e:	005b      	lsls	r3, r3, #1
   10140:	4413      	add	r3, r2
   10142:	009b      	lsls	r3, r3, #2
   10144:	440b      	add	r3, r1
   10146:	685b      	ldr	r3, [r3, #4]
   10148:	9302      	str	r3, [sp, #8]
    uint32_t length         = data_section_table[i].length;
   1014a:	4912      	ldr	r1, [pc, #72]	; (10194 <InitDataSection()+0x88>)
   1014c:	9a05      	ldr	r2, [sp, #20]
   1014e:	4613      	mov	r3, r2
   10150:	005b      	lsls	r3, r3, #1
   10152:	4413      	add	r3, r2
   10154:	009b      	lsls	r3, r3, #2
   10156:	440b      	add	r3, r1
   10158:	3308      	adds	r3, #8
   1015a:	681b      	ldr	r3, [r3, #0]
   1015c:	9301      	str	r3, [sp, #4]
    for (size_t j = 0; j < length; j++)
   1015e:	2300      	movs	r3, #0
   10160:	9304      	str	r3, [sp, #16]
   10162:	9a04      	ldr	r2, [sp, #16]
   10164:	9b01      	ldr	r3, [sp, #4]
   10166:	429a      	cmp	r2, r3
   10168:	d20d      	bcs.n	10186 <InitDataSection()+0x7a>
    {
      ram_location[j] = rom_location[j];
   1016a:	9b04      	ldr	r3, [sp, #16]
   1016c:	009b      	lsls	r3, r3, #2
   1016e:	9a03      	ldr	r2, [sp, #12]
   10170:	441a      	add	r2, r3
   10172:	9b04      	ldr	r3, [sp, #16]
   10174:	009b      	lsls	r3, r3, #2
   10176:	9902      	ldr	r1, [sp, #8]
   10178:	440b      	add	r3, r1
   1017a:	6812      	ldr	r2, [r2, #0]
   1017c:	601a      	str	r2, [r3, #0]
    for (size_t j = 0; j < length; j++)
   1017e:	9b04      	ldr	r3, [sp, #16]
   10180:	3301      	adds	r3, #1
   10182:	9304      	str	r3, [sp, #16]
   10184:	e7ed      	b.n	10162 <InitDataSection()+0x56>
  for (int i = 0; &data_section_table[i] < &data_section_table_end; i++)
   10186:	9b05      	ldr	r3, [sp, #20]
   10188:	3301      	adds	r3, #1
   1018a:	9305      	str	r3, [sp, #20]
   1018c:	e7c1      	b.n	10112 <InitDataSection()+0x6>
    }
  }
}
   1018e:	bf00      	nop
   10190:	b006      	add	sp, #24
   10192:	4770      	bx	lr
   10194:	000100e4 	.word	0x000100e4
   10198:	000100fc 	.word	0x000100fc

0001019c <InitBssSection()>:

// Functions to initialization BSS data sections. This is important because
// the std c libs assume that BSS is set to zero.
SJ2_SECTION(".after_vectors")
void InitBssSection()
{
   1019c:	b084      	sub	sp, #16
  for (int i = 0; &bss_section_table[i] < &bss_section_table_end; i++)
   1019e:	2300      	movs	r3, #0
   101a0:	9303      	str	r3, [sp, #12]
   101a2:	9b03      	ldr	r3, [sp, #12]
   101a4:	00db      	lsls	r3, r3, #3
   101a6:	4a13      	ldr	r2, [pc, #76]	; (101f4 <InitBssSection()+0x58>)
   101a8:	4413      	add	r3, r2
   101aa:	4a13      	ldr	r2, [pc, #76]	; (101f8 <InitBssSection()+0x5c>)
   101ac:	4293      	cmp	r3, r2
   101ae:	d21e      	bcs.n	101ee <InitBssSection()+0x52>
  {
    uint32_t * ram_location = bss_section_table[i].ram_location;
   101b0:	4a10      	ldr	r2, [pc, #64]	; (101f4 <InitBssSection()+0x58>)
   101b2:	9b03      	ldr	r3, [sp, #12]
   101b4:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
   101b8:	9301      	str	r3, [sp, #4]
    uint32_t length         = bss_section_table[i].length;
   101ba:	4a0e      	ldr	r2, [pc, #56]	; (101f4 <InitBssSection()+0x58>)
   101bc:	9b03      	ldr	r3, [sp, #12]
   101be:	00db      	lsls	r3, r3, #3
   101c0:	4413      	add	r3, r2
   101c2:	685b      	ldr	r3, [r3, #4]
   101c4:	9300      	str	r3, [sp, #0]
    for (size_t j = 0; j < length; j++)
   101c6:	2300      	movs	r3, #0
   101c8:	9302      	str	r3, [sp, #8]
   101ca:	9a02      	ldr	r2, [sp, #8]
   101cc:	9b00      	ldr	r3, [sp, #0]
   101ce:	429a      	cmp	r2, r3
   101d0:	d209      	bcs.n	101e6 <InitBssSection()+0x4a>
    {
      ram_location[j] = 0;
   101d2:	9b02      	ldr	r3, [sp, #8]
   101d4:	009b      	lsls	r3, r3, #2
   101d6:	9a01      	ldr	r2, [sp, #4]
   101d8:	4413      	add	r3, r2
   101da:	2200      	movs	r2, #0
   101dc:	601a      	str	r2, [r3, #0]
    for (size_t j = 0; j < length; j++)
   101de:	9b02      	ldr	r3, [sp, #8]
   101e0:	3301      	adds	r3, #1
   101e2:	9302      	str	r3, [sp, #8]
   101e4:	e7f1      	b.n	101ca <InitBssSection()+0x2e>
  for (int i = 0; &bss_section_table[i] < &bss_section_table_end; i++)
   101e6:	9b03      	ldr	r3, [sp, #12]
   101e8:	3301      	adds	r3, #1
   101ea:	9303      	str	r3, [sp, #12]
   101ec:	e7d9      	b.n	101a2 <InitBssSection()+0x6>
    }
  }
}
   101ee:	bf00      	nop
   101f0:	b004      	add	sp, #16
   101f2:	4770      	bx	lr
   101f4:	000100fc 	.word	0x000100fc
   101f8:	0001010c 	.word	0x0001010c

000101fc <InitFpu()>:
      // Write back the modified value to the CPACR
      "STR     R1, [R0]\n"
      // Wait for store to complete
      "DSB\n"
      // reset pipeline now the FPU is enabled
      "ISB\n");
   101fc:	f8df 0014 	ldr.w	r0, [pc, #20]	; 10214 <InitFpu()+0x18>
   10200:	6801      	ldr	r1, [r0, #0]
   10202:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   10206:	6001      	str	r1, [r0, #0]
   10208:	f3bf 8f4f 	dsb	sy
   1020c:	f3bf 8f6f 	isb	sy
}
   10210:	bf00      	nop
   10212:	4770      	bx	lr
   10214:	e000ed88 	.word	0xe000ed88

00010218 <HardFaultHandler>:
      " mrseq r0, msp                                       \n"
      " mrsne r0, psp                                       \n"
      " ldr r1, [r0, #24]                                   \n"
      " ldr r2, handler2_address_const                      \n"
      " bx r2                                               \n"
      " handler2_address_const: .word GetRegistersFromStack \n");
   10218:	f01e 0f04 	tst.w	lr, #4
   1021c:	bf0c      	ite	eq
   1021e:	f3ef 8008 	mrseq	r0, MSP
   10222:	f3ef 8009 	mrsne	r0, PSP
   10226:	6981      	ldr	r1, [r0, #24]
   10228:	4a00      	ldr	r2, [pc, #0]	; (1022c <handler2_address_const>)
   1022a:	4710      	bx	r2

0001022c <handler2_address_const>:
   1022c:	000166a9 	.word	0x000166a9
#endif
}
   10230:	bf00      	nop
   10232:	4770      	bx	lr
   10234:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10238:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1023c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10240:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10244:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10248:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1024c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10250:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10254:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10258:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1025c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10260:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10264:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10268:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1026c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10270:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10274:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10278:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1027c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10280:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10284:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10288:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1028c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10290:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10294:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10298:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1029c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ac:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102bc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102cc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102dc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ec:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

000102fc <__CRP_WORD_START__>:
   102fc:	ffffffff 	.word	0xffffffff

00010300 <_init>:
   10300:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10302:	bf00      	nop
   10304:	bcf8      	pop	{r3, r4, r5, r6, r7}
   10306:	bc08      	pop	{r3}
   10308:	469e      	mov	lr, r3
   1030a:	4770      	bx	lr

0001030c <__init_array_start>:
   1030c:	00010351 	.word	0x00010351
   10310:	00011129 	.word	0x00011129
   10314:	00015215 	.word	0x00015215
   10318:	00016551 	.word	0x00016551
   1031c:	00019d95 	.word	0x00019d95

00010320 <_fini>:
   10320:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10322:	bf00      	nop
   10324:	bcf8      	pop	{r3, r4, r5, r6, r7}
   10326:	bc08      	pop	{r3}
   10328:	469e      	mov	lr, r3
   1032a:	4770      	bx	lr

0001032c <__do_global_dtors_aux>:
   1032c:	b510      	push	{r4, lr}
   1032e:	4c05      	ldr	r4, [pc, #20]	; (10344 <__do_global_dtors_aux+0x18>)
   10330:	7823      	ldrb	r3, [r4, #0]
   10332:	b933      	cbnz	r3, 10342 <__do_global_dtors_aux+0x16>
   10334:	4b04      	ldr	r3, [pc, #16]	; (10348 <__do_global_dtors_aux+0x1c>)
   10336:	b113      	cbz	r3, 1033e <__do_global_dtors_aux+0x12>
   10338:	4804      	ldr	r0, [pc, #16]	; (1034c <__do_global_dtors_aux+0x20>)
   1033a:	f3af 8000 	nop.w
   1033e:	2301      	movs	r3, #1
   10340:	7023      	strb	r3, [r4, #0]
   10342:	bd10      	pop	{r4, pc}
   10344:	100006c0 	.word	0x100006c0
   10348:	00000000 	.word	0x00000000
   1034c:	0001f5a4 	.word	0x0001f5a4

00010350 <frame_dummy>:
   10350:	b508      	push	{r3, lr}
   10352:	4b03      	ldr	r3, [pc, #12]	; (10360 <frame_dummy+0x10>)
   10354:	b11b      	cbz	r3, 1035e <frame_dummy+0xe>
   10356:	4903      	ldr	r1, [pc, #12]	; (10364 <frame_dummy+0x14>)
   10358:	4803      	ldr	r0, [pc, #12]	; (10368 <frame_dummy+0x18>)
   1035a:	f3af 8000 	nop.w
   1035e:	bd08      	pop	{r3, pc}
   10360:	00000000 	.word	0x00000000
   10364:	100006c4 	.word	0x100006c4
   10368:	0001f5a4 	.word	0x0001f5a4

0001036c <LabGPIO::LabGPIO(unsigned char, unsigned char)>:
  };
  static constexpr size_t kPorts = 2;
  static constexpr size_t kPins = 32;

  inline static LPC_GPIO_TypeDef *ports[6] = {LPC_GPIO0, LPC_GPIO1, LPC_GPIO2, LPC_GPIO3, LPC_GPIO4, LPC_GPIO5};
  LabGPIO(uint8_t port, uint8_t pin) : gpio_port(port), gpio_pin(pin), int_port(port){};
   1036c:	b530      	push	{r4, r5, lr}
   1036e:	b083      	sub	sp, #12
   10370:	4675      	mov	r5, lr
   10372:	9001      	str	r0, [sp, #4]
   10374:	460b      	mov	r3, r1
   10376:	f88d 3003 	strb.w	r3, [sp, #3]
   1037a:	4613      	mov	r3, r2
   1037c:	f88d 3002 	strb.w	r3, [sp, #2]
   10380:	462b      	mov	r3, r5
   10382:	4619      	mov	r1, r3
   10384:	480c      	ldr	r0, [pc, #48]	; (103b8 <LabGPIO::LabGPIO(unsigned char, unsigned char)+0x4c>)
   10386:	f006 fab5 	bl	168f4 <__cyg_profile_func_enter>
   1038a:	9b01      	ldr	r3, [sp, #4]
   1038c:	f89d 2003 	ldrb.w	r2, [sp, #3]
   10390:	701a      	strb	r2, [r3, #0]
   10392:	9b01      	ldr	r3, [sp, #4]
   10394:	f89d 2002 	ldrb.w	r2, [sp, #2]
   10398:	705a      	strb	r2, [r3, #1]
   1039a:	9b01      	ldr	r3, [sp, #4]
   1039c:	f89d 2003 	ldrb.w	r2, [sp, #3]
   103a0:	709a      	strb	r2, [r3, #2]
   103a2:	9c01      	ldr	r4, [sp, #4]
   103a4:	462b      	mov	r3, r5
   103a6:	4619      	mov	r1, r3
   103a8:	4803      	ldr	r0, [pc, #12]	; (103b8 <LabGPIO::LabGPIO(unsigned char, unsigned char)+0x4c>)
   103aa:	f006 fab7 	bl	1691c <__cyg_profile_func_exit>
   103ae:	4623      	mov	r3, r4
   103b0:	4618      	mov	r0, r3
   103b2:	b003      	add	sp, #12
   103b4:	bd30      	pop	{r4, r5, pc}
   103b6:	bf00      	nop
   103b8:	0001036d 	.word	0x0001036d

000103bc <LabSPI::LabSPI(unsigned char)>:
    int PowerShiftValues[3] = {21, 10, 20};
    inline static LPC_SSP_TypeDef *SSP_n[3] = {LPC_SSP0, LPC_SSP1, LPC_SSP2};
    /*
    TODO: Find a better way to have pin access without needing to access each pin individually and checking SSP_n
    */
    LabSPI(uint8_t SSP_num){
   103bc:	b570      	push	{r4, r5, r6, lr}
   103be:	b082      	sub	sp, #8
   103c0:	4676      	mov	r6, lr
   103c2:	9001      	str	r0, [sp, #4]
   103c4:	460b      	mov	r3, r1
   103c6:	f88d 3003 	strb.w	r3, [sp, #3]
   103ca:	4633      	mov	r3, r6
   103cc:	4619      	mov	r1, r3
   103ce:	4814      	ldr	r0, [pc, #80]	; (10420 <LabSPI::LabSPI(unsigned char)+0x64>)
   103d0:	f006 fa90 	bl	168f4 <__cyg_profile_func_enter>
   103d4:	9b01      	ldr	r3, [sp, #4]
   103d6:	4a13      	ldr	r2, [pc, #76]	; (10424 <LabSPI::LabSPI(unsigned char)+0x68>)
   103d8:	461c      	mov	r4, r3
   103da:	4615      	mov	r5, r2
   103dc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   103de:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   103e0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   103e2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   103e4:	682b      	ldr	r3, [r5, #0]
   103e6:	6023      	str	r3, [r4, #0]
   103e8:	9b01      	ldr	r3, [sp, #4]
   103ea:	4a0f      	ldr	r2, [pc, #60]	; (10428 <LabSPI::LabSPI(unsigned char)+0x6c>)
   103ec:	3324      	adds	r3, #36	; 0x24
   103ee:	ca07      	ldmia	r2, {r0, r1, r2}
   103f0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   103f4:	9b01      	ldr	r3, [sp, #4]
   103f6:	4a0d      	ldr	r2, [pc, #52]	; (1042c <LabSPI::LabSPI(unsigned char)+0x70>)
   103f8:	3330      	adds	r3, #48	; 0x30
   103fa:	ca07      	ldmia	r2, {r0, r1, r2}
   103fc:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        whichSSP = SSP_num;
   10400:	9b01      	ldr	r3, [sp, #4]
   10402:	f89d 2003 	ldrb.w	r2, [sp, #3]
   10406:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
   1040a:	9c01      	ldr	r4, [sp, #4]
   1040c:	4633      	mov	r3, r6
   1040e:	4619      	mov	r1, r3
   10410:	4803      	ldr	r0, [pc, #12]	; (10420 <LabSPI::LabSPI(unsigned char)+0x64>)
   10412:	f006 fa83 	bl	1691c <__cyg_profile_func_exit>
   10416:	4623      	mov	r3, r4
   10418:	4618      	mov	r0, r3
   1041a:	b002      	add	sp, #8
   1041c:	bd70      	pop	{r4, r5, r6, pc}
   1041e:	bf00      	nop
   10420:	000103bd 	.word	0x000103bd
   10424:	0001cb64 	.word	0x0001cb64
   10428:	0001cb88 	.word	0x0001cb88
   1042c:	0001cb94 	.word	0x0001cb94

00010430 <(anonymous namespace)::DefaultUptime()>:
{
// uptime in nanoseconds
inline uint64_t uptime = 0;
// Returns the system uptime in nanoseconds, do not use this function directly
[[gnu::always_inline]] inline uint64_t DefaultUptime()
{
   10430:	b570      	push	{r4, r5, r6, lr}
   10432:	4676      	mov	r6, lr
   10434:	4633      	mov	r3, r6
   10436:	4619      	mov	r1, r3
   10438:	4807      	ldr	r0, [pc, #28]	; (10458 <(anonymous namespace)::DefaultUptime()+0x28>)
   1043a:	f006 fa5b 	bl	168f4 <__cyg_profile_func_enter>
  return uptime;
   1043e:	4b07      	ldr	r3, [pc, #28]	; (1045c <(anonymous namespace)::DefaultUptime()+0x2c>)
   10440:	e9d3 4500 	ldrd	r4, r5, [r3]
   10444:	4633      	mov	r3, r6
   10446:	4619      	mov	r1, r3
   10448:	4803      	ldr	r0, [pc, #12]	; (10458 <(anonymous namespace)::DefaultUptime()+0x28>)
   1044a:	f006 fa67 	bl	1691c <__cyg_profile_func_exit>
   1044e:	4623      	mov	r3, r4
   10450:	462c      	mov	r4, r5
}
   10452:	4618      	mov	r0, r3
   10454:	4621      	mov	r1, r4
   10456:	bd70      	pop	{r4, r5, r6, pc}
   10458:	00010431 	.word	0x00010431
   1045c:	100006e0 	.word	0x100006e0

00010460 <Milliseconds()>:
{
  Uptime = uptime_function;
}
// Get system uptime in milliseconds as a 64-bit integer
inline uint64_t Milliseconds()
{
   10460:	b570      	push	{r4, r5, r6, lr}
   10462:	4674      	mov	r4, lr
   10464:	4623      	mov	r3, r4
   10466:	4619      	mov	r1, r3
   10468:	480c      	ldr	r0, [pc, #48]	; (1049c <Milliseconds()+0x3c>)
   1046a:	f006 fa43 	bl	168f4 <__cyg_profile_func_enter>
  return Uptime() / 1'000;
   1046e:	4b0c      	ldr	r3, [pc, #48]	; (104a0 <Milliseconds()+0x40>)
   10470:	681b      	ldr	r3, [r3, #0]
   10472:	4798      	blx	r3
   10474:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   10478:	f04f 0300 	mov.w	r3, #0
   1047c:	f00c f8a0 	bl	1c5c0 <__aeabi_uldivmod>
   10480:	4602      	mov	r2, r0
   10482:	460b      	mov	r3, r1
   10484:	4615      	mov	r5, r2
   10486:	461e      	mov	r6, r3
   10488:	4623      	mov	r3, r4
   1048a:	4619      	mov	r1, r3
   1048c:	4803      	ldr	r0, [pc, #12]	; (1049c <Milliseconds()+0x3c>)
   1048e:	f006 fa45 	bl	1691c <__cyg_profile_func_exit>
   10492:	462b      	mov	r3, r5
   10494:	4634      	mov	r4, r6
}
   10496:	4618      	mov	r0, r3
   10498:	4621      	mov	r1, r4
   1049a:	bd70      	pop	{r4, r5, r6, pc}
   1049c:	00010461 	.word	0x00010461
   104a0:	10000000 	.word	0x10000000

000104a4 <Wait(unsigned long long)::{lambda()#1}::operator()() const>:
  return status;
}

inline Status Wait(uint64_t timeout)
{
  return Wait(timeout, []() -> bool { return false; });
   104a4:	b530      	push	{r4, r5, lr}
   104a6:	b083      	sub	sp, #12
   104a8:	4675      	mov	r5, lr
   104aa:	9001      	str	r0, [sp, #4]
   104ac:	462b      	mov	r3, r5
   104ae:	4619      	mov	r1, r3
   104b0:	4806      	ldr	r0, [pc, #24]	; (104cc <Wait(unsigned long long)::{lambda()#1}::operator()() const+0x28>)
   104b2:	f006 fa1f 	bl	168f4 <__cyg_profile_func_enter>
   104b6:	2400      	movs	r4, #0
   104b8:	462b      	mov	r3, r5
   104ba:	4619      	mov	r1, r3
   104bc:	4803      	ldr	r0, [pc, #12]	; (104cc <Wait(unsigned long long)::{lambda()#1}::operator()() const+0x28>)
   104be:	f006 fa2d 	bl	1691c <__cyg_profile_func_exit>
   104c2:	4623      	mov	r3, r4
   104c4:	4618      	mov	r0, r3
   104c6:	b003      	add	sp, #12
   104c8:	bd30      	pop	{r4, r5, pc}
   104ca:	bf00      	nop
   104cc:	000104a5 	.word	0x000104a5

000104d0 <Wait(unsigned long long)::{lambda()#1}::_FUN()>:
   104d0:	b538      	push	{r3, r4, r5, lr}
   104d2:	4674      	mov	r4, lr
   104d4:	4623      	mov	r3, r4
   104d6:	4619      	mov	r1, r3
   104d8:	4807      	ldr	r0, [pc, #28]	; (104f8 <Wait(unsigned long long)::{lambda()#1}::_FUN()+0x28>)
   104da:	f006 fa0b 	bl	168f4 <__cyg_profile_func_enter>
   104de:	2000      	movs	r0, #0
   104e0:	f7ff ffe0 	bl	104a4 <Wait(unsigned long long)::{lambda()#1}::operator()() const>
   104e4:	4603      	mov	r3, r0
   104e6:	461d      	mov	r5, r3
   104e8:	4623      	mov	r3, r4
   104ea:	4619      	mov	r1, r3
   104ec:	4802      	ldr	r0, [pc, #8]	; (104f8 <Wait(unsigned long long)::{lambda()#1}::_FUN()+0x28>)
   104ee:	f006 fa15 	bl	1691c <__cyg_profile_func_exit>
   104f2:	462b      	mov	r3, r5
   104f4:	4618      	mov	r0, r3
   104f6:	bd38      	pop	{r3, r4, r5, pc}
   104f8:	000104d1 	.word	0x000104d1

000104fc <Wait(unsigned long long)>:
{
   104fc:	b5f0      	push	{r4, r5, r6, r7, lr}
   104fe:	b089      	sub	sp, #36	; 0x24
   10500:	4675      	mov	r5, lr
   10502:	e9cd 0100 	strd	r0, r1, [sp]
   10506:	462b      	mov	r3, r5
   10508:	4619      	mov	r1, r3
   1050a:	482b      	ldr	r0, [pc, #172]	; (105b8 <Wait(unsigned long long)+0xbc>)
   1050c:	f006 f9f2 	bl	168f4 <__cyg_profile_func_enter>
   10510:	e9dd 3400 	ldrd	r3, r4, [sp]
   10514:	e9cd 3406 	strd	r3, r4, [sp, #24]
   10518:	f88d 6008 	strb.w	r6, [sp, #8]
   1051c:	462b      	mov	r3, r5
   1051e:	4619      	mov	r1, r3
   10520:	4826      	ldr	r0, [pc, #152]	; (105bc <Wait(unsigned long long)+0xc0>)
   10522:	f006 f9e7 	bl	168f4 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   10526:	f04f 0300 	mov.w	r3, #0
   1052a:	f04f 0400 	mov.w	r4, #0
   1052e:	e9cd 3404 	strd	r3, r4, [sp, #16]
  if (timeout == kMaxWait)
   10532:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   10536:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   1053a:	bf08      	it	eq
   1053c:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   10540:	d106      	bne.n	10550 <Wait(unsigned long long)+0x54>
    timeout_time = kMaxWait;
   10542:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   10546:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1054a:	e9cd 3404 	strd	r3, r4, [sp, #16]
   1054e:	e00a      	b.n	10566 <Wait(unsigned long long)+0x6a>
    timeout_time = Milliseconds() + timeout;
   10550:	f7ff ff86 	bl	10460 <Milliseconds()>
   10554:	460a      	mov	r2, r1
   10556:	4601      	mov	r1, r0
   10558:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   1055c:	185e      	adds	r6, r3, r1
   1055e:	eb44 0702 	adc.w	r7, r4, r2
   10562:	e9cd 6704 	strd	r6, r7, [sp, #16]
  Status status = Status::kTimedOut;
   10566:	2301      	movs	r3, #1
   10568:	9303      	str	r3, [sp, #12]
  while (Milliseconds() < timeout_time)
   1056a:	f7ff ff79 	bl	10460 <Milliseconds()>
   1056e:	460a      	mov	r2, r1
   10570:	4601      	mov	r1, r0
   10572:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
   10576:	42a2      	cmp	r2, r4
   10578:	bf08      	it	eq
   1057a:	4299      	cmpeq	r1, r3
   1057c:	bf34      	ite	cc
   1057e:	2301      	movcc	r3, #1
   10580:	2300      	movcs	r3, #0
   10582:	b2db      	uxtb	r3, r3
   10584:	2b00      	cmp	r3, #0
   10586:	d008      	beq.n	1059a <Wait(unsigned long long)+0x9e>
    if (is_done())
   10588:	ab02      	add	r3, sp, #8
   1058a:	4618      	mov	r0, r3
   1058c:	f7ff ff8a 	bl	104a4 <Wait(unsigned long long)::{lambda()#1}::operator()() const>
   10590:	4603      	mov	r3, r0
   10592:	2b00      	cmp	r3, #0
   10594:	d0e9      	beq.n	1056a <Wait(unsigned long long)+0x6e>
      status = Status::kSuccess;
   10596:	2300      	movs	r3, #0
   10598:	9303      	str	r3, [sp, #12]
  return status;
   1059a:	9c03      	ldr	r4, [sp, #12]
   1059c:	462b      	mov	r3, r5
   1059e:	4619      	mov	r1, r3
   105a0:	4806      	ldr	r0, [pc, #24]	; (105bc <Wait(unsigned long long)+0xc0>)
   105a2:	f006 f9bb 	bl	1691c <__cyg_profile_func_exit>
   105a6:	462b      	mov	r3, r5
   105a8:	4619      	mov	r1, r3
   105aa:	4803      	ldr	r0, [pc, #12]	; (105b8 <Wait(unsigned long long)+0xbc>)
   105ac:	f006 f9b6 	bl	1691c <__cyg_profile_func_exit>
  return Wait(timeout, []() -> bool { return false; });
   105b0:	4623      	mov	r3, r4
}
   105b2:	4618      	mov	r0, r3
   105b4:	b009      	add	sp, #36	; 0x24
   105b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   105b8:	000104fd 	.word	0x000104fd
   105bc:	00010ea5 	.word	0x00010ea5

000105c0 <Delay(unsigned long long)>:

// Delay the system for a duration of time
inline void Delay([[maybe_unused]] uint64_t delay_time_ms)
{
   105c0:	b510      	push	{r4, lr}
   105c2:	b082      	sub	sp, #8
   105c4:	4674      	mov	r4, lr
   105c6:	e9cd 0100 	strd	r0, r1, [sp]
   105ca:	4623      	mov	r3, r4
   105cc:	4619      	mov	r1, r3
   105ce:	4807      	ldr	r0, [pc, #28]	; (105ec <Delay(unsigned long long)+0x2c>)
   105d0:	f006 f990 	bl	168f4 <__cyg_profile_func_enter>
#if defined(HOST_TEST)
  return;
#else
  Wait(delay_time_ms);
   105d4:	e9dd 0100 	ldrd	r0, r1, [sp]
   105d8:	f7ff ff90 	bl	104fc <Wait(unsigned long long)>
   105dc:	4623      	mov	r3, r4
   105de:	4619      	mov	r1, r3
   105e0:	4802      	ldr	r0, [pc, #8]	; (105ec <Delay(unsigned long long)+0x2c>)
   105e2:	f006 f99b 	bl	1691c <__cyg_profile_func_exit>
#endif  // HOST_TEST
}
   105e6:	bf00      	nop
   105e8:	b002      	add	sp, #8
   105ea:	bd10      	pop	{r4, pc}
   105ec:	000105c1 	.word	0x000105c1

000105f0 <Gpio::SetHigh()>:
  inline void SetDirection(Direction direction) override
  {
    (direction) ? SetAsOutput() : SetAsInput();
  }
  // Sets the GPIO output pin to high
  void SetHigh(void) override
   105f0:	b530      	push	{r4, r5, lr}
   105f2:	b083      	sub	sp, #12
   105f4:	4675      	mov	r5, lr
   105f6:	9001      	str	r0, [sp, #4]
   105f8:	462b      	mov	r3, r5
   105fa:	4619      	mov	r1, r3
   105fc:	4813      	ldr	r0, [pc, #76]	; (1064c <Gpio::SetHigh()+0x5c>)
   105fe:	f006 f979 	bl	168f4 <__cyg_profile_func_enter>
  {
    gpio_port[pin_->GetPort()]->SET = (1 << pin_->GetPin());
   10602:	9b01      	ldr	r3, [sp, #4]
   10604:	689a      	ldr	r2, [r3, #8]
   10606:	9b01      	ldr	r3, [sp, #4]
   10608:	689b      	ldr	r3, [r3, #8]
   1060a:	681b      	ldr	r3, [r3, #0]
   1060c:	3330      	adds	r3, #48	; 0x30
   1060e:	681b      	ldr	r3, [r3, #0]
   10610:	4610      	mov	r0, r2
   10612:	4798      	blx	r3
   10614:	4603      	mov	r3, r0
   10616:	461a      	mov	r2, r3
   10618:	2301      	movs	r3, #1
   1061a:	4093      	lsls	r3, r2
   1061c:	461c      	mov	r4, r3
   1061e:	9b01      	ldr	r3, [sp, #4]
   10620:	689a      	ldr	r2, [r3, #8]
   10622:	9b01      	ldr	r3, [sp, #4]
   10624:	689b      	ldr	r3, [r3, #8]
   10626:	681b      	ldr	r3, [r3, #0]
   10628:	332c      	adds	r3, #44	; 0x2c
   1062a:	681b      	ldr	r3, [r3, #0]
   1062c:	4610      	mov	r0, r2
   1062e:	4798      	blx	r3
   10630:	4603      	mov	r3, r0
   10632:	461a      	mov	r2, r3
   10634:	4b06      	ldr	r3, [pc, #24]	; (10650 <Gpio::SetHigh()+0x60>)
   10636:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1063a:	619c      	str	r4, [r3, #24]
   1063c:	462b      	mov	r3, r5
   1063e:	4619      	mov	r1, r3
   10640:	4802      	ldr	r0, [pc, #8]	; (1064c <Gpio::SetHigh()+0x5c>)
   10642:	f006 f96b 	bl	1691c <__cyg_profile_func_exit>
  }
   10646:	bf00      	nop
   10648:	b003      	add	sp, #12
   1064a:	bd30      	pop	{r4, r5, pc}
   1064c:	000105f1 	.word	0x000105f1
   10650:	10000014 	.word	0x10000014

00010654 <Gpio::SetLow()>:
  // Sets the GPIO output pin to low
  void SetLow(void) override
   10654:	b530      	push	{r4, r5, lr}
   10656:	b083      	sub	sp, #12
   10658:	4675      	mov	r5, lr
   1065a:	9001      	str	r0, [sp, #4]
   1065c:	462b      	mov	r3, r5
   1065e:	4619      	mov	r1, r3
   10660:	4813      	ldr	r0, [pc, #76]	; (106b0 <Gpio::SetLow()+0x5c>)
   10662:	f006 f947 	bl	168f4 <__cyg_profile_func_enter>
  {
    gpio_port[pin_->GetPort()]->CLR = (1 << pin_->GetPin());
   10666:	9b01      	ldr	r3, [sp, #4]
   10668:	689a      	ldr	r2, [r3, #8]
   1066a:	9b01      	ldr	r3, [sp, #4]
   1066c:	689b      	ldr	r3, [r3, #8]
   1066e:	681b      	ldr	r3, [r3, #0]
   10670:	3330      	adds	r3, #48	; 0x30
   10672:	681b      	ldr	r3, [r3, #0]
   10674:	4610      	mov	r0, r2
   10676:	4798      	blx	r3
   10678:	4603      	mov	r3, r0
   1067a:	461a      	mov	r2, r3
   1067c:	2301      	movs	r3, #1
   1067e:	4093      	lsls	r3, r2
   10680:	461c      	mov	r4, r3
   10682:	9b01      	ldr	r3, [sp, #4]
   10684:	689a      	ldr	r2, [r3, #8]
   10686:	9b01      	ldr	r3, [sp, #4]
   10688:	689b      	ldr	r3, [r3, #8]
   1068a:	681b      	ldr	r3, [r3, #0]
   1068c:	332c      	adds	r3, #44	; 0x2c
   1068e:	681b      	ldr	r3, [r3, #0]
   10690:	4610      	mov	r0, r2
   10692:	4798      	blx	r3
   10694:	4603      	mov	r3, r0
   10696:	461a      	mov	r2, r3
   10698:	4b06      	ldr	r3, [pc, #24]	; (106b4 <Gpio::SetLow()+0x60>)
   1069a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1069e:	61dc      	str	r4, [r3, #28]
   106a0:	462b      	mov	r3, r5
   106a2:	4619      	mov	r1, r3
   106a4:	4802      	ldr	r0, [pc, #8]	; (106b0 <Gpio::SetLow()+0x5c>)
   106a6:	f006 f939 	bl	1691c <__cyg_profile_func_exit>
  }
   106aa:	bf00      	nop
   106ac:	b003      	add	sp, #12
   106ae:	bd30      	pop	{r4, r5, pc}
   106b0:	00010655 	.word	0x00010655
   106b4:	10000014 	.word	0x10000014

000106b8 <Gpio::Set(GpioInterface::State)>:
  // Sets the GPIO output pin to high or low depending on the State enum
  // parameter
  void Set(State output = kHigh) override
   106b8:	b510      	push	{r4, lr}
   106ba:	b082      	sub	sp, #8
   106bc:	4674      	mov	r4, lr
   106be:	9001      	str	r0, [sp, #4]
   106c0:	460b      	mov	r3, r1
   106c2:	f88d 3003 	strb.w	r3, [sp, #3]
   106c6:	4623      	mov	r3, r4
   106c8:	4619      	mov	r1, r3
   106ca:	480b      	ldr	r0, [pc, #44]	; (106f8 <Gpio::Set(GpioInterface::State)+0x40>)
   106cc:	f006 f912 	bl	168f4 <__cyg_profile_func_enter>
  {
    (output) ? SetHigh() : SetLow();
   106d0:	f89d 3003 	ldrb.w	r3, [sp, #3]
   106d4:	2b00      	cmp	r3, #0
   106d6:	d003      	beq.n	106e0 <Gpio::Set(GpioInterface::State)+0x28>
   106d8:	9801      	ldr	r0, [sp, #4]
   106da:	f7ff ff89 	bl	105f0 <Gpio::SetHigh()>
   106de:	e002      	b.n	106e6 <Gpio::Set(GpioInterface::State)+0x2e>
   106e0:	9801      	ldr	r0, [sp, #4]
   106e2:	f7ff ffb7 	bl	10654 <Gpio::SetLow()>
   106e6:	4623      	mov	r3, r4
   106e8:	4619      	mov	r1, r3
   106ea:	4803      	ldr	r0, [pc, #12]	; (106f8 <Gpio::Set(GpioInterface::State)+0x40>)
   106ec:	f006 f916 	bl	1691c <__cyg_profile_func_exit>
  }
   106f0:	bf00      	nop
   106f2:	b002      	add	sp, #8
   106f4:	bd10      	pop	{r4, pc}
   106f6:	bf00      	nop
   106f8:	000106b9 	.word	0x000106b9

000106fc <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>:
//
// @param enum_type_value variable you would like to get the value of.
// @return the value of the enum class type variable of with the underlying
//         type of the enum class.
template <typename Enum, typename Type = typename std::underlying_type_t<Enum>>
constexpr Type Value(Enum enum_type_value)
   106fc:	b530      	push	{r4, r5, lr}
   106fe:	b083      	sub	sp, #12
   10700:	4675      	mov	r5, lr
   10702:	9001      	str	r0, [sp, #4]
   10704:	462b      	mov	r3, r5
   10706:	4619      	mov	r1, r3
   10708:	4806      	ldr	r0, [pc, #24]	; (10724 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)+0x28>)
   1070a:	f006 f8f3 	bl	168f4 <__cyg_profile_func_enter>
{
  return static_cast<Type>(enum_type_value);
   1070e:	9c01      	ldr	r4, [sp, #4]
   10710:	462b      	mov	r3, r5
   10712:	4619      	mov	r1, r3
   10714:	4803      	ldr	r0, [pc, #12]	; (10724 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)+0x28>)
   10716:	f006 f901 	bl	1691c <__cyg_profile_func_exit>
   1071a:	4623      	mov	r3, r4
}
   1071c:	4618      	mov	r0, r3
   1071e:	b003      	add	sp, #12
   10720:	bd30      	pop	{r4, r5, pc}
   10722:	bf00      	nop
   10724:	000106fd 	.word	0x000106fd

00010728 <Ssp::IsTransferRegBusy()>:
  }

  /// Checks if the SSP controller is idle.
  /// @returns true if the controller is sending or receiving a data frame and
  /// false if it is idle.
  bool IsTransferRegBusy() override
   10728:	b530      	push	{r4, r5, lr}
   1072a:	b085      	sub	sp, #20
   1072c:	4675      	mov	r5, lr
   1072e:	9001      	str	r0, [sp, #4]
   10730:	462b      	mov	r3, r5
   10732:	4619      	mov	r1, r3
   10734:	4817      	ldr	r0, [pc, #92]	; (10794 <Ssp::IsTransferRegBusy()+0x6c>)
   10736:	f006 f8dd 	bl	168f4 <__cyg_profile_func_enter>
  {
    return (bit::Read(ssp_registers[util::Value(pssp_)]->SR, kDataLineIdleBit));
   1073a:	9b01      	ldr	r3, [sp, #4]
   1073c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1073e:	4618      	mov	r0, r3
   10740:	f7ff ffdc 	bl	106fc <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   10744:	4602      	mov	r2, r0
   10746:	4b14      	ldr	r3, [pc, #80]	; (10798 <Ssp::IsTransferRegBusy()+0x70>)
   10748:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1074c:	68db      	ldr	r3, [r3, #12]
   1074e:	9303      	str	r3, [sp, #12]
   10750:	2304      	movs	r3, #4
   10752:	9302      	str	r3, [sp, #8]
   10754:	462b      	mov	r3, r5
   10756:	4619      	mov	r1, r3
   10758:	4810      	ldr	r0, [pc, #64]	; (1079c <Ssp::IsTransferRegBusy()+0x74>)
   1075a:	f006 f8cb 	bl	168f4 <__cyg_profile_func_enter>
[[gnu::always_inline]][[nodiscard]] constexpr bool Read(T target,
                                                        uint32_t position)
{
  static_assert(std::numeric_limits<T>::is_integer,
                "Read only accepts intergers.");
  return static_cast<bool>(target & (1 << position));
   1075e:	2201      	movs	r2, #1
   10760:	9b02      	ldr	r3, [sp, #8]
   10762:	fa02 f303 	lsl.w	r3, r2, r3
   10766:	461a      	mov	r2, r3
   10768:	9b03      	ldr	r3, [sp, #12]
   1076a:	4013      	ands	r3, r2
   1076c:	2b00      	cmp	r3, #0
   1076e:	bf14      	ite	ne
   10770:	2301      	movne	r3, #1
   10772:	2300      	moveq	r3, #0
   10774:	b2dc      	uxtb	r4, r3
   10776:	462b      	mov	r3, r5
   10778:	4619      	mov	r1, r3
   1077a:	4808      	ldr	r0, [pc, #32]	; (1079c <Ssp::IsTransferRegBusy()+0x74>)
   1077c:	f006 f8ce 	bl	1691c <__cyg_profile_func_exit>
   10780:	462b      	mov	r3, r5
   10782:	4619      	mov	r1, r3
   10784:	4803      	ldr	r0, [pc, #12]	; (10794 <Ssp::IsTransferRegBusy()+0x6c>)
   10786:	f006 f8c9 	bl	1691c <__cyg_profile_func_exit>
   1078a:	4623      	mov	r3, r4
  }
   1078c:	4618      	mov	r0, r3
   1078e:	b005      	add	sp, #20
   10790:	bd30      	pop	{r4, r5, pc}
   10792:	bf00      	nop
   10794:	00010729 	.word	0x00010729
   10798:	1000002c 	.word	0x1000002c
   1079c:	00010f51 	.word	0x00010f51

000107a0 <Ssp::Transfer(unsigned short)>:
  /// data register. This functions for both transmitting and
  /// receiving data. It is recommended this region be protected
  /// by a mutex.
  /// @param data - information to be placed in data register
  /// @return - received data from external device
  uint16_t Transfer(uint16_t data) override
   107a0:	b530      	push	{r4, r5, lr}
   107a2:	b085      	sub	sp, #20
   107a4:	4675      	mov	r5, lr
   107a6:	9001      	str	r0, [sp, #4]
   107a8:	460b      	mov	r3, r1
   107aa:	f8ad 3002 	strh.w	r3, [sp, #2]
   107ae:	462b      	mov	r3, r5
   107b0:	4619      	mov	r1, r3
   107b2:	4814      	ldr	r0, [pc, #80]	; (10804 <Ssp::Transfer(unsigned short)+0x64>)
   107b4:	f006 f89e 	bl	168f4 <__cyg_profile_func_enter>
  {
    uint32_t pssp = util::Value(pssp_);
   107b8:	9b01      	ldr	r3, [sp, #4]
   107ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   107bc:	4618      	mov	r0, r3
   107be:	f7ff ff9d 	bl	106fc <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   107c2:	4603      	mov	r3, r0
   107c4:	9303      	str	r3, [sp, #12]

    ssp_registers[pssp]->DR = data;
   107c6:	4a10      	ldr	r2, [pc, #64]	; (10808 <Ssp::Transfer(unsigned short)+0x68>)
   107c8:	9b03      	ldr	r3, [sp, #12]
   107ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   107ce:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   107d2:	609a      	str	r2, [r3, #8]
    while (IsTransferRegBusy())
   107d4:	9801      	ldr	r0, [sp, #4]
   107d6:	f7ff ffa7 	bl	10728 <Ssp::IsTransferRegBusy()>
   107da:	4603      	mov	r3, r0
   107dc:	2b00      	cmp	r3, #0
   107de:	d001      	beq.n	107e4 <Ssp::Transfer(unsigned short)+0x44>
    {
      continue;
   107e0:	bf00      	nop
    while (IsTransferRegBusy())
   107e2:	e7f7      	b.n	107d4 <Ssp::Transfer(unsigned short)+0x34>
    }
    return static_cast<uint16_t>(ssp_registers[pssp]->DR);
   107e4:	4a08      	ldr	r2, [pc, #32]	; (10808 <Ssp::Transfer(unsigned short)+0x68>)
   107e6:	9b03      	ldr	r3, [sp, #12]
   107e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   107ec:	689b      	ldr	r3, [r3, #8]
   107ee:	b29c      	uxth	r4, r3
   107f0:	462b      	mov	r3, r5
   107f2:	4619      	mov	r1, r3
   107f4:	4803      	ldr	r0, [pc, #12]	; (10804 <Ssp::Transfer(unsigned short)+0x64>)
   107f6:	f006 f891 	bl	1691c <__cyg_profile_func_exit>
   107fa:	4623      	mov	r3, r4
  }
   107fc:	4618      	mov	r0, r3
   107fe:	b005      	add	sp, #20
   10800:	bd30      	pop	{r4, r5, pc}
   10802:	bf00      	nop
   10804:	000107a1 	.word	0x000107a1
   10808:	1000002c 	.word	0x1000002c

0001080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>:
                   /* Alpha      = */ 1,
                   /* Color Bits = */ 1,
                   /* Monochrome = */ true);
  }

  void Write(uint32_t data, Transaction transaction, size_t size = 1)
   1080c:	b510      	push	{r4, lr}
   1080e:	b086      	sub	sp, #24
   10810:	4674      	mov	r4, lr
   10812:	9003      	str	r0, [sp, #12]
   10814:	9102      	str	r1, [sp, #8]
   10816:	9201      	str	r2, [sp, #4]
   10818:	9300      	str	r3, [sp, #0]
   1081a:	4623      	mov	r3, r4
   1081c:	4619      	mov	r1, r3
   1081e:	481e      	ldr	r0, [pc, #120]	; (10898 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)+0x8c>)
   10820:	f006 f868 	bl	168f4 <__cyg_profile_func_enter>
  {
    dc_->Set(static_cast<Gpio::State>(transaction));
   10824:	9b03      	ldr	r3, [sp, #12]
   10826:	68db      	ldr	r3, [r3, #12]
   10828:	9a01      	ldr	r2, [sp, #4]
   1082a:	b2d2      	uxtb	r2, r2
   1082c:	4611      	mov	r1, r2
   1082e:	4618      	mov	r0, r3
   10830:	f7ff ff42 	bl	106b8 <Gpio::Set(GpioInterface::State)>
    cs_->SetLow();
   10834:	9b03      	ldr	r3, [sp, #12]
   10836:	689b      	ldr	r3, [r3, #8]
   10838:	4618      	mov	r0, r3
   1083a:	f7ff ff0b 	bl	10654 <Gpio::SetLow()>
    for (size_t i = 0; i < size; i++)
   1083e:	2300      	movs	r3, #0
   10840:	9305      	str	r3, [sp, #20]
   10842:	9a05      	ldr	r2, [sp, #20]
   10844:	9b00      	ldr	r3, [sp, #0]
   10846:	429a      	cmp	r2, r3
   10848:	d218      	bcs.n	1087c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)+0x70>
    {
      uint8_t send = static_cast<uint8_t>(data >> (((size - 1) - i) * 8));
   1084a:	9a00      	ldr	r2, [sp, #0]
   1084c:	9b05      	ldr	r3, [sp, #20]
   1084e:	1ad3      	subs	r3, r2, r3
   10850:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   10854:	3b01      	subs	r3, #1
   10856:	00db      	lsls	r3, r3, #3
   10858:	9a02      	ldr	r2, [sp, #8]
   1085a:	fa22 f303 	lsr.w	r3, r2, r3
   1085e:	f88d 3013 	strb.w	r3, [sp, #19]
      if (transaction == Transaction::kCommand)
      {
        LOG_DEBUG("send = 0x%X", send);
      }
      ssp_->Transfer(send);
   10862:	9b03      	ldr	r3, [sp, #12]
   10864:	685b      	ldr	r3, [r3, #4]
   10866:	f89d 2013 	ldrb.w	r2, [sp, #19]
   1086a:	b292      	uxth	r2, r2
   1086c:	4611      	mov	r1, r2
   1086e:	4618      	mov	r0, r3
   10870:	f7ff ff96 	bl	107a0 <Ssp::Transfer(unsigned short)>
    for (size_t i = 0; i < size; i++)
   10874:	9b05      	ldr	r3, [sp, #20]
   10876:	3301      	adds	r3, #1
   10878:	9305      	str	r3, [sp, #20]
   1087a:	e7e2      	b.n	10842 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)+0x36>
    }
    cs_->SetHigh();
   1087c:	9b03      	ldr	r3, [sp, #12]
   1087e:	689b      	ldr	r3, [r3, #8]
   10880:	4618      	mov	r0, r3
   10882:	f7ff feb5 	bl	105f0 <Gpio::SetHigh()>
   10886:	4623      	mov	r3, r4
   10888:	4619      	mov	r1, r3
   1088a:	4803      	ldr	r0, [pc, #12]	; (10898 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)+0x8c>)
   1088c:	f006 f846 	bl	1691c <__cyg_profile_func_exit>
  }
   10890:	bf00      	nop
   10892:	b006      	add	sp, #24
   10894:	bd10      	pop	{r4, pc}
   10896:	bf00      	nop
   10898:	0001080d 	.word	0x0001080d

0001089c <Graphics::Initialize()>:
  void SetColor(PixelDisplayInterface::Color_t color)
  {
    color_ = color;
  }

  void Initialize()
   1089c:	b510      	push	{r4, lr}
   1089e:	b082      	sub	sp, #8
   108a0:	4674      	mov	r4, lr
   108a2:	9001      	str	r0, [sp, #4]
   108a4:	4623      	mov	r3, r4
   108a6:	4619      	mov	r1, r3
   108a8:	480e      	ldr	r0, [pc, #56]	; (108e4 <Graphics::Initialize()+0x48>)
   108aa:	f006 f823 	bl	168f4 <__cyg_profile_func_enter>
  {
    display_->Initialize();
   108ae:	9b01      	ldr	r3, [sp, #4]
   108b0:	681a      	ldr	r2, [r3, #0]
   108b2:	9b01      	ldr	r3, [sp, #4]
   108b4:	681b      	ldr	r3, [r3, #0]
   108b6:	681b      	ldr	r3, [r3, #0]
   108b8:	330c      	adds	r3, #12
   108ba:	681b      	ldr	r3, [r3, #0]
   108bc:	4610      	mov	r0, r2
   108be:	4798      	blx	r3
    display_->Enable();
   108c0:	9b01      	ldr	r3, [sp, #4]
   108c2:	681a      	ldr	r2, [r3, #0]
   108c4:	9b01      	ldr	r3, [sp, #4]
   108c6:	681b      	ldr	r3, [r3, #0]
   108c8:	681b      	ldr	r3, [r3, #0]
   108ca:	3310      	adds	r3, #16
   108cc:	681b      	ldr	r3, [r3, #0]
   108ce:	4610      	mov	r0, r2
   108d0:	4798      	blx	r3
   108d2:	4623      	mov	r3, r4
   108d4:	4619      	mov	r1, r3
   108d6:	4803      	ldr	r0, [pc, #12]	; (108e4 <Graphics::Initialize()+0x48>)
   108d8:	f006 f820 	bl	1691c <__cyg_profile_func_exit>
  }
   108dc:	bf00      	nop
   108de:	b002      	add	sp, #8
   108e0:	bd10      	pop	{r4, pc}
   108e2:	bf00      	nop
   108e4:	0001089d 	.word	0x0001089d

000108e8 <Graphics::Update()>:
    if (x <= width_ && y <= height_)
    {
      display_->DrawPixel(x, y, color_);
    }
  }
  void Update()
   108e8:	b510      	push	{r4, lr}
   108ea:	b082      	sub	sp, #8
   108ec:	4674      	mov	r4, lr
   108ee:	9001      	str	r0, [sp, #4]
   108f0:	4623      	mov	r3, r4
   108f2:	4619      	mov	r1, r3
   108f4:	4809      	ldr	r0, [pc, #36]	; (1091c <Graphics::Update()+0x34>)
   108f6:	f005 fffd 	bl	168f4 <__cyg_profile_func_enter>
  {
    display_->Update();
   108fa:	9b01      	ldr	r3, [sp, #4]
   108fc:	681a      	ldr	r2, [r3, #0]
   108fe:	9b01      	ldr	r3, [sp, #4]
   10900:	681b      	ldr	r3, [r3, #0]
   10902:	681b      	ldr	r3, [r3, #0]
   10904:	3320      	adds	r3, #32
   10906:	681b      	ldr	r3, [r3, #0]
   10908:	4610      	mov	r0, r2
   1090a:	4798      	blx	r3
   1090c:	4623      	mov	r3, r4
   1090e:	4619      	mov	r1, r3
   10910:	4802      	ldr	r0, [pc, #8]	; (1091c <Graphics::Update()+0x34>)
   10912:	f006 f803 	bl	1691c <__cyg_profile_func_exit>
  }
   10916:	bf00      	nop
   10918:	b002      	add	sp, #8
   1091a:	bd10      	pop	{r4, pc}
   1091c:	000108e9 	.word	0x000108e9

00010920 <Graphics::Clear()>:
  void Clear()
   10920:	b510      	push	{r4, lr}
   10922:	b082      	sub	sp, #8
   10924:	4674      	mov	r4, lr
   10926:	9001      	str	r0, [sp, #4]
   10928:	4623      	mov	r3, r4
   1092a:	4619      	mov	r1, r3
   1092c:	4809      	ldr	r0, [pc, #36]	; (10954 <Graphics::Clear()+0x34>)
   1092e:	f005 ffe1 	bl	168f4 <__cyg_profile_func_enter>
  {
    display_->Clear();
   10932:	9b01      	ldr	r3, [sp, #4]
   10934:	681a      	ldr	r2, [r3, #0]
   10936:	9b01      	ldr	r3, [sp, #4]
   10938:	681b      	ldr	r3, [r3, #0]
   1093a:	681b      	ldr	r3, [r3, #0]
   1093c:	3318      	adds	r3, #24
   1093e:	681b      	ldr	r3, [r3, #0]
   10940:	4610      	mov	r0, r2
   10942:	4798      	blx	r3
   10944:	4623      	mov	r3, r4
   10946:	4619      	mov	r1, r3
   10948:	4802      	ldr	r0, [pc, #8]	; (10954 <Graphics::Clear()+0x34>)
   1094a:	f005 ffe7 	bl	1691c <__cyg_profile_func_exit>
  }
   1094e:	bf00      	nop
   10950:	b002      	add	sp, #8
   10952:	bd10      	pop	{r4, pc}
   10954:	00010921 	.word	0x00010921

00010958 <OledTerminal::Initialize()>:
  static constexpr size_t kCharacterHeight = 8;
  static constexpr size_t kCharacterWidth  = 8;
  static constexpr size_t kMaxColumns      = Ssd1306::kWidth / kCharacterWidth;
  static constexpr size_t kMaxRows = Ssd1306::kHeight / kCharacterHeight;

  void Initialize()
   10958:	b510      	push	{r4, lr}
   1095a:	b082      	sub	sp, #8
   1095c:	4674      	mov	r4, lr
   1095e:	9001      	str	r0, [sp, #4]
   10960:	4623      	mov	r3, r4
   10962:	4619      	mov	r1, r3
   10964:	480e      	ldr	r0, [pc, #56]	; (109a0 <OledTerminal::Initialize()+0x48>)
   10966:	f005 ffc5 	bl	168f4 <__cyg_profile_func_enter>
  {
    graphics_.Initialize();
   1096a:	9b01      	ldr	r3, [sp, #4]
   1096c:	f203 732c 	addw	r3, r3, #1836	; 0x72c
   10970:	4618      	mov	r0, r3
   10972:	f7ff ff93 	bl	1089c <Graphics::Initialize()>
    graphics_.Clear();
   10976:	9b01      	ldr	r3, [sp, #4]
   10978:	f203 732c 	addw	r3, r3, #1836	; 0x72c
   1097c:	4618      	mov	r0, r3
   1097e:	f7ff ffcf 	bl	10920 <Graphics::Clear()>
    graphics_.Update();
   10982:	9b01      	ldr	r3, [sp, #4]
   10984:	f203 732c 	addw	r3, r3, #1836	; 0x72c
   10988:	4618      	mov	r0, r3
   1098a:	f7ff ffad 	bl	108e8 <Graphics::Update()>
   1098e:	4623      	mov	r3, r4
   10990:	4619      	mov	r1, r3
   10992:	4803      	ldr	r0, [pc, #12]	; (109a0 <OledTerminal::Initialize()+0x48>)
   10994:	f005 ffc2 	bl	1691c <__cyg_profile_func_exit>
  }
   10998:	bf00      	nop
   1099a:	b002      	add	sp, #8
   1099c:	bd10      	pop	{r4, pc}
   1099e:	bf00      	nop
   109a0:	00010959 	.word	0x00010959

000109a4 <MP3_Decoder::initialize()>:
LabGPIO SW3(0, 29);
LabGPIO SW2(0, 30);
LabGPIO SW1(1, 15);
LabGPIO SW0(1, 19);

bool MP3_Decoder::initialize(){
   109a4:	b530      	push	{r4, r5, lr}
   109a6:	b085      	sub	sp, #20
   109a8:	4675      	mov	r5, lr
   109aa:	9001      	str	r0, [sp, #4]
   109ac:	462b      	mov	r3, r5
   109ae:	4619      	mov	r1, r3
   109b0:	4829      	ldr	r0, [pc, #164]	; (10a58 <MP3_Decoder::initialize()+0xb4>)
   109b2:	f005 ff9f 	bl	168f4 <__cyg_profile_func_enter>
    //GPIO pin setups
    DREQ.SetAsInput();
   109b6:	4829      	ldr	r0, [pc, #164]	; (10a5c <MP3_Decoder::initialize()+0xb8>)
   109b8:	f004 fc40 	bl	1523c <LabGPIO::SetAsInput()>
    XCS.SetAsOutput();
   109bc:	4828      	ldr	r0, [pc, #160]	; (10a60 <MP3_Decoder::initialize()+0xbc>)
   109be:	f004 fc69 	bl	15294 <LabGPIO::SetAsOutput()>
    XCS.SetHigh();
   109c2:	4827      	ldr	r0, [pc, #156]	; (10a60 <MP3_Decoder::initialize()+0xbc>)
   109c4:	f004 fc90 	bl	152e8 <LabGPIO::SetHigh()>
    CS_SD.SetAsOutput();
   109c8:	4826      	ldr	r0, [pc, #152]	; (10a64 <MP3_Decoder::initialize()+0xc0>)
   109ca:	f004 fc63 	bl	15294 <LabGPIO::SetAsOutput()>
    CS_SD.SetHigh();
   109ce:	4825      	ldr	r0, [pc, #148]	; (10a64 <MP3_Decoder::initialize()+0xc0>)
   109d0:	f004 fc8a 	bl	152e8 <LabGPIO::SetHigh()>
    SD_Detect.SetAsOutput();
   109d4:	4824      	ldr	r0, [pc, #144]	; (10a68 <MP3_Decoder::initialize()+0xc4>)
   109d6:	f004 fc5d 	bl	15294 <LabGPIO::SetAsOutput()>
    SD_Detect.SetHigh();
   109da:	4823      	ldr	r0, [pc, #140]	; (10a68 <MP3_Decoder::initialize()+0xc4>)
   109dc:	f004 fc84 	bl	152e8 <LabGPIO::SetHigh()>
    XDCS.SetAsOutput();
   109e0:	4822      	ldr	r0, [pc, #136]	; (10a6c <MP3_Decoder::initialize()+0xc8>)
   109e2:	f004 fc57 	bl	15294 <LabGPIO::SetAsOutput()>
    XDCS.SetHigh();
   109e6:	4821      	ldr	r0, [pc, #132]	; (10a6c <MP3_Decoder::initialize()+0xc8>)
   109e8:	f004 fc7e 	bl	152e8 <LabGPIO::SetHigh()>
    XRESET.SetAsOutput();
   109ec:	4820      	ldr	r0, [pc, #128]	; (10a70 <MP3_Decoder::initialize()+0xcc>)
   109ee:	f004 fc51 	bl	15294 <LabGPIO::SetAsOutput()>
    XRESET.SetHigh();
   109f2:	481f      	ldr	r0, [pc, #124]	; (10a70 <MP3_Decoder::initialize()+0xcc>)
   109f4:	f004 fc78 	bl	152e8 <LabGPIO::SetHigh()>
    SW3.SetAsInput();
   109f8:	481e      	ldr	r0, [pc, #120]	; (10a74 <MP3_Decoder::initialize()+0xd0>)
   109fa:	f004 fc1f 	bl	1523c <LabGPIO::SetAsInput()>
    SW2.SetAsInput();
   109fe:	481e      	ldr	r0, [pc, #120]	; (10a78 <MP3_Decoder::initialize()+0xd4>)
   10a00:	f004 fc1c 	bl	1523c <LabGPIO::SetAsInput()>
    //switch setup with sw1/sw0 with pull-down enabled
    LPC_IOCON->P1_15 |= 0b01 << 3;
   10a04:	4b1d      	ldr	r3, [pc, #116]	; (10a7c <MP3_Decoder::initialize()+0xd8>)
   10a06:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
   10a0a:	4a1c      	ldr	r2, [pc, #112]	; (10a7c <MP3_Decoder::initialize()+0xd8>)
   10a0c:	f043 0308 	orr.w	r3, r3, #8
   10a10:	f8c2 30bc 	str.w	r3, [r2, #188]	; 0xbc
    LPC_IOCON->P1_19 |= 0b01 << 3;
   10a14:	4b19      	ldr	r3, [pc, #100]	; (10a7c <MP3_Decoder::initialize()+0xd8>)
   10a16:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
   10a1a:	4a18      	ldr	r2, [pc, #96]	; (10a7c <MP3_Decoder::initialize()+0xd8>)
   10a1c:	f043 0308 	orr.w	r3, r3, #8
   10a20:	f8c2 30cc 	str.w	r3, [r2, #204]	; 0xcc
    SW1.SetAsInput();
   10a24:	4816      	ldr	r0, [pc, #88]	; (10a80 <MP3_Decoder::initialize()+0xdc>)
   10a26:	f004 fc09 	bl	1523c <LabGPIO::SetAsInput()>
    SW0.SetAsInput();
   10a2a:	4816      	ldr	r0, [pc, #88]	; (10a84 <MP3_Decoder::initialize()+0xe0>)
   10a2c:	f004 fc06 	bl	1523c <LabGPIO::SetAsInput()>
    //SPI setup
    bool ret = data_trans.Initialize(8, LabSPI::FrameModes::kSPI, 8);
   10a30:	2308      	movs	r3, #8
   10a32:	2200      	movs	r2, #0
   10a34:	2108      	movs	r1, #8
   10a36:	4814      	ldr	r0, [pc, #80]	; (10a88 <MP3_Decoder::initialize()+0xe4>)
   10a38:	f000 fc52 	bl	112e0 <LabSPI::Initialize(unsigned char, LabSPI::FrameModes, unsigned char)>
   10a3c:	4603      	mov	r3, r0
   10a3e:	f88d 300f 	strb.w	r3, [sp, #15]
    return ret;
   10a42:	f89d 400f 	ldrb.w	r4, [sp, #15]
   10a46:	462b      	mov	r3, r5
   10a48:	4619      	mov	r1, r3
   10a4a:	4803      	ldr	r0, [pc, #12]	; (10a58 <MP3_Decoder::initialize()+0xb4>)
   10a4c:	f005 ff66 	bl	1691c <__cyg_profile_func_exit>
   10a50:	4623      	mov	r3, r4
}
   10a52:	4618      	mov	r0, r3
   10a54:	b005      	add	sp, #20
   10a56:	bd30      	pop	{r4, r5, pc}
   10a58:	000109a5 	.word	0x000109a5
   10a5c:	10000768 	.word	0x10000768
   10a60:	1000076c 	.word	0x1000076c
   10a64:	10000770 	.word	0x10000770
   10a68:	10000774 	.word	0x10000774
   10a6c:	10000778 	.word	0x10000778
   10a70:	1000077c 	.word	0x1000077c
   10a74:	10000780 	.word	0x10000780
   10a78:	10000784 	.word	0x10000784
   10a7c:	4002c000 	.word	0x4002c000
   10a80:	10000788 	.word	0x10000788
   10a84:	1000078c 	.word	0x1000078c
   10a88:	10000728 	.word	0x10000728

00010a8c <MP3_Decoder::ReadRegister(unsigned char)>:
void MP3_Decoder::ReadRegister(unsigned char addrByte){
   10a8c:	b510      	push	{r4, lr}
   10a8e:	b082      	sub	sp, #8
   10a90:	4674      	mov	r4, lr
   10a92:	9001      	str	r0, [sp, #4]
   10a94:	460b      	mov	r3, r1
   10a96:	f88d 3003 	strb.w	r3, [sp, #3]
   10a9a:	4623      	mov	r3, r4
   10a9c:	4619      	mov	r1, r3
   10a9e:	4818      	ldr	r0, [pc, #96]	; (10b00 <MP3_Decoder::ReadRegister(unsigned char)+0x74>)
   10aa0:	f005 ff28 	bl	168f4 <__cyg_profile_func_enter>
    XDCS.SetHigh();
   10aa4:	4817      	ldr	r0, [pc, #92]	; (10b04 <MP3_Decoder::ReadRegister(unsigned char)+0x78>)
   10aa6:	f004 fc1f 	bl	152e8 <LabGPIO::SetHigh()>
    while(!DREQ.ReadBool());
   10aaa:	4817      	ldr	r0, [pc, #92]	; (10b08 <MP3_Decoder::ReadRegister(unsigned char)+0x7c>)
   10aac:	f004 fc60 	bl	15370 <LabGPIO::ReadBool()>
   10ab0:	4603      	mov	r3, r0
   10ab2:	f083 0301 	eor.w	r3, r3, #1
   10ab6:	b2db      	uxtb	r3, r3
   10ab8:	2b00      	cmp	r3, #0
   10aba:	d000      	beq.n	10abe <MP3_Decoder::ReadRegister(unsigned char)+0x32>
   10abc:	e7f5      	b.n	10aaa <MP3_Decoder::ReadRegister(unsigned char)+0x1e>
    XCS.SetLow();
   10abe:	4813      	ldr	r0, [pc, #76]	; (10b0c <MP3_Decoder::ReadRegister(unsigned char)+0x80>)
   10ac0:	f004 fc34 	bl	1532c <LabGPIO::SetLow()>
    data_trans.Transfer(VS1053_Commands::READ_COMMAND);
   10ac4:	2103      	movs	r1, #3
   10ac6:	4812      	ldr	r0, [pc, #72]	; (10b10 <MP3_Decoder::ReadRegister(unsigned char)+0x84>)
   10ac8:	f000 fcaa 	bl	11420 <LabSPI::Transfer(unsigned char)>
    data_trans.Transfer(addrByte);
   10acc:	f89d 3003 	ldrb.w	r3, [sp, #3]
   10ad0:	4619      	mov	r1, r3
   10ad2:	480f      	ldr	r0, [pc, #60]	; (10b10 <MP3_Decoder::ReadRegister(unsigned char)+0x84>)
   10ad4:	f000 fca4 	bl	11420 <LabSPI::Transfer(unsigned char)>
    data_trans.Transfer(0xFF); //garbage transfer
   10ad8:	21ff      	movs	r1, #255	; 0xff
   10ada:	480d      	ldr	r0, [pc, #52]	; (10b10 <MP3_Decoder::ReadRegister(unsigned char)+0x84>)
   10adc:	f000 fca0 	bl	11420 <LabSPI::Transfer(unsigned char)>
    data_trans.Transfer(0xFF); //garbage transfer
   10ae0:	21ff      	movs	r1, #255	; 0xff
   10ae2:	480b      	ldr	r0, [pc, #44]	; (10b10 <MP3_Decoder::ReadRegister(unsigned char)+0x84>)
   10ae4:	f000 fc9c 	bl	11420 <LabSPI::Transfer(unsigned char)>
    XCS.SetHigh();
   10ae8:	4808      	ldr	r0, [pc, #32]	; (10b0c <MP3_Decoder::ReadRegister(unsigned char)+0x80>)
   10aea:	f004 fbfd 	bl	152e8 <LabGPIO::SetHigh()>
   10aee:	4623      	mov	r3, r4
   10af0:	4619      	mov	r1, r3
   10af2:	4803      	ldr	r0, [pc, #12]	; (10b00 <MP3_Decoder::ReadRegister(unsigned char)+0x74>)
   10af4:	f005 ff12 	bl	1691c <__cyg_profile_func_exit>
}
   10af8:	bf00      	nop
   10afa:	b002      	add	sp, #8
   10afc:	bd10      	pop	{r4, pc}
   10afe:	bf00      	nop
   10b00:	00010a8d 	.word	0x00010a8d
   10b04:	10000778 	.word	0x10000778
   10b08:	10000768 	.word	0x10000768
   10b0c:	1000076c 	.word	0x1000076c
   10b10:	10000728 	.word	0x10000728

00010b14 <MP3_Decoder::WriteRegister(unsigned char, unsigned short)>:
void MP3_Decoder::WriteRegister(unsigned char addrByte, uint16_t value){
   10b14:	b510      	push	{r4, lr}
   10b16:	b082      	sub	sp, #8
   10b18:	4674      	mov	r4, lr
   10b1a:	9001      	str	r0, [sp, #4]
   10b1c:	460b      	mov	r3, r1
   10b1e:	f88d 3003 	strb.w	r3, [sp, #3]
   10b22:	4613      	mov	r3, r2
   10b24:	f8ad 3000 	strh.w	r3, [sp]
   10b28:	4623      	mov	r3, r4
   10b2a:	4619      	mov	r1, r3
   10b2c:	481b      	ldr	r0, [pc, #108]	; (10b9c <MP3_Decoder::WriteRegister(unsigned char, unsigned short)+0x88>)
   10b2e:	f005 fee1 	bl	168f4 <__cyg_profile_func_enter>
    XDCS.SetHigh();
   10b32:	481b      	ldr	r0, [pc, #108]	; (10ba0 <MP3_Decoder::WriteRegister(unsigned char, unsigned short)+0x8c>)
   10b34:	f004 fbd8 	bl	152e8 <LabGPIO::SetHigh()>
    while(!DREQ.ReadBool());
   10b38:	481a      	ldr	r0, [pc, #104]	; (10ba4 <MP3_Decoder::WriteRegister(unsigned char, unsigned short)+0x90>)
   10b3a:	f004 fc19 	bl	15370 <LabGPIO::ReadBool()>
   10b3e:	4603      	mov	r3, r0
   10b40:	f083 0301 	eor.w	r3, r3, #1
   10b44:	b2db      	uxtb	r3, r3
   10b46:	2b00      	cmp	r3, #0
   10b48:	d000      	beq.n	10b4c <MP3_Decoder::WriteRegister(unsigned char, unsigned short)+0x38>
   10b4a:	e7f5      	b.n	10b38 <MP3_Decoder::WriteRegister(unsigned char, unsigned short)+0x24>
    XCS.SetLow();
   10b4c:	4816      	ldr	r0, [pc, #88]	; (10ba8 <MP3_Decoder::WriteRegister(unsigned char, unsigned short)+0x94>)
   10b4e:	f004 fbed 	bl	1532c <LabGPIO::SetLow()>
    data_trans.Transfer(VS1053_Commands::WRITE_COMMAND);
   10b52:	2102      	movs	r1, #2
   10b54:	4815      	ldr	r0, [pc, #84]	; (10bac <MP3_Decoder::WriteRegister(unsigned char, unsigned short)+0x98>)
   10b56:	f000 fc63 	bl	11420 <LabSPI::Transfer(unsigned char)>
    data_trans.Transfer(addrByte);
   10b5a:	f89d 3003 	ldrb.w	r3, [sp, #3]
   10b5e:	4619      	mov	r1, r3
   10b60:	4812      	ldr	r0, [pc, #72]	; (10bac <MP3_Decoder::WriteRegister(unsigned char, unsigned short)+0x98>)
   10b62:	f000 fc5d 	bl	11420 <LabSPI::Transfer(unsigned char)>
    data_trans.Transfer(value >> 8);
   10b66:	f8bd 3000 	ldrh.w	r3, [sp]
   10b6a:	121b      	asrs	r3, r3, #8
   10b6c:	b2db      	uxtb	r3, r3
   10b6e:	4619      	mov	r1, r3
   10b70:	480e      	ldr	r0, [pc, #56]	; (10bac <MP3_Decoder::WriteRegister(unsigned char, unsigned short)+0x98>)
   10b72:	f000 fc55 	bl	11420 <LabSPI::Transfer(unsigned char)>
    data_trans.Transfer(value & 0xFF);
   10b76:	f8bd 3000 	ldrh.w	r3, [sp]
   10b7a:	b2db      	uxtb	r3, r3
   10b7c:	4619      	mov	r1, r3
   10b7e:	480b      	ldr	r0, [pc, #44]	; (10bac <MP3_Decoder::WriteRegister(unsigned char, unsigned short)+0x98>)
   10b80:	f000 fc4e 	bl	11420 <LabSPI::Transfer(unsigned char)>
    XCS.SetHigh();
   10b84:	4808      	ldr	r0, [pc, #32]	; (10ba8 <MP3_Decoder::WriteRegister(unsigned char, unsigned short)+0x94>)
   10b86:	f004 fbaf 	bl	152e8 <LabGPIO::SetHigh()>
   10b8a:	4623      	mov	r3, r4
   10b8c:	4619      	mov	r1, r3
   10b8e:	4803      	ldr	r0, [pc, #12]	; (10b9c <MP3_Decoder::WriteRegister(unsigned char, unsigned short)+0x88>)
   10b90:	f005 fec4 	bl	1691c <__cyg_profile_func_exit>
}
   10b94:	bf00      	nop
   10b96:	b002      	add	sp, #8
   10b98:	bd10      	pop	{r4, pc}
   10b9a:	bf00      	nop
   10b9c:	00010b15 	.word	0x00010b15
   10ba0:	10000778 	.word	0x10000778
   10ba4:	10000768 	.word	0x10000768
   10ba8:	1000076c 	.word	0x1000076c
   10bac:	10000728 	.word	0x10000728

00010bb0 <MP3_Decoder::DataWrite(unsigned char*, unsigned char, unsigned long)>:
void MP3_Decoder::DataWrite(uint8_t *data, uint8_t byte_count, uint32_t start){
   10bb0:	b510      	push	{r4, lr}
   10bb2:	b086      	sub	sp, #24
   10bb4:	4674      	mov	r4, lr
   10bb6:	9003      	str	r0, [sp, #12]
   10bb8:	9102      	str	r1, [sp, #8]
   10bba:	9300      	str	r3, [sp, #0]
   10bbc:	4613      	mov	r3, r2
   10bbe:	f88d 3007 	strb.w	r3, [sp, #7]
   10bc2:	4623      	mov	r3, r4
   10bc4:	4619      	mov	r1, r3
   10bc6:	4814      	ldr	r0, [pc, #80]	; (10c18 <MP3_Decoder::DataWrite(unsigned char*, unsigned char, unsigned long)+0x68>)
   10bc8:	f005 fe94 	bl	168f4 <__cyg_profile_func_enter>
    XCS.SetHigh();
   10bcc:	4813      	ldr	r0, [pc, #76]	; (10c1c <MP3_Decoder::DataWrite(unsigned char*, unsigned char, unsigned long)+0x6c>)
   10bce:	f004 fb8b 	bl	152e8 <LabGPIO::SetHigh()>
    XDCS.SetLow();
   10bd2:	4813      	ldr	r0, [pc, #76]	; (10c20 <MP3_Decoder::DataWrite(unsigned char*, unsigned char, unsigned long)+0x70>)
   10bd4:	f004 fbaa 	bl	1532c <LabGPIO::SetLow()>
    
    for(int i=start; i<start+byte_count; i++){
   10bd8:	9b00      	ldr	r3, [sp, #0]
   10bda:	9305      	str	r3, [sp, #20]
   10bdc:	f89d 2007 	ldrb.w	r2, [sp, #7]
   10be0:	9b00      	ldr	r3, [sp, #0]
   10be2:	441a      	add	r2, r3
   10be4:	9b05      	ldr	r3, [sp, #20]
   10be6:	429a      	cmp	r2, r3
   10be8:	d90b      	bls.n	10c02 <MP3_Decoder::DataWrite(unsigned char*, unsigned char, unsigned long)+0x52>
        //printf("%i, %i\n", byte_count, start);
        data_trans.Transfer(data[i]);
   10bea:	9b05      	ldr	r3, [sp, #20]
   10bec:	9a02      	ldr	r2, [sp, #8]
   10bee:	4413      	add	r3, r2
   10bf0:	781b      	ldrb	r3, [r3, #0]
   10bf2:	4619      	mov	r1, r3
   10bf4:	480b      	ldr	r0, [pc, #44]	; (10c24 <MP3_Decoder::DataWrite(unsigned char*, unsigned char, unsigned long)+0x74>)
   10bf6:	f000 fc13 	bl	11420 <LabSPI::Transfer(unsigned char)>
    for(int i=start; i<start+byte_count; i++){
   10bfa:	9b05      	ldr	r3, [sp, #20]
   10bfc:	3301      	adds	r3, #1
   10bfe:	9305      	str	r3, [sp, #20]
   10c00:	e7ec      	b.n	10bdc <MP3_Decoder::DataWrite(unsigned char*, unsigned char, unsigned long)+0x2c>
        //printf("%i, %i\n", data[0], data[byte_count-1]);
    }
    XDCS.SetHigh();
   10c02:	4807      	ldr	r0, [pc, #28]	; (10c20 <MP3_Decoder::DataWrite(unsigned char*, unsigned char, unsigned long)+0x70>)
   10c04:	f004 fb70 	bl	152e8 <LabGPIO::SetHigh()>
   10c08:	4623      	mov	r3, r4
   10c0a:	4619      	mov	r1, r3
   10c0c:	4802      	ldr	r0, [pc, #8]	; (10c18 <MP3_Decoder::DataWrite(unsigned char*, unsigned char, unsigned long)+0x68>)
   10c0e:	f005 fe85 	bl	1691c <__cyg_profile_func_exit>
}
   10c12:	bf00      	nop
   10c14:	b006      	add	sp, #24
   10c16:	bd10      	pop	{r4, pc}
   10c18:	00010bb1 	.word	0x00010bb1
   10c1c:	1000076c 	.word	0x1000076c
   10c20:	10000778 	.word	0x10000778
   10c24:	10000728 	.word	0x10000728

00010c28 <MP3_Decoder::HardReset()>:
void MP3_Decoder::HardReset(){
   10c28:	b510      	push	{r4, lr}
   10c2a:	b082      	sub	sp, #8
   10c2c:	4674      	mov	r4, lr
   10c2e:	9001      	str	r0, [sp, #4]
   10c30:	4623      	mov	r3, r4
   10c32:	4619      	mov	r1, r3
   10c34:	4813      	ldr	r0, [pc, #76]	; (10c84 <MP3_Decoder::HardReset()+0x5c>)
   10c36:	f005 fe5d 	bl	168f4 <__cyg_profile_func_enter>
    XRESET.SetLow();
   10c3a:	4813      	ldr	r0, [pc, #76]	; (10c88 <MP3_Decoder::HardReset()+0x60>)
   10c3c:	f004 fb76 	bl	1532c <LabGPIO::SetLow()>
    Delay(100); //longer than necessary reset to avoid any conflicts
   10c40:	f04f 0064 	mov.w	r0, #100	; 0x64
   10c44:	f04f 0100 	mov.w	r1, #0
   10c48:	f7ff fcba 	bl	105c0 <Delay(unsigned long long)>
    data_trans.Transfer(0x00); //garbage transfer
   10c4c:	2100      	movs	r1, #0
   10c4e:	480f      	ldr	r0, [pc, #60]	; (10c8c <MP3_Decoder::HardReset()+0x64>)
   10c50:	f000 fbe6 	bl	11420 <LabSPI::Transfer(unsigned char)>
    XRESET.SetHigh();
   10c54:	480c      	ldr	r0, [pc, #48]	; (10c88 <MP3_Decoder::HardReset()+0x60>)
   10c56:	f004 fb47 	bl	152e8 <LabGPIO::SetHigh()>
    while(!DREQ.ReadBool()); //wait until DREQ goes high to continue transfers
   10c5a:	480d      	ldr	r0, [pc, #52]	; (10c90 <MP3_Decoder::HardReset()+0x68>)
   10c5c:	f004 fb88 	bl	15370 <LabGPIO::ReadBool()>
   10c60:	4603      	mov	r3, r0
   10c62:	f083 0301 	eor.w	r3, r3, #1
   10c66:	b2db      	uxtb	r3, r3
   10c68:	2b00      	cmp	r3, #0
   10c6a:	d000      	beq.n	10c6e <MP3_Decoder::HardReset()+0x46>
   10c6c:	e7f5      	b.n	10c5a <MP3_Decoder::HardReset()+0x32>
    SoftReset();
   10c6e:	9801      	ldr	r0, [sp, #4]
   10c70:	f000 f810 	bl	10c94 <MP3_Decoder::SoftReset()>
   10c74:	4623      	mov	r3, r4
   10c76:	4619      	mov	r1, r3
   10c78:	4802      	ldr	r0, [pc, #8]	; (10c84 <MP3_Decoder::HardReset()+0x5c>)
   10c7a:	f005 fe4f 	bl	1691c <__cyg_profile_func_exit>
}
   10c7e:	bf00      	nop
   10c80:	b002      	add	sp, #8
   10c82:	bd10      	pop	{r4, pc}
   10c84:	00010c29 	.word	0x00010c29
   10c88:	1000077c 	.word	0x1000077c
   10c8c:	10000728 	.word	0x10000728
   10c90:	10000768 	.word	0x10000768

00010c94 <MP3_Decoder::SoftReset()>:
void MP3_Decoder::SoftReset(){
   10c94:	b510      	push	{r4, lr}
   10c96:	b082      	sub	sp, #8
   10c98:	4674      	mov	r4, lr
   10c9a:	9001      	str	r0, [sp, #4]
   10c9c:	4623      	mov	r3, r4
   10c9e:	4619      	mov	r1, r3
   10ca0:	482f      	ldr	r0, [pc, #188]	; (10d60 <MP3_Decoder::SoftReset()+0xcc>)
   10ca2:	f005 fe27 	bl	168f4 <__cyg_profile_func_enter>
    WriteRegister(MP3_Decoder::RegisterSetup::MODE, 0x0804);//, 0x04);
   10ca6:	f640 0204 	movw	r2, #2052	; 0x804
   10caa:	2100      	movs	r1, #0
   10cac:	9801      	ldr	r0, [sp, #4]
   10cae:	f7ff ff31 	bl	10b14 <MP3_Decoder::WriteRegister(unsigned char, unsigned short)>
    Delay(100); //longer than necessary reset to avoid any conflicts
   10cb2:	f04f 0064 	mov.w	r0, #100	; 0x64
   10cb6:	f04f 0100 	mov.w	r1, #0
   10cba:	f7ff fc81 	bl	105c0 <Delay(unsigned long long)>
    //data_trans.Transfer(0x00); //garbage transfer
    WriteRegister(MP3_Decoder::RegisterSetup::MODE, 0x0880);//, 0x80);
   10cbe:	f44f 6208 	mov.w	r2, #2176	; 0x880
   10cc2:	2100      	movs	r1, #0
   10cc4:	9801      	ldr	r0, [sp, #4]
   10cc6:	f7ff ff25 	bl	10b14 <MP3_Decoder::WriteRegister(unsigned char, unsigned short)>
    WriteRegister(MP3_Decoder::RegisterSetup::CLOCK, 0xC000);//, 0x00);
   10cca:	f44f 4240 	mov.w	r2, #49152	; 0xc000
   10cce:	2103      	movs	r1, #3
   10cd0:	9801      	ldr	r0, [sp, #4]
   10cd2:	f7ff ff1f 	bl	10b14 <MP3_Decoder::WriteRegister(unsigned char, unsigned short)>
    WriteRegister(MP3_Decoder::RegisterSetup::BASS, 0x0055);//, 0x55);
   10cd6:	2255      	movs	r2, #85	; 0x55
   10cd8:	2102      	movs	r1, #2
   10cda:	9801      	ldr	r0, [sp, #4]
   10cdc:	f7ff ff1a 	bl	10b14 <MP3_Decoder::WriteRegister(unsigned char, unsigned short)>
    WriteRegister(MP3_Decoder::RegisterSetup::VOL, 0x4040);//, 0x40);
   10ce0:	f244 0240 	movw	r2, #16448	; 0x4040
   10ce4:	210b      	movs	r1, #11
   10ce6:	9801      	ldr	r0, [sp, #4]
   10ce8:	f7ff ff14 	bl	10b14 <MP3_Decoder::WriteRegister(unsigned char, unsigned short)>
    while(!DREQ.ReadBool()); //wait until DREQ goes high to continue transfers
   10cec:	481d      	ldr	r0, [pc, #116]	; (10d64 <MP3_Decoder::SoftReset()+0xd0>)
   10cee:	f004 fb3f 	bl	15370 <LabGPIO::ReadBool()>
   10cf2:	4603      	mov	r3, r0
   10cf4:	f083 0301 	eor.w	r3, r3, #1
   10cf8:	b2db      	uxtb	r3, r3
   10cfa:	2b00      	cmp	r3, #0
   10cfc:	d000      	beq.n	10d00 <MP3_Decoder::SoftReset()+0x6c>
   10cfe:	e7f5      	b.n	10cec <MP3_Decoder::SoftReset()+0x58>
    WriteRegister(MP3_Decoder::RegisterSetup::MODE, 0x0880);//, 0x80);
   10d00:	f44f 6208 	mov.w	r2, #2176	; 0x880
   10d04:	2100      	movs	r1, #0
   10d06:	9801      	ldr	r0, [sp, #4]
   10d08:	f7ff ff04 	bl	10b14 <MP3_Decoder::WriteRegister(unsigned char, unsigned short)>
    WriteRegister(MP3_Decoder::RegisterSetup::CLOCK, 0xC000);//, 0x00);
   10d0c:	f44f 4240 	mov.w	r2, #49152	; 0xc000
   10d10:	2103      	movs	r1, #3
   10d12:	9801      	ldr	r0, [sp, #4]
   10d14:	f7ff fefe 	bl	10b14 <MP3_Decoder::WriteRegister(unsigned char, unsigned short)>
    WriteRegister(MP3_Decoder::RegisterSetup::BASS, 0x0055);//, 0x55);
   10d18:	2255      	movs	r2, #85	; 0x55
   10d1a:	2102      	movs	r1, #2
   10d1c:	9801      	ldr	r0, [sp, #4]
   10d1e:	f7ff fef9 	bl	10b14 <MP3_Decoder::WriteRegister(unsigned char, unsigned short)>
    WriteRegister(MP3_Decoder::RegisterSetup::VOL, 0x4040);//, 0x40);
   10d22:	f244 0240 	movw	r2, #16448	; 0x4040
   10d26:	210b      	movs	r1, #11
   10d28:	9801      	ldr	r0, [sp, #4]
   10d2a:	f7ff fef3 	bl	10b14 <MP3_Decoder::WriteRegister(unsigned char, unsigned short)>
    //confirm register values read back the same as they're written
    ReadRegister(MP3_Decoder::RegisterSetup::MODE);
   10d2e:	2100      	movs	r1, #0
   10d30:	9801      	ldr	r0, [sp, #4]
   10d32:	f7ff feab 	bl	10a8c <MP3_Decoder::ReadRegister(unsigned char)>
    ReadRegister(MP3_Decoder::RegisterSetup::CLOCK);
   10d36:	2103      	movs	r1, #3
   10d38:	9801      	ldr	r0, [sp, #4]
   10d3a:	f7ff fea7 	bl	10a8c <MP3_Decoder::ReadRegister(unsigned char)>
    ReadRegister(MP3_Decoder::RegisterSetup::BASS);
   10d3e:	2102      	movs	r1, #2
   10d40:	9801      	ldr	r0, [sp, #4]
   10d42:	f7ff fea3 	bl	10a8c <MP3_Decoder::ReadRegister(unsigned char)>
    ReadRegister(MP3_Decoder::RegisterSetup::VOL);
   10d46:	210b      	movs	r1, #11
   10d48:	9801      	ldr	r0, [sp, #4]
   10d4a:	f7ff fe9f 	bl	10a8c <MP3_Decoder::ReadRegister(unsigned char)>
   10d4e:	4623      	mov	r3, r4
   10d50:	4619      	mov	r1, r3
   10d52:	4803      	ldr	r0, [pc, #12]	; (10d60 <MP3_Decoder::SoftReset()+0xcc>)
   10d54:	f005 fde2 	bl	1691c <__cyg_profile_func_exit>

}
   10d58:	bf00      	nop
   10d5a:	b002      	add	sp, #8
   10d5c:	bd10      	pop	{r4, pc}
   10d5e:	bf00      	nop
   10d60:	00010c95 	.word	0x00010c95
   10d64:	10000768 	.word	0x10000768

00010d68 <MP3_Decoder::waitDREQ()>:
void MP3_Decoder::IncreaseClock(){
    //data_trans.Initialize(8, LabSPI::FrameModes::kSPI, 4);
    XCS.SetHigh();
    XDCS.SetHigh();
}
bool MP3_Decoder::waitDREQ(){
   10d68:	b530      	push	{r4, r5, lr}
   10d6a:	b083      	sub	sp, #12
   10d6c:	4674      	mov	r4, lr
   10d6e:	9001      	str	r0, [sp, #4]
   10d70:	4623      	mov	r3, r4
   10d72:	4619      	mov	r1, r3
   10d74:	4808      	ldr	r0, [pc, #32]	; (10d98 <MP3_Decoder::waitDREQ()+0x30>)
   10d76:	f005 fdbd 	bl	168f4 <__cyg_profile_func_enter>
    return DREQ.ReadBool();
   10d7a:	4808      	ldr	r0, [pc, #32]	; (10d9c <MP3_Decoder::waitDREQ()+0x34>)
   10d7c:	f004 faf8 	bl	15370 <LabGPIO::ReadBool()>
   10d80:	4603      	mov	r3, r0
   10d82:	461d      	mov	r5, r3
   10d84:	4623      	mov	r3, r4
   10d86:	4619      	mov	r1, r3
   10d88:	4803      	ldr	r0, [pc, #12]	; (10d98 <MP3_Decoder::waitDREQ()+0x30>)
   10d8a:	f005 fdc7 	bl	1691c <__cyg_profile_func_exit>
   10d8e:	462b      	mov	r3, r5
}
   10d90:	4618      	mov	r0, r3
   10d92:	b003      	add	sp, #12
   10d94:	bd30      	pop	{r4, r5, pc}
   10d96:	bf00      	nop
   10d98:	00010d69 	.word	0x00010d69
   10d9c:	10000768 	.word	0x10000768

00010da0 <MP3_Decoder::scan_files(char*)>:
FRESULT MP3_Decoder::scan_files (
    char* path        /* Start node to be scanned (***also used as work area***) */
)
{
   10da0:	b530      	push	{r4, r5, lr}
   10da2:	b091      	sub	sp, #68	; 0x44
   10da4:	4675      	mov	r5, lr
   10da6:	9001      	str	r0, [sp, #4]
   10da8:	9100      	str	r1, [sp, #0]
   10daa:	462b      	mov	r3, r5
   10dac:	4619      	mov	r1, r3
   10dae:	4838      	ldr	r0, [pc, #224]	; (10e90 <MP3_Decoder::scan_files(char*)+0xf0>)
   10db0:	f005 fda0 	bl	168f4 <__cyg_profile_func_enter>
    DIR dir;
    UINT i;
    uint8_t index;
    static FILINFO fno;

    oled.Initialize();
   10db4:	9b01      	ldr	r3, [sp, #4]
   10db6:	3310      	adds	r3, #16
   10db8:	4618      	mov	r0, r3
   10dba:	f7ff fdcd 	bl	10958 <OledTerminal::Initialize()>
    res = f_opendir(&dir, path);                       /* Open the directory */
   10dbe:	ab03      	add	r3, sp, #12
   10dc0:	9900      	ldr	r1, [sp, #0]
   10dc2:	4618      	mov	r0, r3
   10dc4:	f00b fa7c 	bl	1c2c0 <f_opendir>
   10dc8:	4603      	mov	r3, r0
   10dca:	f88d 303f 	strb.w	r3, [sp, #63]	; 0x3f
    if (res == FR_OK) {
   10dce:	f89d 303f 	ldrb.w	r3, [sp, #63]	; 0x3f
   10dd2:	2b00      	cmp	r3, #0
   10dd4:	d151      	bne.n	10e7a <MP3_Decoder::scan_files(char*)+0xda>
        for (;;) {
            res = f_readdir(&dir, &fno);                   /* Read a directory item */
   10dd6:	ab03      	add	r3, sp, #12
   10dd8:	492e      	ldr	r1, [pc, #184]	; (10e94 <MP3_Decoder::scan_files(char*)+0xf4>)
   10dda:	4618      	mov	r0, r3
   10ddc:	f00b fb06 	bl	1c3ec <f_readdir>
   10de0:	4603      	mov	r3, r0
   10de2:	f88d 303f 	strb.w	r3, [sp, #63]	; 0x3f
            if (res != FR_OK || fno.fname[0] == 0) break;  /* Break on error or end of dir */
   10de6:	f89d 303f 	ldrb.w	r3, [sp, #63]	; 0x3f
   10dea:	2b00      	cmp	r3, #0
   10dec:	d13d      	bne.n	10e6a <MP3_Decoder::scan_files(char*)+0xca>
   10dee:	4b29      	ldr	r3, [pc, #164]	; (10e94 <MP3_Decoder::scan_files(char*)+0xf4>)
   10df0:	7a5b      	ldrb	r3, [r3, #9]
   10df2:	2b00      	cmp	r3, #0
   10df4:	d039      	beq.n	10e6a <MP3_Decoder::scan_files(char*)+0xca>
            if (fno.fattrib & AM_DIR) {                    /* It is a directory */
   10df6:	4b27      	ldr	r3, [pc, #156]	; (10e94 <MP3_Decoder::scan_files(char*)+0xf4>)
   10df8:	7a1b      	ldrb	r3, [r3, #8]
   10dfa:	f003 0310 	and.w	r3, r3, #16
   10dfe:	2b00      	cmp	r3, #0
   10e00:	d01c      	beq.n	10e3c <MP3_Decoder::scan_files(char*)+0x9c>
                i = strlen(path);
   10e02:	9800      	ldr	r0, [sp, #0]
   10e04:	f00b fea4 	bl	1cb50 <strlen>
   10e08:	900e      	str	r0, [sp, #56]	; 0x38
                sprintf(&path[i], "/%s", fno.fname);
   10e0a:	9a00      	ldr	r2, [sp, #0]
   10e0c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   10e0e:	4413      	add	r3, r2
   10e10:	4a21      	ldr	r2, [pc, #132]	; (10e98 <MP3_Decoder::scan_files(char*)+0xf8>)
   10e12:	4922      	ldr	r1, [pc, #136]	; (10e9c <MP3_Decoder::scan_files(char*)+0xfc>)
   10e14:	4618      	mov	r0, r3
   10e16:	f007 fd09 	bl	1882c <sprintf>
                res = scan_files(path);                    /* Enter the directory */
   10e1a:	9900      	ldr	r1, [sp, #0]
   10e1c:	9801      	ldr	r0, [sp, #4]
   10e1e:	f7ff ffbf 	bl	10da0 <MP3_Decoder::scan_files(char*)>
   10e22:	4603      	mov	r3, r0
   10e24:	f88d 303f 	strb.w	r3, [sp, #63]	; 0x3f
                if (res != FR_OK) break;
   10e28:	f89d 303f 	ldrb.w	r3, [sp, #63]	; 0x3f
   10e2c:	2b00      	cmp	r3, #0
   10e2e:	d11b      	bne.n	10e68 <MP3_Decoder::scan_files(char*)+0xc8>
                path[i] = 0;
   10e30:	9a00      	ldr	r2, [sp, #0]
   10e32:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   10e34:	4413      	add	r3, r2
   10e36:	2200      	movs	r2, #0
   10e38:	701a      	strb	r2, [r3, #0]
   10e3a:	e7cc      	b.n	10dd6 <MP3_Decoder::scan_files(char*)+0x36>
            } else {      
                strcpy(songlist[index], fno.fname);         /* It is a file. */
   10e3c:	f89d 303e 	ldrb.w	r3, [sp, #62]	; 0x3e
   10e40:	021b      	lsls	r3, r3, #8
   10e42:	f503 63fb 	add.w	r3, r3, #2008	; 0x7d8
   10e46:	9a01      	ldr	r2, [sp, #4]
   10e48:	4413      	add	r3, r2
   10e4a:	4913      	ldr	r1, [pc, #76]	; (10e98 <MP3_Decoder::scan_files(char*)+0xf8>)
   10e4c:	4618      	mov	r0, r3
   10e4e:	f00b fe77 	bl	1cb40 <strcpy>
                printf("%s/%s\n", path, fno.fname);
   10e52:	4a11      	ldr	r2, [pc, #68]	; (10e98 <MP3_Decoder::scan_files(char*)+0xf8>)
   10e54:	9900      	ldr	r1, [sp, #0]
   10e56:	4812      	ldr	r0, [pc, #72]	; (10ea0 <MP3_Decoder::scan_files(char*)+0x100>)
   10e58:	f007 fcc2 	bl	187e0 <printf>
                index++;
   10e5c:	f89d 303e 	ldrb.w	r3, [sp, #62]	; 0x3e
   10e60:	3301      	adds	r3, #1
   10e62:	f88d 303e 	strb.w	r3, [sp, #62]	; 0x3e
            res = f_readdir(&dir, &fno);                   /* Read a directory item */
   10e66:	e7b6      	b.n	10dd6 <MP3_Decoder::scan_files(char*)+0x36>
                if (res != FR_OK) break;
   10e68:	bf00      	nop
            }
        }
        maxSong = index;
   10e6a:	9b01      	ldr	r3, [sp, #4]
   10e6c:	f89d 203e 	ldrb.w	r2, [sp, #62]	; 0x3e
   10e70:	711a      	strb	r2, [r3, #4]
        f_closedir(&dir);
   10e72:	ab03      	add	r3, sp, #12
   10e74:	4618      	mov	r0, r3
   10e76:	f00b fa93 	bl	1c3a0 <f_closedir>
    }

    return res;
   10e7a:	f89d 403f 	ldrb.w	r4, [sp, #63]	; 0x3f
   10e7e:	462b      	mov	r3, r5
   10e80:	4619      	mov	r1, r3
   10e82:	4803      	ldr	r0, [pc, #12]	; (10e90 <MP3_Decoder::scan_files(char*)+0xf0>)
   10e84:	f005 fd4a 	bl	1691c <__cyg_profile_func_exit>
   10e88:	4623      	mov	r3, r4
}
   10e8a:	4618      	mov	r0, r3
   10e8c:	b011      	add	sp, #68	; 0x44
   10e8e:	bd30      	pop	{r4, r5, pc}
   10e90:	00010da1 	.word	0x00010da1
   10e94:	10000790 	.word	0x10000790
   10e98:	10000799 	.word	0x10000799
   10e9c:	0001cba0 	.word	0x0001cba0
   10ea0:	0001cba4 	.word	0x0001cba4

00010ea4 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})>:
inline Status Wait(uint64_t timeout, F is_done)
   10ea4:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   10ea8:	b088      	sub	sp, #32
   10eaa:	4675      	mov	r5, lr
   10eac:	e9cd 0102 	strd	r0, r1, [sp, #8]
   10eb0:	f88d 2004 	strb.w	r2, [sp, #4]
   10eb4:	462b      	mov	r3, r5
   10eb6:	4619      	mov	r1, r3
   10eb8:	4824      	ldr	r0, [pc, #144]	; (10f4c <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0xa8>)
   10eba:	f005 fd1b 	bl	168f4 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   10ebe:	f04f 0300 	mov.w	r3, #0
   10ec2:	f04f 0400 	mov.w	r4, #0
   10ec6:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   10eca:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   10ece:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   10ed2:	bf08      	it	eq
   10ed4:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   10ed8:	d106      	bne.n	10ee8 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x44>
    timeout_time = kMaxWait;
   10eda:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   10ede:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   10ee2:	e9cd 3406 	strd	r3, r4, [sp, #24]
   10ee6:	e00b      	b.n	10f00 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x5c>
    timeout_time = Milliseconds() + timeout;
   10ee8:	f7ff faba 	bl	10460 <Milliseconds()>
   10eec:	460a      	mov	r2, r1
   10eee:	4601      	mov	r1, r0
   10ef0:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   10ef4:	eb13 0b01 	adds.w	fp, r3, r1
   10ef8:	eb44 0c02 	adc.w	ip, r4, r2
   10efc:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   10f00:	2301      	movs	r3, #1
   10f02:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   10f04:	f7ff faac 	bl	10460 <Milliseconds()>
   10f08:	460a      	mov	r2, r1
   10f0a:	4601      	mov	r1, r0
   10f0c:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   10f10:	42a2      	cmp	r2, r4
   10f12:	bf08      	it	eq
   10f14:	4299      	cmpeq	r1, r3
   10f16:	bf34      	ite	cc
   10f18:	2301      	movcc	r3, #1
   10f1a:	2300      	movcs	r3, #0
   10f1c:	b2db      	uxtb	r3, r3
   10f1e:	2b00      	cmp	r3, #0
   10f20:	d008      	beq.n	10f34 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x90>
    if (is_done())
   10f22:	ab01      	add	r3, sp, #4
   10f24:	4618      	mov	r0, r3
   10f26:	f7ff fabd 	bl	104a4 <Wait(unsigned long long)::{lambda()#1}::operator()() const>
   10f2a:	4603      	mov	r3, r0
   10f2c:	2b00      	cmp	r3, #0
   10f2e:	d0e9      	beq.n	10f04 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x60>
      status = Status::kSuccess;
   10f30:	2300      	movs	r3, #0
   10f32:	9305      	str	r3, [sp, #20]
  return status;
   10f34:	9c05      	ldr	r4, [sp, #20]
   10f36:	462b      	mov	r3, r5
   10f38:	4619      	mov	r1, r3
   10f3a:	4804      	ldr	r0, [pc, #16]	; (10f4c <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0xa8>)
   10f3c:	f005 fcee 	bl	1691c <__cyg_profile_func_exit>
   10f40:	4623      	mov	r3, r4
}
   10f42:	4618      	mov	r0, r3
   10f44:	b008      	add	sp, #32
   10f46:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   10f4a:	bf00      	nop
   10f4c:	00010ea5 	.word	0x00010ea5

00010f50 <bool bit::Read<unsigned long>(unsigned long, unsigned long)>:
[[gnu::always_inline]][[nodiscard]] constexpr bool Read(T target,
   10f50:	b530      	push	{r4, r5, lr}
   10f52:	b083      	sub	sp, #12
   10f54:	4675      	mov	r5, lr
   10f56:	9001      	str	r0, [sp, #4]
   10f58:	9100      	str	r1, [sp, #0]
   10f5a:	462b      	mov	r3, r5
   10f5c:	4619      	mov	r1, r3
   10f5e:	480c      	ldr	r0, [pc, #48]	; (10f90 <bool bit::Read<unsigned long>(unsigned long, unsigned long)+0x40>)
   10f60:	f005 fcc8 	bl	168f4 <__cyg_profile_func_enter>
  return static_cast<bool>(target & (1 << position));
   10f64:	2201      	movs	r2, #1
   10f66:	9b00      	ldr	r3, [sp, #0]
   10f68:	fa02 f303 	lsl.w	r3, r2, r3
   10f6c:	461a      	mov	r2, r3
   10f6e:	9b01      	ldr	r3, [sp, #4]
   10f70:	4013      	ands	r3, r2
   10f72:	2b00      	cmp	r3, #0
   10f74:	bf14      	ite	ne
   10f76:	2301      	movne	r3, #1
   10f78:	2300      	moveq	r3, #0
   10f7a:	b2dc      	uxtb	r4, r3
   10f7c:	462b      	mov	r3, r5
   10f7e:	4619      	mov	r1, r3
   10f80:	4803      	ldr	r0, [pc, #12]	; (10f90 <bool bit::Read<unsigned long>(unsigned long, unsigned long)+0x40>)
   10f82:	f005 fccb 	bl	1691c <__cyg_profile_func_exit>
   10f86:	4623      	mov	r3, r4
}
   10f88:	4618      	mov	r0, r3
   10f8a:	b003      	add	sp, #12
   10f8c:	bd30      	pop	{r4, r5, pc}
   10f8e:	bf00      	nop
   10f90:	00010f51 	.word	0x00010f51

00010f94 <__static_initialization_and_destruction_0(int, int)>:
   10f94:	b510      	push	{r4, lr}
   10f96:	b082      	sub	sp, #8
   10f98:	4674      	mov	r4, lr
   10f9a:	9001      	str	r0, [sp, #4]
   10f9c:	9100      	str	r1, [sp, #0]
   10f9e:	4623      	mov	r3, r4
   10fa0:	4619      	mov	r1, r3
   10fa2:	4852      	ldr	r0, [pc, #328]	; (110ec <__static_initialization_and_destruction_0(int, int)+0x158>)
   10fa4:	f005 fca6 	bl	168f4 <__cyg_profile_func_enter>
   10fa8:	9b01      	ldr	r3, [sp, #4]
   10faa:	2b01      	cmp	r3, #1
   10fac:	f040 8095 	bne.w	110da <__static_initialization_and_destruction_0(int, int)+0x146>
   10fb0:	9b00      	ldr	r3, [sp, #0]
   10fb2:	f64f 72ff 	movw	r2, #65535	; 0xffff
   10fb6:	4293      	cmp	r3, r2
   10fb8:	f040 808f 	bne.w	110da <__static_initialization_and_destruction_0(int, int)+0x146>

  static constexpr IRQn kTimerIrq[] = { IRQn::TIMER0_IRQn, IRQn::TIMER1_IRQn,
                                        IRQn::TIMER2_IRQn, IRQn::TIMER3_IRQn };
  static void DoNothingIsr() {}

  inline static volatile uint32_t * match[4][4] = {
   10fbc:	4b4c      	ldr	r3, [pc, #304]	; (110f0 <__static_initialization_and_destruction_0(int, int)+0x15c>)
   10fbe:	681b      	ldr	r3, [r3, #0]
   10fc0:	f003 0301 	and.w	r3, r3, #1
   10fc4:	2b00      	cmp	r3, #0
   10fc6:	d152      	bne.n	1106e <__static_initialization_and_destruction_0(int, int)+0xda>
   10fc8:	4b49      	ldr	r3, [pc, #292]	; (110f0 <__static_initialization_and_destruction_0(int, int)+0x15c>)
   10fca:	2201      	movs	r2, #1
   10fcc:	601a      	str	r2, [r3, #0]
    [kTimer0] = { &tim_register[0]->MR0, &tim_register[0]->MR1,
   10fce:	4b49      	ldr	r3, [pc, #292]	; (110f4 <__static_initialization_and_destruction_0(int, int)+0x160>)
   10fd0:	681b      	ldr	r3, [r3, #0]
   10fd2:	3318      	adds	r3, #24
                  &tim_register[1]->MR2, &tim_register[1]->MR3 },
    [kTimer2] = { &tim_register[2]->MR0, &tim_register[2]->MR1,
                  &tim_register[2]->MR2, &tim_register[2]->MR3 },
    [kTimer3] = { &tim_register[3]->MR0, &tim_register[3]->MR1,
                  &tim_register[3]->MR2, &tim_register[3]->MR3 }
  };
   10fd4:	4a48      	ldr	r2, [pc, #288]	; (110f8 <__static_initialization_and_destruction_0(int, int)+0x164>)
   10fd6:	6013      	str	r3, [r2, #0]
    [kTimer0] = { &tim_register[0]->MR0, &tim_register[0]->MR1,
   10fd8:	4b46      	ldr	r3, [pc, #280]	; (110f4 <__static_initialization_and_destruction_0(int, int)+0x160>)
   10fda:	681b      	ldr	r3, [r3, #0]
   10fdc:	331c      	adds	r3, #28
  };
   10fde:	4a46      	ldr	r2, [pc, #280]	; (110f8 <__static_initialization_and_destruction_0(int, int)+0x164>)
   10fe0:	6053      	str	r3, [r2, #4]
                  &tim_register[0]->MR2, &tim_register[0]->MR3 },
   10fe2:	4b44      	ldr	r3, [pc, #272]	; (110f4 <__static_initialization_and_destruction_0(int, int)+0x160>)
   10fe4:	681b      	ldr	r3, [r3, #0]
   10fe6:	3320      	adds	r3, #32
  };
   10fe8:	4a43      	ldr	r2, [pc, #268]	; (110f8 <__static_initialization_and_destruction_0(int, int)+0x164>)
   10fea:	6093      	str	r3, [r2, #8]
                  &tim_register[0]->MR2, &tim_register[0]->MR3 },
   10fec:	4b41      	ldr	r3, [pc, #260]	; (110f4 <__static_initialization_and_destruction_0(int, int)+0x160>)
   10fee:	681b      	ldr	r3, [r3, #0]
   10ff0:	3324      	adds	r3, #36	; 0x24
  };
   10ff2:	4a41      	ldr	r2, [pc, #260]	; (110f8 <__static_initialization_and_destruction_0(int, int)+0x164>)
   10ff4:	60d3      	str	r3, [r2, #12]
    [kTimer1] = { &tim_register[1]->MR0, &tim_register[1]->MR1,
   10ff6:	4b3f      	ldr	r3, [pc, #252]	; (110f4 <__static_initialization_and_destruction_0(int, int)+0x160>)
   10ff8:	685b      	ldr	r3, [r3, #4]
   10ffa:	3318      	adds	r3, #24
  };
   10ffc:	4a3e      	ldr	r2, [pc, #248]	; (110f8 <__static_initialization_and_destruction_0(int, int)+0x164>)
   10ffe:	6113      	str	r3, [r2, #16]
    [kTimer1] = { &tim_register[1]->MR0, &tim_register[1]->MR1,
   11000:	4b3c      	ldr	r3, [pc, #240]	; (110f4 <__static_initialization_and_destruction_0(int, int)+0x160>)
   11002:	685b      	ldr	r3, [r3, #4]
   11004:	331c      	adds	r3, #28
  };
   11006:	4a3c      	ldr	r2, [pc, #240]	; (110f8 <__static_initialization_and_destruction_0(int, int)+0x164>)
   11008:	6153      	str	r3, [r2, #20]
                  &tim_register[1]->MR2, &tim_register[1]->MR3 },
   1100a:	4b3a      	ldr	r3, [pc, #232]	; (110f4 <__static_initialization_and_destruction_0(int, int)+0x160>)
   1100c:	685b      	ldr	r3, [r3, #4]
   1100e:	3320      	adds	r3, #32
  };
   11010:	4a39      	ldr	r2, [pc, #228]	; (110f8 <__static_initialization_and_destruction_0(int, int)+0x164>)
   11012:	6193      	str	r3, [r2, #24]
                  &tim_register[1]->MR2, &tim_register[1]->MR3 },
   11014:	4b37      	ldr	r3, [pc, #220]	; (110f4 <__static_initialization_and_destruction_0(int, int)+0x160>)
   11016:	685b      	ldr	r3, [r3, #4]
   11018:	3324      	adds	r3, #36	; 0x24
  };
   1101a:	4a37      	ldr	r2, [pc, #220]	; (110f8 <__static_initialization_and_destruction_0(int, int)+0x164>)
   1101c:	61d3      	str	r3, [r2, #28]
    [kTimer2] = { &tim_register[2]->MR0, &tim_register[2]->MR1,
   1101e:	4b35      	ldr	r3, [pc, #212]	; (110f4 <__static_initialization_and_destruction_0(int, int)+0x160>)
   11020:	689b      	ldr	r3, [r3, #8]
   11022:	3318      	adds	r3, #24
  };
   11024:	4a34      	ldr	r2, [pc, #208]	; (110f8 <__static_initialization_and_destruction_0(int, int)+0x164>)
   11026:	6213      	str	r3, [r2, #32]
    [kTimer2] = { &tim_register[2]->MR0, &tim_register[2]->MR1,
   11028:	4b32      	ldr	r3, [pc, #200]	; (110f4 <__static_initialization_and_destruction_0(int, int)+0x160>)
   1102a:	689b      	ldr	r3, [r3, #8]
   1102c:	331c      	adds	r3, #28
  };
   1102e:	4a32      	ldr	r2, [pc, #200]	; (110f8 <__static_initialization_and_destruction_0(int, int)+0x164>)
   11030:	6253      	str	r3, [r2, #36]	; 0x24
                  &tim_register[2]->MR2, &tim_register[2]->MR3 },
   11032:	4b30      	ldr	r3, [pc, #192]	; (110f4 <__static_initialization_and_destruction_0(int, int)+0x160>)
   11034:	689b      	ldr	r3, [r3, #8]
   11036:	3320      	adds	r3, #32
  };
   11038:	4a2f      	ldr	r2, [pc, #188]	; (110f8 <__static_initialization_and_destruction_0(int, int)+0x164>)
   1103a:	6293      	str	r3, [r2, #40]	; 0x28
                  &tim_register[2]->MR2, &tim_register[2]->MR3 },
   1103c:	4b2d      	ldr	r3, [pc, #180]	; (110f4 <__static_initialization_and_destruction_0(int, int)+0x160>)
   1103e:	689b      	ldr	r3, [r3, #8]
   11040:	3324      	adds	r3, #36	; 0x24
  };
   11042:	4a2d      	ldr	r2, [pc, #180]	; (110f8 <__static_initialization_and_destruction_0(int, int)+0x164>)
   11044:	62d3      	str	r3, [r2, #44]	; 0x2c
    [kTimer3] = { &tim_register[3]->MR0, &tim_register[3]->MR1,
   11046:	4b2b      	ldr	r3, [pc, #172]	; (110f4 <__static_initialization_and_destruction_0(int, int)+0x160>)
   11048:	68db      	ldr	r3, [r3, #12]
   1104a:	3318      	adds	r3, #24
  };
   1104c:	4a2a      	ldr	r2, [pc, #168]	; (110f8 <__static_initialization_and_destruction_0(int, int)+0x164>)
   1104e:	6313      	str	r3, [r2, #48]	; 0x30
    [kTimer3] = { &tim_register[3]->MR0, &tim_register[3]->MR1,
   11050:	4b28      	ldr	r3, [pc, #160]	; (110f4 <__static_initialization_and_destruction_0(int, int)+0x160>)
   11052:	68db      	ldr	r3, [r3, #12]
   11054:	331c      	adds	r3, #28
  };
   11056:	4a28      	ldr	r2, [pc, #160]	; (110f8 <__static_initialization_and_destruction_0(int, int)+0x164>)
   11058:	6353      	str	r3, [r2, #52]	; 0x34
                  &tim_register[3]->MR2, &tim_register[3]->MR3 }
   1105a:	4b26      	ldr	r3, [pc, #152]	; (110f4 <__static_initialization_and_destruction_0(int, int)+0x160>)
   1105c:	68db      	ldr	r3, [r3, #12]
   1105e:	3320      	adds	r3, #32
  };
   11060:	4a25      	ldr	r2, [pc, #148]	; (110f8 <__static_initialization_and_destruction_0(int, int)+0x164>)
   11062:	6393      	str	r3, [r2, #56]	; 0x38
                  &tim_register[3]->MR2, &tim_register[3]->MR3 }
   11064:	4b23      	ldr	r3, [pc, #140]	; (110f4 <__static_initialization_and_destruction_0(int, int)+0x160>)
   11066:	68db      	ldr	r3, [r3, #12]
   11068:	3324      	adds	r3, #36	; 0x24
  };
   1106a:	4a23      	ldr	r2, [pc, #140]	; (110f8 <__static_initialization_and_destruction_0(int, int)+0x164>)
   1106c:	63d3      	str	r3, [r2, #60]	; 0x3c
LabSPI data_trans(0);
   1106e:	2100      	movs	r1, #0
   11070:	4822      	ldr	r0, [pc, #136]	; (110fc <__static_initialization_and_destruction_0(int, int)+0x168>)
   11072:	f7ff f9a3 	bl	103bc <LabSPI::LabSPI(unsigned char)>
LabGPIO DREQ(0, 0);
   11076:	2200      	movs	r2, #0
   11078:	2100      	movs	r1, #0
   1107a:	4821      	ldr	r0, [pc, #132]	; (11100 <__static_initialization_and_destruction_0(int, int)+0x16c>)
   1107c:	f7ff f976 	bl	1036c <LabGPIO::LabGPIO(unsigned char, unsigned char)>
LabGPIO XCS(1, 28);
   11080:	221c      	movs	r2, #28
   11082:	2101      	movs	r1, #1
   11084:	481f      	ldr	r0, [pc, #124]	; (11104 <__static_initialization_and_destruction_0(int, int)+0x170>)
   11086:	f7ff f971 	bl	1036c <LabGPIO::LabGPIO(unsigned char, unsigned char)>
LabGPIO CS_SD(1, 23);
   1108a:	2217      	movs	r2, #23
   1108c:	2101      	movs	r1, #1
   1108e:	481e      	ldr	r0, [pc, #120]	; (11108 <__static_initialization_and_destruction_0(int, int)+0x174>)
   11090:	f7ff f96c 	bl	1036c <LabGPIO::LabGPIO(unsigned char, unsigned char)>
LabGPIO SD_Detect(2, 2);
   11094:	2202      	movs	r2, #2
   11096:	2102      	movs	r1, #2
   11098:	481c      	ldr	r0, [pc, #112]	; (1110c <__static_initialization_and_destruction_0(int, int)+0x178>)
   1109a:	f7ff f967 	bl	1036c <LabGPIO::LabGPIO(unsigned char, unsigned char)>
LabGPIO XDCS(1, 20);
   1109e:	2214      	movs	r2, #20
   110a0:	2101      	movs	r1, #1
   110a2:	481b      	ldr	r0, [pc, #108]	; (11110 <__static_initialization_and_destruction_0(int, int)+0x17c>)
   110a4:	f7ff f962 	bl	1036c <LabGPIO::LabGPIO(unsigned char, unsigned char)>
LabGPIO XRESET(2, 7);
   110a8:	2207      	movs	r2, #7
   110aa:	2102      	movs	r1, #2
   110ac:	4819      	ldr	r0, [pc, #100]	; (11114 <__static_initialization_and_destruction_0(int, int)+0x180>)
   110ae:	f7ff f95d 	bl	1036c <LabGPIO::LabGPIO(unsigned char, unsigned char)>
LabGPIO SW3(0, 29);
   110b2:	221d      	movs	r2, #29
   110b4:	2100      	movs	r1, #0
   110b6:	4818      	ldr	r0, [pc, #96]	; (11118 <__static_initialization_and_destruction_0(int, int)+0x184>)
   110b8:	f7ff f958 	bl	1036c <LabGPIO::LabGPIO(unsigned char, unsigned char)>
LabGPIO SW2(0, 30);
   110bc:	221e      	movs	r2, #30
   110be:	2100      	movs	r1, #0
   110c0:	4816      	ldr	r0, [pc, #88]	; (1111c <__static_initialization_and_destruction_0(int, int)+0x188>)
   110c2:	f7ff f953 	bl	1036c <LabGPIO::LabGPIO(unsigned char, unsigned char)>
LabGPIO SW1(1, 15);
   110c6:	220f      	movs	r2, #15
   110c8:	2101      	movs	r1, #1
   110ca:	4815      	ldr	r0, [pc, #84]	; (11120 <__static_initialization_and_destruction_0(int, int)+0x18c>)
   110cc:	f7ff f94e 	bl	1036c <LabGPIO::LabGPIO(unsigned char, unsigned char)>
LabGPIO SW0(1, 19);
   110d0:	2213      	movs	r2, #19
   110d2:	2101      	movs	r1, #1
   110d4:	4813      	ldr	r0, [pc, #76]	; (11124 <__static_initialization_and_destruction_0(int, int)+0x190>)
   110d6:	f7ff f949 	bl	1036c <LabGPIO::LabGPIO(unsigned char, unsigned char)>
   110da:	4623      	mov	r3, r4
   110dc:	4619      	mov	r1, r3
   110de:	4803      	ldr	r0, [pc, #12]	; (110ec <__static_initialization_and_destruction_0(int, int)+0x158>)
   110e0:	f005 fc1c 	bl	1691c <__cyg_profile_func_exit>
}
   110e4:	bf00      	nop
   110e6:	b002      	add	sp, #8
   110e8:	bd10      	pop	{r4, pc}
   110ea:	bf00      	nop
   110ec:	00010f95 	.word	0x00010f95
   110f0:	100007a8 	.word	0x100007a8
   110f4:	10000004 	.word	0x10000004
   110f8:	100006e8 	.word	0x100006e8
   110fc:	10000728 	.word	0x10000728
   11100:	10000768 	.word	0x10000768
   11104:	1000076c 	.word	0x1000076c
   11108:	10000770 	.word	0x10000770
   1110c:	10000774 	.word	0x10000774
   11110:	10000778 	.word	0x10000778
   11114:	1000077c 	.word	0x1000077c
   11118:	10000780 	.word	0x10000780
   1111c:	10000784 	.word	0x10000784
   11120:	10000788 	.word	0x10000788
   11124:	1000078c 	.word	0x1000078c

00011128 <_GLOBAL__sub_I_data_trans>:
   11128:	b510      	push	{r4, lr}
   1112a:	4674      	mov	r4, lr
   1112c:	4623      	mov	r3, r4
   1112e:	4619      	mov	r1, r3
   11130:	4806      	ldr	r0, [pc, #24]	; (1114c <_GLOBAL__sub_I_data_trans+0x24>)
   11132:	f005 fbdf 	bl	168f4 <__cyg_profile_func_enter>
   11136:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1113a:	2001      	movs	r0, #1
   1113c:	f7ff ff2a 	bl	10f94 <__static_initialization_and_destruction_0(int, int)>
   11140:	4623      	mov	r3, r4
   11142:	4619      	mov	r1, r3
   11144:	4801      	ldr	r0, [pc, #4]	; (1114c <_GLOBAL__sub_I_data_trans+0x24>)
   11146:	f005 fbe9 	bl	1691c <__cyg_profile_func_exit>
   1114a:	bd10      	pop	{r4, pc}
   1114c:	00011129 	.word	0x00011129

00011150 <LabSPI::SSPnPower()>:
#include "LabSPI.hpp"
#include "L0_LowLevel/LPC40xx.h"
#include <stdio.h>

void LabSPI::SSPnPower(){
   11150:	b510      	push	{r4, lr}
   11152:	b082      	sub	sp, #8
   11154:	4674      	mov	r4, lr
   11156:	9001      	str	r0, [sp, #4]
   11158:	4623      	mov	r3, r4
   1115a:	4619      	mov	r1, r3
   1115c:	4812      	ldr	r0, [pc, #72]	; (111a8 <LabSPI::SSPnPower()+0x58>)
   1115e:	f005 fbc9 	bl	168f4 <__cyg_profile_func_enter>
    
    printf("Setting ON SSP%u.\n", whichSSP);
   11162:	9b01      	ldr	r3, [sp, #4]
   11164:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   11168:	4619      	mov	r1, r3
   1116a:	4810      	ldr	r0, [pc, #64]	; (111ac <LabSPI::SSPnPower()+0x5c>)
   1116c:	f007 fb38 	bl	187e0 <printf>
    LPC_SC->PCONP |= 1 << PowerShiftValues[whichSSP];
   11170:	4b0f      	ldr	r3, [pc, #60]	; (111b0 <LabSPI::SSPnPower()+0x60>)
   11172:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   11176:	9a01      	ldr	r2, [sp, #4]
   11178:	f892 203c 	ldrb.w	r2, [r2, #60]	; 0x3c
   1117c:	4611      	mov	r1, r2
   1117e:	9a01      	ldr	r2, [sp, #4]
   11180:	310c      	adds	r1, #12
   11182:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
   11186:	2101      	movs	r1, #1
   11188:	fa01 f202 	lsl.w	r2, r1, r2
   1118c:	4611      	mov	r1, r2
   1118e:	4a08      	ldr	r2, [pc, #32]	; (111b0 <LabSPI::SSPnPower()+0x60>)
   11190:	430b      	orrs	r3, r1
   11192:	f8c2 30c4 	str.w	r3, [r2, #196]	; 0xc4
   11196:	4623      	mov	r3, r4
   11198:	4619      	mov	r1, r3
   1119a:	4803      	ldr	r0, [pc, #12]	; (111a8 <LabSPI::SSPnPower()+0x58>)
   1119c:	f005 fbbe 	bl	1691c <__cyg_profile_func_exit>
}
   111a0:	bf00      	nop
   111a2:	b002      	add	sp, #8
   111a4:	bd10      	pop	{r4, pc}
   111a6:	bf00      	nop
   111a8:	00011151 	.word	0x00011151
   111ac:	0001cbac 	.word	0x0001cbac
   111b0:	400fc000 	.word	0x400fc000

000111b4 <LabSPI::SetClocks(unsigned char)>:
bool LabSPI::SetClocks(uint8_t divide){
   111b4:	b510      	push	{r4, lr}
   111b6:	b082      	sub	sp, #8
   111b8:	4674      	mov	r4, lr
   111ba:	9001      	str	r0, [sp, #4]
   111bc:	460b      	mov	r3, r1
   111be:	f88d 3003 	strb.w	r3, [sp, #3]
   111c2:	4623      	mov	r3, r4
   111c4:	4619      	mov	r1, r3
   111c6:	481b      	ldr	r0, [pc, #108]	; (11234 <LabSPI::SetClocks(unsigned char)+0x80>)
   111c8:	f005 fb94 	bl	168f4 <__cyg_profile_func_enter>
    printf("Setting clock rate.\n");
   111cc:	481a      	ldr	r0, [pc, #104]	; (11238 <LabSPI::SetClocks(unsigned char)+0x84>)
   111ce:	f005 fb61 	bl	16894 <puts>
    SSP_n[whichSSP]->CPSR |= 1 << 2; //set CPSR to 2
   111d2:	9b01      	ldr	r3, [sp, #4]
   111d4:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   111d8:	461a      	mov	r2, r3
   111da:	4b18      	ldr	r3, [pc, #96]	; (1123c <LabSPI::SetClocks(unsigned char)+0x88>)
   111dc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   111e0:	691a      	ldr	r2, [r3, #16]
   111e2:	9b01      	ldr	r3, [sp, #4]
   111e4:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   111e8:	4619      	mov	r1, r3
   111ea:	4b14      	ldr	r3, [pc, #80]	; (1123c <LabSPI::SetClocks(unsigned char)+0x88>)
   111ec:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   111f0:	f042 0204 	orr.w	r2, r2, #4
   111f4:	611a      	str	r2, [r3, #16]
    //if((divide%2 == 0) & (divide != 0)){
        SSP_n[whichSSP]->CR0 |= divide << RegisterShiftValues::kClkRate;
   111f6:	9b01      	ldr	r3, [sp, #4]
   111f8:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   111fc:	461a      	mov	r2, r3
   111fe:	4b0f      	ldr	r3, [pc, #60]	; (1123c <LabSPI::SetClocks(unsigned char)+0x88>)
   11200:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11204:	681a      	ldr	r2, [r3, #0]
   11206:	f89d 3003 	ldrb.w	r3, [sp, #3]
   1120a:	021b      	lsls	r3, r3, #8
   1120c:	4619      	mov	r1, r3
   1120e:	9b01      	ldr	r3, [sp, #4]
   11210:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   11214:	4618      	mov	r0, r3
   11216:	4b09      	ldr	r3, [pc, #36]	; (1123c <LabSPI::SetClocks(unsigned char)+0x88>)
   11218:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   1121c:	430a      	orrs	r2, r1
   1121e:	601a      	str	r2, [r3, #0]
   11220:	4623      	mov	r3, r4
   11222:	4619      	mov	r1, r3
   11224:	4803      	ldr	r0, [pc, #12]	; (11234 <LabSPI::SetClocks(unsigned char)+0x80>)
   11226:	f005 fb79 	bl	1691c <__cyg_profile_func_exit>
    //}
    // else {
    //     printf("That value of clock division is invalid!\n");
    //     return false;
    // }
}
   1122a:	bf00      	nop
   1122c:	4618      	mov	r0, r3
   1122e:	b002      	add	sp, #8
   11230:	bd10      	pop	{r4, pc}
   11232:	bf00      	nop
   11234:	000111b5 	.word	0x000111b5
   11238:	0001cbc0 	.word	0x0001cbc0
   1123c:	10000038 	.word	0x10000038

00011240 <LabSPI::SetPinMode()>:
void LabSPI::SetPinMode(){
   11240:	b530      	push	{r4, r5, lr}
   11242:	b085      	sub	sp, #20
   11244:	4675      	mov	r5, lr
   11246:	9001      	str	r0, [sp, #4]
   11248:	462b      	mov	r3, r5
   1124a:	4619      	mov	r1, r3
   1124c:	4822      	ldr	r0, [pc, #136]	; (112d8 <LabSPI::SetPinMode()+0x98>)
   1124e:	f005 fb51 	bl	168f4 <__cyg_profile_func_enter>
    printf("Setting pin mode to SSP.\n");
   11252:	4822      	ldr	r0, [pc, #136]	; (112dc <LabSPI::SetPinMode()+0x9c>)
   11254:	f005 fb1e 	bl	16894 <puts>
    for(int i=0; i<3; i++){
   11258:	2300      	movs	r3, #0
   1125a:	9303      	str	r3, [sp, #12]
   1125c:	9b03      	ldr	r3, [sp, #12]
   1125e:	2b02      	cmp	r3, #2
   11260:	dc31      	bgt.n	112c6 <LabSPI::SetPinMode()+0x86>
        *SPI_pin[whichSSP][i] = ((*SPI_pin[whichSSP][i] & ~(FunctionModeShift[whichSSP])) | (FunctionModeShift[whichSSP]));
   11262:	9b01      	ldr	r3, [sp, #4]
   11264:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   11268:	4619      	mov	r1, r3
   1126a:	9a01      	ldr	r2, [sp, #4]
   1126c:	460b      	mov	r3, r1
   1126e:	005b      	lsls	r3, r3, #1
   11270:	440b      	add	r3, r1
   11272:	9903      	ldr	r1, [sp, #12]
   11274:	440b      	add	r3, r1
   11276:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1127a:	681a      	ldr	r2, [r3, #0]
   1127c:	9b01      	ldr	r3, [sp, #4]
   1127e:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   11282:	9901      	ldr	r1, [sp, #4]
   11284:	3308      	adds	r3, #8
   11286:	009b      	lsls	r3, r3, #2
   11288:	440b      	add	r3, r1
   1128a:	685b      	ldr	r3, [r3, #4]
   1128c:	43db      	mvns	r3, r3
   1128e:	401a      	ands	r2, r3
   11290:	9b01      	ldr	r3, [sp, #4]
   11292:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   11296:	9901      	ldr	r1, [sp, #4]
   11298:	3308      	adds	r3, #8
   1129a:	009b      	lsls	r3, r3, #2
   1129c:	440b      	add	r3, r1
   1129e:	685b      	ldr	r3, [r3, #4]
   112a0:	461c      	mov	r4, r3
   112a2:	9b01      	ldr	r3, [sp, #4]
   112a4:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   112a8:	4618      	mov	r0, r3
   112aa:	9901      	ldr	r1, [sp, #4]
   112ac:	4603      	mov	r3, r0
   112ae:	005b      	lsls	r3, r3, #1
   112b0:	4403      	add	r3, r0
   112b2:	9803      	ldr	r0, [sp, #12]
   112b4:	4403      	add	r3, r0
   112b6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   112ba:	4322      	orrs	r2, r4
   112bc:	601a      	str	r2, [r3, #0]
    for(int i=0; i<3; i++){
   112be:	9b03      	ldr	r3, [sp, #12]
   112c0:	3301      	adds	r3, #1
   112c2:	9303      	str	r3, [sp, #12]
   112c4:	e7ca      	b.n	1125c <LabSPI::SetPinMode()+0x1c>
   112c6:	462b      	mov	r3, r5
   112c8:	4619      	mov	r1, r3
   112ca:	4803      	ldr	r0, [pc, #12]	; (112d8 <LabSPI::SetPinMode()+0x98>)
   112cc:	f005 fb26 	bl	1691c <__cyg_profile_func_exit>
    }
}
   112d0:	bf00      	nop
   112d2:	b005      	add	sp, #20
   112d4:	bd30      	pop	{r4, r5, pc}
   112d6:	bf00      	nop
   112d8:	00011241 	.word	0x00011241
   112dc:	0001cbd4 	.word	0x0001cbd4

000112e0 <LabSPI::Initialize(unsigned char, LabSPI::FrameModes, unsigned char)>:
bool LabSPI::Initialize(uint8_t data_size_select, FrameModes format, uint8_t divide){
   112e0:	b530      	push	{r4, r5, lr}
   112e2:	b085      	sub	sp, #20
   112e4:	4675      	mov	r5, lr
   112e6:	9001      	str	r0, [sp, #4]
   112e8:	4608      	mov	r0, r1
   112ea:	4611      	mov	r1, r2
   112ec:	461a      	mov	r2, r3
   112ee:	4603      	mov	r3, r0
   112f0:	f88d 3003 	strb.w	r3, [sp, #3]
   112f4:	460b      	mov	r3, r1
   112f6:	f88d 3002 	strb.w	r3, [sp, #2]
   112fa:	4613      	mov	r3, r2
   112fc:	f88d 3001 	strb.w	r3, [sp, #1]
   11300:	462b      	mov	r3, r5
   11302:	4619      	mov	r1, r3
   11304:	4843      	ldr	r0, [pc, #268]	; (11414 <LabSPI::Initialize(unsigned char, LabSPI::FrameModes, unsigned char)+0x134>)
   11306:	f005 faf5 	bl	168f4 <__cyg_profile_func_enter>
    SSPnPower(); //turn on SSPn
   1130a:	9801      	ldr	r0, [sp, #4]
   1130c:	f7ff ff20 	bl	11150 <LabSPI::SSPnPower()>
    bool cont = SetClocks(divide); //set clock
   11310:	f89d 3001 	ldrb.w	r3, [sp, #1]
   11314:	4619      	mov	r1, r3
   11316:	9801      	ldr	r0, [sp, #4]
   11318:	f7ff ff4c 	bl	111b4 <LabSPI::SetClocks(unsigned char)>
   1131c:	4603      	mov	r3, r0
   1131e:	f88d 300f 	strb.w	r3, [sp, #15]
   if(cont){
   11322:	f89d 300f 	ldrb.w	r3, [sp, #15]
   11326:	2b00      	cmp	r3, #0
   11328:	d06a      	beq.n	11400 <LabSPI::Initialize(unsigned char, LabSPI::FrameModes, unsigned char)+0x120>
      SetPinMode(); //set pin mode to SSP
   1132a:	9801      	ldr	r0, [sp, #4]
   1132c:	f7ff ff88 	bl	11240 <LabSPI::SetPinMode()>
      printf("Setting data_size_select to %u.\nSetting format to SPI mode.\nEnabling device.\n", data_size_select);
   11330:	f89d 3003 	ldrb.w	r3, [sp, #3]
   11334:	4619      	mov	r1, r3
   11336:	4838      	ldr	r0, [pc, #224]	; (11418 <LabSPI::Initialize(unsigned char, LabSPI::FrameModes, unsigned char)+0x138>)
   11338:	f007 fa52 	bl	187e0 <printf>
      SSP_n[whichSSP]->CR0 |= (data_size_select-1) << kDataSize;
   1133c:	9b01      	ldr	r3, [sp, #4]
   1133e:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   11342:	461a      	mov	r2, r3
   11344:	4b35      	ldr	r3, [pc, #212]	; (1141c <LabSPI::Initialize(unsigned char, LabSPI::FrameModes, unsigned char)+0x13c>)
   11346:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1134a:	681a      	ldr	r2, [r3, #0]
   1134c:	f89d 3003 	ldrb.w	r3, [sp, #3]
   11350:	3b01      	subs	r3, #1
   11352:	4619      	mov	r1, r3
   11354:	9b01      	ldr	r3, [sp, #4]
   11356:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   1135a:	4618      	mov	r0, r3
   1135c:	4b2f      	ldr	r3, [pc, #188]	; (1141c <LabSPI::Initialize(unsigned char, LabSPI::FrameModes, unsigned char)+0x13c>)
   1135e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   11362:	430a      	orrs	r2, r1
   11364:	601a      	str	r2, [r3, #0]
      SSP_n[whichSSP]->CR0 |= format << kFrameFormat;
   11366:	9b01      	ldr	r3, [sp, #4]
   11368:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   1136c:	461a      	mov	r2, r3
   1136e:	4b2b      	ldr	r3, [pc, #172]	; (1141c <LabSPI::Initialize(unsigned char, LabSPI::FrameModes, unsigned char)+0x13c>)
   11370:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11374:	681a      	ldr	r2, [r3, #0]
   11376:	f89d 3002 	ldrb.w	r3, [sp, #2]
   1137a:	011b      	lsls	r3, r3, #4
   1137c:	4619      	mov	r1, r3
   1137e:	9b01      	ldr	r3, [sp, #4]
   11380:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   11384:	4618      	mov	r0, r3
   11386:	4b25      	ldr	r3, [pc, #148]	; (1141c <LabSPI::Initialize(unsigned char, LabSPI::FrameModes, unsigned char)+0x13c>)
   11388:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   1138c:	430a      	orrs	r2, r1
   1138e:	601a      	str	r2, [r3, #0]
      SSP_n[whichSSP]->CR0 |= 1 << kPolarity;
   11390:	9b01      	ldr	r3, [sp, #4]
   11392:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   11396:	461a      	mov	r2, r3
   11398:	4b20      	ldr	r3, [pc, #128]	; (1141c <LabSPI::Initialize(unsigned char, LabSPI::FrameModes, unsigned char)+0x13c>)
   1139a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1139e:	681a      	ldr	r2, [r3, #0]
   113a0:	9b01      	ldr	r3, [sp, #4]
   113a2:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   113a6:	4619      	mov	r1, r3
   113a8:	4b1c      	ldr	r3, [pc, #112]	; (1141c <LabSPI::Initialize(unsigned char, LabSPI::FrameModes, unsigned char)+0x13c>)
   113aa:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   113ae:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   113b2:	601a      	str	r2, [r3, #0]
      SSP_n[whichSSP]->CR0 |= 1 << kPhase;
   113b4:	9b01      	ldr	r3, [sp, #4]
   113b6:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   113ba:	461a      	mov	r2, r3
   113bc:	4b17      	ldr	r3, [pc, #92]	; (1141c <LabSPI::Initialize(unsigned char, LabSPI::FrameModes, unsigned char)+0x13c>)
   113be:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   113c2:	681a      	ldr	r2, [r3, #0]
   113c4:	9b01      	ldr	r3, [sp, #4]
   113c6:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   113ca:	4619      	mov	r1, r3
   113cc:	4b13      	ldr	r3, [pc, #76]	; (1141c <LabSPI::Initialize(unsigned char, LabSPI::FrameModes, unsigned char)+0x13c>)
   113ce:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   113d2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   113d6:	601a      	str	r2, [r3, #0]
      SSP_n[whichSSP]->CR1 |= 1 << kEnable;
   113d8:	9b01      	ldr	r3, [sp, #4]
   113da:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   113de:	461a      	mov	r2, r3
   113e0:	4b0e      	ldr	r3, [pc, #56]	; (1141c <LabSPI::Initialize(unsigned char, LabSPI::FrameModes, unsigned char)+0x13c>)
   113e2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   113e6:	685a      	ldr	r2, [r3, #4]
   113e8:	9b01      	ldr	r3, [sp, #4]
   113ea:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   113ee:	4619      	mov	r1, r3
   113f0:	4b0a      	ldr	r3, [pc, #40]	; (1141c <LabSPI::Initialize(unsigned char, LabSPI::FrameModes, unsigned char)+0x13c>)
   113f2:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   113f6:	f042 0202 	orr.w	r2, r2, #2
   113fa:	605a      	str	r2, [r3, #4]
      return true;
   113fc:	2401      	movs	r4, #1
   113fe:	e000      	b.n	11402 <LabSPI::Initialize(unsigned char, LabSPI::FrameModes, unsigned char)+0x122>
   }
   else {return false;};
   11400:	2400      	movs	r4, #0
   11402:	462b      	mov	r3, r5
   11404:	4619      	mov	r1, r3
   11406:	4803      	ldr	r0, [pc, #12]	; (11414 <LabSPI::Initialize(unsigned char, LabSPI::FrameModes, unsigned char)+0x134>)
   11408:	f005 fa88 	bl	1691c <__cyg_profile_func_exit>
   1140c:	4623      	mov	r3, r4
}
   1140e:	4618      	mov	r0, r3
   11410:	b005      	add	sp, #20
   11412:	bd30      	pop	{r4, r5, pc}
   11414:	000112e1 	.word	0x000112e1
   11418:	0001cbf0 	.word	0x0001cbf0
   1141c:	10000038 	.word	0x10000038

00011420 <LabSPI::Transfer(unsigned char)>:
uint8_t LabSPI::Transfer(uint8_t data){
   11420:	b530      	push	{r4, r5, lr}
   11422:	b083      	sub	sp, #12
   11424:	4675      	mov	r5, lr
   11426:	9001      	str	r0, [sp, #4]
   11428:	460b      	mov	r3, r1
   1142a:	f88d 3003 	strb.w	r3, [sp, #3]
   1142e:	462b      	mov	r3, r5
   11430:	4619      	mov	r1, r3
   11432:	4819      	ldr	r0, [pc, #100]	; (11498 <LabSPI::Transfer(unsigned char)+0x78>)
   11434:	f005 fa5e 	bl	168f4 <__cyg_profile_func_enter>
    
    
    SSP_n[whichSSP]->DR = data;
   11438:	9b01      	ldr	r3, [sp, #4]
   1143a:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   1143e:	461a      	mov	r2, r3
   11440:	4b16      	ldr	r3, [pc, #88]	; (1149c <LabSPI::Transfer(unsigned char)+0x7c>)
   11442:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11446:	f89d 2003 	ldrb.w	r2, [sp, #3]
   1144a:	609a      	str	r2, [r3, #8]
    //check if the device is busy
    while(SSP_n[whichSSP]->SR & 1 << kBusyBit){
   1144c:	9b01      	ldr	r3, [sp, #4]
   1144e:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   11452:	461a      	mov	r2, r3
   11454:	4b11      	ldr	r3, [pc, #68]	; (1149c <LabSPI::Transfer(unsigned char)+0x7c>)
   11456:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1145a:	68db      	ldr	r3, [r3, #12]
   1145c:	f003 0310 	and.w	r3, r3, #16
   11460:	2b00      	cmp	r3, #0
   11462:	bf14      	ite	ne
   11464:	2301      	movne	r3, #1
   11466:	2300      	moveq	r3, #0
   11468:	b2db      	uxtb	r3, r3
   1146a:	2b00      	cmp	r3, #0
   1146c:	d001      	beq.n	11472 <LabSPI::Transfer(unsigned char)+0x52>
        continue;
   1146e:	bf00      	nop
    while(SSP_n[whichSSP]->SR & 1 << kBusyBit){
   11470:	e7ec      	b.n	1144c <LabSPI::Transfer(unsigned char)+0x2c>
    }
    //if the loop exits, then the device is no longer busy
    //return the value inside the DR
    
    return static_cast<uint8_t>(SSP_n[whichSSP]->DR);
   11472:	9b01      	ldr	r3, [sp, #4]
   11474:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   11478:	461a      	mov	r2, r3
   1147a:	4b08      	ldr	r3, [pc, #32]	; (1149c <LabSPI::Transfer(unsigned char)+0x7c>)
   1147c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11480:	689b      	ldr	r3, [r3, #8]
   11482:	b2dc      	uxtb	r4, r3
   11484:	462b      	mov	r3, r5
   11486:	4619      	mov	r1, r3
   11488:	4803      	ldr	r0, [pc, #12]	; (11498 <LabSPI::Transfer(unsigned char)+0x78>)
   1148a:	f005 fa47 	bl	1691c <__cyg_profile_func_exit>
   1148e:	4623      	mov	r3, r4
}
   11490:	4618      	mov	r0, r3
   11492:	b003      	add	sp, #12
   11494:	bd30      	pop	{r4, r5, pc}
   11496:	bf00      	nop
   11498:	00011421 	.word	0x00011421
   1149c:	10000038 	.word	0x10000038

000114a0 <debug::PrintBacktrace(bool, void*)>:
}

[[gnu::no_instrument_function]]
inline void PrintBacktrace(bool show_make_command = false,
                           void * final_address   = nullptr)
{
   114a0:	b500      	push	{lr}
   114a2:	b08b      	sub	sp, #44	; 0x2c
   114a4:	4603      	mov	r3, r0
   114a6:	9100      	str	r1, [sp, #0]
   114a8:	f88d 3007 	strb.w	r3, [sp, #7]
  printf("Stack Depth = %zd\n", GetStackDepth());
   114ac:	f005 fa58 	bl	16960 <GetStackDepth()>
   114b0:	4603      	mov	r3, r0
   114b2:	4619      	mov	r1, r3
   114b4:	4831      	ldr	r0, [pc, #196]	; (1157c <debug::PrintBacktrace(bool, void*)+0xdc>)
   114b6:	f007 f993 	bl	187e0 <printf>
  // stack_depth-1 to ignore PrintBacktrace()
  // PrintBacktrace shouldn't be ignored in profiling because it causes
  // the exit to still fire, which can result in a negative stack_depth
  void ** list_of_called_functions = GetStackTrace();
   114ba:	f005 fa3d 	bl	16938 <GetStackTrace()>
   114be:	9007      	str	r0, [sp, #28]
  size_t stack_depth               = GetStackDepth();
   114c0:	f005 fa4e 	bl	16960 <GetStackDepth()>
   114c4:	9006      	str	r0, [sp, #24]
  // Ignore the last function as it is the Backtrace function
  for (size_t pos = 0; pos < stack_depth - 1; pos++)
   114c6:	2300      	movs	r3, #0
   114c8:	9309      	str	r3, [sp, #36]	; 0x24
   114ca:	9b06      	ldr	r3, [sp, #24]
   114cc:	3b01      	subs	r3, #1
   114ce:	9a09      	ldr	r2, [sp, #36]	; 0x24
   114d0:	429a      	cmp	r2, r3
   114d2:	d20d      	bcs.n	114f0 <debug::PrintBacktrace(bool, void*)+0x50>
  {
    printf("  #%zu: 0x%p\n", pos, list_of_called_functions[pos]);
   114d4:	9b09      	ldr	r3, [sp, #36]	; 0x24
   114d6:	009b      	lsls	r3, r3, #2
   114d8:	9a07      	ldr	r2, [sp, #28]
   114da:	4413      	add	r3, r2
   114dc:	681b      	ldr	r3, [r3, #0]
   114de:	461a      	mov	r2, r3
   114e0:	9909      	ldr	r1, [sp, #36]	; 0x24
   114e2:	4827      	ldr	r0, [pc, #156]	; (11580 <debug::PrintBacktrace(bool, void*)+0xe0>)
   114e4:	f007 f97c 	bl	187e0 <printf>
  for (size_t pos = 0; pos < stack_depth - 1; pos++)
   114e8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   114ea:	3301      	adds	r3, #1
   114ec:	9309      	str	r3, [sp, #36]	; 0x24
   114ee:	e7ec      	b.n	114ca <debug::PrintBacktrace(bool, void*)+0x2a>
  }
  if (final_address != nullptr)
   114f0:	9b00      	ldr	r3, [sp, #0]
   114f2:	2b00      	cmp	r3, #0
   114f4:	d006      	beq.n	11504 <debug::PrintBacktrace(bool, void*)+0x64>
  {
    printf("  #%zu: 0x%p\n", stack_depth - 1, final_address);
   114f6:	9b06      	ldr	r3, [sp, #24]
   114f8:	3b01      	subs	r3, #1
   114fa:	9a00      	ldr	r2, [sp, #0]
   114fc:	4619      	mov	r1, r3
   114fe:	4820      	ldr	r0, [pc, #128]	; (11580 <debug::PrintBacktrace(bool, void*)+0xe0>)
   11500:	f007 f96e 	bl	187e0 <printf>
  }
  if (show_make_command)
   11504:	f89d 3007 	ldrb.w	r3, [sp, #7]
   11508:	2b00      	cmp	r3, #0
   1150a:	d033      	beq.n	11574 <debug::PrintBacktrace(bool, void*)+0xd4>
  {
    constexpr const char kBuildType[] =
   1150c:	4a1d      	ldr	r2, [pc, #116]	; (11584 <debug::PrintBacktrace(bool, void*)+0xe4>)
   1150e:	ab03      	add	r3, sp, #12
   11510:	ca07      	ldmia	r2, {r0, r1, r2}
   11512:	e883 0007 	stmia.w	r3, {r0, r1, r2}
#if defined(APPLICATION)
        "application";
#else
        "bootloader";
#endif
    puts("\nRun: the following command in your project directory");
   11516:	481c      	ldr	r0, [pc, #112]	; (11588 <debug::PrintBacktrace(bool, void*)+0xe8>)
   11518:	f005 f9bc 	bl	16894 <puts>
    printf("\n  " SJ2_BOLD_WHITE "make stacktrace-%s TRACES=\"", kBuildType);
   1151c:	ab03      	add	r3, sp, #12
   1151e:	4619      	mov	r1, r3
   11520:	481a      	ldr	r0, [pc, #104]	; (1158c <debug::PrintBacktrace(bool, void*)+0xec>)
   11522:	f007 f95d 	bl	187e0 <printf>
    for (size_t pos = 0; pos < stack_depth - 1; pos++)
   11526:	2300      	movs	r3, #0
   11528:	9308      	str	r3, [sp, #32]
   1152a:	9b06      	ldr	r3, [sp, #24]
   1152c:	3b01      	subs	r3, #1
   1152e:	9a08      	ldr	r2, [sp, #32]
   11530:	429a      	cmp	r2, r3
   11532:	d212      	bcs.n	1155a <debug::PrintBacktrace(bool, void*)+0xba>
    {
      if (pos != 0)
   11534:	9b08      	ldr	r3, [sp, #32]
   11536:	2b00      	cmp	r3, #0
   11538:	d002      	beq.n	11540 <debug::PrintBacktrace(bool, void*)+0xa0>
      {
        putchar(' ');
   1153a:	2020      	movs	r0, #32
   1153c:	f005 f98e 	bl	1685c <putchar>
      }
      printf("0x%p", list_of_called_functions[pos]);
   11540:	9b08      	ldr	r3, [sp, #32]
   11542:	009b      	lsls	r3, r3, #2
   11544:	9a07      	ldr	r2, [sp, #28]
   11546:	4413      	add	r3, r2
   11548:	681b      	ldr	r3, [r3, #0]
   1154a:	4619      	mov	r1, r3
   1154c:	4810      	ldr	r0, [pc, #64]	; (11590 <debug::PrintBacktrace(bool, void*)+0xf0>)
   1154e:	f007 f947 	bl	187e0 <printf>
    for (size_t pos = 0; pos < stack_depth - 1; pos++)
   11552:	9b08      	ldr	r3, [sp, #32]
   11554:	3301      	adds	r3, #1
   11556:	9308      	str	r3, [sp, #32]
   11558:	e7e7      	b.n	1152a <debug::PrintBacktrace(bool, void*)+0x8a>
    }
    if (final_address != nullptr)
   1155a:	9b00      	ldr	r3, [sp, #0]
   1155c:	2b00      	cmp	r3, #0
   1155e:	d003      	beq.n	11568 <debug::PrintBacktrace(bool, void*)+0xc8>
    {
      printf(" 0x%p", final_address);
   11560:	9900      	ldr	r1, [sp, #0]
   11562:	480c      	ldr	r0, [pc, #48]	; (11594 <debug::PrintBacktrace(bool, void*)+0xf4>)
   11564:	f007 f93c 	bl	187e0 <printf>
    }
    puts("\"\n" SJ2_COLOR_RESET);
   11568:	480b      	ldr	r0, [pc, #44]	; (11598 <debug::PrintBacktrace(bool, void*)+0xf8>)
   1156a:	f005 f993 	bl	16894 <puts>
    puts(
   1156e:	480b      	ldr	r0, [pc, #44]	; (1159c <debug::PrintBacktrace(bool, void*)+0xfc>)
   11570:	f005 f990 	bl	16894 <puts>
        "This will report the file and line number that led to this function "
        "being called.");
  }
}
   11574:	bf00      	nop
   11576:	b00b      	add	sp, #44	; 0x2c
   11578:	f85d fb04 	ldr.w	pc, [sp], #4
   1157c:	0001cc40 	.word	0x0001cc40
   11580:	0001cc54 	.word	0x0001cc54
   11584:	0001cd30 	.word	0x0001cd30
   11588:	0001cc64 	.word	0x0001cc64
   1158c:	0001cc9c 	.word	0x0001cc9c
   11590:	0001ccc4 	.word	0x0001ccc4
   11594:	0001cccc 	.word	0x0001cccc
   11598:	0001ccd4 	.word	0x0001ccd4
   1159c:	0001ccdc 	.word	0x0001ccdc

000115a0 <SystemControllerInterface::SystemControllerInterface()>:
#include "L0_LowLevel/LPC40xx.h"
#include "utility/enum.hpp"
#include "utility/log.hpp"
#include "utility/macros.hpp"

class SystemControllerInterface
   115a0:	b082      	sub	sp, #8
   115a2:	9001      	str	r0, [sp, #4]
   115a4:	4a03      	ldr	r2, [pc, #12]	; (115b4 <SystemControllerInterface::SystemControllerInterface()+0x14>)
   115a6:	9b01      	ldr	r3, [sp, #4]
   115a8:	601a      	str	r2, [r3, #0]
   115aa:	9b01      	ldr	r3, [sp, #4]
   115ac:	4618      	mov	r0, r3
   115ae:	b002      	add	sp, #8
   115b0:	4770      	bx	lr
   115b2:	bf00      	nop
   115b4:	0001d7c4 	.word	0x0001d7c4

000115b8 <Lpc40xxSystemController::Lpc40xxSystemController()>:
  static constexpr uint32_t kDefaultIRCFrequency    = 12'000'000;
  static constexpr uint32_t kDefaultTimeout         = 1'000;  // ms

  inline static LPC_SC_TypeDef * system_controller = LPC_SC;

  constexpr Lpc40xxSystemController() {}
   115b8:	b500      	push	{lr}
   115ba:	b083      	sub	sp, #12
   115bc:	9001      	str	r0, [sp, #4]
   115be:	9b01      	ldr	r3, [sp, #4]
   115c0:	4618      	mov	r0, r3
   115c2:	f7ff ffed 	bl	115a0 <SystemControllerInterface::SystemControllerInterface()>
   115c6:	4a04      	ldr	r2, [pc, #16]	; (115d8 <Lpc40xxSystemController::Lpc40xxSystemController()+0x20>)
   115c8:	9b01      	ldr	r3, [sp, #4]
   115ca:	601a      	str	r2, [r3, #0]
   115cc:	9b01      	ldr	r3, [sp, #4]
   115ce:	4618      	mov	r0, r3
   115d0:	b003      	add	sp, #12
   115d2:	f85d fb04 	ldr.w	pc, [sp], #4
   115d6:	bf00      	nop
   115d8:	0001d7a0 	.word	0x0001d7a0

000115dc <Lpc40xxSystemController::SetClockFrequency(unsigned char)>:

  uint32_t SetClockFrequency(uint8_t frequency_in_mhz) override
   115dc:	b500      	push	{lr}
   115de:	b085      	sub	sp, #20
   115e0:	9001      	str	r0, [sp, #4]
   115e2:	460b      	mov	r3, r1
   115e4:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    uint32_t offset = 0;
   115e8:	2300      	movs	r3, #0
   115ea:	9303      	str	r3, [sp, #12]
    SelectOscillatorSource(OscillatorSource::kIrc);
   115ec:	2100      	movs	r1, #0
   115ee:	9801      	ldr	r0, [sp, #4]
   115f0:	f000 f8ce 	bl	11790 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)>
    if (frequency_in_mhz > 12)
   115f4:	f89d 3003 	ldrb.w	r3, [sp, #3]
   115f8:	2b0c      	cmp	r3, #12
   115fa:	d916      	bls.n	1162a <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x4e>
    {
      offset = SetMainPll(PllInput::kIrc, frequency_in_mhz);
   115fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
   11600:	b29b      	uxth	r3, r3
   11602:	461a      	mov	r2, r3
   11604:	210c      	movs	r1, #12
   11606:	9801      	ldr	r0, [sp, #4]
   11608:	f000 f9ac 	bl	11964 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)>
   1160c:	9003      	str	r0, [sp, #12]
      SelectMainClockSource(MainClockSource::kPllClock);
   1160e:	f44f 7180 	mov.w	r1, #256	; 0x100
   11612:	9801      	ldr	r0, [sp, #4]
   11614:	f000 f8d6 	bl	117c4 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>
      speed_in_hertz = frequency_in_mhz * 1'000'000;
   11618:	f89d 3003 	ldrb.w	r3, [sp, #3]
   1161c:	4a10      	ldr	r2, [pc, #64]	; (11660 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x84>)
   1161e:	fb02 f303 	mul.w	r3, r2, r3
   11622:	461a      	mov	r2, r3
   11624:	4b0f      	ldr	r3, [pc, #60]	; (11664 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x88>)
   11626:	601a      	str	r2, [r3, #0]
   11628:	e006      	b.n	11638 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x5c>
    }
    else
    {
      SelectMainClockSource(MainClockSource::kBaseClock);
   1162a:	2100      	movs	r1, #0
   1162c:	9801      	ldr	r0, [sp, #4]
   1162e:	f000 f8c9 	bl	117c4 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>
      speed_in_hertz = kDefaultIRCFrequency;
   11632:	4b0c      	ldr	r3, [pc, #48]	; (11664 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x88>)
   11634:	4a0c      	ldr	r2, [pc, #48]	; (11668 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x8c>)
   11636:	601a      	str	r2, [r3, #0]
    }
    SetCpuClockDivider(kDivideInputBy1);
   11638:	2101      	movs	r1, #1
   1163a:	9801      	ldr	r0, [sp, #4]
   1163c:	f000 fa4a 	bl	11ad4 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)>
    SetPeripheralClockDivider(kDivideInputBy1);
   11640:	9b01      	ldr	r3, [sp, #4]
   11642:	681b      	ldr	r3, [r3, #0]
   11644:	3304      	adds	r3, #4
   11646:	681b      	ldr	r3, [r3, #0]
   11648:	2101      	movs	r1, #1
   1164a:	9801      	ldr	r0, [sp, #4]
   1164c:	4798      	blx	r3
    SetEmcClockDivider(EmcDivider::kSameSpeedAsCpu);
   1164e:	2100      	movs	r1, #0
   11650:	9801      	ldr	r0, [sp, #4]
   11652:	f000 fa73 	bl	11b3c <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)>
    return offset;
   11656:	9b03      	ldr	r3, [sp, #12]
  }
   11658:	4618      	mov	r0, r3
   1165a:	b005      	add	sp, #20
   1165c:	f85d fb04 	ldr.w	pc, [sp], #4
   11660:	000f4240 	.word	0x000f4240
   11664:	10000048 	.word	0x10000048
   11668:	00b71b00 	.word	0x00b71b00

0001166c <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)>:

  void SetPeripheralClockDivider(uint8_t peripheral_divider) override
   1166c:	b500      	push	{lr}
   1166e:	b083      	sub	sp, #12
   11670:	9001      	str	r0, [sp, #4]
   11672:	460b      	mov	r3, r1
   11674:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    SJ2_ASSERT_FATAL(peripheral_divider <= 4, "Divider mustn't exceed 32");
   11678:	f89d 3003 	ldrb.w	r3, [sp, #3]
   1167c:	2b04      	cmp	r3, #4
   1167e:	d90d      	bls.n	1169c <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x30>
   11680:	23ae      	movs	r3, #174	; 0xae
   11682:	4a0b      	ldr	r2, [pc, #44]	; (116b0 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x44>)
   11684:	490b      	ldr	r1, [pc, #44]	; (116b4 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x48>)
   11686:	480c      	ldr	r0, [pc, #48]	; (116b8 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x4c>)
   11688:	f007 f8aa 	bl	187e0 <printf>
   1168c:	480b      	ldr	r0, [pc, #44]	; (116bc <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x50>)
   1168e:	f005 f901 	bl	16894 <puts>
   11692:	2100      	movs	r1, #0
   11694:	2001      	movs	r0, #1
   11696:	f7ff ff03 	bl	114a0 <debug::PrintBacktrace(bool, void*)>
   1169a:	e7fe      	b.n	1169a <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x2e>
    system_controller->PCLKSEL = peripheral_divider;
   1169c:	4b08      	ldr	r3, [pc, #32]	; (116c0 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x54>)
   1169e:	681b      	ldr	r3, [r3, #0]
   116a0:	f89d 2003 	ldrb.w	r2, [sp, #3]
   116a4:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
  }
   116a8:	bf00      	nop
   116aa:	b003      	add	sp, #12
   116ac:	f85d fb04 	ldr.w	pc, [sp], #4
   116b0:	0001d938 	.word	0x0001d938
   116b4:	0001d404 	.word	0x0001d404
   116b8:	0001cd3c 	.word	0x0001cd3c
   116bc:	0001cddc 	.word	0x0001cddc
   116c0:	10000044 	.word	0x10000044

000116c4 <Lpc40xxSystemController::GetPeripheralClockDivider() const>:

  uint32_t GetPeripheralClockDivider() const override
   116c4:	b082      	sub	sp, #8
   116c6:	9001      	str	r0, [sp, #4]
  {
#if defined(HOST_TEST)
    return 1;
#else
    return system_controller->PCLKSEL;
   116c8:	4b03      	ldr	r3, [pc, #12]	; (116d8 <Lpc40xxSystemController::GetPeripheralClockDivider() const+0x14>)
   116ca:	681b      	ldr	r3, [r3, #0]
   116cc:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
#endif
  }
   116d0:	4618      	mov	r0, r3
   116d2:	b002      	add	sp, #8
   116d4:	4770      	bx	lr
   116d6:	bf00      	nop
   116d8:	10000044 	.word	0x10000044

000116dc <Lpc40xxSystemController::GetSystemFrequency() const>:

  uint32_t GetSystemFrequency() const override
   116dc:	b082      	sub	sp, #8
   116de:	9001      	str	r0, [sp, #4]
  {
#if defined(HOST_TEST)
    return config::kSystemClockRate;
#else
    return speed_in_hertz;
   116e0:	4b02      	ldr	r3, [pc, #8]	; (116ec <Lpc40xxSystemController::GetSystemFrequency() const+0x10>)
   116e2:	681b      	ldr	r3, [r3, #0]
#endif
  }
   116e4:	4618      	mov	r0, r3
   116e6:	b002      	add	sp, #8
   116e8:	4770      	bx	lr
   116ea:	bf00      	nop
   116ec:	10000048 	.word	0x10000048

000116f0 <Lpc40xxSystemController::GetPeripheralFrequency() const>:

  uint32_t GetPeripheralFrequency() const override
   116f0:	b500      	push	{lr}
   116f2:	b085      	sub	sp, #20
   116f4:	9001      	str	r0, [sp, #4]
  {
    uint32_t peripheral_clock_divider = GetPeripheralClockDivider();
   116f6:	9b01      	ldr	r3, [sp, #4]
   116f8:	681b      	ldr	r3, [r3, #0]
   116fa:	3308      	adds	r3, #8
   116fc:	681b      	ldr	r3, [r3, #0]
   116fe:	9801      	ldr	r0, [sp, #4]
   11700:	4798      	blx	r3
   11702:	9002      	str	r0, [sp, #8]
    uint32_t result = 0;  // return 0 if peripheral_clock_divider == 0
   11704:	2300      	movs	r3, #0
   11706:	9303      	str	r3, [sp, #12]
    if (peripheral_clock_divider != 0)
   11708:	9b02      	ldr	r3, [sp, #8]
   1170a:	2b00      	cmp	r3, #0
   1170c:	d00a      	beq.n	11724 <Lpc40xxSystemController::GetPeripheralFrequency() const+0x34>
    {
      result = GetSystemFrequency() / peripheral_clock_divider;
   1170e:	9b01      	ldr	r3, [sp, #4]
   11710:	681b      	ldr	r3, [r3, #0]
   11712:	330c      	adds	r3, #12
   11714:	681b      	ldr	r3, [r3, #0]
   11716:	9801      	ldr	r0, [sp, #4]
   11718:	4798      	blx	r3
   1171a:	4602      	mov	r2, r0
   1171c:	9b02      	ldr	r3, [sp, #8]
   1171e:	fbb2 f3f3 	udiv	r3, r2, r3
   11722:	9303      	str	r3, [sp, #12]
    }
    return result;
   11724:	9b03      	ldr	r3, [sp, #12]
  }
   11726:	4618      	mov	r0, r3
   11728:	b005      	add	sp, #20
   1172a:	f85d fb04 	ldr.w	pc, [sp], #4
   1172e:	Address 0x000000000001172e is out of bounds.


00011730 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>:

  void PowerUpPeripheral(const PeripheralID & peripheral_select) override
   11730:	b084      	sub	sp, #16
   11732:	9001      	str	r0, [sp, #4]
   11734:	9100      	str	r1, [sp, #0]
  {
    auto power_connection_with_enabled_peripheral =
        system_controller->PCONP | (1 << peripheral_select.device_id);
   11736:	4b09      	ldr	r3, [pc, #36]	; (1175c <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   11738:	681b      	ldr	r3, [r3, #0]
   1173a:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   1173e:	9a00      	ldr	r2, [sp, #0]
   11740:	6812      	ldr	r2, [r2, #0]
   11742:	2101      	movs	r1, #1
   11744:	fa01 f202 	lsl.w	r2, r1, r2
   11748:	4313      	orrs	r3, r2
   1174a:	9303      	str	r3, [sp, #12]

    system_controller->PCONP = power_connection_with_enabled_peripheral;
   1174c:	4b03      	ldr	r3, [pc, #12]	; (1175c <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   1174e:	681b      	ldr	r3, [r3, #0]
   11750:	9a03      	ldr	r2, [sp, #12]
   11752:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
  }
   11756:	bf00      	nop
   11758:	b004      	add	sp, #16
   1175a:	4770      	bx	lr
   1175c:	10000044 	.word	0x10000044

00011760 <Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)>:
  void PowerDownPeripheral(const PeripheralID & peripheral_select) override
   11760:	b084      	sub	sp, #16
   11762:	9001      	str	r0, [sp, #4]
   11764:	9100      	str	r1, [sp, #0]
  {
    auto power_connection_without_enabled_peripheral =
        system_controller->PCONP & (1 << peripheral_select.device_id);
   11766:	4b09      	ldr	r3, [pc, #36]	; (1178c <Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   11768:	681b      	ldr	r3, [r3, #0]
   1176a:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   1176e:	9a00      	ldr	r2, [sp, #0]
   11770:	6812      	ldr	r2, [r2, #0]
   11772:	2101      	movs	r1, #1
   11774:	fa01 f202 	lsl.w	r2, r1, r2
   11778:	4013      	ands	r3, r2
   1177a:	9303      	str	r3, [sp, #12]

    system_controller->PCONP = power_connection_without_enabled_peripheral;
   1177c:	4b03      	ldr	r3, [pc, #12]	; (1178c <Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   1177e:	681b      	ldr	r3, [r3, #0]
   11780:	9a03      	ldr	r2, [sp, #12]
   11782:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
  }
   11786:	bf00      	nop
   11788:	b004      	add	sp, #16
   1178a:	4770      	bx	lr
   1178c:	10000044 	.word	0x10000044

00011790 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)>:

 private:
  void SelectOscillatorSource(OscillatorSource source)
   11790:	b084      	sub	sp, #16
   11792:	9001      	str	r0, [sp, #4]
   11794:	460b      	mov	r3, r1
   11796:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    uint32_t source_bit = static_cast<uint32_t>(source);
   1179a:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   1179e:	9303      	str	r3, [sp, #12]
    system_controller->CLKSRCSEL =
        (system_controller->CLKSRCSEL & ~(kOscillatorSelect)) | source_bit;
   117a0:	4b07      	ldr	r3, [pc, #28]	; (117c0 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)+0x30>)
   117a2:	681b      	ldr	r3, [r3, #0]
   117a4:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
   117a8:	f023 0101 	bic.w	r1, r3, #1
    system_controller->CLKSRCSEL =
   117ac:	4b04      	ldr	r3, [pc, #16]	; (117c0 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)+0x30>)
   117ae:	681b      	ldr	r3, [r3, #0]
        (system_controller->CLKSRCSEL & ~(kOscillatorSelect)) | source_bit;
   117b0:	9a03      	ldr	r2, [sp, #12]
   117b2:	430a      	orrs	r2, r1
    system_controller->CLKSRCSEL =
   117b4:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
  }
   117b8:	bf00      	nop
   117ba:	b004      	add	sp, #16
   117bc:	4770      	bx	lr
   117be:	bf00      	nop
   117c0:	10000044 	.word	0x10000044

000117c4 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>:

  void SelectMainClockSource(MainClockSource source)
   117c4:	b082      	sub	sp, #8
   117c6:	9001      	str	r0, [sp, #4]
   117c8:	460b      	mov	r3, r1
   117ca:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    system_controller->CCLKSEL =
        (system_controller->CCLKSEL & ~(kBaseClockSelect)) |
   117ce:	4b08      	ldr	r3, [pc, #32]	; (117f0 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)+0x2c>)
   117d0:	681b      	ldr	r3, [r3, #0]
   117d2:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   117d6:	f423 7180 	bic.w	r1, r3, #256	; 0x100
        static_cast<uint32_t>(source);
   117da:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    system_controller->CCLKSEL =
   117de:	4b04      	ldr	r3, [pc, #16]	; (117f0 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)+0x2c>)
   117e0:	681b      	ldr	r3, [r3, #0]
        (system_controller->CCLKSEL & ~(kBaseClockSelect)) |
   117e2:	430a      	orrs	r2, r1
    system_controller->CCLKSEL =
   117e4:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  }
   117e8:	bf00      	nop
   117ea:	b002      	add	sp, #8
   117ec:	4770      	bx	lr
   117ee:	bf00      	nop
   117f0:	10000044 	.word	0x10000044

000117f4 <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)>:

  void SelectUsbClockSource(UsbSource usb_clock)
   117f4:	b082      	sub	sp, #8
   117f6:	9001      	str	r0, [sp, #4]
   117f8:	460b      	mov	r3, r1
   117fa:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    system_controller->USBCLKSEL =
        (system_controller->USBCLKSEL & ~(kUsbClockSource)) |
   117fe:	4b08      	ldr	r3, [pc, #32]	; (11820 <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)+0x2c>)
   11800:	681b      	ldr	r3, [r3, #0]
   11802:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
   11806:	f423 7140 	bic.w	r1, r3, #768	; 0x300
        static_cast<uint32_t>(usb_clock);
   1180a:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    system_controller->USBCLKSEL =
   1180e:	4b04      	ldr	r3, [pc, #16]	; (11820 <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)+0x2c>)
   11810:	681b      	ldr	r3, [r3, #0]
        (system_controller->USBCLKSEL & ~(kUsbClockSource)) |
   11812:	430a      	orrs	r2, r1
    system_controller->USBCLKSEL =
   11814:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
  }
   11818:	bf00      	nop
   1181a:	b002      	add	sp, #8
   1181c:	4770      	bx	lr
   1181e:	bf00      	nop
   11820:	10000044 	.word	0x10000044

00011824 <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)>:

  void SelectSpifiClockSource(SpifiSource spifi_clock)
   11824:	b082      	sub	sp, #8
   11826:	9001      	str	r0, [sp, #4]
   11828:	460b      	mov	r3, r1
   1182a:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    system_controller->SPIFISEL =
        (system_controller->SPIFISEL & ~(kSpifiClockSource)) |
   1182e:	4b08      	ldr	r3, [pc, #32]	; (11850 <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)+0x2c>)
   11830:	681b      	ldr	r3, [r3, #0]
   11832:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
   11836:	f423 7140 	bic.w	r1, r3, #768	; 0x300
        static_cast<uint32_t>(spifi_clock);
   1183a:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    system_controller->SPIFISEL =
   1183e:	4b04      	ldr	r3, [pc, #16]	; (11850 <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)+0x2c>)
   11840:	681b      	ldr	r3, [r3, #0]
        (system_controller->SPIFISEL & ~(kSpifiClockSource)) |
   11842:	430a      	orrs	r2, r1
    system_controller->SPIFISEL =
   11844:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
  }
   11848:	bf00      	nop
   1184a:	b002      	add	sp, #8
   1184c:	4770      	bx	lr
   1184e:	bf00      	nop
   11850:	10000044 	.word	0x10000044

00011854 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)>:

  uint32_t CalculatePll(PllInput input_frequency, uint16_t desired_speed_in_mhz)
   11854:	b500      	push	{lr}
   11856:	b087      	sub	sp, #28
   11858:	9001      	str	r0, [sp, #4]
   1185a:	460b      	mov	r3, r1
   1185c:	f8ad 3002 	strh.w	r3, [sp, #2]
   11860:	4613      	mov	r3, r2
   11862:	f8ad 3000 	strh.w	r3, [sp]
  {
    SJ2_ASSERT_FATAL(desired_speed_in_mhz < 384 && desired_speed_in_mhz > 12,
   11866:	f8bd 3000 	ldrh.w	r3, [sp]
   1186a:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
   1186e:	d203      	bcs.n	11878 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x24>
   11870:	f8bd 3000 	ldrh.w	r3, [sp]
   11874:	2b0c      	cmp	r3, #12
   11876:	d80d      	bhi.n	11894 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x40>
   11878:	23ff      	movs	r3, #255	; 0xff
   1187a:	4a34      	ldr	r2, [pc, #208]	; (1194c <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xf8>)
   1187c:	4934      	ldr	r1, [pc, #208]	; (11950 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xfc>)
   1187e:	4835      	ldr	r0, [pc, #212]	; (11954 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x100>)
   11880:	f006 ffae 	bl	187e0 <printf>
   11884:	4834      	ldr	r0, [pc, #208]	; (11958 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x104>)
   11886:	f005 f805 	bl	16894 <puts>
   1188a:	2100      	movs	r1, #0
   1188c:	2001      	movs	r0, #1
   1188e:	f7ff fe07 	bl	114a0 <debug::PrintBacktrace(bool, void*)>
   11892:	e7fe      	b.n	11892 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x3e>
                     "Frequency must be lower than 384 MHz"
                     "and greater than or equal to 12 MHz");
    bool calculating = true;
   11894:	2301      	movs	r3, #1
   11896:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32_t multiplier_value;
    if ((desired_speed_in_mhz % static_cast<uint16_t>(input_frequency)) >= 1)
   1189a:	f8bd 3000 	ldrh.w	r3, [sp]
   1189e:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   118a2:	fbb3 f1f2 	udiv	r1, r3, r2
   118a6:	fb02 f201 	mul.w	r2, r2, r1
   118aa:	1a9b      	subs	r3, r3, r2
   118ac:	b29b      	uxth	r3, r3
   118ae:	2b00      	cmp	r3, #0
   118b0:	d009      	beq.n	118c6 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x72>
    {
      multiplier_value = static_cast<uint32_t>(
          (desired_speed_in_mhz / static_cast<uint16_t>(input_frequency)) + 1);
   118b2:	f8bd 2000 	ldrh.w	r2, [sp]
   118b6:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   118ba:	fbb2 f3f3 	udiv	r3, r2, r3
   118be:	b29b      	uxth	r3, r3
   118c0:	3301      	adds	r3, #1
      multiplier_value = static_cast<uint32_t>(
   118c2:	9304      	str	r3, [sp, #16]
   118c4:	e007      	b.n	118d6 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x82>
    }
    else
    {
      multiplier_value = static_cast<uint32_t>(
          desired_speed_in_mhz / static_cast<uint16_t>(input_frequency));
   118c6:	f8bd 2000 	ldrh.w	r2, [sp]
   118ca:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   118ce:	fbb2 f3f3 	udiv	r3, r2, r3
   118d2:	b29b      	uxth	r3, r3
      multiplier_value = static_cast<uint32_t>(
   118d4:	9304      	str	r3, [sp, #16]
    }
    uint16_t divider_value = 1;
   118d6:	2301      	movs	r3, #1
   118d8:	f8ad 300e 	strh.w	r3, [sp, #14]
    while (calculating)
   118dc:	f89d 3017 	ldrb.w	r3, [sp, #23]
   118e0:	2b00      	cmp	r3, #0
   118e2:	d02e      	beq.n	11942 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xee>
    {
      uint16_t current_controlled_oscillator_frequency;
      current_controlled_oscillator_frequency = static_cast<uint16_t>(
   118e4:	9b04      	ldr	r3, [sp, #16]
   118e6:	b29b      	uxth	r3, r3
   118e8:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   118ec:	fb12 f303 	smulbb	r3, r2, r3
   118f0:	b29b      	uxth	r3, r3
   118f2:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   118f6:	fb12 f303 	smulbb	r3, r2, r3
   118fa:	b29b      	uxth	r3, r3
   118fc:	005b      	lsls	r3, r3, #1
   118fe:	f8ad 300c 	strh.w	r3, [sp, #12]
          (static_cast<uint16_t>(input_frequency) * multiplier_value * 2) *
          divider_value);
      if (current_controlled_oscillator_frequency >= 156)
   11902:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   11906:	2b9b      	cmp	r3, #155	; 0x9b
   11908:	d903      	bls.n	11912 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xbe>
      {
        calculating = false;
   1190a:	2300      	movs	r3, #0
   1190c:	f88d 3017 	strb.w	r3, [sp, #23]
   11910:	e7e4      	b.n	118dc <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x88>
      }
      else
      {
        divider_value = static_cast<uint16_t>(divider_value * 2);
   11912:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   11916:	005b      	lsls	r3, r3, #1
   11918:	f8ad 300e 	strh.w	r3, [sp, #14]
        SJ2_ASSERT_FATAL(divider_value < 8,
   1191c:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   11920:	2b07      	cmp	r3, #7
   11922:	d9db      	bls.n	118dc <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x88>
   11924:	f240 131b 	movw	r3, #283	; 0x11b
   11928:	4a08      	ldr	r2, [pc, #32]	; (1194c <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xf8>)
   1192a:	490c      	ldr	r1, [pc, #48]	; (1195c <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x108>)
   1192c:	480c      	ldr	r0, [pc, #48]	; (11960 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x10c>)
   1192e:	f006 ff57 	bl	187e0 <printf>
   11932:	4809      	ldr	r0, [pc, #36]	; (11958 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x104>)
   11934:	f004 ffae 	bl	16894 <puts>
   11938:	2100      	movs	r1, #0
   1193a:	2001      	movs	r0, #1
   1193c:	f7ff fdb0 	bl	114a0 <debug::PrintBacktrace(bool, void*)>
   11940:	e7fe      	b.n	11940 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xec>
                         "PLL divider value went out of bounds");
      }
    }

    return multiplier_value;
   11942:	9b04      	ldr	r3, [sp, #16]
  }
   11944:	4618      	mov	r0, r3
   11946:	b007      	add	sp, #28
   11948:	f85d fb04 	ldr.w	pc, [sp], #4
   1194c:	0001d9e0 	.word	0x0001d9e0
   11950:	0001d41c 	.word	0x0001d41c
   11954:	0001cdf4 	.word	0x0001cdf4
   11958:	0001cddc 	.word	0x0001cddc
   1195c:	0001d434 	.word	0x0001d434
   11960:	0001cee4 	.word	0x0001cee4

00011964 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)>:

  uint32_t SetMainPll(PllInput input_frequency, uint16_t desired_speed_in_mhz)
   11964:	b510      	push	{r4, lr}
   11966:	b08a      	sub	sp, #40	; 0x28
   11968:	9001      	str	r0, [sp, #4]
   1196a:	460b      	mov	r3, r1
   1196c:	f8ad 3002 	strh.w	r3, [sp, #2]
   11970:	4613      	mov	r3, r2
   11972:	f8ad 3000 	strh.w	r3, [sp]
  {
    uint16_t divider_value = 1;
   11976:	2301      	movs	r3, #1
   11978:	f8ad 301a 	strh.w	r3, [sp, #26]
    uint64_t timeout_time  = Milliseconds() + kDefaultTimeout;
   1197c:	f7fe fd70 	bl	10460 <Milliseconds()>
   11980:	460a      	mov	r2, r1
   11982:	4601      	mov	r1, r0
   11984:	f511 737a 	adds.w	r3, r1, #1000	; 0x3e8
   11988:	f142 0400 	adc.w	r4, r2, #0
   1198c:	e9cd 3404 	strd	r3, r4, [sp, #16]
    uint64_t current_time  = Milliseconds();
   11990:	f7fe fd66 	bl	10460 <Milliseconds()>
   11994:	e9cd 0108 	strd	r0, r1, [sp, #32]
    uint32_t multiplier_value =
        CalculatePll(input_frequency, desired_speed_in_mhz);
   11998:	f8bd 2000 	ldrh.w	r2, [sp]
   1199c:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   119a0:	4619      	mov	r1, r3
   119a2:	9801      	ldr	r0, [sp, #4]
   119a4:	f7ff ff56 	bl	11854 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)>
   119a8:	9003      	str	r0, [sp, #12]
    uint32_t actual_speed =
        static_cast<uint32_t>(input_frequency) * multiplier_value;
   119aa:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    uint32_t actual_speed =
   119ae:	9b03      	ldr	r3, [sp, #12]
   119b0:	fb02 f303 	mul.w	r3, r2, r3
   119b4:	9307      	str	r3, [sp, #28]
    // TO DO: use registers to retreive values
    SelectOscillatorSource(OscillatorSource::kIrc);
   119b6:	2100      	movs	r1, #0
   119b8:	9801      	ldr	r0, [sp, #4]
   119ba:	f7ff fee9 	bl	11790 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)>
    SelectMainClockSource(MainClockSource::kBaseClock);
   119be:	2100      	movs	r1, #0
   119c0:	9801      	ldr	r0, [sp, #4]
   119c2:	f7ff feff 	bl	117c4 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>
    SelectUsbClockSource(UsbSource::kBaseClock);
   119c6:	2100      	movs	r1, #0
   119c8:	9801      	ldr	r0, [sp, #4]
   119ca:	f7ff ff13 	bl	117f4 <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)>
    SelectSpifiClockSource(SpifiSource::kBaseClock);
   119ce:	2100      	movs	r1, #0
   119d0:	9801      	ldr	r0, [sp, #4]
   119d2:	f7ff ff27 	bl	11824 <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)>
    // must subtract 1 from multiplier value as specified in datasheet
    system_controller->PLL0CFG =
        (system_controller->PLL0CFG & ~kClearPllMultiplier) |
   119d6:	4b3a      	ldr	r3, [pc, #232]	; (11ac0 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   119d8:	681b      	ldr	r3, [r3, #0]
   119da:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   119de:	f023 011f 	bic.w	r1, r3, #31
        (multiplier_value - 1);
   119e2:	9b03      	ldr	r3, [sp, #12]
   119e4:	1e5a      	subs	r2, r3, #1
    system_controller->PLL0CFG =
   119e6:	4b36      	ldr	r3, [pc, #216]	; (11ac0 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   119e8:	681b      	ldr	r3, [r3, #0]
        (system_controller->PLL0CFG & ~kClearPllMultiplier) |
   119ea:	430a      	orrs	r2, r1
    system_controller->PLL0CFG =
   119ec:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    system_controller->PLL0CFG =
        (system_controller->PLL0CFG & ~kClearPllDivider) | (divider_value << 5);
   119f0:	4b33      	ldr	r3, [pc, #204]	; (11ac0 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   119f2:	681b      	ldr	r3, [r3, #0]
   119f4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   119f8:	f023 0260 	bic.w	r2, r3, #96	; 0x60
   119fc:	f8bd 301a 	ldrh.w	r3, [sp, #26]
   11a00:	015b      	lsls	r3, r3, #5
   11a02:	4619      	mov	r1, r3
    system_controller->PLL0CFG =
   11a04:	4b2e      	ldr	r3, [pc, #184]	; (11ac0 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11a06:	681b      	ldr	r3, [r3, #0]
        (system_controller->PLL0CFG & ~kClearPllDivider) | (divider_value << 5);
   11a08:	430a      	orrs	r2, r1
    system_controller->PLL0CFG =
   11a0a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    system_controller->PLL0CON |= kEnablePll;
   11a0e:	4b2c      	ldr	r3, [pc, #176]	; (11ac0 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11a10:	681b      	ldr	r3, [r3, #0]
   11a12:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
   11a16:	4b2a      	ldr	r3, [pc, #168]	; (11ac0 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11a18:	681b      	ldr	r3, [r3, #0]
   11a1a:	f042 0201 	orr.w	r2, r2, #1
   11a1e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    // nessecary feed sequence to ensure the changes are intentional
    system_controller->PLL0FEED = 0xAA;
   11a22:	4b27      	ldr	r3, [pc, #156]	; (11ac0 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11a24:	681b      	ldr	r3, [r3, #0]
   11a26:	22aa      	movs	r2, #170	; 0xaa
   11a28:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    system_controller->PLL0FEED = 0x55;
   11a2c:	4b24      	ldr	r3, [pc, #144]	; (11ac0 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11a2e:	681b      	ldr	r3, [r3, #0]
   11a30:	2255      	movs	r2, #85	; 0x55
   11a32:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    while (!(system_controller->PLL0STAT >> kPlock & 1) &&
   11a36:	4b22      	ldr	r3, [pc, #136]	; (11ac0 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11a38:	681b      	ldr	r3, [r3, #0]
   11a3a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11a3e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   11a42:	2b00      	cmp	r3, #0
   11a44:	d109      	bne.n	11a5a <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xf6>
   11a46:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
   11a4a:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
   11a4e:	42a2      	cmp	r2, r4
   11a50:	bf08      	it	eq
   11a52:	4299      	cmpeq	r1, r3
   11a54:	d201      	bcs.n	11a5a <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xf6>
   11a56:	2301      	movs	r3, #1
   11a58:	e000      	b.n	11a5c <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xf8>
   11a5a:	2300      	movs	r3, #0
   11a5c:	2b00      	cmp	r3, #0
   11a5e:	d004      	beq.n	11a6a <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x106>
           (current_time < timeout_time))
    {
      current_time = Milliseconds();
   11a60:	f7fe fcfe 	bl	10460 <Milliseconds()>
   11a64:	e9cd 0108 	strd	r0, r1, [sp, #32]
    while (!(system_controller->PLL0STAT >> kPlock & 1) &&
   11a68:	e7e5      	b.n	11a36 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xd2>
    }
    if (!(system_controller->PLL0STAT >> kPlock & 1) &&
   11a6a:	4b15      	ldr	r3, [pc, #84]	; (11ac0 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11a6c:	681b      	ldr	r3, [r3, #0]
   11a6e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11a72:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   11a76:	2b00      	cmp	r3, #0
   11a78:	d109      	bne.n	11a8e <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x12a>
   11a7a:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
   11a7e:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
   11a82:	42a2      	cmp	r2, r4
   11a84:	bf08      	it	eq
   11a86:	4299      	cmpeq	r1, r3
   11a88:	d301      	bcc.n	11a8e <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x12a>
   11a8a:	2301      	movs	r3, #1
   11a8c:	e000      	b.n	11a90 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x12c>
   11a8e:	2300      	movs	r3, #0
   11a90:	2b00      	cmp	r3, #0
   11a92:	d00e      	beq.n	11ab2 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x14e>
        (current_time >= timeout_time))
    {
      SJ2_ASSERT_FATAL(false,
   11a94:	f240 1343 	movw	r3, #323	; 0x143
   11a98:	4a0a      	ldr	r2, [pc, #40]	; (11ac4 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x160>)
   11a9a:	490b      	ldr	r1, [pc, #44]	; (11ac8 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x164>)
   11a9c:	480b      	ldr	r0, [pc, #44]	; (11acc <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x168>)
   11a9e:	f006 fe9f 	bl	187e0 <printf>
   11aa2:	480b      	ldr	r0, [pc, #44]	; (11ad0 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x16c>)
   11aa4:	f004 fef6 	bl	16894 <puts>
   11aa8:	2100      	movs	r1, #0
   11aaa:	2001      	movs	r0, #1
   11aac:	f7ff fcf8 	bl	114a0 <debug::PrintBacktrace(bool, void*)>
   11ab0:	e7fe      	b.n	11ab0 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x14c>
                       "PLL lock could not be established before timeout");
      actual_speed = kDefaultIRCFrequency;
    }
    return (actual_speed - desired_speed_in_mhz);
   11ab2:	f8bd 3000 	ldrh.w	r3, [sp]
   11ab6:	9a07      	ldr	r2, [sp, #28]
   11ab8:	1ad3      	subs	r3, r2, r3
  }
   11aba:	4618      	mov	r0, r3
   11abc:	b00a      	add	sp, #40	; 0x28
   11abe:	bd10      	pop	{r4, pc}
   11ac0:	10000044 	.word	0x10000044
   11ac4:	0001d984 	.word	0x0001d984
   11ac8:	0001d44c 	.word	0x0001d44c
   11acc:	0001cf8c 	.word	0x0001cf8c
   11ad0:	0001cddc 	.word	0x0001cddc

00011ad4 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)>:
                       "PLL lock could not be established before timeout");
    }
    return (actual_speed - desired_speed_in_mhz);
  }

  void SetCpuClockDivider(uint8_t cpu_divider)
   11ad4:	b500      	push	{lr}
   11ad6:	b083      	sub	sp, #12
   11ad8:	9001      	str	r0, [sp, #4]
   11ada:	460b      	mov	r3, r1
   11adc:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    SJ2_ASSERT_FATAL(cpu_divider < 32, "Divider mustn't exceed 32");
   11ae0:	f89d 3003 	ldrb.w	r3, [sp, #3]
   11ae4:	2b1f      	cmp	r3, #31
   11ae6:	d90e      	bls.n	11b06 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x32>
   11ae8:	f240 136f 	movw	r3, #367	; 0x16f
   11aec:	4a0e      	ldr	r2, [pc, #56]	; (11b28 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x54>)
   11aee:	490f      	ldr	r1, [pc, #60]	; (11b2c <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x58>)
   11af0:	480f      	ldr	r0, [pc, #60]	; (11b30 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x5c>)
   11af2:	f006 fe75 	bl	187e0 <printf>
   11af6:	480f      	ldr	r0, [pc, #60]	; (11b34 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x60>)
   11af8:	f004 fecc 	bl	16894 <puts>
   11afc:	2100      	movs	r1, #0
   11afe:	2001      	movs	r0, #1
   11b00:	f7ff fcce 	bl	114a0 <debug::PrintBacktrace(bool, void*)>
   11b04:	e7fe      	b.n	11b04 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x30>
    system_controller->CCLKSEL =
        (system_controller->CCLKSEL & ~kClearCpuDivider) | cpu_divider;
   11b06:	4b0c      	ldr	r3, [pc, #48]	; (11b38 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x64>)
   11b08:	681b      	ldr	r3, [r3, #0]
   11b0a:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   11b0e:	f023 011f 	bic.w	r1, r3, #31
   11b12:	f89d 2003 	ldrb.w	r2, [sp, #3]
    system_controller->CCLKSEL =
   11b16:	4b08      	ldr	r3, [pc, #32]	; (11b38 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x64>)
   11b18:	681b      	ldr	r3, [r3, #0]
        (system_controller->CCLKSEL & ~kClearCpuDivider) | cpu_divider;
   11b1a:	430a      	orrs	r2, r1
    system_controller->CCLKSEL =
   11b1c:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  }
   11b20:	bf00      	nop
   11b22:	b003      	add	sp, #12
   11b24:	f85d fb04 	ldr.w	pc, [sp], #4
   11b28:	0001da3c 	.word	0x0001da3c
   11b2c:	0001d464 	.word	0x0001d464
   11b30:	0001d034 	.word	0x0001d034
   11b34:	0001cddc 	.word	0x0001cddc
   11b38:	10000044 	.word	0x10000044

00011b3c <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)>:

  void SetEmcClockDivider(EmcDivider emc_divider)
   11b3c:	b082      	sub	sp, #8
   11b3e:	9001      	str	r0, [sp, #4]
   11b40:	460b      	mov	r3, r1
   11b42:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    system_controller->EMCCLKSEL =
        (system_controller->EMCCLKSEL & ~kClearEmcDivider) |
   11b46:	4b08      	ldr	r3, [pc, #32]	; (11b68 <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)+0x2c>)
   11b48:	681b      	ldr	r3, [r3, #0]
   11b4a:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
   11b4e:	f023 0101 	bic.w	r1, r3, #1
        static_cast<uint8_t>(emc_divider);
   11b52:	f89d 2003 	ldrb.w	r2, [sp, #3]
    system_controller->EMCCLKSEL =
   11b56:	4b04      	ldr	r3, [pc, #16]	; (11b68 <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)+0x2c>)
   11b58:	681b      	ldr	r3, [r3, #0]
        (system_controller->EMCCLKSEL & ~kClearEmcDivider) |
   11b5a:	430a      	orrs	r2, r1
    system_controller->EMCCLKSEL =
   11b5c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  }
   11b60:	bf00      	nop
   11b62:	b002      	add	sp, #8
   11b64:	4770      	bx	lr
   11b66:	bf00      	nop
   11b68:	10000044 	.word	0x10000044

00011b6c <PinInterface::PinInterface()>:
#include <cstdio>

#include "L0_LowLevel/LPC40xx.h"
#include "utility/macros.hpp"

class PinInterface
   11b6c:	b530      	push	{r4, r5, lr}
   11b6e:	b083      	sub	sp, #12
   11b70:	4675      	mov	r5, lr
   11b72:	9001      	str	r0, [sp, #4]
   11b74:	462b      	mov	r3, r5
   11b76:	4619      	mov	r1, r3
   11b78:	4807      	ldr	r0, [pc, #28]	; (11b98 <PinInterface::PinInterface()+0x2c>)
   11b7a:	f004 febb 	bl	168f4 <__cyg_profile_func_enter>
   11b7e:	4a07      	ldr	r2, [pc, #28]	; (11b9c <PinInterface::PinInterface()+0x30>)
   11b80:	9b01      	ldr	r3, [sp, #4]
   11b82:	601a      	str	r2, [r3, #0]
   11b84:	9c01      	ldr	r4, [sp, #4]
   11b86:	462b      	mov	r3, r5
   11b88:	4619      	mov	r1, r3
   11b8a:	4803      	ldr	r0, [pc, #12]	; (11b98 <PinInterface::PinInterface()+0x2c>)
   11b8c:	f004 fec6 	bl	1691c <__cyg_profile_func_exit>
   11b90:	4623      	mov	r3, r4
   11b92:	4618      	mov	r0, r3
   11b94:	b003      	add	sp, #12
   11b96:	bd30      	pop	{r4, r5, pc}
   11b98:	00011b6d 	.word	0x00011b6d
   11b9c:	0001d764 	.word	0x0001d764

00011ba0 <Pin::Pin(unsigned char, unsigned char)>:
  // no effect.
  static constexpr Pin CreateInactivePin()
  {
    return Pin(5, 4);
  }
  constexpr Pin(uint8_t port_number, uint8_t pin_number)
   11ba0:	b530      	push	{r4, r5, lr}
   11ba2:	b083      	sub	sp, #12
   11ba4:	4675      	mov	r5, lr
   11ba6:	9001      	str	r0, [sp, #4]
   11ba8:	460b      	mov	r3, r1
   11baa:	f88d 3003 	strb.w	r3, [sp, #3]
   11bae:	4613      	mov	r3, r2
   11bb0:	f88d 3002 	strb.w	r3, [sp, #2]
   11bb4:	462b      	mov	r3, r5
   11bb6:	4619      	mov	r1, r3
   11bb8:	480d      	ldr	r0, [pc, #52]	; (11bf0 <Pin::Pin(unsigned char, unsigned char)+0x50>)
   11bba:	f004 fe9b 	bl	168f4 <__cyg_profile_func_enter>
      : port_(port_number), pin_(pin_number)
   11bbe:	9b01      	ldr	r3, [sp, #4]
   11bc0:	4618      	mov	r0, r3
   11bc2:	f7ff ffd3 	bl	11b6c <PinInterface::PinInterface()>
   11bc6:	4a0b      	ldr	r2, [pc, #44]	; (11bf4 <Pin::Pin(unsigned char, unsigned char)+0x54>)
   11bc8:	9b01      	ldr	r3, [sp, #4]
   11bca:	601a      	str	r2, [r3, #0]
   11bcc:	9b01      	ldr	r3, [sp, #4]
   11bce:	f89d 2003 	ldrb.w	r2, [sp, #3]
   11bd2:	711a      	strb	r2, [r3, #4]
   11bd4:	9b01      	ldr	r3, [sp, #4]
   11bd6:	f89d 2002 	ldrb.w	r2, [sp, #2]
   11bda:	715a      	strb	r2, [r3, #5]
  {
  }
   11bdc:	9c01      	ldr	r4, [sp, #4]
   11bde:	462b      	mov	r3, r5
   11be0:	4619      	mov	r1, r3
   11be2:	4803      	ldr	r0, [pc, #12]	; (11bf0 <Pin::Pin(unsigned char, unsigned char)+0x50>)
   11be4:	f004 fe9a 	bl	1691c <__cyg_profile_func_exit>
   11be8:	4623      	mov	r3, r4
   11bea:	4618      	mov	r0, r3
   11bec:	b003      	add	sp, #12
   11bee:	bd30      	pop	{r4, r5, pc}
   11bf0:	00011ba1 	.word	0x00011ba1
   11bf4:	0001d728 	.word	0x0001d728

00011bf8 <Pin::SetPinFunction(unsigned char)>:
  void SetPinFunction(uint8_t function) override
   11bf8:	b5f0      	push	{r4, r5, r6, r7, lr}
   11bfa:	b085      	sub	sp, #20
   11bfc:	4677      	mov	r7, lr
   11bfe:	9003      	str	r0, [sp, #12]
   11c00:	460b      	mov	r3, r1
   11c02:	f88d 300b 	strb.w	r3, [sp, #11]
   11c06:	463b      	mov	r3, r7
   11c08:	4619      	mov	r1, r3
   11c0a:	4817      	ldr	r0, [pc, #92]	; (11c68 <Pin::SetPinFunction(unsigned char)+0x70>)
   11c0c:	f004 fe72 	bl	168f4 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kFunction,
   11c10:	4b16      	ldr	r3, [pc, #88]	; (11c6c <Pin::SetPinFunction(unsigned char)+0x74>)
   11c12:	681b      	ldr	r3, [r3, #0]
   11c14:	9a03      	ldr	r2, [sp, #12]
   11c16:	7912      	ldrb	r2, [r2, #4]
   11c18:	4610      	mov	r0, r2
   11c1a:	9a03      	ldr	r2, [sp, #12]
   11c1c:	7952      	ldrb	r2, [r2, #5]
   11c1e:	4611      	mov	r1, r2
   11c20:	0142      	lsls	r2, r0, #5
   11c22:	440a      	add	r2, r1
   11c24:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 function & 0b111, 3);
   11c28:	f89d 300b 	ldrb.w	r3, [sp, #11]
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kFunction,
   11c2c:	f003 0207 	and.w	r2, r3, #7
    pin_map->_register[port_][pin_] =
   11c30:	4b0e      	ldr	r3, [pc, #56]	; (11c6c <Pin::SetPinFunction(unsigned char)+0x74>)
   11c32:	681c      	ldr	r4, [r3, #0]
   11c34:	9b03      	ldr	r3, [sp, #12]
   11c36:	791b      	ldrb	r3, [r3, #4]
   11c38:	461e      	mov	r6, r3
   11c3a:	9b03      	ldr	r3, [sp, #12]
   11c3c:	795b      	ldrb	r3, [r3, #5]
   11c3e:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kFunction,
   11c40:	2303      	movs	r3, #3
   11c42:	9300      	str	r3, [sp, #0]
   11c44:	4613      	mov	r3, r2
   11c46:	2200      	movs	r2, #0
   11c48:	9803      	ldr	r0, [sp, #12]
   11c4a:	f000 fa67 	bl	1211c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11c4e:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   11c50:	0173      	lsls	r3, r6, #5
   11c52:	442b      	add	r3, r5
   11c54:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11c58:	463b      	mov	r3, r7
   11c5a:	4619      	mov	r1, r3
   11c5c:	4802      	ldr	r0, [pc, #8]	; (11c68 <Pin::SetPinFunction(unsigned char)+0x70>)
   11c5e:	f004 fe5d 	bl	1691c <__cyg_profile_func_exit>
  }
   11c62:	bf00      	nop
   11c64:	b005      	add	sp, #20
   11c66:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11c68:	00011bf9 	.word	0x00011bf9
   11c6c:	1000004c 	.word	0x1000004c

00011c70 <Pin::SetMode(PinInterface::Mode)>:
  void SetMode(PinInterface::Mode mode) override
   11c70:	b5f0      	push	{r4, r5, r6, r7, lr}
   11c72:	b087      	sub	sp, #28
   11c74:	4677      	mov	r7, lr
   11c76:	9003      	str	r0, [sp, #12]
   11c78:	460b      	mov	r3, r1
   11c7a:	f88d 300b 	strb.w	r3, [sp, #11]
   11c7e:	463b      	mov	r3, r7
   11c80:	4619      	mov	r1, r3
   11c82:	4819      	ldr	r0, [pc, #100]	; (11ce8 <Pin::SetMode(PinInterface::Mode)+0x78>)
   11c84:	f004 fe36 	bl	168f4 <__cyg_profile_func_enter>
  {
    uint8_t ui_mode                 = static_cast<uint8_t>(mode);
   11c88:	f89d 300b 	ldrb.w	r3, [sp, #11]
   11c8c:	f88d 3017 	strb.w	r3, [sp, #23]
    pin_map->_register[port_][pin_] = BitPlace(
   11c90:	4b16      	ldr	r3, [pc, #88]	; (11cec <Pin::SetMode(PinInterface::Mode)+0x7c>)
   11c92:	681b      	ldr	r3, [r3, #0]
        pin_map->_register[port_][pin_], PinBitMap::kMode, ui_mode & 0b11, 2);
   11c94:	9a03      	ldr	r2, [sp, #12]
   11c96:	7912      	ldrb	r2, [r2, #4]
   11c98:	4610      	mov	r0, r2
   11c9a:	9a03      	ldr	r2, [sp, #12]
   11c9c:	7952      	ldrb	r2, [r2, #5]
   11c9e:	4611      	mov	r1, r2
    pin_map->_register[port_][pin_] = BitPlace(
   11ca0:	0142      	lsls	r2, r0, #5
   11ca2:	440a      	add	r2, r1
   11ca4:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
        pin_map->_register[port_][pin_], PinBitMap::kMode, ui_mode & 0b11, 2);
   11ca8:	f89d 3017 	ldrb.w	r3, [sp, #23]
    pin_map->_register[port_][pin_] = BitPlace(
   11cac:	f003 0203 	and.w	r2, r3, #3
   11cb0:	4b0e      	ldr	r3, [pc, #56]	; (11cec <Pin::SetMode(PinInterface::Mode)+0x7c>)
   11cb2:	681c      	ldr	r4, [r3, #0]
   11cb4:	9b03      	ldr	r3, [sp, #12]
   11cb6:	791b      	ldrb	r3, [r3, #4]
   11cb8:	461e      	mov	r6, r3
   11cba:	9b03      	ldr	r3, [sp, #12]
   11cbc:	795b      	ldrb	r3, [r3, #5]
   11cbe:	461d      	mov	r5, r3
   11cc0:	2302      	movs	r3, #2
   11cc2:	9300      	str	r3, [sp, #0]
   11cc4:	4613      	mov	r3, r2
   11cc6:	2203      	movs	r2, #3
   11cc8:	9803      	ldr	r0, [sp, #12]
   11cca:	f000 fa27 	bl	1211c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11cce:	4602      	mov	r2, r0
   11cd0:	0173      	lsls	r3, r6, #5
   11cd2:	442b      	add	r3, r5
   11cd4:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11cd8:	463b      	mov	r3, r7
   11cda:	4619      	mov	r1, r3
   11cdc:	4802      	ldr	r0, [pc, #8]	; (11ce8 <Pin::SetMode(PinInterface::Mode)+0x78>)
   11cde:	f004 fe1d 	bl	1691c <__cyg_profile_func_exit>
  }
   11ce2:	bf00      	nop
   11ce4:	b007      	add	sp, #28
   11ce6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11ce8:	00011c71 	.word	0x00011c71
   11cec:	1000004c 	.word	0x1000004c

00011cf0 <Pin::EnableHysteresis(bool)>:
  void EnableHysteresis(bool enable_hysteresis = true) override
   11cf0:	b5f0      	push	{r4, r5, r6, r7, lr}
   11cf2:	b085      	sub	sp, #20
   11cf4:	4677      	mov	r7, lr
   11cf6:	9003      	str	r0, [sp, #12]
   11cf8:	460b      	mov	r3, r1
   11cfa:	f88d 300b 	strb.w	r3, [sp, #11]
   11cfe:	463b      	mov	r3, r7
   11d00:	4619      	mov	r1, r3
   11d02:	4816      	ldr	r0, [pc, #88]	; (11d5c <Pin::EnableHysteresis(bool)+0x6c>)
   11d04:	f004 fdf6 	bl	168f4 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kHysteresis,
   11d08:	4b15      	ldr	r3, [pc, #84]	; (11d60 <Pin::EnableHysteresis(bool)+0x70>)
   11d0a:	681b      	ldr	r3, [r3, #0]
   11d0c:	9a03      	ldr	r2, [sp, #12]
   11d0e:	7912      	ldrb	r2, [r2, #4]
   11d10:	4610      	mov	r0, r2
   11d12:	9a03      	ldr	r2, [sp, #12]
   11d14:	7952      	ldrb	r2, [r2, #5]
   11d16:	4611      	mov	r1, r2
   11d18:	0142      	lsls	r2, r0, #5
   11d1a:	440a      	add	r2, r1
   11d1c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   11d20:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   11d24:	4b0e      	ldr	r3, [pc, #56]	; (11d60 <Pin::EnableHysteresis(bool)+0x70>)
   11d26:	681c      	ldr	r4, [r3, #0]
   11d28:	9b03      	ldr	r3, [sp, #12]
   11d2a:	791b      	ldrb	r3, [r3, #4]
   11d2c:	461e      	mov	r6, r3
   11d2e:	9b03      	ldr	r3, [sp, #12]
   11d30:	795b      	ldrb	r3, [r3, #5]
   11d32:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kHysteresis,
   11d34:	2301      	movs	r3, #1
   11d36:	9300      	str	r3, [sp, #0]
   11d38:	4613      	mov	r3, r2
   11d3a:	2205      	movs	r2, #5
   11d3c:	9803      	ldr	r0, [sp, #12]
   11d3e:	f000 f9ed 	bl	1211c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11d42:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   11d44:	0173      	lsls	r3, r6, #5
   11d46:	442b      	add	r3, r5
   11d48:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11d4c:	463b      	mov	r3, r7
   11d4e:	4619      	mov	r1, r3
   11d50:	4802      	ldr	r0, [pc, #8]	; (11d5c <Pin::EnableHysteresis(bool)+0x6c>)
   11d52:	f004 fde3 	bl	1691c <__cyg_profile_func_exit>
                 enable_hysteresis, 1);
  }
   11d56:	bf00      	nop
   11d58:	b005      	add	sp, #20
   11d5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11d5c:	00011cf1 	.word	0x00011cf1
   11d60:	1000004c 	.word	0x1000004c

00011d64 <Pin::SetAsActiveLow(bool)>:
  void SetAsActiveLow(bool set_as_active_low = true) override
   11d64:	b5f0      	push	{r4, r5, r6, r7, lr}
   11d66:	b085      	sub	sp, #20
   11d68:	4677      	mov	r7, lr
   11d6a:	9003      	str	r0, [sp, #12]
   11d6c:	460b      	mov	r3, r1
   11d6e:	f88d 300b 	strb.w	r3, [sp, #11]
   11d72:	463b      	mov	r3, r7
   11d74:	4619      	mov	r1, r3
   11d76:	4816      	ldr	r0, [pc, #88]	; (11dd0 <Pin::SetAsActiveLow(bool)+0x6c>)
   11d78:	f004 fdbc 	bl	168f4 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kInputInvert,
   11d7c:	4b15      	ldr	r3, [pc, #84]	; (11dd4 <Pin::SetAsActiveLow(bool)+0x70>)
   11d7e:	681b      	ldr	r3, [r3, #0]
   11d80:	9a03      	ldr	r2, [sp, #12]
   11d82:	7912      	ldrb	r2, [r2, #4]
   11d84:	4610      	mov	r0, r2
   11d86:	9a03      	ldr	r2, [sp, #12]
   11d88:	7952      	ldrb	r2, [r2, #5]
   11d8a:	4611      	mov	r1, r2
   11d8c:	0142      	lsls	r2, r0, #5
   11d8e:	440a      	add	r2, r1
   11d90:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   11d94:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   11d98:	4b0e      	ldr	r3, [pc, #56]	; (11dd4 <Pin::SetAsActiveLow(bool)+0x70>)
   11d9a:	681c      	ldr	r4, [r3, #0]
   11d9c:	9b03      	ldr	r3, [sp, #12]
   11d9e:	791b      	ldrb	r3, [r3, #4]
   11da0:	461e      	mov	r6, r3
   11da2:	9b03      	ldr	r3, [sp, #12]
   11da4:	795b      	ldrb	r3, [r3, #5]
   11da6:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kInputInvert,
   11da8:	2301      	movs	r3, #1
   11daa:	9300      	str	r3, [sp, #0]
   11dac:	4613      	mov	r3, r2
   11dae:	2206      	movs	r2, #6
   11db0:	9803      	ldr	r0, [sp, #12]
   11db2:	f000 f9b3 	bl	1211c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11db6:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   11db8:	0173      	lsls	r3, r6, #5
   11dba:	442b      	add	r3, r5
   11dbc:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11dc0:	463b      	mov	r3, r7
   11dc2:	4619      	mov	r1, r3
   11dc4:	4802      	ldr	r0, [pc, #8]	; (11dd0 <Pin::SetAsActiveLow(bool)+0x6c>)
   11dc6:	f004 fda9 	bl	1691c <__cyg_profile_func_exit>
                 set_as_active_low, 1);
  }
   11dca:	bf00      	nop
   11dcc:	b005      	add	sp, #20
   11dce:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11dd0:	00011d65 	.word	0x00011d65
   11dd4:	1000004c 	.word	0x1000004c

00011dd8 <Pin::SetAsAnalogMode(bool)>:
  // Set bit to 0 to enable analog mode
  void SetAsAnalogMode(bool set_as_analog = true) override
   11dd8:	b5f0      	push	{r4, r5, r6, r7, lr}
   11dda:	b085      	sub	sp, #20
   11ddc:	4677      	mov	r7, lr
   11dde:	9003      	str	r0, [sp, #12]
   11de0:	460b      	mov	r3, r1
   11de2:	f88d 300b 	strb.w	r3, [sp, #11]
   11de6:	463b      	mov	r3, r7
   11de8:	4619      	mov	r1, r3
   11dea:	4818      	ldr	r0, [pc, #96]	; (11e4c <Pin::SetAsAnalogMode(bool)+0x74>)
   11dec:	f004 fd82 	bl	168f4 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kAnalogDigitalMode,
   11df0:	4b17      	ldr	r3, [pc, #92]	; (11e50 <Pin::SetAsAnalogMode(bool)+0x78>)
   11df2:	681b      	ldr	r3, [r3, #0]
   11df4:	9a03      	ldr	r2, [sp, #12]
   11df6:	7912      	ldrb	r2, [r2, #4]
   11df8:	4610      	mov	r0, r2
   11dfa:	9a03      	ldr	r2, [sp, #12]
   11dfc:	7952      	ldrb	r2, [r2, #5]
   11dfe:	4611      	mov	r1, r2
   11e00:	0142      	lsls	r2, r0, #5
   11e02:	440a      	add	r2, r1
   11e04:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 !set_as_analog, 1);
   11e08:	f89d 300b 	ldrb.w	r3, [sp, #11]
   11e0c:	f083 0301 	eor.w	r3, r3, #1
   11e10:	b2db      	uxtb	r3, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kAnalogDigitalMode,
   11e12:	461a      	mov	r2, r3
    pin_map->_register[port_][pin_] =
   11e14:	4b0e      	ldr	r3, [pc, #56]	; (11e50 <Pin::SetAsAnalogMode(bool)+0x78>)
   11e16:	681c      	ldr	r4, [r3, #0]
   11e18:	9b03      	ldr	r3, [sp, #12]
   11e1a:	791b      	ldrb	r3, [r3, #4]
   11e1c:	461e      	mov	r6, r3
   11e1e:	9b03      	ldr	r3, [sp, #12]
   11e20:	795b      	ldrb	r3, [r3, #5]
   11e22:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kAnalogDigitalMode,
   11e24:	2301      	movs	r3, #1
   11e26:	9300      	str	r3, [sp, #0]
   11e28:	4613      	mov	r3, r2
   11e2a:	2207      	movs	r2, #7
   11e2c:	9803      	ldr	r0, [sp, #12]
   11e2e:	f000 f975 	bl	1211c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11e32:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   11e34:	0173      	lsls	r3, r6, #5
   11e36:	442b      	add	r3, r5
   11e38:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11e3c:	463b      	mov	r3, r7
   11e3e:	4619      	mov	r1, r3
   11e40:	4802      	ldr	r0, [pc, #8]	; (11e4c <Pin::SetAsAnalogMode(bool)+0x74>)
   11e42:	f004 fd6b 	bl	1691c <__cyg_profile_func_exit>
  }
   11e46:	bf00      	nop
   11e48:	b005      	add	sp, #20
   11e4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11e4c:	00011dd9 	.word	0x00011dd9
   11e50:	1000004c 	.word	0x1000004c

00011e54 <Pin::EnableDigitalFilter(bool)>:
  // Enable by setting bit to 0 to enable digital filter.
  void EnableDigitalFilter(bool enable_digital_filter = true) override
   11e54:	b5f0      	push	{r4, r5, r6, r7, lr}
   11e56:	b085      	sub	sp, #20
   11e58:	4677      	mov	r7, lr
   11e5a:	9003      	str	r0, [sp, #12]
   11e5c:	460b      	mov	r3, r1
   11e5e:	f88d 300b 	strb.w	r3, [sp, #11]
   11e62:	463b      	mov	r3, r7
   11e64:	4619      	mov	r1, r3
   11e66:	4818      	ldr	r0, [pc, #96]	; (11ec8 <Pin::EnableDigitalFilter(bool)+0x74>)
   11e68:	f004 fd44 	bl	168f4 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kDigitalFilter,
   11e6c:	4b17      	ldr	r3, [pc, #92]	; (11ecc <Pin::EnableDigitalFilter(bool)+0x78>)
   11e6e:	681b      	ldr	r3, [r3, #0]
   11e70:	9a03      	ldr	r2, [sp, #12]
   11e72:	7912      	ldrb	r2, [r2, #4]
   11e74:	4610      	mov	r0, r2
   11e76:	9a03      	ldr	r2, [sp, #12]
   11e78:	7952      	ldrb	r2, [r2, #5]
   11e7a:	4611      	mov	r1, r2
   11e7c:	0142      	lsls	r2, r0, #5
   11e7e:	440a      	add	r2, r1
   11e80:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 !enable_digital_filter, 1);
   11e84:	f89d 300b 	ldrb.w	r3, [sp, #11]
   11e88:	f083 0301 	eor.w	r3, r3, #1
   11e8c:	b2db      	uxtb	r3, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kDigitalFilter,
   11e8e:	461a      	mov	r2, r3
    pin_map->_register[port_][pin_] =
   11e90:	4b0e      	ldr	r3, [pc, #56]	; (11ecc <Pin::EnableDigitalFilter(bool)+0x78>)
   11e92:	681c      	ldr	r4, [r3, #0]
   11e94:	9b03      	ldr	r3, [sp, #12]
   11e96:	791b      	ldrb	r3, [r3, #4]
   11e98:	461e      	mov	r6, r3
   11e9a:	9b03      	ldr	r3, [sp, #12]
   11e9c:	795b      	ldrb	r3, [r3, #5]
   11e9e:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kDigitalFilter,
   11ea0:	2301      	movs	r3, #1
   11ea2:	9300      	str	r3, [sp, #0]
   11ea4:	4613      	mov	r3, r2
   11ea6:	2208      	movs	r2, #8
   11ea8:	9803      	ldr	r0, [sp, #12]
   11eaa:	f000 f937 	bl	1211c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11eae:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   11eb0:	0173      	lsls	r3, r6, #5
   11eb2:	442b      	add	r3, r5
   11eb4:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11eb8:	463b      	mov	r3, r7
   11eba:	4619      	mov	r1, r3
   11ebc:	4802      	ldr	r0, [pc, #8]	; (11ec8 <Pin::EnableDigitalFilter(bool)+0x74>)
   11ebe:	f004 fd2d 	bl	1691c <__cyg_profile_func_exit>
  }
   11ec2:	bf00      	nop
   11ec4:	b005      	add	sp, #20
   11ec6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11ec8:	00011e55 	.word	0x00011e55
   11ecc:	1000004c 	.word	0x1000004c

00011ed0 <Pin::EnableFastMode(bool)>:
  void EnableFastMode(bool enable_fast_mode = true) override
   11ed0:	b5f0      	push	{r4, r5, r6, r7, lr}
   11ed2:	b085      	sub	sp, #20
   11ed4:	4677      	mov	r7, lr
   11ed6:	9003      	str	r0, [sp, #12]
   11ed8:	460b      	mov	r3, r1
   11eda:	f88d 300b 	strb.w	r3, [sp, #11]
   11ede:	463b      	mov	r3, r7
   11ee0:	4619      	mov	r1, r3
   11ee2:	4816      	ldr	r0, [pc, #88]	; (11f3c <Pin::EnableFastMode(bool)+0x6c>)
   11ee4:	f004 fd06 	bl	168f4 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] = BitPlace(
   11ee8:	4b15      	ldr	r3, [pc, #84]	; (11f40 <Pin::EnableFastMode(bool)+0x70>)
   11eea:	681b      	ldr	r3, [r3, #0]
        pin_map->_register[port_][pin_], PinBitMap::kSlew, enable_fast_mode, 1);
   11eec:	9a03      	ldr	r2, [sp, #12]
   11eee:	7912      	ldrb	r2, [r2, #4]
   11ef0:	4610      	mov	r0, r2
   11ef2:	9a03      	ldr	r2, [sp, #12]
   11ef4:	7952      	ldrb	r2, [r2, #5]
   11ef6:	4611      	mov	r1, r2
    pin_map->_register[port_][pin_] = BitPlace(
   11ef8:	0142      	lsls	r2, r0, #5
   11efa:	440a      	add	r2, r1
   11efc:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   11f00:	f89d 200b 	ldrb.w	r2, [sp, #11]
   11f04:	4b0e      	ldr	r3, [pc, #56]	; (11f40 <Pin::EnableFastMode(bool)+0x70>)
   11f06:	681c      	ldr	r4, [r3, #0]
   11f08:	9b03      	ldr	r3, [sp, #12]
   11f0a:	791b      	ldrb	r3, [r3, #4]
   11f0c:	461e      	mov	r6, r3
   11f0e:	9b03      	ldr	r3, [sp, #12]
   11f10:	795b      	ldrb	r3, [r3, #5]
   11f12:	461d      	mov	r5, r3
   11f14:	2301      	movs	r3, #1
   11f16:	9300      	str	r3, [sp, #0]
   11f18:	4613      	mov	r3, r2
   11f1a:	2209      	movs	r2, #9
   11f1c:	9803      	ldr	r0, [sp, #12]
   11f1e:	f000 f8fd 	bl	1211c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11f22:	4602      	mov	r2, r0
   11f24:	0173      	lsls	r3, r6, #5
   11f26:	442b      	add	r3, r5
   11f28:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11f2c:	463b      	mov	r3, r7
   11f2e:	4619      	mov	r1, r3
   11f30:	4802      	ldr	r0, [pc, #8]	; (11f3c <Pin::EnableFastMode(bool)+0x6c>)
   11f32:	f004 fcf3 	bl	1691c <__cyg_profile_func_exit>
  }
   11f36:	bf00      	nop
   11f38:	b005      	add	sp, #20
   11f3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11f3c:	00011ed1 	.word	0x00011ed1
   11f40:	1000004c 	.word	0x1000004c

00011f44 <Pin::EnableI2cHighSpeedMode(bool)>:
  // Enable by setting bit to 0 for i2c high speed mode
  void EnableI2cHighSpeedMode(bool enable_high_speed = true) override
   11f44:	b5f0      	push	{r4, r5, r6, r7, lr}
   11f46:	b085      	sub	sp, #20
   11f48:	4677      	mov	r7, lr
   11f4a:	9003      	str	r0, [sp, #12]
   11f4c:	460b      	mov	r3, r1
   11f4e:	f88d 300b 	strb.w	r3, [sp, #11]
   11f52:	463b      	mov	r3, r7
   11f54:	4619      	mov	r1, r3
   11f56:	4818      	ldr	r0, [pc, #96]	; (11fb8 <Pin::EnableI2cHighSpeedMode(bool)+0x74>)
   11f58:	f004 fccc 	bl	168f4 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kI2cHighSpeed,
   11f5c:	4b17      	ldr	r3, [pc, #92]	; (11fbc <Pin::EnableI2cHighSpeedMode(bool)+0x78>)
   11f5e:	681b      	ldr	r3, [r3, #0]
   11f60:	9a03      	ldr	r2, [sp, #12]
   11f62:	7912      	ldrb	r2, [r2, #4]
   11f64:	4610      	mov	r0, r2
   11f66:	9a03      	ldr	r2, [sp, #12]
   11f68:	7952      	ldrb	r2, [r2, #5]
   11f6a:	4611      	mov	r1, r2
   11f6c:	0142      	lsls	r2, r0, #5
   11f6e:	440a      	add	r2, r1
   11f70:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 !enable_high_speed, 1);
   11f74:	f89d 300b 	ldrb.w	r3, [sp, #11]
   11f78:	f083 0301 	eor.w	r3, r3, #1
   11f7c:	b2db      	uxtb	r3, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kI2cHighSpeed,
   11f7e:	461a      	mov	r2, r3
    pin_map->_register[port_][pin_] =
   11f80:	4b0e      	ldr	r3, [pc, #56]	; (11fbc <Pin::EnableI2cHighSpeedMode(bool)+0x78>)
   11f82:	681c      	ldr	r4, [r3, #0]
   11f84:	9b03      	ldr	r3, [sp, #12]
   11f86:	791b      	ldrb	r3, [r3, #4]
   11f88:	461e      	mov	r6, r3
   11f8a:	9b03      	ldr	r3, [sp, #12]
   11f8c:	795b      	ldrb	r3, [r3, #5]
   11f8e:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kI2cHighSpeed,
   11f90:	2301      	movs	r3, #1
   11f92:	9300      	str	r3, [sp, #0]
   11f94:	4613      	mov	r3, r2
   11f96:	2208      	movs	r2, #8
   11f98:	9803      	ldr	r0, [sp, #12]
   11f9a:	f000 f8bf 	bl	1211c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11f9e:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   11fa0:	0173      	lsls	r3, r6, #5
   11fa2:	442b      	add	r3, r5
   11fa4:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11fa8:	463b      	mov	r3, r7
   11faa:	4619      	mov	r1, r3
   11fac:	4802      	ldr	r0, [pc, #8]	; (11fb8 <Pin::EnableI2cHighSpeedMode(bool)+0x74>)
   11fae:	f004 fcb5 	bl	1691c <__cyg_profile_func_exit>
  }
   11fb2:	bf00      	nop
   11fb4:	b005      	add	sp, #20
   11fb6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11fb8:	00011f45 	.word	0x00011f45
   11fbc:	1000004c 	.word	0x1000004c

00011fc0 <Pin::EnableI2cHighCurrentDrive(bool)>:
  void EnableI2cHighCurrentDrive(bool enable_high_current = true) override
   11fc0:	b5f0      	push	{r4, r5, r6, r7, lr}
   11fc2:	b085      	sub	sp, #20
   11fc4:	4677      	mov	r7, lr
   11fc6:	9003      	str	r0, [sp, #12]
   11fc8:	460b      	mov	r3, r1
   11fca:	f88d 300b 	strb.w	r3, [sp, #11]
   11fce:	463b      	mov	r3, r7
   11fd0:	4619      	mov	r1, r3
   11fd2:	4816      	ldr	r0, [pc, #88]	; (1202c <Pin::EnableI2cHighCurrentDrive(bool)+0x6c>)
   11fd4:	f004 fc8e 	bl	168f4 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_],
   11fd8:	4b15      	ldr	r3, [pc, #84]	; (12030 <Pin::EnableI2cHighCurrentDrive(bool)+0x70>)
   11fda:	681b      	ldr	r3, [r3, #0]
   11fdc:	9a03      	ldr	r2, [sp, #12]
   11fde:	7912      	ldrb	r2, [r2, #4]
   11fe0:	4610      	mov	r0, r2
   11fe2:	9a03      	ldr	r2, [sp, #12]
   11fe4:	7952      	ldrb	r2, [r2, #5]
   11fe6:	4611      	mov	r1, r2
   11fe8:	0142      	lsls	r2, r0, #5
   11fea:	440a      	add	r2, r1
   11fec:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   11ff0:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   11ff4:	4b0e      	ldr	r3, [pc, #56]	; (12030 <Pin::EnableI2cHighCurrentDrive(bool)+0x70>)
   11ff6:	681c      	ldr	r4, [r3, #0]
   11ff8:	9b03      	ldr	r3, [sp, #12]
   11ffa:	791b      	ldrb	r3, [r3, #4]
   11ffc:	461e      	mov	r6, r3
   11ffe:	9b03      	ldr	r3, [sp, #12]
   12000:	795b      	ldrb	r3, [r3, #5]
   12002:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_],
   12004:	2301      	movs	r3, #1
   12006:	9300      	str	r3, [sp, #0]
   12008:	4613      	mov	r3, r2
   1200a:	2209      	movs	r2, #9
   1200c:	9803      	ldr	r0, [sp, #12]
   1200e:	f000 f885 	bl	1211c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   12012:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   12014:	0173      	lsls	r3, r6, #5
   12016:	442b      	add	r3, r5
   12018:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   1201c:	463b      	mov	r3, r7
   1201e:	4619      	mov	r1, r3
   12020:	4802      	ldr	r0, [pc, #8]	; (1202c <Pin::EnableI2cHighCurrentDrive(bool)+0x6c>)
   12022:	f004 fc7b 	bl	1691c <__cyg_profile_func_exit>
                 PinBitMap::kI2cHighCurrentDrive, enable_high_current, 1);
  }
   12026:	bf00      	nop
   12028:	b005      	add	sp, #20
   1202a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1202c:	00011fc1 	.word	0x00011fc1
   12030:	1000004c 	.word	0x1000004c

00012034 <Pin::SetAsOpenDrain(bool)>:
  void SetAsOpenDrain(bool set_as_open_drain = true) override
   12034:	b5f0      	push	{r4, r5, r6, r7, lr}
   12036:	b085      	sub	sp, #20
   12038:	4677      	mov	r7, lr
   1203a:	9003      	str	r0, [sp, #12]
   1203c:	460b      	mov	r3, r1
   1203e:	f88d 300b 	strb.w	r3, [sp, #11]
   12042:	463b      	mov	r3, r7
   12044:	4619      	mov	r1, r3
   12046:	4816      	ldr	r0, [pc, #88]	; (120a0 <Pin::SetAsOpenDrain(bool)+0x6c>)
   12048:	f004 fc54 	bl	168f4 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kOpenDrain,
   1204c:	4b15      	ldr	r3, [pc, #84]	; (120a4 <Pin::SetAsOpenDrain(bool)+0x70>)
   1204e:	681b      	ldr	r3, [r3, #0]
   12050:	9a03      	ldr	r2, [sp, #12]
   12052:	7912      	ldrb	r2, [r2, #4]
   12054:	4610      	mov	r0, r2
   12056:	9a03      	ldr	r2, [sp, #12]
   12058:	7952      	ldrb	r2, [r2, #5]
   1205a:	4611      	mov	r1, r2
   1205c:	0142      	lsls	r2, r0, #5
   1205e:	440a      	add	r2, r1
   12060:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   12064:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   12068:	4b0e      	ldr	r3, [pc, #56]	; (120a4 <Pin::SetAsOpenDrain(bool)+0x70>)
   1206a:	681c      	ldr	r4, [r3, #0]
   1206c:	9b03      	ldr	r3, [sp, #12]
   1206e:	791b      	ldrb	r3, [r3, #4]
   12070:	461e      	mov	r6, r3
   12072:	9b03      	ldr	r3, [sp, #12]
   12074:	795b      	ldrb	r3, [r3, #5]
   12076:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kOpenDrain,
   12078:	2301      	movs	r3, #1
   1207a:	9300      	str	r3, [sp, #0]
   1207c:	4613      	mov	r3, r2
   1207e:	220a      	movs	r2, #10
   12080:	9803      	ldr	r0, [sp, #12]
   12082:	f000 f84b 	bl	1211c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   12086:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   12088:	0173      	lsls	r3, r6, #5
   1208a:	442b      	add	r3, r5
   1208c:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   12090:	463b      	mov	r3, r7
   12092:	4619      	mov	r1, r3
   12094:	4802      	ldr	r0, [pc, #8]	; (120a0 <Pin::SetAsOpenDrain(bool)+0x6c>)
   12096:	f004 fc41 	bl	1691c <__cyg_profile_func_exit>
                 set_as_open_drain, 1);
  }
   1209a:	bf00      	nop
   1209c:	b005      	add	sp, #20
   1209e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   120a0:	00012035 	.word	0x00012035
   120a4:	1000004c 	.word	0x1000004c

000120a8 <Pin::EnableDac(bool)>:
  void EnableDac(bool enable_dac = true) override
   120a8:	b5f0      	push	{r4, r5, r6, r7, lr}
   120aa:	b085      	sub	sp, #20
   120ac:	4677      	mov	r7, lr
   120ae:	9003      	str	r0, [sp, #12]
   120b0:	460b      	mov	r3, r1
   120b2:	f88d 300b 	strb.w	r3, [sp, #11]
   120b6:	463b      	mov	r3, r7
   120b8:	4619      	mov	r1, r3
   120ba:	4816      	ldr	r0, [pc, #88]	; (12114 <Pin::EnableDac(bool)+0x6c>)
   120bc:	f004 fc1a 	bl	168f4 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] = BitPlace(
   120c0:	4b15      	ldr	r3, [pc, #84]	; (12118 <Pin::EnableDac(bool)+0x70>)
   120c2:	681b      	ldr	r3, [r3, #0]
        pin_map->_register[port_][pin_], PinBitMap::kDacEnable, enable_dac, 1);
   120c4:	9a03      	ldr	r2, [sp, #12]
   120c6:	7912      	ldrb	r2, [r2, #4]
   120c8:	4610      	mov	r0, r2
   120ca:	9a03      	ldr	r2, [sp, #12]
   120cc:	7952      	ldrb	r2, [r2, #5]
   120ce:	4611      	mov	r1, r2
    pin_map->_register[port_][pin_] = BitPlace(
   120d0:	0142      	lsls	r2, r0, #5
   120d2:	440a      	add	r2, r1
   120d4:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   120d8:	f89d 200b 	ldrb.w	r2, [sp, #11]
   120dc:	4b0e      	ldr	r3, [pc, #56]	; (12118 <Pin::EnableDac(bool)+0x70>)
   120de:	681c      	ldr	r4, [r3, #0]
   120e0:	9b03      	ldr	r3, [sp, #12]
   120e2:	791b      	ldrb	r3, [r3, #4]
   120e4:	461e      	mov	r6, r3
   120e6:	9b03      	ldr	r3, [sp, #12]
   120e8:	795b      	ldrb	r3, [r3, #5]
   120ea:	461d      	mov	r5, r3
   120ec:	2301      	movs	r3, #1
   120ee:	9300      	str	r3, [sp, #0]
   120f0:	4613      	mov	r3, r2
   120f2:	2210      	movs	r2, #16
   120f4:	9803      	ldr	r0, [sp, #12]
   120f6:	f000 f811 	bl	1211c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   120fa:	4602      	mov	r2, r0
   120fc:	0173      	lsls	r3, r6, #5
   120fe:	442b      	add	r3, r5
   12100:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   12104:	463b      	mov	r3, r7
   12106:	4619      	mov	r1, r3
   12108:	4802      	ldr	r0, [pc, #8]	; (12114 <Pin::EnableDac(bool)+0x6c>)
   1210a:	f004 fc07 	bl	1691c <__cyg_profile_func_exit>
  }
   1210e:	bf00      	nop
   12110:	b005      	add	sp, #20
   12112:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12114:	000120a9 	.word	0x000120a9
   12118:	1000004c 	.word	0x1000004c

0001211c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>:
  inline uint32_t BitPlace(uint32_t target, uint32_t position, uint32_t value,
   1211c:	b530      	push	{r4, r5, lr}
   1211e:	b087      	sub	sp, #28
   12120:	4675      	mov	r5, lr
   12122:	9003      	str	r0, [sp, #12]
   12124:	9102      	str	r1, [sp, #8]
   12126:	9201      	str	r2, [sp, #4]
   12128:	9300      	str	r3, [sp, #0]
   1212a:	462b      	mov	r3, r5
   1212c:	4619      	mov	r1, r3
   1212e:	4813      	ldr	r0, [pc, #76]	; (1217c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)+0x60>)
   12130:	f004 fbe0 	bl	168f4 <__cyg_profile_func_enter>
                           uint32_t value_width)
  {
    // Generate mask with all 1s
    uint32_t mask = 0xFFFFFFFF >> (32 - value_width);
   12134:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   12136:	f1c3 0320 	rsb	r3, r3, #32
   1213a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1213e:	fa22 f303 	lsr.w	r3, r2, r3
   12142:	9305      	str	r3, [sp, #20]
    target &= ~(mask << position);
   12144:	9a05      	ldr	r2, [sp, #20]
   12146:	9b01      	ldr	r3, [sp, #4]
   12148:	fa02 f303 	lsl.w	r3, r2, r3
   1214c:	43db      	mvns	r3, r3
   1214e:	9a02      	ldr	r2, [sp, #8]
   12150:	4013      	ands	r3, r2
   12152:	9302      	str	r3, [sp, #8]
    target |= (value & mask) << position;
   12154:	9a00      	ldr	r2, [sp, #0]
   12156:	9b05      	ldr	r3, [sp, #20]
   12158:	401a      	ands	r2, r3
   1215a:	9b01      	ldr	r3, [sp, #4]
   1215c:	fa02 f303 	lsl.w	r3, r2, r3
   12160:	9a02      	ldr	r2, [sp, #8]
   12162:	4313      	orrs	r3, r2
   12164:	9302      	str	r3, [sp, #8]
    return target;
   12166:	9c02      	ldr	r4, [sp, #8]
   12168:	462b      	mov	r3, r5
   1216a:	4619      	mov	r1, r3
   1216c:	4803      	ldr	r0, [pc, #12]	; (1217c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)+0x60>)
   1216e:	f004 fbd5 	bl	1691c <__cyg_profile_func_exit>
   12172:	4623      	mov	r3, r4
  }
   12174:	4618      	mov	r0, r3
   12176:	b007      	add	sp, #28
   12178:	bd30      	pop	{r4, r5, pc}
   1217a:	bf00      	nop
   1217c:	0001211d 	.word	0x0001211d

00012180 <Pin::GetPort() const>:
  uint8_t GetPort() const override
   12180:	b530      	push	{r4, r5, lr}
   12182:	b083      	sub	sp, #12
   12184:	4675      	mov	r5, lr
   12186:	9001      	str	r0, [sp, #4]
   12188:	462b      	mov	r3, r5
   1218a:	4619      	mov	r1, r3
   1218c:	4806      	ldr	r0, [pc, #24]	; (121a8 <Pin::GetPort() const+0x28>)
   1218e:	f004 fbb1 	bl	168f4 <__cyg_profile_func_enter>
  {
    return port_;
   12192:	9b01      	ldr	r3, [sp, #4]
   12194:	791c      	ldrb	r4, [r3, #4]
   12196:	462b      	mov	r3, r5
   12198:	4619      	mov	r1, r3
   1219a:	4803      	ldr	r0, [pc, #12]	; (121a8 <Pin::GetPort() const+0x28>)
   1219c:	f004 fbbe 	bl	1691c <__cyg_profile_func_exit>
   121a0:	4623      	mov	r3, r4
  }
   121a2:	4618      	mov	r0, r3
   121a4:	b003      	add	sp, #12
   121a6:	bd30      	pop	{r4, r5, pc}
   121a8:	00012181 	.word	0x00012181

000121ac <Pin::GetPin() const>:
  uint8_t GetPin() const override
   121ac:	b530      	push	{r4, r5, lr}
   121ae:	b083      	sub	sp, #12
   121b0:	4675      	mov	r5, lr
   121b2:	9001      	str	r0, [sp, #4]
   121b4:	462b      	mov	r3, r5
   121b6:	4619      	mov	r1, r3
   121b8:	4806      	ldr	r0, [pc, #24]	; (121d4 <Pin::GetPin() const+0x28>)
   121ba:	f004 fb9b 	bl	168f4 <__cyg_profile_func_enter>
  {
    return pin_;
   121be:	9b01      	ldr	r3, [sp, #4]
   121c0:	795c      	ldrb	r4, [r3, #5]
   121c2:	462b      	mov	r3, r5
   121c4:	4619      	mov	r1, r3
   121c6:	4803      	ldr	r0, [pc, #12]	; (121d4 <Pin::GetPin() const+0x28>)
   121c8:	f004 fba8 	bl	1691c <__cyg_profile_func_exit>
   121cc:	4623      	mov	r3, r4
  }
   121ce:	4618      	mov	r0, r3
   121d0:	b003      	add	sp, #12
   121d2:	bd30      	pop	{r4, r5, pc}
   121d4:	000121ad 	.word	0x000121ad

000121d8 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>:
constexpr Type Value(Enum enum_type_value)
   121d8:	b530      	push	{r4, r5, lr}
   121da:	b083      	sub	sp, #12
   121dc:	4675      	mov	r5, lr
   121de:	4603      	mov	r3, r0
   121e0:	f88d 3007 	strb.w	r3, [sp, #7]
   121e4:	462b      	mov	r3, r5
   121e6:	4619      	mov	r1, r3
   121e8:	4806      	ldr	r0, [pc, #24]	; (12204 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)+0x2c>)
   121ea:	f004 fb83 	bl	168f4 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   121ee:	f89d 4007 	ldrb.w	r4, [sp, #7]
   121f2:	462b      	mov	r3, r5
   121f4:	4619      	mov	r1, r3
   121f6:	4803      	ldr	r0, [pc, #12]	; (12204 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)+0x2c>)
   121f8:	f004 fb90 	bl	1691c <__cyg_profile_func_exit>
   121fc:	4623      	mov	r3, r4
}
   121fe:	4618      	mov	r0, r3
   12200:	b003      	add	sp, #12
   12202:	bd30      	pop	{r4, r5, pc}
   12204:	000121d9 	.word	0x000121d9

00012208 <Timer::Initialize(unsigned long, void (*)(), long)>:
  ///                  register will be 10 ms.
  /// @param isr an ISR that will fire when the condition set by SetTimer
  ///            method is achieved.
  /// @param priority sets the Timer interrupt's priority level, defaults to -1
  ///                 which uses the platforms default priority.
  void Initialize(uint32_t frequency, IsrPointer isr = DoNothingIsr,
   12208:	b510      	push	{r4, lr}
   1220a:	b086      	sub	sp, #24
   1220c:	4674      	mov	r4, lr
   1220e:	9003      	str	r0, [sp, #12]
   12210:	9102      	str	r1, [sp, #8]
   12212:	9201      	str	r2, [sp, #4]
   12214:	9300      	str	r3, [sp, #0]
   12216:	4623      	mov	r3, r4
   12218:	4619      	mov	r1, r3
   1221a:	483e      	ldr	r0, [pc, #248]	; (12314 <Timer::Initialize(unsigned long, void (*)(), long)+0x10c>)
   1221c:	f004 fb6a 	bl	168f4 <__cyg_profile_func_enter>
                  int32_t priority = -1) override final
  {
    PowerUpPeripheral(kPowerbit[channel_]);
   12220:	9b03      	ldr	r3, [sp, #12]
   12222:	1d18      	adds	r0, r3, #4
   12224:	9b03      	ldr	r3, [sp, #12]
   12226:	685b      	ldr	r3, [r3, #4]
   12228:	3314      	adds	r3, #20
   1222a:	681b      	ldr	r3, [r3, #0]
   1222c:	9a03      	ldr	r2, [sp, #12]
   1222e:	7a12      	ldrb	r2, [r2, #8]
   12230:	0092      	lsls	r2, r2, #2
   12232:	4939      	ldr	r1, [pc, #228]	; (12318 <Timer::Initialize(unsigned long, void (*)(), long)+0x110>)
   12234:	440a      	add	r2, r1
   12236:	4611      	mov	r1, r2
   12238:	4798      	blx	r3
    SJ2_ASSERT_FATAL(
   1223a:	9b02      	ldr	r3, [sp, #8]
   1223c:	2b00      	cmp	r3, #0
   1223e:	d10d      	bne.n	1225c <Timer::Initialize(unsigned long, void (*)(), long)+0x54>
   12240:	2384      	movs	r3, #132	; 0x84
   12242:	4a36      	ldr	r2, [pc, #216]	; (1231c <Timer::Initialize(unsigned long, void (*)(), long)+0x114>)
   12244:	4936      	ldr	r1, [pc, #216]	; (12320 <Timer::Initialize(unsigned long, void (*)(), long)+0x118>)
   12246:	4837      	ldr	r0, [pc, #220]	; (12324 <Timer::Initialize(unsigned long, void (*)(), long)+0x11c>)
   12248:	f006 faca 	bl	187e0 <printf>
   1224c:	4836      	ldr	r0, [pc, #216]	; (12328 <Timer::Initialize(unsigned long, void (*)(), long)+0x120>)
   1224e:	f004 fb21 	bl	16894 <puts>
   12252:	2100      	movs	r1, #0
   12254:	2001      	movs	r0, #1
   12256:	f7ff f923 	bl	114a0 <debug::PrintBacktrace(bool, void*)>
   1225a:	e7fe      	b.n	1225a <Timer::Initialize(unsigned long, void (*)(), long)+0x52>
        frequency != 0,
        "Cannot have zero ticks per microsecond, please choose 1 or more.");
    // Set Prescale register for Prescale Counter to milliseconds
    uint32_t prescaler = GetPeripheralFrequency() / frequency;
   1225c:	9b03      	ldr	r3, [sp, #12]
   1225e:	1d1a      	adds	r2, r3, #4
   12260:	9b03      	ldr	r3, [sp, #12]
   12262:	685b      	ldr	r3, [r3, #4]
   12264:	3310      	adds	r3, #16
   12266:	681b      	ldr	r3, [r3, #0]
   12268:	4610      	mov	r0, r2
   1226a:	4798      	blx	r3
   1226c:	4602      	mov	r2, r0
   1226e:	9b02      	ldr	r3, [sp, #8]
   12270:	fbb2 f3f3 	udiv	r3, r2, r3
   12274:	9305      	str	r3, [sp, #20]
    tim_register[channel_]->PR &= ~(kClear << 1);
   12276:	9b03      	ldr	r3, [sp, #12]
   12278:	7a1b      	ldrb	r3, [r3, #8]
   1227a:	461a      	mov	r2, r3
   1227c:	4b2b      	ldr	r3, [pc, #172]	; (1232c <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   1227e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12282:	68da      	ldr	r2, [r3, #12]
   12284:	9b03      	ldr	r3, [sp, #12]
   12286:	7a1b      	ldrb	r3, [r3, #8]
   12288:	4619      	mov	r1, r3
   1228a:	4b28      	ldr	r3, [pc, #160]	; (1232c <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   1228c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   12290:	f002 0201 	and.w	r2, r2, #1
   12294:	60da      	str	r2, [r3, #12]
    tim_register[channel_]->PR |= (prescaler << 1);
   12296:	9b03      	ldr	r3, [sp, #12]
   12298:	7a1b      	ldrb	r3, [r3, #8]
   1229a:	461a      	mov	r2, r3
   1229c:	4b23      	ldr	r3, [pc, #140]	; (1232c <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   1229e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   122a2:	68d9      	ldr	r1, [r3, #12]
   122a4:	9b05      	ldr	r3, [sp, #20]
   122a6:	005a      	lsls	r2, r3, #1
   122a8:	9b03      	ldr	r3, [sp, #12]
   122aa:	7a1b      	ldrb	r3, [r3, #8]
   122ac:	4618      	mov	r0, r3
   122ae:	4b1f      	ldr	r3, [pc, #124]	; (1232c <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   122b0:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   122b4:	430a      	orrs	r2, r1
   122b6:	60da      	str	r2, [r3, #12]
    tim_register[channel_]->TCR |= (1 << 0);
   122b8:	9b03      	ldr	r3, [sp, #12]
   122ba:	7a1b      	ldrb	r3, [r3, #8]
   122bc:	461a      	mov	r2, r3
   122be:	4b1b      	ldr	r3, [pc, #108]	; (1232c <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   122c0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   122c4:	685a      	ldr	r2, [r3, #4]
   122c6:	9b03      	ldr	r3, [sp, #12]
   122c8:	7a1b      	ldrb	r3, [r3, #8]
   122ca:	4619      	mov	r1, r3
   122cc:	4b17      	ldr	r3, [pc, #92]	; (1232c <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   122ce:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   122d2:	f042 0201 	orr.w	r2, r2, #1
   122d6:	605a      	str	r2, [r3, #4]
    user_timer_isr[channel_] = isr;
   122d8:	9b03      	ldr	r3, [sp, #12]
   122da:	7a1b      	ldrb	r3, [r3, #8]
   122dc:	4619      	mov	r1, r3
   122de:	4a14      	ldr	r2, [pc, #80]	; (12330 <Timer::Initialize(unsigned long, void (*)(), long)+0x128>)
   122e0:	9b01      	ldr	r3, [sp, #4]
   122e2:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    RegisterIsr(kTimerIrq[channel_], kTimerIsr[channel_], true, priority);
   122e6:	9b03      	ldr	r3, [sp, #12]
   122e8:	7a1b      	ldrb	r3, [r3, #8]
   122ea:	461a      	mov	r2, r3
   122ec:	4b11      	ldr	r3, [pc, #68]	; (12334 <Timer::Initialize(unsigned long, void (*)(), long)+0x12c>)
   122ee:	5698      	ldrsb	r0, [r3, r2]
   122f0:	9b03      	ldr	r3, [sp, #12]
   122f2:	7a1b      	ldrb	r3, [r3, #8]
   122f4:	461a      	mov	r2, r3
   122f6:	4b10      	ldr	r3, [pc, #64]	; (12338 <Timer::Initialize(unsigned long, void (*)(), long)+0x130>)
   122f8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   122fc:	9b00      	ldr	r3, [sp, #0]
   122fe:	2201      	movs	r2, #1
   12300:	f004 f9a4 	bl	1664c <RegisterIsr(IRQn, void (*)(), bool, long)>
   12304:	4623      	mov	r3, r4
   12306:	4619      	mov	r1, r3
   12308:	4802      	ldr	r0, [pc, #8]	; (12314 <Timer::Initialize(unsigned long, void (*)(), long)+0x10c>)
   1230a:	f004 fb07 	bl	1691c <__cyg_profile_func_exit>
  }
   1230e:	bf00      	nop
   12310:	b006      	add	sp, #24
   12312:	bd10      	pop	{r4, pc}
   12314:	00012209 	.word	0x00012209
   12318:	0001d47c 	.word	0x0001d47c
   1231c:	0001da78 	.word	0x0001da78
   12320:	0001d4a0 	.word	0x0001d4a0
   12324:	0001d0d0 	.word	0x0001d0d0
   12328:	0001cddc 	.word	0x0001cddc
   1232c:	10000004 	.word	0x10000004
   12330:	100007ac 	.word	0x100007ac
   12334:	0001d48c 	.word	0x0001d48c
   12338:	0001d490 	.word	0x0001d490

0001233c <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)>:
constexpr Type Value(Enum enum_type_value)
   1233c:	b530      	push	{r4, r5, lr}
   1233e:	b083      	sub	sp, #12
   12340:	4675      	mov	r5, lr
   12342:	4603      	mov	r3, r0
   12344:	f88d 3007 	strb.w	r3, [sp, #7]
   12348:	462b      	mov	r3, r5
   1234a:	4619      	mov	r1, r3
   1234c:	4806      	ldr	r0, [pc, #24]	; (12368 <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)+0x2c>)
   1234e:	f004 fad1 	bl	168f4 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   12352:	f89d 4007 	ldrb.w	r4, [sp, #7]
   12356:	462b      	mov	r3, r5
   12358:	4619      	mov	r1, r3
   1235a:	4803      	ldr	r0, [pc, #12]	; (12368 <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)+0x2c>)
   1235c:	f004 fade 	bl	1691c <__cyg_profile_func_exit>
   12360:	4623      	mov	r3, r4
}
   12362:	4618      	mov	r0, r3
   12364:	b003      	add	sp, #12
   12366:	bd30      	pop	{r4, r5, pc}
   12368:	0001233d 	.word	0x0001233d

0001236c <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)>:
  ///
  /// @param ticks the count of the timer register (TC) to have an ISR fire
  /// @param condition the condition for which a timer interrupt will occur
  /// @param match_register which match register (from 0 to 3) should be used
  ///                       for holding the ticks for the condition.
  void SetTimer(uint32_t ticks, TimerIsrCondition condition,
   1236c:	b570      	push	{r4, r5, r6, lr}
   1236e:	b086      	sub	sp, #24
   12370:	4676      	mov	r6, lr
   12372:	9003      	str	r0, [sp, #12]
   12374:	9102      	str	r1, [sp, #8]
   12376:	4611      	mov	r1, r2
   12378:	461a      	mov	r2, r3
   1237a:	460b      	mov	r3, r1
   1237c:	f88d 3007 	strb.w	r3, [sp, #7]
   12380:	4613      	mov	r3, r2
   12382:	f88d 3006 	strb.w	r3, [sp, #6]
   12386:	4633      	mov	r3, r6
   12388:	4619      	mov	r1, r3
   1238a:	4832      	ldr	r0, [pc, #200]	; (12454 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xe8>)
   1238c:	f004 fab2 	bl	168f4 <__cyg_profile_func_enter>
                MatchControlRegister match_register = kMat0) override final
  {
    static constexpr uint8_t kClearMode = 0b0111;

    uint8_t match_value = util::Value(match_register);
   12390:	f89d 3006 	ldrb.w	r3, [sp, #6]
   12394:	4618      	mov	r0, r3
   12396:	f7ff ffd1 	bl	1233c <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)>
   1239a:	4603      	mov	r3, r0
   1239c:	f88d 3017 	strb.w	r3, [sp, #23]
    tim_register[channel_]->MCR &= ~(kClearMode << match_value);
   123a0:	9b03      	ldr	r3, [sp, #12]
   123a2:	7a1b      	ldrb	r3, [r3, #8]
   123a4:	461a      	mov	r2, r3
   123a6:	4b2c      	ldr	r3, [pc, #176]	; (12458 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   123a8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   123ac:	695a      	ldr	r2, [r3, #20]
   123ae:	f89d 3017 	ldrb.w	r3, [sp, #23]
   123b2:	2107      	movs	r1, #7
   123b4:	fa01 f303 	lsl.w	r3, r1, r3
   123b8:	43db      	mvns	r3, r3
   123ba:	4619      	mov	r1, r3
   123bc:	9b03      	ldr	r3, [sp, #12]
   123be:	7a1b      	ldrb	r3, [r3, #8]
   123c0:	4618      	mov	r0, r3
   123c2:	4b25      	ldr	r3, [pc, #148]	; (12458 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   123c4:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   123c8:	400a      	ands	r2, r1
   123ca:	615a      	str	r2, [r3, #20]
    tim_register[channel_]->MCR |= condition << match_value;
   123cc:	9b03      	ldr	r3, [sp, #12]
   123ce:	7a1b      	ldrb	r3, [r3, #8]
   123d0:	461a      	mov	r2, r3
   123d2:	4b21      	ldr	r3, [pc, #132]	; (12458 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   123d4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   123d8:	695a      	ldr	r2, [r3, #20]
   123da:	f89d 1007 	ldrb.w	r1, [sp, #7]
   123de:	f89d 3017 	ldrb.w	r3, [sp, #23]
   123e2:	fa01 f303 	lsl.w	r3, r1, r3
   123e6:	4619      	mov	r1, r3
   123e8:	9b03      	ldr	r3, [sp, #12]
   123ea:	7a1b      	ldrb	r3, [r3, #8]
   123ec:	4618      	mov	r0, r3
   123ee:	4b1a      	ldr	r3, [pc, #104]	; (12458 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   123f0:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   123f4:	430a      	orrs	r2, r1
   123f6:	615a      	str	r2, [r3, #20]
    *match[channel_][match_value / 3] |= (((ticks / 2)) << 0);
   123f8:	9b03      	ldr	r3, [sp, #12]
   123fa:	7a1b      	ldrb	r3, [r3, #8]
   123fc:	4618      	mov	r0, r3
   123fe:	f89d 3017 	ldrb.w	r3, [sp, #23]
   12402:	4a16      	ldr	r2, [pc, #88]	; (1245c <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf0>)
   12404:	fba2 2303 	umull	r2, r3, r2, r3
   12408:	085b      	lsrs	r3, r3, #1
   1240a:	b2db      	uxtb	r3, r3
   1240c:	4619      	mov	r1, r3
   1240e:	4a14      	ldr	r2, [pc, #80]	; (12460 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf4>)
   12410:	0083      	lsls	r3, r0, #2
   12412:	440b      	add	r3, r1
   12414:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12418:	6819      	ldr	r1, [r3, #0]
   1241a:	9b02      	ldr	r3, [sp, #8]
   1241c:	085a      	lsrs	r2, r3, #1
   1241e:	9b03      	ldr	r3, [sp, #12]
   12420:	7a1b      	ldrb	r3, [r3, #8]
   12422:	461d      	mov	r5, r3
   12424:	f89d 3017 	ldrb.w	r3, [sp, #23]
   12428:	480c      	ldr	r0, [pc, #48]	; (1245c <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf0>)
   1242a:	fba0 0303 	umull	r0, r3, r0, r3
   1242e:	085b      	lsrs	r3, r3, #1
   12430:	b2db      	uxtb	r3, r3
   12432:	461c      	mov	r4, r3
   12434:	480a      	ldr	r0, [pc, #40]	; (12460 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf4>)
   12436:	00ab      	lsls	r3, r5, #2
   12438:	4423      	add	r3, r4
   1243a:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   1243e:	430a      	orrs	r2, r1
   12440:	601a      	str	r2, [r3, #0]
   12442:	4633      	mov	r3, r6
   12444:	4619      	mov	r1, r3
   12446:	4803      	ldr	r0, [pc, #12]	; (12454 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xe8>)
   12448:	f004 fa68 	bl	1691c <__cyg_profile_func_exit>
  }
   1244c:	bf00      	nop
   1244e:	b006      	add	sp, #24
   12450:	bd70      	pop	{r4, r5, r6, pc}
   12452:	bf00      	nop
   12454:	0001236d 	.word	0x0001236d
   12458:	10000004 	.word	0x10000004
   1245c:	aaaaaaab 	.word	0xaaaaaaab
   12460:	100006e8 	.word	0x100006e8

00012464 <Timer::GetTimer()>:

  [[gnu::always_inline]] uint32_t GetTimer() override final {
   12464:	b530      	push	{r4, r5, lr}
   12466:	b083      	sub	sp, #12
   12468:	4675      	mov	r5, lr
   1246a:	9001      	str	r0, [sp, #4]
   1246c:	462b      	mov	r3, r5
   1246e:	4619      	mov	r1, r3
   12470:	4809      	ldr	r0, [pc, #36]	; (12498 <Timer::GetTimer()+0x34>)
   12472:	f004 fa3f 	bl	168f4 <__cyg_profile_func_enter>
    return tim_register[channel_]->TC;
   12476:	9b01      	ldr	r3, [sp, #4]
   12478:	7a1b      	ldrb	r3, [r3, #8]
   1247a:	461a      	mov	r2, r3
   1247c:	4b07      	ldr	r3, [pc, #28]	; (1249c <Timer::GetTimer()+0x38>)
   1247e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12482:	689c      	ldr	r4, [r3, #8]
   12484:	462b      	mov	r3, r5
   12486:	4619      	mov	r1, r3
   12488:	4803      	ldr	r0, [pc, #12]	; (12498 <Timer::GetTimer()+0x34>)
   1248a:	f004 fa47 	bl	1691c <__cyg_profile_func_exit>
   1248e:	4623      	mov	r3, r4
  }
   12490:	4618      	mov	r0, r3
   12492:	b003      	add	sp, #12
   12494:	bd30      	pop	{r4, r5, pc}
   12496:	bf00      	nop
   12498:	00012465 	.word	0x00012465
   1249c:	10000004 	.word	0x10000004

000124a0 <GpioInterface::GpioInterface()>:
class GpioInterface
   124a0:	b530      	push	{r4, r5, lr}
   124a2:	b083      	sub	sp, #12
   124a4:	4675      	mov	r5, lr
   124a6:	9001      	str	r0, [sp, #4]
   124a8:	462b      	mov	r3, r5
   124aa:	4619      	mov	r1, r3
   124ac:	4807      	ldr	r0, [pc, #28]	; (124cc <GpioInterface::GpioInterface()+0x2c>)
   124ae:	f004 fa21 	bl	168f4 <__cyg_profile_func_enter>
   124b2:	4a07      	ldr	r2, [pc, #28]	; (124d0 <GpioInterface::GpioInterface()+0x30>)
   124b4:	9b01      	ldr	r3, [sp, #4]
   124b6:	601a      	str	r2, [r3, #0]
   124b8:	9c01      	ldr	r4, [sp, #4]
   124ba:	462b      	mov	r3, r5
   124bc:	4619      	mov	r1, r3
   124be:	4803      	ldr	r0, [pc, #12]	; (124cc <GpioInterface::GpioInterface()+0x2c>)
   124c0:	f004 fa2c 	bl	1691c <__cyg_profile_func_exit>
   124c4:	4623      	mov	r3, r4
   124c6:	4618      	mov	r0, r3
   124c8:	b003      	add	sp, #12
   124ca:	bd30      	pop	{r4, r5, pc}
   124cc:	000124a1 	.word	0x000124a1
   124d0:	0001d6a8 	.word	0x0001d6a8

000124d4 <Gpio::Gpio(unsigned char, unsigned char)>:
  constexpr Gpio(uint8_t port_number, uint8_t pin_number)
   124d4:	b530      	push	{r4, r5, lr}
   124d6:	b083      	sub	sp, #12
   124d8:	4675      	mov	r5, lr
   124da:	9001      	str	r0, [sp, #4]
   124dc:	460b      	mov	r3, r1
   124de:	f88d 3003 	strb.w	r3, [sp, #3]
   124e2:	4613      	mov	r3, r2
   124e4:	f88d 3002 	strb.w	r3, [sp, #2]
   124e8:	462b      	mov	r3, r5
   124ea:	4619      	mov	r1, r3
   124ec:	4816      	ldr	r0, [pc, #88]	; (12548 <Gpio::Gpio(unsigned char, unsigned char)+0x74>)
   124ee:	f004 fa01 	bl	168f4 <__cyg_profile_func_enter>
        lpc40xx_pin_(port_number, pin_number)
   124f2:	9b01      	ldr	r3, [sp, #4]
   124f4:	4618      	mov	r0, r3
   124f6:	f7ff ffd3 	bl	124a0 <GpioInterface::GpioInterface()>
   124fa:	4a14      	ldr	r2, [pc, #80]	; (1254c <Gpio::Gpio(unsigned char, unsigned char)+0x78>)
   124fc:	9b01      	ldr	r3, [sp, #4]
   124fe:	601a      	str	r2, [r3, #0]
   12500:	9b01      	ldr	r3, [sp, #4]
   12502:	2200      	movs	r2, #0
   12504:	711a      	strb	r2, [r3, #4]
   12506:	9b01      	ldr	r3, [sp, #4]
   12508:	f103 020c 	add.w	r2, r3, #12
   1250c:	9b01      	ldr	r3, [sp, #4]
   1250e:	609a      	str	r2, [r3, #8]
   12510:	9b01      	ldr	r3, [sp, #4]
   12512:	330c      	adds	r3, #12
   12514:	f89d 2002 	ldrb.w	r2, [sp, #2]
   12518:	f89d 1003 	ldrb.w	r1, [sp, #3]
   1251c:	4618      	mov	r0, r3
   1251e:	f7ff fb3f 	bl	11ba0 <Pin::Pin(unsigned char, unsigned char)>
    interupt_port_ = (port_number == 2) ? 1 : 0;
   12522:	f89d 3003 	ldrb.w	r3, [sp, #3]
   12526:	2b02      	cmp	r3, #2
   12528:	d101      	bne.n	1252e <Gpio::Gpio(unsigned char, unsigned char)+0x5a>
   1252a:	2201      	movs	r2, #1
   1252c:	e000      	b.n	12530 <Gpio::Gpio(unsigned char, unsigned char)+0x5c>
   1252e:	2200      	movs	r2, #0
   12530:	9b01      	ldr	r3, [sp, #4]
   12532:	711a      	strb	r2, [r3, #4]
  }
   12534:	9c01      	ldr	r4, [sp, #4]
   12536:	462b      	mov	r3, r5
   12538:	4619      	mov	r1, r3
   1253a:	4803      	ldr	r0, [pc, #12]	; (12548 <Gpio::Gpio(unsigned char, unsigned char)+0x74>)
   1253c:	f004 f9ee 	bl	1691c <__cyg_profile_func_exit>
   12540:	4623      	mov	r3, r4
   12542:	4618      	mov	r0, r3
   12544:	b003      	add	sp, #12
   12546:	bd30      	pop	{r4, r5, pc}
   12548:	000124d5 	.word	0x000124d5
   1254c:	0001d660 	.word	0x0001d660

00012550 <Gpio::SetAsInput()>:
  void SetAsInput(void) override
   12550:	b530      	push	{r4, r5, lr}
   12552:	b083      	sub	sp, #12
   12554:	4675      	mov	r5, lr
   12556:	9001      	str	r0, [sp, #4]
   12558:	462b      	mov	r3, r5
   1255a:	4619      	mov	r1, r3
   1255c:	4819      	ldr	r0, [pc, #100]	; (125c4 <Gpio::SetAsInput()+0x74>)
   1255e:	f004 f9c9 	bl	168f4 <__cyg_profile_func_enter>
    pin_->SetPinFunction(kGpioFunction);
   12562:	9b01      	ldr	r3, [sp, #4]
   12564:	689a      	ldr	r2, [r3, #8]
   12566:	9b01      	ldr	r3, [sp, #4]
   12568:	689b      	ldr	r3, [r3, #8]
   1256a:	681b      	ldr	r3, [r3, #0]
   1256c:	681b      	ldr	r3, [r3, #0]
   1256e:	2100      	movs	r1, #0
   12570:	4610      	mov	r0, r2
   12572:	4798      	blx	r3
    gpio_port[pin_->GetPort()]->DIR &= ~(1 << pin_->GetPin());
   12574:	9b01      	ldr	r3, [sp, #4]
   12576:	689a      	ldr	r2, [r3, #8]
   12578:	9b01      	ldr	r3, [sp, #4]
   1257a:	689b      	ldr	r3, [r3, #8]
   1257c:	681b      	ldr	r3, [r3, #0]
   1257e:	3330      	adds	r3, #48	; 0x30
   12580:	681b      	ldr	r3, [r3, #0]
   12582:	4610      	mov	r0, r2
   12584:	4798      	blx	r3
   12586:	4603      	mov	r3, r0
   12588:	461a      	mov	r2, r3
   1258a:	2301      	movs	r3, #1
   1258c:	4093      	lsls	r3, r2
   1258e:	43dc      	mvns	r4, r3
   12590:	9b01      	ldr	r3, [sp, #4]
   12592:	689a      	ldr	r2, [r3, #8]
   12594:	9b01      	ldr	r3, [sp, #4]
   12596:	689b      	ldr	r3, [r3, #8]
   12598:	681b      	ldr	r3, [r3, #0]
   1259a:	332c      	adds	r3, #44	; 0x2c
   1259c:	681b      	ldr	r3, [r3, #0]
   1259e:	4610      	mov	r0, r2
   125a0:	4798      	blx	r3
   125a2:	4603      	mov	r3, r0
   125a4:	461a      	mov	r2, r3
   125a6:	4b08      	ldr	r3, [pc, #32]	; (125c8 <Gpio::SetAsInput()+0x78>)
   125a8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   125ac:	681a      	ldr	r2, [r3, #0]
   125ae:	4621      	mov	r1, r4
   125b0:	400a      	ands	r2, r1
   125b2:	601a      	str	r2, [r3, #0]
   125b4:	462b      	mov	r3, r5
   125b6:	4619      	mov	r1, r3
   125b8:	4802      	ldr	r0, [pc, #8]	; (125c4 <Gpio::SetAsInput()+0x74>)
   125ba:	f004 f9af 	bl	1691c <__cyg_profile_func_exit>
  }
   125be:	bf00      	nop
   125c0:	b003      	add	sp, #12
   125c2:	bd30      	pop	{r4, r5, pc}
   125c4:	00012551 	.word	0x00012551
   125c8:	10000014 	.word	0x10000014

000125cc <Gpio::SetAsOutput()>:
  void SetAsOutput(void) override
   125cc:	b530      	push	{r4, r5, lr}
   125ce:	b083      	sub	sp, #12
   125d0:	4675      	mov	r5, lr
   125d2:	9001      	str	r0, [sp, #4]
   125d4:	462b      	mov	r3, r5
   125d6:	4619      	mov	r1, r3
   125d8:	4819      	ldr	r0, [pc, #100]	; (12640 <Gpio::SetAsOutput()+0x74>)
   125da:	f004 f98b 	bl	168f4 <__cyg_profile_func_enter>
    pin_->SetPinFunction(kGpioFunction);
   125de:	9b01      	ldr	r3, [sp, #4]
   125e0:	689a      	ldr	r2, [r3, #8]
   125e2:	9b01      	ldr	r3, [sp, #4]
   125e4:	689b      	ldr	r3, [r3, #8]
   125e6:	681b      	ldr	r3, [r3, #0]
   125e8:	681b      	ldr	r3, [r3, #0]
   125ea:	2100      	movs	r1, #0
   125ec:	4610      	mov	r0, r2
   125ee:	4798      	blx	r3
    gpio_port[pin_->GetPort()]->DIR |= (1 << pin_->GetPin());
   125f0:	9b01      	ldr	r3, [sp, #4]
   125f2:	689a      	ldr	r2, [r3, #8]
   125f4:	9b01      	ldr	r3, [sp, #4]
   125f6:	689b      	ldr	r3, [r3, #8]
   125f8:	681b      	ldr	r3, [r3, #0]
   125fa:	3330      	adds	r3, #48	; 0x30
   125fc:	681b      	ldr	r3, [r3, #0]
   125fe:	4610      	mov	r0, r2
   12600:	4798      	blx	r3
   12602:	4603      	mov	r3, r0
   12604:	461a      	mov	r2, r3
   12606:	2301      	movs	r3, #1
   12608:	fa03 f402 	lsl.w	r4, r3, r2
   1260c:	9b01      	ldr	r3, [sp, #4]
   1260e:	689a      	ldr	r2, [r3, #8]
   12610:	9b01      	ldr	r3, [sp, #4]
   12612:	689b      	ldr	r3, [r3, #8]
   12614:	681b      	ldr	r3, [r3, #0]
   12616:	332c      	adds	r3, #44	; 0x2c
   12618:	681b      	ldr	r3, [r3, #0]
   1261a:	4610      	mov	r0, r2
   1261c:	4798      	blx	r3
   1261e:	4603      	mov	r3, r0
   12620:	461a      	mov	r2, r3
   12622:	4b08      	ldr	r3, [pc, #32]	; (12644 <Gpio::SetAsOutput()+0x78>)
   12624:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12628:	681a      	ldr	r2, [r3, #0]
   1262a:	4621      	mov	r1, r4
   1262c:	430a      	orrs	r2, r1
   1262e:	601a      	str	r2, [r3, #0]
   12630:	462b      	mov	r3, r5
   12632:	4619      	mov	r1, r3
   12634:	4802      	ldr	r0, [pc, #8]	; (12640 <Gpio::SetAsOutput()+0x74>)
   12636:	f004 f971 	bl	1691c <__cyg_profile_func_exit>
  }
   1263a:	bf00      	nop
   1263c:	b003      	add	sp, #12
   1263e:	bd30      	pop	{r4, r5, pc}
   12640:	000125cd 	.word	0x000125cd
   12644:	10000014 	.word	0x10000014

00012648 <Gpio::SetDirection(GpioInterface::Direction)>:
  inline void SetDirection(Direction direction) override
   12648:	b510      	push	{r4, lr}
   1264a:	b082      	sub	sp, #8
   1264c:	4674      	mov	r4, lr
   1264e:	9001      	str	r0, [sp, #4]
   12650:	460b      	mov	r3, r1
   12652:	f88d 3003 	strb.w	r3, [sp, #3]
   12656:	4623      	mov	r3, r4
   12658:	4619      	mov	r1, r3
   1265a:	480b      	ldr	r0, [pc, #44]	; (12688 <Gpio::SetDirection(GpioInterface::Direction)+0x40>)
   1265c:	f004 f94a 	bl	168f4 <__cyg_profile_func_enter>
    (direction) ? SetAsOutput() : SetAsInput();
   12660:	f89d 3003 	ldrb.w	r3, [sp, #3]
   12664:	2b00      	cmp	r3, #0
   12666:	d003      	beq.n	12670 <Gpio::SetDirection(GpioInterface::Direction)+0x28>
   12668:	9801      	ldr	r0, [sp, #4]
   1266a:	f7ff ffaf 	bl	125cc <Gpio::SetAsOutput()>
   1266e:	e002      	b.n	12676 <Gpio::SetDirection(GpioInterface::Direction)+0x2e>
   12670:	9801      	ldr	r0, [sp, #4]
   12672:	f7ff ff6d 	bl	12550 <Gpio::SetAsInput()>
   12676:	4623      	mov	r3, r4
   12678:	4619      	mov	r1, r3
   1267a:	4803      	ldr	r0, [pc, #12]	; (12688 <Gpio::SetDirection(GpioInterface::Direction)+0x40>)
   1267c:	f004 f94e 	bl	1691c <__cyg_profile_func_exit>
  }
   12680:	bf00      	nop
   12682:	b002      	add	sp, #8
   12684:	bd10      	pop	{r4, pc}
   12686:	bf00      	nop
   12688:	00012649 	.word	0x00012649

0001268c <Gpio::Toggle()>:
  // Toggle the output of a GPIO output pin
  void Toggle() override
   1268c:	b530      	push	{r4, r5, lr}
   1268e:	b083      	sub	sp, #12
   12690:	4675      	mov	r5, lr
   12692:	9001      	str	r0, [sp, #4]
   12694:	462b      	mov	r3, r5
   12696:	4619      	mov	r1, r3
   12698:	4815      	ldr	r0, [pc, #84]	; (126f0 <Gpio::Toggle()+0x64>)
   1269a:	f004 f92b 	bl	168f4 <__cyg_profile_func_enter>
  {
    gpio_port[pin_->GetPort()]->PIN ^= (1 << pin_->GetPin());
   1269e:	9b01      	ldr	r3, [sp, #4]
   126a0:	689a      	ldr	r2, [r3, #8]
   126a2:	9b01      	ldr	r3, [sp, #4]
   126a4:	689b      	ldr	r3, [r3, #8]
   126a6:	681b      	ldr	r3, [r3, #0]
   126a8:	3330      	adds	r3, #48	; 0x30
   126aa:	681b      	ldr	r3, [r3, #0]
   126ac:	4610      	mov	r0, r2
   126ae:	4798      	blx	r3
   126b0:	4603      	mov	r3, r0
   126b2:	461a      	mov	r2, r3
   126b4:	2301      	movs	r3, #1
   126b6:	fa03 f402 	lsl.w	r4, r3, r2
   126ba:	9b01      	ldr	r3, [sp, #4]
   126bc:	689a      	ldr	r2, [r3, #8]
   126be:	9b01      	ldr	r3, [sp, #4]
   126c0:	689b      	ldr	r3, [r3, #8]
   126c2:	681b      	ldr	r3, [r3, #0]
   126c4:	332c      	adds	r3, #44	; 0x2c
   126c6:	681b      	ldr	r3, [r3, #0]
   126c8:	4610      	mov	r0, r2
   126ca:	4798      	blx	r3
   126cc:	4603      	mov	r3, r0
   126ce:	461a      	mov	r2, r3
   126d0:	4b08      	ldr	r3, [pc, #32]	; (126f4 <Gpio::Toggle()+0x68>)
   126d2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   126d6:	695a      	ldr	r2, [r3, #20]
   126d8:	4621      	mov	r1, r4
   126da:	404a      	eors	r2, r1
   126dc:	615a      	str	r2, [r3, #20]
   126de:	462b      	mov	r3, r5
   126e0:	4619      	mov	r1, r3
   126e2:	4803      	ldr	r0, [pc, #12]	; (126f0 <Gpio::Toggle()+0x64>)
   126e4:	f004 f91a 	bl	1691c <__cyg_profile_func_exit>
  }
   126e8:	bf00      	nop
   126ea:	b003      	add	sp, #12
   126ec:	bd30      	pop	{r4, r5, pc}
   126ee:	bf00      	nop
   126f0:	0001268d 	.word	0x0001268d
   126f4:	10000014 	.word	0x10000014

000126f8 <Gpio::ReadState()>:
  // Returns the current State state of the pin
  State ReadState(void) override
   126f8:	b530      	push	{r4, r5, lr}
   126fa:	b085      	sub	sp, #20
   126fc:	4675      	mov	r5, lr
   126fe:	9001      	str	r0, [sp, #4]
   12700:	462b      	mov	r3, r5
   12702:	4619      	mov	r1, r3
   12704:	4818      	ldr	r0, [pc, #96]	; (12768 <Gpio::ReadState()+0x70>)
   12706:	f004 f8f5 	bl	168f4 <__cyg_profile_func_enter>
  {
    bool state = (gpio_port[pin_->GetPort()]->PIN >> pin_->GetPin()) & 1;
   1270a:	9b01      	ldr	r3, [sp, #4]
   1270c:	689a      	ldr	r2, [r3, #8]
   1270e:	9b01      	ldr	r3, [sp, #4]
   12710:	689b      	ldr	r3, [r3, #8]
   12712:	681b      	ldr	r3, [r3, #0]
   12714:	332c      	adds	r3, #44	; 0x2c
   12716:	681b      	ldr	r3, [r3, #0]
   12718:	4610      	mov	r0, r2
   1271a:	4798      	blx	r3
   1271c:	4603      	mov	r3, r0
   1271e:	461a      	mov	r2, r3
   12720:	4b12      	ldr	r3, [pc, #72]	; (1276c <Gpio::ReadState()+0x74>)
   12722:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12726:	695c      	ldr	r4, [r3, #20]
   12728:	9b01      	ldr	r3, [sp, #4]
   1272a:	689a      	ldr	r2, [r3, #8]
   1272c:	9b01      	ldr	r3, [sp, #4]
   1272e:	689b      	ldr	r3, [r3, #8]
   12730:	681b      	ldr	r3, [r3, #0]
   12732:	3330      	adds	r3, #48	; 0x30
   12734:	681b      	ldr	r3, [r3, #0]
   12736:	4610      	mov	r0, r2
   12738:	4798      	blx	r3
   1273a:	4603      	mov	r3, r0
   1273c:	fa24 f303 	lsr.w	r3, r4, r3
   12740:	f003 0301 	and.w	r3, r3, #1
   12744:	2b00      	cmp	r3, #0
   12746:	bf14      	ite	ne
   12748:	2301      	movne	r3, #1
   1274a:	2300      	moveq	r3, #0
   1274c:	f88d 300f 	strb.w	r3, [sp, #15]
    return static_cast<State>(state);
   12750:	f89d 400f 	ldrb.w	r4, [sp, #15]
   12754:	462b      	mov	r3, r5
   12756:	4619      	mov	r1, r3
   12758:	4803      	ldr	r0, [pc, #12]	; (12768 <Gpio::ReadState()+0x70>)
   1275a:	f004 f8df 	bl	1691c <__cyg_profile_func_exit>
   1275e:	4623      	mov	r3, r4
  }
   12760:	4618      	mov	r0, r3
   12762:	b005      	add	sp, #20
   12764:	bd30      	pop	{r4, r5, pc}
   12766:	bf00      	nop
   12768:	000126f9 	.word	0x000126f9
   1276c:	10000014 	.word	0x10000014

00012770 <Gpio::Read()>:
  // Returns true if input or output pin is high
  bool Read(void) override
   12770:	b530      	push	{r4, r5, lr}
   12772:	b083      	sub	sp, #12
   12774:	4675      	mov	r5, lr
   12776:	9001      	str	r0, [sp, #4]
   12778:	462b      	mov	r3, r5
   1277a:	4619      	mov	r1, r3
   1277c:	4816      	ldr	r0, [pc, #88]	; (127d8 <Gpio::Read()+0x68>)
   1277e:	f004 f8b9 	bl	168f4 <__cyg_profile_func_enter>
  {
    return (gpio_port[pin_->GetPort()]->PIN >> pin_->GetPin()) & 1;
   12782:	9b01      	ldr	r3, [sp, #4]
   12784:	689a      	ldr	r2, [r3, #8]
   12786:	9b01      	ldr	r3, [sp, #4]
   12788:	689b      	ldr	r3, [r3, #8]
   1278a:	681b      	ldr	r3, [r3, #0]
   1278c:	332c      	adds	r3, #44	; 0x2c
   1278e:	681b      	ldr	r3, [r3, #0]
   12790:	4610      	mov	r0, r2
   12792:	4798      	blx	r3
   12794:	4603      	mov	r3, r0
   12796:	461a      	mov	r2, r3
   12798:	4b10      	ldr	r3, [pc, #64]	; (127dc <Gpio::Read()+0x6c>)
   1279a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1279e:	695c      	ldr	r4, [r3, #20]
   127a0:	9b01      	ldr	r3, [sp, #4]
   127a2:	689a      	ldr	r2, [r3, #8]
   127a4:	9b01      	ldr	r3, [sp, #4]
   127a6:	689b      	ldr	r3, [r3, #8]
   127a8:	681b      	ldr	r3, [r3, #0]
   127aa:	3330      	adds	r3, #48	; 0x30
   127ac:	681b      	ldr	r3, [r3, #0]
   127ae:	4610      	mov	r0, r2
   127b0:	4798      	blx	r3
   127b2:	4603      	mov	r3, r0
   127b4:	fa24 f303 	lsr.w	r3, r4, r3
   127b8:	f003 0301 	and.w	r3, r3, #1
   127bc:	2b00      	cmp	r3, #0
   127be:	bf14      	ite	ne
   127c0:	2301      	movne	r3, #1
   127c2:	2300      	moveq	r3, #0
   127c4:	b2dc      	uxtb	r4, r3
   127c6:	462b      	mov	r3, r5
   127c8:	4619      	mov	r1, r3
   127ca:	4803      	ldr	r0, [pc, #12]	; (127d8 <Gpio::Read()+0x68>)
   127cc:	f004 f8a6 	bl	1691c <__cyg_profile_func_exit>
   127d0:	4623      	mov	r3, r4
  }
   127d2:	4618      	mov	r0, r3
   127d4:	b003      	add	sp, #12
   127d6:	bd30      	pop	{r4, r5, pc}
   127d8:	00012771 	.word	0x00012771
   127dc:	10000014 	.word	0x10000014

000127e0 <Gpio::GetPin()>:
  PinInterface & GetPin() override
   127e0:	b530      	push	{r4, r5, lr}
   127e2:	b083      	sub	sp, #12
   127e4:	4675      	mov	r5, lr
   127e6:	9001      	str	r0, [sp, #4]
   127e8:	462b      	mov	r3, r5
   127ea:	4619      	mov	r1, r3
   127ec:	4806      	ldr	r0, [pc, #24]	; (12808 <Gpio::GetPin()+0x28>)
   127ee:	f004 f881 	bl	168f4 <__cyg_profile_func_enter>
  {
    return *pin_;
   127f2:	9b01      	ldr	r3, [sp, #4]
   127f4:	689c      	ldr	r4, [r3, #8]
   127f6:	462b      	mov	r3, r5
   127f8:	4619      	mov	r1, r3
   127fa:	4803      	ldr	r0, [pc, #12]	; (12808 <Gpio::GetPin()+0x28>)
   127fc:	f004 f88e 	bl	1691c <__cyg_profile_func_exit>
   12800:	4623      	mov	r3, r4
  }
   12802:	4618      	mov	r0, r3
   12804:	b003      	add	sp, #12
   12806:	bd30      	pop	{r4, r5, pc}
   12808:	000127e1 	.word	0x000127e1

0001280c <Gpio::ValidPortCheck()>:

  // Checks if the selected gpio port is valid for external interrupts.
  bool ValidPortCheck()
   1280c:	b530      	push	{r4, r5, lr}
   1280e:	b087      	sub	sp, #28
   12810:	4675      	mov	r5, lr
   12812:	9003      	str	r0, [sp, #12]
   12814:	462b      	mov	r3, r5
   12816:	4619      	mov	r1, r3
   12818:	4817      	ldr	r0, [pc, #92]	; (12878 <Gpio::ValidPortCheck()+0x6c>)
   1281a:	f004 f86b 	bl	168f4 <__cyg_profile_func_enter>
  {
    bool is_valid = (interupt_port_ <= 1);
   1281e:	9b03      	ldr	r3, [sp, #12]
   12820:	791b      	ldrb	r3, [r3, #4]
   12822:	2b01      	cmp	r3, #1
   12824:	bf94      	ite	ls
   12826:	2301      	movls	r3, #1
   12828:	2300      	movhi	r3, #0
   1282a:	b2db      	uxtb	r3, r3
   1282c:	f88d 3017 	strb.w	r3, [sp, #23]
    SJ2_ASSERT_WARNING(is_valid,
   12830:	f89d 3017 	ldrb.w	r3, [sp, #23]
   12834:	f083 0301 	eor.w	r3, r3, #1
   12838:	b2db      	uxtb	r3, r3
   1283a:	2b00      	cmp	r3, #0
   1283c:	d010      	beq.n	12860 <Gpio::ValidPortCheck()+0x54>
   1283e:	9b03      	ldr	r3, [sp, #12]
   12840:	689a      	ldr	r2, [r3, #8]
   12842:	9b03      	ldr	r3, [sp, #12]
   12844:	689b      	ldr	r3, [r3, #8]
   12846:	681b      	ldr	r3, [r3, #0]
   12848:	332c      	adds	r3, #44	; 0x2c
   1284a:	681b      	ldr	r3, [r3, #0]
   1284c:	4610      	mov	r0, r2
   1284e:	4798      	blx	r3
   12850:	4603      	mov	r3, r0
   12852:	9300      	str	r3, [sp, #0]
   12854:	23a6      	movs	r3, #166	; 0xa6
   12856:	4a09      	ldr	r2, [pc, #36]	; (1287c <Gpio::ValidPortCheck()+0x70>)
   12858:	4909      	ldr	r1, [pc, #36]	; (12880 <Gpio::ValidPortCheck()+0x74>)
   1285a:	480a      	ldr	r0, [pc, #40]	; (12884 <Gpio::ValidPortCheck()+0x78>)
   1285c:	f005 ffc0 	bl	187e0 <printf>
                       "Port %d cannot be used for External Interrupts. Need "
                       "to use GPIO on Port 0 or 2.",
                       pin_->GetPort());
    return is_valid;
   12860:	f89d 4017 	ldrb.w	r4, [sp, #23]
   12864:	462b      	mov	r3, r5
   12866:	4619      	mov	r1, r3
   12868:	4803      	ldr	r0, [pc, #12]	; (12878 <Gpio::ValidPortCheck()+0x6c>)
   1286a:	f004 f857 	bl	1691c <__cyg_profile_func_exit>
   1286e:	4623      	mov	r3, r4
  }
   12870:	4618      	mov	r0, r3
   12872:	b007      	add	sp, #28
   12874:	bd30      	pop	{r4, r5, pc}
   12876:	bf00      	nop
   12878:	0001280d 	.word	0x0001280d
   1287c:	0001d81c 	.word	0x0001d81c
   12880:	0001d4ac 	.word	0x0001d4ac
   12884:	0001d190 	.word	0x0001d190

00012888 <Gpio::SetInterruptRoutine(void (*)())>:

  // Assigns the developer's ISR function to the port/pin gpio instance.
  void SetInterruptRoutine(IsrPointer function) override
   12888:	b570      	push	{r4, r5, r6, lr}
   1288a:	b082      	sub	sp, #8
   1288c:	4676      	mov	r6, lr
   1288e:	9001      	str	r0, [sp, #4]
   12890:	9100      	str	r1, [sp, #0]
   12892:	4633      	mov	r3, r6
   12894:	4619      	mov	r1, r3
   12896:	4811      	ldr	r0, [pc, #68]	; (128dc <Gpio::SetInterruptRoutine(void (*)())+0x54>)
   12898:	f004 f82c 	bl	168f4 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   1289c:	9801      	ldr	r0, [sp, #4]
   1289e:	f7ff ffb5 	bl	1280c <Gpio::ValidPortCheck()>
    interrupthandlers[interupt_port_][pin_->GetPin()] = function;
   128a2:	9c00      	ldr	r4, [sp, #0]
   128a4:	9b01      	ldr	r3, [sp, #4]
   128a6:	791b      	ldrb	r3, [r3, #4]
   128a8:	461d      	mov	r5, r3
   128aa:	9b01      	ldr	r3, [sp, #4]
   128ac:	689a      	ldr	r2, [r3, #8]
   128ae:	9b01      	ldr	r3, [sp, #4]
   128b0:	689b      	ldr	r3, [r3, #8]
   128b2:	681b      	ldr	r3, [r3, #0]
   128b4:	3330      	adds	r3, #48	; 0x30
   128b6:	681b      	ldr	r3, [r3, #0]
   128b8:	4610      	mov	r0, r2
   128ba:	4798      	blx	r3
   128bc:	4603      	mov	r3, r0
   128be:	4619      	mov	r1, r3
   128c0:	4a07      	ldr	r2, [pc, #28]	; (128e0 <Gpio::SetInterruptRoutine(void (*)())+0x58>)
   128c2:	016b      	lsls	r3, r5, #5
   128c4:	440b      	add	r3, r1
   128c6:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
   128ca:	4633      	mov	r3, r6
   128cc:	4619      	mov	r1, r3
   128ce:	4803      	ldr	r0, [pc, #12]	; (128dc <Gpio::SetInterruptRoutine(void (*)())+0x54>)
   128d0:	f004 f824 	bl	1691c <__cyg_profile_func_exit>
  }
   128d4:	bf00      	nop
   128d6:	b002      	add	sp, #8
   128d8:	bd70      	pop	{r4, r5, r6, pc}
   128da:	bf00      	nop
   128dc:	00012889 	.word	0x00012889
   128e0:	100007bc 	.word	0x100007bc

000128e4 <Gpio::ClearInterruptRoutine()>:

  // Clears the developers ISR function from the port/pin gio instance.
  void ClearInterruptRoutine() override
   128e4:	b530      	push	{r4, r5, lr}
   128e6:	b083      	sub	sp, #12
   128e8:	4675      	mov	r5, lr
   128ea:	9001      	str	r0, [sp, #4]
   128ec:	462b      	mov	r3, r5
   128ee:	4619      	mov	r1, r3
   128f0:	480f      	ldr	r0, [pc, #60]	; (12930 <Gpio::ClearInterruptRoutine()+0x4c>)
   128f2:	f003 ffff 	bl	168f4 <__cyg_profile_func_enter>
  {
    interrupthandlers[interupt_port_][pin_->GetPin()] = nullptr;
   128f6:	9b01      	ldr	r3, [sp, #4]
   128f8:	791b      	ldrb	r3, [r3, #4]
   128fa:	461c      	mov	r4, r3
   128fc:	9b01      	ldr	r3, [sp, #4]
   128fe:	689a      	ldr	r2, [r3, #8]
   12900:	9b01      	ldr	r3, [sp, #4]
   12902:	689b      	ldr	r3, [r3, #8]
   12904:	681b      	ldr	r3, [r3, #0]
   12906:	3330      	adds	r3, #48	; 0x30
   12908:	681b      	ldr	r3, [r3, #0]
   1290a:	4610      	mov	r0, r2
   1290c:	4798      	blx	r3
   1290e:	4603      	mov	r3, r0
   12910:	4619      	mov	r1, r3
   12912:	4a08      	ldr	r2, [pc, #32]	; (12934 <Gpio::ClearInterruptRoutine()+0x50>)
   12914:	0163      	lsls	r3, r4, #5
   12916:	440b      	add	r3, r1
   12918:	2100      	movs	r1, #0
   1291a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
   1291e:	462b      	mov	r3, r5
   12920:	4619      	mov	r1, r3
   12922:	4803      	ldr	r0, [pc, #12]	; (12930 <Gpio::ClearInterruptRoutine()+0x4c>)
   12924:	f003 fffa 	bl	1691c <__cyg_profile_func_exit>
  }
   12928:	bf00      	nop
   1292a:	b003      	add	sp, #12
   1292c:	bd30      	pop	{r4, r5, pc}
   1292e:	bf00      	nop
   12930:	000128e5 	.word	0x000128e5
   12934:	100007bc 	.word	0x100007bc

00012938 <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)>:
constexpr Type Value(Enum enum_type_value)
   12938:	b530      	push	{r4, r5, lr}
   1293a:	b083      	sub	sp, #12
   1293c:	4675      	mov	r5, lr
   1293e:	4603      	mov	r3, r0
   12940:	f88d 3007 	strb.w	r3, [sp, #7]
   12944:	462b      	mov	r3, r5
   12946:	4619      	mov	r1, r3
   12948:	4806      	ldr	r0, [pc, #24]	; (12964 <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)+0x2c>)
   1294a:	f003 ffd3 	bl	168f4 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   1294e:	f89d 4007 	ldrb.w	r4, [sp, #7]
   12952:	462b      	mov	r3, r5
   12954:	4619      	mov	r1, r3
   12956:	4803      	ldr	r0, [pc, #12]	; (12964 <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)+0x2c>)
   12958:	f003 ffe0 	bl	1691c <__cyg_profile_func_exit>
   1295c:	4623      	mov	r3, r4
}
   1295e:	4618      	mov	r0, r3
   12960:	b003      	add	sp, #12
   12962:	bd30      	pop	{r4, r5, pc}
   12964:	00012939 	.word	0x00012939

00012968 <Gpio::SetInterruptEdge(GpioInterface::Edge)>:

  // Sets the selected edge that the gpio interrupt will be triggered on.
  void SetInterruptEdge(Edge edge) override
   12968:	b510      	push	{r4, lr}
   1296a:	b084      	sub	sp, #16
   1296c:	4674      	mov	r4, lr
   1296e:	9003      	str	r0, [sp, #12]
   12970:	460b      	mov	r3, r1
   12972:	f88d 300b 	strb.w	r3, [sp, #11]
   12976:	4623      	mov	r3, r4
   12978:	4619      	mov	r1, r3
   1297a:	4819      	ldr	r0, [pc, #100]	; (129e0 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x78>)
   1297c:	f003 ffba 	bl	168f4 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   12980:	9803      	ldr	r0, [sp, #12]
   12982:	f7ff ff43 	bl	1280c <Gpio::ValidPortCheck()>
    switch (edge)
   12986:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1298a:	2b01      	cmp	r3, #1
   1298c:	d008      	beq.n	129a0 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x38>
   1298e:	2b01      	cmp	r3, #1
   12990:	d302      	bcc.n	12998 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x30>
   12992:	2b02      	cmp	r3, #2
   12994:	d008      	beq.n	129a8 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x40>
   12996:	e00e      	b.n	129b6 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x4e>
    {
      case Edge::kEdgeRising:
      {
        SetEdgeRising();
   12998:	9803      	ldr	r0, [sp, #12]
   1299a:	f000 f8b1 	bl	12b00 <Gpio::SetEdgeRising()>
        break;
   1299e:	e017      	b.n	129d0 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeFalling:
      {
        SetEdgeFalling();
   129a0:	9803      	ldr	r0, [sp, #12]
   129a2:	f000 f8eb 	bl	12b7c <Gpio::SetEdgeFalling()>
        break;
   129a6:	e013      	b.n	129d0 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeBoth:
      {
        SetEdgeRising();
   129a8:	9803      	ldr	r0, [sp, #12]
   129aa:	f000 f8a9 	bl	12b00 <Gpio::SetEdgeRising()>
        SetEdgeFalling();
   129ae:	9803      	ldr	r0, [sp, #12]
   129b0:	f000 f8e4 	bl	12b7c <Gpio::SetEdgeFalling()>
        break;
   129b4:	e00c      	b.n	129d0 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x68>
      }
      default:
      {
        LOG_WARNING(
   129b6:	f89d 300b 	ldrb.w	r3, [sp, #11]
   129ba:	4618      	mov	r0, r3
   129bc:	f7ff ffbc 	bl	12938 <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)>
   129c0:	4603      	mov	r3, r0
   129c2:	9300      	str	r3, [sp, #0]
   129c4:	23d2      	movs	r3, #210	; 0xd2
   129c6:	4a07      	ldr	r2, [pc, #28]	; (129e4 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x7c>)
   129c8:	4907      	ldr	r1, [pc, #28]	; (129e8 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x80>)
   129ca:	4808      	ldr	r0, [pc, #32]	; (129ec <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x84>)
   129cc:	f005 ff08 	bl	187e0 <printf>
   129d0:	4623      	mov	r3, r4
   129d2:	4619      	mov	r1, r3
   129d4:	4802      	ldr	r0, [pc, #8]	; (129e0 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x78>)
   129d6:	f003 ffa1 	bl	1691c <__cyg_profile_func_exit>
            "Edge %d cannot be used for External Interrupts."
            "Need to use a rising, falling, or both configuration.",
            util::Value(edge));
      }
    }
  }
   129da:	bf00      	nop
   129dc:	b004      	add	sp, #16
   129de:	bd10      	pop	{r4, pc}
   129e0:	00012969 	.word	0x00012969
   129e4:	0001d838 	.word	0x0001d838
   129e8:	0001d4b8 	.word	0x0001d4b8
   129ec:	0001d220 	.word	0x0001d220

000129f0 <Gpio::ClearInterruptEdge(GpioInterface::Edge)>:

  // Clears the seleted edge of the gpio interrupt from being triggered.
  void ClearInterruptEdge(Edge edge) override
   129f0:	b510      	push	{r4, lr}
   129f2:	b084      	sub	sp, #16
   129f4:	4674      	mov	r4, lr
   129f6:	9003      	str	r0, [sp, #12]
   129f8:	460b      	mov	r3, r1
   129fa:	f88d 300b 	strb.w	r3, [sp, #11]
   129fe:	4623      	mov	r3, r4
   12a00:	4619      	mov	r1, r3
   12a02:	4819      	ldr	r0, [pc, #100]	; (12a68 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x78>)
   12a04:	f003 ff76 	bl	168f4 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   12a08:	9803      	ldr	r0, [sp, #12]
   12a0a:	f7ff feff 	bl	1280c <Gpio::ValidPortCheck()>
    switch (edge)
   12a0e:	f89d 300b 	ldrb.w	r3, [sp, #11]
   12a12:	2b01      	cmp	r3, #1
   12a14:	d008      	beq.n	12a28 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x38>
   12a16:	2b01      	cmp	r3, #1
   12a18:	d302      	bcc.n	12a20 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x30>
   12a1a:	2b02      	cmp	r3, #2
   12a1c:	d008      	beq.n	12a30 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x40>
   12a1e:	e00e      	b.n	12a3e <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x4e>
    {
      case Edge::kEdgeRising:
      {
        ClearEdgeRising();
   12a20:	9803      	ldr	r0, [sp, #12]
   12a22:	f000 f8e9 	bl	12bf8 <Gpio::ClearEdgeRising()>
        break;
   12a26:	e017      	b.n	12a58 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeFalling:
      {
        ClearEdgeFalling();
   12a28:	9803      	ldr	r0, [sp, #12]
   12a2a:	f000 f923 	bl	12c74 <Gpio::ClearEdgeFalling()>
        break;
   12a2e:	e013      	b.n	12a58 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeBoth:
      {
        ClearEdgeRising();
   12a30:	9803      	ldr	r0, [sp, #12]
   12a32:	f000 f8e1 	bl	12bf8 <Gpio::ClearEdgeRising()>
        ClearEdgeFalling();
   12a36:	9803      	ldr	r0, [sp, #12]
   12a38:	f000 f91c 	bl	12c74 <Gpio::ClearEdgeFalling()>
        break;
   12a3c:	e00c      	b.n	12a58 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x68>
      }
      default:
      {
        LOG_WARNING(
   12a3e:	f89d 300b 	ldrb.w	r3, [sp, #11]
   12a42:	4618      	mov	r0, r3
   12a44:	f7ff ff78 	bl	12938 <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)>
   12a48:	4603      	mov	r3, r0
   12a4a:	9300      	str	r3, [sp, #0]
   12a4c:	23f2      	movs	r3, #242	; 0xf2
   12a4e:	4a07      	ldr	r2, [pc, #28]	; (12a6c <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x7c>)
   12a50:	4907      	ldr	r1, [pc, #28]	; (12a70 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x80>)
   12a52:	4808      	ldr	r0, [pc, #32]	; (12a74 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x84>)
   12a54:	f005 fec4 	bl	187e0 <printf>
   12a58:	4623      	mov	r3, r4
   12a5a:	4619      	mov	r1, r3
   12a5c:	4802      	ldr	r0, [pc, #8]	; (12a68 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x78>)
   12a5e:	f003 ff5d 	bl	1691c <__cyg_profile_func_exit>
            "Edge %d cannot be used for External Interrupts."
            "Need to use a rising, falling, or both configuration.",
           util::Value(edge));
      }
    }
  }
   12a62:	bf00      	nop
   12a64:	b004      	add	sp, #16
   12a66:	bd10      	pop	{r4, pc}
   12a68:	000129f1 	.word	0x000129f1
   12a6c:	0001d7e0 	.word	0x0001d7e0
   12a70:	0001d4c4 	.word	0x0001d4c4
   12a74:	0001d220 	.word	0x0001d220

00012a78 <Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)>:

  // Assign the developer's ISR and sets the selected edge that the gpio
  // interrupt will be triggered on.
  void AttachInterrupt(IsrPointer function, Edge edge) override
   12a78:	b510      	push	{r4, lr}
   12a7a:	b084      	sub	sp, #16
   12a7c:	4674      	mov	r4, lr
   12a7e:	9003      	str	r0, [sp, #12]
   12a80:	9102      	str	r1, [sp, #8]
   12a82:	4613      	mov	r3, r2
   12a84:	f88d 3007 	strb.w	r3, [sp, #7]
   12a88:	4623      	mov	r3, r4
   12a8a:	4619      	mov	r1, r3
   12a8c:	480b      	ldr	r0, [pc, #44]	; (12abc <Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)+0x44>)
   12a8e:	f003 ff31 	bl	168f4 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   12a92:	9803      	ldr	r0, [sp, #12]
   12a94:	f7ff feba 	bl	1280c <Gpio::ValidPortCheck()>
    SetInterruptRoutine(function);
   12a98:	9902      	ldr	r1, [sp, #8]
   12a9a:	9803      	ldr	r0, [sp, #12]
   12a9c:	f7ff fef4 	bl	12888 <Gpio::SetInterruptRoutine(void (*)())>
    SetInterruptEdge(edge);
   12aa0:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12aa4:	4619      	mov	r1, r3
   12aa6:	9803      	ldr	r0, [sp, #12]
   12aa8:	f7ff ff5e 	bl	12968 <Gpio::SetInterruptEdge(GpioInterface::Edge)>
   12aac:	4623      	mov	r3, r4
   12aae:	4619      	mov	r1, r3
   12ab0:	4802      	ldr	r0, [pc, #8]	; (12abc <Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)+0x44>)
   12ab2:	f003 ff33 	bl	1691c <__cyg_profile_func_exit>
  }
   12ab6:	bf00      	nop
   12ab8:	b004      	add	sp, #16
   12aba:	bd10      	pop	{r4, pc}
   12abc:	00012a79 	.word	0x00012a79

00012ac0 <Gpio::DetachInterrupt()>:

  // Removes the developer's ISR and clears the selected edge of the gpio
  // interrupt from being triggered.
  void DetachInterrupt() override
   12ac0:	b510      	push	{r4, lr}
   12ac2:	b082      	sub	sp, #8
   12ac4:	4674      	mov	r4, lr
   12ac6:	9001      	str	r0, [sp, #4]
   12ac8:	4623      	mov	r3, r4
   12aca:	4619      	mov	r1, r3
   12acc:	480b      	ldr	r0, [pc, #44]	; (12afc <Gpio::DetachInterrupt()+0x3c>)
   12ace:	f003 ff11 	bl	168f4 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   12ad2:	9801      	ldr	r0, [sp, #4]
   12ad4:	f7ff fe9a 	bl	1280c <Gpio::ValidPortCheck()>
    ClearInterruptRoutine();
   12ad8:	9801      	ldr	r0, [sp, #4]
   12ada:	f7ff ff03 	bl	128e4 <Gpio::ClearInterruptRoutine()>
    ClearEdgeRising();
   12ade:	9801      	ldr	r0, [sp, #4]
   12ae0:	f000 f88a 	bl	12bf8 <Gpio::ClearEdgeRising()>
    ClearEdgeFalling();
   12ae4:	9801      	ldr	r0, [sp, #4]
   12ae6:	f000 f8c5 	bl	12c74 <Gpio::ClearEdgeFalling()>
   12aea:	4623      	mov	r3, r4
   12aec:	4619      	mov	r1, r3
   12aee:	4803      	ldr	r0, [pc, #12]	; (12afc <Gpio::DetachInterrupt()+0x3c>)
   12af0:	f003 ff14 	bl	1691c <__cyg_profile_func_exit>
  }
   12af4:	bf00      	nop
   12af6:	b002      	add	sp, #8
   12af8:	bd10      	pop	{r4, pc}
   12afa:	bf00      	nop
   12afc:	00012ac1 	.word	0x00012ac1

00012b00 <Gpio::SetEdgeRising()>:
    *interrupt[triggered_port].clear |= (1 << triggered_pin);
  }

 private:
  // Sets the gpio interrupt to trigger on a rising edge.
  void SetEdgeRising()
   12b00:	b530      	push	{r4, r5, lr}
   12b02:	b083      	sub	sp, #12
   12b04:	4675      	mov	r5, lr
   12b06:	9001      	str	r0, [sp, #4]
   12b08:	462b      	mov	r3, r5
   12b0a:	4619      	mov	r1, r3
   12b0c:	4819      	ldr	r0, [pc, #100]	; (12b74 <Gpio::SetEdgeRising()+0x74>)
   12b0e:	f003 fef1 	bl	168f4 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_rising_edge |= (1 << pin_->GetPin());
   12b12:	9b01      	ldr	r3, [sp, #4]
   12b14:	689a      	ldr	r2, [r3, #8]
   12b16:	9b01      	ldr	r3, [sp, #4]
   12b18:	689b      	ldr	r3, [r3, #8]
   12b1a:	681b      	ldr	r3, [r3, #0]
   12b1c:	3330      	adds	r3, #48	; 0x30
   12b1e:	681b      	ldr	r3, [r3, #0]
   12b20:	4610      	mov	r0, r2
   12b22:	4798      	blx	r3
   12b24:	4603      	mov	r3, r0
   12b26:	461a      	mov	r2, r3
   12b28:	2301      	movs	r3, #1
   12b2a:	fa03 f002 	lsl.w	r0, r3, r2
   12b2e:	9b01      	ldr	r3, [sp, #4]
   12b30:	791b      	ldrb	r3, [r3, #4]
   12b32:	4619      	mov	r1, r3
   12b34:	4a10      	ldr	r2, [pc, #64]	; (12b78 <Gpio::SetEdgeRising()+0x78>)
   12b36:	460b      	mov	r3, r1
   12b38:	009b      	lsls	r3, r3, #2
   12b3a:	440b      	add	r3, r1
   12b3c:	009b      	lsls	r3, r3, #2
   12b3e:	4413      	add	r3, r2
   12b40:	330c      	adds	r3, #12
   12b42:	681b      	ldr	r3, [r3, #0]
   12b44:	681a      	ldr	r2, [r3, #0]
   12b46:	4604      	mov	r4, r0
   12b48:	9b01      	ldr	r3, [sp, #4]
   12b4a:	791b      	ldrb	r3, [r3, #4]
   12b4c:	4618      	mov	r0, r3
   12b4e:	490a      	ldr	r1, [pc, #40]	; (12b78 <Gpio::SetEdgeRising()+0x78>)
   12b50:	4603      	mov	r3, r0
   12b52:	009b      	lsls	r3, r3, #2
   12b54:	4403      	add	r3, r0
   12b56:	009b      	lsls	r3, r3, #2
   12b58:	440b      	add	r3, r1
   12b5a:	330c      	adds	r3, #12
   12b5c:	681b      	ldr	r3, [r3, #0]
   12b5e:	4322      	orrs	r2, r4
   12b60:	601a      	str	r2, [r3, #0]
   12b62:	462b      	mov	r3, r5
   12b64:	4619      	mov	r1, r3
   12b66:	4803      	ldr	r0, [pc, #12]	; (12b74 <Gpio::SetEdgeRising()+0x74>)
   12b68:	f003 fed8 	bl	1691c <__cyg_profile_func_exit>
  }
   12b6c:	bf00      	nop
   12b6e:	b003      	add	sp, #12
   12b70:	bd30      	pop	{r4, r5, pc}
   12b72:	bf00      	nop
   12b74:	00012b01 	.word	0x00012b01
   12b78:	10000050 	.word	0x10000050

00012b7c <Gpio::SetEdgeFalling()>:

  // Sets the gpio interrupt to trigger on a falling edge.
  void SetEdgeFalling()
   12b7c:	b530      	push	{r4, r5, lr}
   12b7e:	b083      	sub	sp, #12
   12b80:	4675      	mov	r5, lr
   12b82:	9001      	str	r0, [sp, #4]
   12b84:	462b      	mov	r3, r5
   12b86:	4619      	mov	r1, r3
   12b88:	4819      	ldr	r0, [pc, #100]	; (12bf0 <Gpio::SetEdgeFalling()+0x74>)
   12b8a:	f003 feb3 	bl	168f4 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_falling_edge |= (1 << pin_->GetPin());
   12b8e:	9b01      	ldr	r3, [sp, #4]
   12b90:	689a      	ldr	r2, [r3, #8]
   12b92:	9b01      	ldr	r3, [sp, #4]
   12b94:	689b      	ldr	r3, [r3, #8]
   12b96:	681b      	ldr	r3, [r3, #0]
   12b98:	3330      	adds	r3, #48	; 0x30
   12b9a:	681b      	ldr	r3, [r3, #0]
   12b9c:	4610      	mov	r0, r2
   12b9e:	4798      	blx	r3
   12ba0:	4603      	mov	r3, r0
   12ba2:	461a      	mov	r2, r3
   12ba4:	2301      	movs	r3, #1
   12ba6:	fa03 f002 	lsl.w	r0, r3, r2
   12baa:	9b01      	ldr	r3, [sp, #4]
   12bac:	791b      	ldrb	r3, [r3, #4]
   12bae:	4619      	mov	r1, r3
   12bb0:	4a10      	ldr	r2, [pc, #64]	; (12bf4 <Gpio::SetEdgeFalling()+0x78>)
   12bb2:	460b      	mov	r3, r1
   12bb4:	009b      	lsls	r3, r3, #2
   12bb6:	440b      	add	r3, r1
   12bb8:	009b      	lsls	r3, r3, #2
   12bba:	4413      	add	r3, r2
   12bbc:	3310      	adds	r3, #16
   12bbe:	681b      	ldr	r3, [r3, #0]
   12bc0:	681a      	ldr	r2, [r3, #0]
   12bc2:	4604      	mov	r4, r0
   12bc4:	9b01      	ldr	r3, [sp, #4]
   12bc6:	791b      	ldrb	r3, [r3, #4]
   12bc8:	4618      	mov	r0, r3
   12bca:	490a      	ldr	r1, [pc, #40]	; (12bf4 <Gpio::SetEdgeFalling()+0x78>)
   12bcc:	4603      	mov	r3, r0
   12bce:	009b      	lsls	r3, r3, #2
   12bd0:	4403      	add	r3, r0
   12bd2:	009b      	lsls	r3, r3, #2
   12bd4:	440b      	add	r3, r1
   12bd6:	3310      	adds	r3, #16
   12bd8:	681b      	ldr	r3, [r3, #0]
   12bda:	4322      	orrs	r2, r4
   12bdc:	601a      	str	r2, [r3, #0]
   12bde:	462b      	mov	r3, r5
   12be0:	4619      	mov	r1, r3
   12be2:	4803      	ldr	r0, [pc, #12]	; (12bf0 <Gpio::SetEdgeFalling()+0x74>)
   12be4:	f003 fe9a 	bl	1691c <__cyg_profile_func_exit>
  }
   12be8:	bf00      	nop
   12bea:	b003      	add	sp, #12
   12bec:	bd30      	pop	{r4, r5, pc}
   12bee:	bf00      	nop
   12bf0:	00012b7d 	.word	0x00012b7d
   12bf4:	10000050 	.word	0x10000050

00012bf8 <Gpio::ClearEdgeRising()>:

  // Clears the gpio interrupt to no longer trigger on a rising edge.
  void ClearEdgeRising()
   12bf8:	b530      	push	{r4, r5, lr}
   12bfa:	b083      	sub	sp, #12
   12bfc:	4675      	mov	r5, lr
   12bfe:	9001      	str	r0, [sp, #4]
   12c00:	462b      	mov	r3, r5
   12c02:	4619      	mov	r1, r3
   12c04:	4819      	ldr	r0, [pc, #100]	; (12c6c <Gpio::ClearEdgeRising()+0x74>)
   12c06:	f003 fe75 	bl	168f4 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_rising_edge &= ~(1 << pin_->GetPin());
   12c0a:	9b01      	ldr	r3, [sp, #4]
   12c0c:	689a      	ldr	r2, [r3, #8]
   12c0e:	9b01      	ldr	r3, [sp, #4]
   12c10:	689b      	ldr	r3, [r3, #8]
   12c12:	681b      	ldr	r3, [r3, #0]
   12c14:	3330      	adds	r3, #48	; 0x30
   12c16:	681b      	ldr	r3, [r3, #0]
   12c18:	4610      	mov	r0, r2
   12c1a:	4798      	blx	r3
   12c1c:	4603      	mov	r3, r0
   12c1e:	461a      	mov	r2, r3
   12c20:	2301      	movs	r3, #1
   12c22:	4093      	lsls	r3, r2
   12c24:	43d8      	mvns	r0, r3
   12c26:	9b01      	ldr	r3, [sp, #4]
   12c28:	791b      	ldrb	r3, [r3, #4]
   12c2a:	4619      	mov	r1, r3
   12c2c:	4a10      	ldr	r2, [pc, #64]	; (12c70 <Gpio::ClearEdgeRising()+0x78>)
   12c2e:	460b      	mov	r3, r1
   12c30:	009b      	lsls	r3, r3, #2
   12c32:	440b      	add	r3, r1
   12c34:	009b      	lsls	r3, r3, #2
   12c36:	4413      	add	r3, r2
   12c38:	330c      	adds	r3, #12
   12c3a:	681b      	ldr	r3, [r3, #0]
   12c3c:	681a      	ldr	r2, [r3, #0]
   12c3e:	4604      	mov	r4, r0
   12c40:	9b01      	ldr	r3, [sp, #4]
   12c42:	791b      	ldrb	r3, [r3, #4]
   12c44:	4618      	mov	r0, r3
   12c46:	490a      	ldr	r1, [pc, #40]	; (12c70 <Gpio::ClearEdgeRising()+0x78>)
   12c48:	4603      	mov	r3, r0
   12c4a:	009b      	lsls	r3, r3, #2
   12c4c:	4403      	add	r3, r0
   12c4e:	009b      	lsls	r3, r3, #2
   12c50:	440b      	add	r3, r1
   12c52:	330c      	adds	r3, #12
   12c54:	681b      	ldr	r3, [r3, #0]
   12c56:	4022      	ands	r2, r4
   12c58:	601a      	str	r2, [r3, #0]
   12c5a:	462b      	mov	r3, r5
   12c5c:	4619      	mov	r1, r3
   12c5e:	4803      	ldr	r0, [pc, #12]	; (12c6c <Gpio::ClearEdgeRising()+0x74>)
   12c60:	f003 fe5c 	bl	1691c <__cyg_profile_func_exit>
  }
   12c64:	bf00      	nop
   12c66:	b003      	add	sp, #12
   12c68:	bd30      	pop	{r4, r5, pc}
   12c6a:	bf00      	nop
   12c6c:	00012bf9 	.word	0x00012bf9
   12c70:	10000050 	.word	0x10000050

00012c74 <Gpio::ClearEdgeFalling()>:

  // Clears the gpio interrupt to no longer trigger on a falling edge.
  void ClearEdgeFalling()
   12c74:	b530      	push	{r4, r5, lr}
   12c76:	b083      	sub	sp, #12
   12c78:	4675      	mov	r5, lr
   12c7a:	9001      	str	r0, [sp, #4]
   12c7c:	462b      	mov	r3, r5
   12c7e:	4619      	mov	r1, r3
   12c80:	4819      	ldr	r0, [pc, #100]	; (12ce8 <Gpio::ClearEdgeFalling()+0x74>)
   12c82:	f003 fe37 	bl	168f4 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_falling_edge &= ~(1 << pin_->GetPin());
   12c86:	9b01      	ldr	r3, [sp, #4]
   12c88:	689a      	ldr	r2, [r3, #8]
   12c8a:	9b01      	ldr	r3, [sp, #4]
   12c8c:	689b      	ldr	r3, [r3, #8]
   12c8e:	681b      	ldr	r3, [r3, #0]
   12c90:	3330      	adds	r3, #48	; 0x30
   12c92:	681b      	ldr	r3, [r3, #0]
   12c94:	4610      	mov	r0, r2
   12c96:	4798      	blx	r3
   12c98:	4603      	mov	r3, r0
   12c9a:	461a      	mov	r2, r3
   12c9c:	2301      	movs	r3, #1
   12c9e:	4093      	lsls	r3, r2
   12ca0:	43d8      	mvns	r0, r3
   12ca2:	9b01      	ldr	r3, [sp, #4]
   12ca4:	791b      	ldrb	r3, [r3, #4]
   12ca6:	4619      	mov	r1, r3
   12ca8:	4a10      	ldr	r2, [pc, #64]	; (12cec <Gpio::ClearEdgeFalling()+0x78>)
   12caa:	460b      	mov	r3, r1
   12cac:	009b      	lsls	r3, r3, #2
   12cae:	440b      	add	r3, r1
   12cb0:	009b      	lsls	r3, r3, #2
   12cb2:	4413      	add	r3, r2
   12cb4:	3310      	adds	r3, #16
   12cb6:	681b      	ldr	r3, [r3, #0]
   12cb8:	681a      	ldr	r2, [r3, #0]
   12cba:	4604      	mov	r4, r0
   12cbc:	9b01      	ldr	r3, [sp, #4]
   12cbe:	791b      	ldrb	r3, [r3, #4]
   12cc0:	4618      	mov	r0, r3
   12cc2:	490a      	ldr	r1, [pc, #40]	; (12cec <Gpio::ClearEdgeFalling()+0x78>)
   12cc4:	4603      	mov	r3, r0
   12cc6:	009b      	lsls	r3, r3, #2
   12cc8:	4403      	add	r3, r0
   12cca:	009b      	lsls	r3, r3, #2
   12ccc:	440b      	add	r3, r1
   12cce:	3310      	adds	r3, #16
   12cd0:	681b      	ldr	r3, [r3, #0]
   12cd2:	4022      	ands	r2, r4
   12cd4:	601a      	str	r2, [r3, #0]
   12cd6:	462b      	mov	r3, r5
   12cd8:	4619      	mov	r1, r3
   12cda:	4803      	ldr	r0, [pc, #12]	; (12ce8 <Gpio::ClearEdgeFalling()+0x74>)
   12cdc:	f003 fe1e 	bl	1691c <__cyg_profile_func_exit>
  }
   12ce0:	bf00      	nop
   12ce2:	b003      	add	sp, #12
   12ce4:	bd30      	pop	{r4, r5, pc}
   12ce6:	bf00      	nop
   12ce8:	00012c75 	.word	0x00012c75
   12cec:	10000050 	.word	0x10000050

00012cf0 <OnBoardLed::Initialize()>:
class OnBoardLed : public OnBoardLedInterface
{
 public:
  // Initialize takes the array of Gpios, sets each one to an output, and
  // then turns off all of the leds by setting the output high.
  void Initialize(void) override
   12cf0:	b510      	push	{r4, lr}
   12cf2:	b084      	sub	sp, #16
   12cf4:	4674      	mov	r4, lr
   12cf6:	9001      	str	r0, [sp, #4]
   12cf8:	4623      	mov	r3, r4
   12cfa:	4619      	mov	r1, r3
   12cfc:	4817      	ldr	r0, [pc, #92]	; (12d5c <OnBoardLed::Initialize()+0x6c>)
   12cfe:	f003 fdf9 	bl	168f4 <__cyg_profile_func_enter>
  {
    for (uint8_t i = 0; i < 4; i++)
   12d02:	2300      	movs	r3, #0
   12d04:	f88d 300f 	strb.w	r3, [sp, #15]
   12d08:	f89d 300f 	ldrb.w	r3, [sp, #15]
   12d0c:	2b03      	cmp	r3, #3
   12d0e:	d81d      	bhi.n	12d4c <OnBoardLed::Initialize()+0x5c>
    {
      led[i].SetAsOutput();
   12d10:	f89d 200f 	ldrb.w	r2, [sp, #15]
   12d14:	4613      	mov	r3, r2
   12d16:	009b      	lsls	r3, r3, #2
   12d18:	4413      	add	r3, r2
   12d1a:	009b      	lsls	r3, r3, #2
   12d1c:	9a01      	ldr	r2, [sp, #4]
   12d1e:	4413      	add	r3, r2
   12d20:	3304      	adds	r3, #4
   12d22:	4618      	mov	r0, r3
   12d24:	f7ff fc52 	bl	125cc <Gpio::SetAsOutput()>
      led[i].SetHigh();
   12d28:	f89d 200f 	ldrb.w	r2, [sp, #15]
   12d2c:	4613      	mov	r3, r2
   12d2e:	009b      	lsls	r3, r3, #2
   12d30:	4413      	add	r3, r2
   12d32:	009b      	lsls	r3, r3, #2
   12d34:	9a01      	ldr	r2, [sp, #4]
   12d36:	4413      	add	r3, r2
   12d38:	3304      	adds	r3, #4
   12d3a:	4618      	mov	r0, r3
   12d3c:	f7fd fc58 	bl	105f0 <Gpio::SetHigh()>
    for (uint8_t i = 0; i < 4; i++)
   12d40:	f89d 300f 	ldrb.w	r3, [sp, #15]
   12d44:	3301      	adds	r3, #1
   12d46:	f88d 300f 	strb.w	r3, [sp, #15]
   12d4a:	e7dd      	b.n	12d08 <OnBoardLed::Initialize()+0x18>
   12d4c:	4623      	mov	r3, r4
   12d4e:	4619      	mov	r1, r3
   12d50:	4802      	ldr	r0, [pc, #8]	; (12d5c <OnBoardLed::Initialize()+0x6c>)
   12d52:	f003 fde3 	bl	1691c <__cyg_profile_func_exit>
    }
  }
   12d56:	bf00      	nop
   12d58:	b004      	add	sp, #16
   12d5a:	bd10      	pop	{r4, pc}
   12d5c:	00012cf1 	.word	0x00012cf1

00012d60 <OnBoardLed::On(unsigned char)>:

  void On(uint8_t led_number) override
   12d60:	b510      	push	{r4, lr}
   12d62:	b084      	sub	sp, #16
   12d64:	4674      	mov	r4, lr
   12d66:	9003      	str	r0, [sp, #12]
   12d68:	460b      	mov	r3, r1
   12d6a:	f88d 300b 	strb.w	r3, [sp, #11]
   12d6e:	4623      	mov	r3, r4
   12d70:	4619      	mov	r1, r3
   12d72:	4816      	ldr	r0, [pc, #88]	; (12dcc <OnBoardLed::On(unsigned char)+0x6c>)
   12d74:	f003 fdbe 	bl	168f4 <__cyg_profile_func_enter>
  {
    SJ2_ASSERT_FATAL(led_number < 4,
   12d78:	f89d 300b 	ldrb.w	r3, [sp, #11]
   12d7c:	2b03      	cmp	r3, #3
   12d7e:	d910      	bls.n	12da2 <OnBoardLed::On(unsigned char)+0x42>
   12d80:	f89d 300b 	ldrb.w	r3, [sp, #11]
   12d84:	9300      	str	r3, [sp, #0]
   12d86:	2331      	movs	r3, #49	; 0x31
   12d88:	4a11      	ldr	r2, [pc, #68]	; (12dd0 <OnBoardLed::On(unsigned char)+0x70>)
   12d8a:	4912      	ldr	r1, [pc, #72]	; (12dd4 <OnBoardLed::On(unsigned char)+0x74>)
   12d8c:	4812      	ldr	r0, [pc, #72]	; (12dd8 <OnBoardLed::On(unsigned char)+0x78>)
   12d8e:	f005 fd27 	bl	187e0 <printf>
   12d92:	4812      	ldr	r0, [pc, #72]	; (12ddc <OnBoardLed::On(unsigned char)+0x7c>)
   12d94:	f003 fd7e 	bl	16894 <puts>
   12d98:	2100      	movs	r1, #0
   12d9a:	2001      	movs	r0, #1
   12d9c:	f7fe fb80 	bl	114a0 <debug::PrintBacktrace(bool, void*)>
   12da0:	e7fe      	b.n	12da0 <OnBoardLed::On(unsigned char)+0x40>
                     "Input Led number can't be greater than 3, input = %d.\n",
                     led_number);
    led[led_number].SetLow();
   12da2:	f89d 200b 	ldrb.w	r2, [sp, #11]
   12da6:	4613      	mov	r3, r2
   12da8:	009b      	lsls	r3, r3, #2
   12daa:	4413      	add	r3, r2
   12dac:	009b      	lsls	r3, r3, #2
   12dae:	9a03      	ldr	r2, [sp, #12]
   12db0:	4413      	add	r3, r2
   12db2:	3304      	adds	r3, #4
   12db4:	4618      	mov	r0, r3
   12db6:	f7fd fc4d 	bl	10654 <Gpio::SetLow()>
   12dba:	4623      	mov	r3, r4
   12dbc:	4619      	mov	r1, r3
   12dbe:	4803      	ldr	r0, [pc, #12]	; (12dcc <OnBoardLed::On(unsigned char)+0x6c>)
   12dc0:	f003 fdac 	bl	1691c <__cyg_profile_func_exit>
  }
   12dc4:	bf00      	nop
   12dc6:	b004      	add	sp, #16
   12dc8:	bd10      	pop	{r4, pc}
   12dca:	bf00      	nop
   12dcc:	00012d61 	.word	0x00012d61
   12dd0:	0001d910 	.word	0x0001d910
   12dd4:	0001d4d0 	.word	0x0001d4d0
   12dd8:	0001d2c0 	.word	0x0001d2c0
   12ddc:	0001cddc 	.word	0x0001cddc

00012de0 <OnBoardLed::Off(unsigned char)>:

  void Off(uint8_t led_number) override
   12de0:	b510      	push	{r4, lr}
   12de2:	b084      	sub	sp, #16
   12de4:	4674      	mov	r4, lr
   12de6:	9003      	str	r0, [sp, #12]
   12de8:	460b      	mov	r3, r1
   12dea:	f88d 300b 	strb.w	r3, [sp, #11]
   12dee:	4623      	mov	r3, r4
   12df0:	4619      	mov	r1, r3
   12df2:	4816      	ldr	r0, [pc, #88]	; (12e4c <OnBoardLed::Off(unsigned char)+0x6c>)
   12df4:	f003 fd7e 	bl	168f4 <__cyg_profile_func_enter>
  {
    SJ2_ASSERT_FATAL(led_number < 4,
   12df8:	f89d 300b 	ldrb.w	r3, [sp, #11]
   12dfc:	2b03      	cmp	r3, #3
   12dfe:	d910      	bls.n	12e22 <OnBoardLed::Off(unsigned char)+0x42>
   12e00:	f89d 300b 	ldrb.w	r3, [sp, #11]
   12e04:	9300      	str	r3, [sp, #0]
   12e06:	2339      	movs	r3, #57	; 0x39
   12e08:	4a11      	ldr	r2, [pc, #68]	; (12e50 <OnBoardLed::Off(unsigned char)+0x70>)
   12e0a:	4912      	ldr	r1, [pc, #72]	; (12e54 <OnBoardLed::Off(unsigned char)+0x74>)
   12e0c:	4812      	ldr	r0, [pc, #72]	; (12e58 <OnBoardLed::Off(unsigned char)+0x78>)
   12e0e:	f005 fce7 	bl	187e0 <printf>
   12e12:	4812      	ldr	r0, [pc, #72]	; (12e5c <OnBoardLed::Off(unsigned char)+0x7c>)
   12e14:	f003 fd3e 	bl	16894 <puts>
   12e18:	2100      	movs	r1, #0
   12e1a:	2001      	movs	r0, #1
   12e1c:	f7fe fb40 	bl	114a0 <debug::PrintBacktrace(bool, void*)>
   12e20:	e7fe      	b.n	12e20 <OnBoardLed::Off(unsigned char)+0x40>
                     "Input Led number can't be greater than 3, input = %d.\n",
                     led_number);
    led[led_number].SetHigh();
   12e22:	f89d 200b 	ldrb.w	r2, [sp, #11]
   12e26:	4613      	mov	r3, r2
   12e28:	009b      	lsls	r3, r3, #2
   12e2a:	4413      	add	r3, r2
   12e2c:	009b      	lsls	r3, r3, #2
   12e2e:	9a03      	ldr	r2, [sp, #12]
   12e30:	4413      	add	r3, r2
   12e32:	3304      	adds	r3, #4
   12e34:	4618      	mov	r0, r3
   12e36:	f7fd fbdb 	bl	105f0 <Gpio::SetHigh()>
   12e3a:	4623      	mov	r3, r4
   12e3c:	4619      	mov	r1, r3
   12e3e:	4803      	ldr	r0, [pc, #12]	; (12e4c <OnBoardLed::Off(unsigned char)+0x6c>)
   12e40:	f003 fd6c 	bl	1691c <__cyg_profile_func_exit>
  }
   12e44:	bf00      	nop
   12e46:	b004      	add	sp, #16
   12e48:	bd10      	pop	{r4, pc}
   12e4a:	bf00      	nop
   12e4c:	00012de1 	.word	0x00012de1
   12e50:	0001d8e8 	.word	0x0001d8e8
   12e54:	0001d4e0 	.word	0x0001d4e0
   12e58:	0001d2c0 	.word	0x0001d2c0
   12e5c:	0001cddc 	.word	0x0001cddc

00012e60 <OnBoardLed::Set(unsigned char, OnBoardLedInterface::LightState)>:

  void Set(uint8_t led_number,
   12e60:	b510      	push	{r4, lr}
   12e62:	b084      	sub	sp, #16
   12e64:	4674      	mov	r4, lr
   12e66:	9003      	str	r0, [sp, #12]
   12e68:	460b      	mov	r3, r1
   12e6a:	f88d 300b 	strb.w	r3, [sp, #11]
   12e6e:	4613      	mov	r3, r2
   12e70:	f88d 300a 	strb.w	r3, [sp, #10]
   12e74:	4623      	mov	r3, r4
   12e76:	4619      	mov	r1, r3
   12e78:	481b      	ldr	r0, [pc, #108]	; (12ee8 <OnBoardLed::Set(unsigned char, OnBoardLedInterface::LightState)+0x88>)
   12e7a:	f003 fd3b 	bl	168f4 <__cyg_profile_func_enter>
           OnBoardLedInterface::LightState state = LightState::kOn) override
  {
    SJ2_ASSERT_FATAL(led_number < 4,
   12e7e:	f89d 300b 	ldrb.w	r3, [sp, #11]
   12e82:	2b03      	cmp	r3, #3
   12e84:	d910      	bls.n	12ea8 <OnBoardLed::Set(unsigned char, OnBoardLedInterface::LightState)+0x48>
   12e86:	f89d 300b 	ldrb.w	r3, [sp, #11]
   12e8a:	9300      	str	r3, [sp, #0]
   12e8c:	2342      	movs	r3, #66	; 0x42
   12e8e:	4a17      	ldr	r2, [pc, #92]	; (12eec <OnBoardLed::Set(unsigned char, OnBoardLedInterface::LightState)+0x8c>)
   12e90:	4917      	ldr	r1, [pc, #92]	; (12ef0 <OnBoardLed::Set(unsigned char, OnBoardLedInterface::LightState)+0x90>)
   12e92:	4818      	ldr	r0, [pc, #96]	; (12ef4 <OnBoardLed::Set(unsigned char, OnBoardLedInterface::LightState)+0x94>)
   12e94:	f005 fca4 	bl	187e0 <printf>
   12e98:	4817      	ldr	r0, [pc, #92]	; (12ef8 <OnBoardLed::Set(unsigned char, OnBoardLedInterface::LightState)+0x98>)
   12e9a:	f003 fcfb 	bl	16894 <puts>
   12e9e:	2100      	movs	r1, #0
   12ea0:	2001      	movs	r0, #1
   12ea2:	f7fe fafd 	bl	114a0 <debug::PrintBacktrace(bool, void*)>
   12ea6:	e7fe      	b.n	12ea6 <OnBoardLed::Set(unsigned char, OnBoardLedInterface::LightState)+0x46>
                     "Input Led number can't be greater than 3, input = %d.\n",
                     led_number);
    if (state == LightState::kOn)
   12ea8:	f89d 300a 	ldrb.w	r3, [sp, #10]
   12eac:	2b01      	cmp	r3, #1
   12eae:	d109      	bne.n	12ec4 <OnBoardLed::Set(unsigned char, OnBoardLedInterface::LightState)+0x64>
    {
      On(led_number);
   12eb0:	9b03      	ldr	r3, [sp, #12]
   12eb2:	681b      	ldr	r3, [r3, #0]
   12eb4:	3304      	adds	r3, #4
   12eb6:	681b      	ldr	r3, [r3, #0]
   12eb8:	f89d 200b 	ldrb.w	r2, [sp, #11]
   12ebc:	4611      	mov	r1, r2
   12ebe:	9803      	ldr	r0, [sp, #12]
   12ec0:	4798      	blx	r3
   12ec2:	e008      	b.n	12ed6 <OnBoardLed::Set(unsigned char, OnBoardLedInterface::LightState)+0x76>
    }
    else
    {
      Off(led_number);
   12ec4:	9b03      	ldr	r3, [sp, #12]
   12ec6:	681b      	ldr	r3, [r3, #0]
   12ec8:	3308      	adds	r3, #8
   12eca:	681b      	ldr	r3, [r3, #0]
   12ecc:	f89d 200b 	ldrb.w	r2, [sp, #11]
   12ed0:	4611      	mov	r1, r2
   12ed2:	9803      	ldr	r0, [sp, #12]
   12ed4:	4798      	blx	r3
   12ed6:	4623      	mov	r3, r4
   12ed8:	4619      	mov	r1, r3
   12eda:	4803      	ldr	r0, [pc, #12]	; (12ee8 <OnBoardLed::Set(unsigned char, OnBoardLedInterface::LightState)+0x88>)
   12edc:	f003 fd1e 	bl	1691c <__cyg_profile_func_exit>
    }
  }
   12ee0:	bf00      	nop
   12ee2:	b004      	add	sp, #16
   12ee4:	bd10      	pop	{r4, pc}
   12ee6:	bf00      	nop
   12ee8:	00012e61 	.word	0x00012e61
   12eec:	0001d8a0 	.word	0x0001d8a0
   12ef0:	0001d4f0 	.word	0x0001d4f0
   12ef4:	0001d2c0 	.word	0x0001d2c0
   12ef8:	0001cddc 	.word	0x0001cddc

00012efc <OnBoardLed::Toggle(unsigned char)>:

  void Toggle(uint8_t led_number) override
   12efc:	b510      	push	{r4, lr}
   12efe:	b084      	sub	sp, #16
   12f00:	4674      	mov	r4, lr
   12f02:	9003      	str	r0, [sp, #12]
   12f04:	460b      	mov	r3, r1
   12f06:	f88d 300b 	strb.w	r3, [sp, #11]
   12f0a:	4623      	mov	r3, r4
   12f0c:	4619      	mov	r1, r3
   12f0e:	4816      	ldr	r0, [pc, #88]	; (12f68 <OnBoardLed::Toggle(unsigned char)+0x6c>)
   12f10:	f003 fcf0 	bl	168f4 <__cyg_profile_func_enter>
  {
    SJ2_ASSERT_FATAL(led_number < 4,
   12f14:	f89d 300b 	ldrb.w	r3, [sp, #11]
   12f18:	2b03      	cmp	r3, #3
   12f1a:	d910      	bls.n	12f3e <OnBoardLed::Toggle(unsigned char)+0x42>
   12f1c:	f89d 300b 	ldrb.w	r3, [sp, #11]
   12f20:	9300      	str	r3, [sp, #0]
   12f22:	2351      	movs	r3, #81	; 0x51
   12f24:	4a11      	ldr	r2, [pc, #68]	; (12f6c <OnBoardLed::Toggle(unsigned char)+0x70>)
   12f26:	4912      	ldr	r1, [pc, #72]	; (12f70 <OnBoardLed::Toggle(unsigned char)+0x74>)
   12f28:	4812      	ldr	r0, [pc, #72]	; (12f74 <OnBoardLed::Toggle(unsigned char)+0x78>)
   12f2a:	f005 fc59 	bl	187e0 <printf>
   12f2e:	4812      	ldr	r0, [pc, #72]	; (12f78 <OnBoardLed::Toggle(unsigned char)+0x7c>)
   12f30:	f003 fcb0 	bl	16894 <puts>
   12f34:	2100      	movs	r1, #0
   12f36:	2001      	movs	r0, #1
   12f38:	f7fe fab2 	bl	114a0 <debug::PrintBacktrace(bool, void*)>
   12f3c:	e7fe      	b.n	12f3c <OnBoardLed::Toggle(unsigned char)+0x40>
                     "Input Led number can't be greater than 3, input = %d.\n",
                     led_number);
    led[led_number].Toggle();
   12f3e:	f89d 200b 	ldrb.w	r2, [sp, #11]
   12f42:	4613      	mov	r3, r2
   12f44:	009b      	lsls	r3, r3, #2
   12f46:	4413      	add	r3, r2
   12f48:	009b      	lsls	r3, r3, #2
   12f4a:	9a03      	ldr	r2, [sp, #12]
   12f4c:	4413      	add	r3, r2
   12f4e:	3304      	adds	r3, #4
   12f50:	4618      	mov	r0, r3
   12f52:	f7ff fb9b 	bl	1268c <Gpio::Toggle()>
   12f56:	4623      	mov	r3, r4
   12f58:	4619      	mov	r1, r3
   12f5a:	4803      	ldr	r0, [pc, #12]	; (12f68 <OnBoardLed::Toggle(unsigned char)+0x6c>)
   12f5c:	f003 fcde 	bl	1691c <__cyg_profile_func_exit>
  }
   12f60:	bf00      	nop
   12f62:	b004      	add	sp, #16
   12f64:	bd10      	pop	{r4, pc}
   12f66:	bf00      	nop
   12f68:	00012efd 	.word	0x00012efd
   12f6c:	0001d874 	.word	0x0001d874
   12f70:	0001d500 	.word	0x0001d500
   12f74:	0001d2c0 	.word	0x0001d2c0
   12f78:	0001cddc 	.word	0x0001cddc

00012f7c <OnBoardLed::SetAll(unsigned char)>:

  // This function takes in the 4 least significant bits from value, and sets
  // the led to be ON or OFF. The least significant bit corresponds to LED0,
  // next least significant corresponds to LED1, etc. ON =1, OFF =0. The four
  // most significant bits will be unused.
  void SetAll(uint8_t value) override
   12f7c:	b510      	push	{r4, lr}
   12f7e:	b084      	sub	sp, #16
   12f80:	4674      	mov	r4, lr
   12f82:	9001      	str	r0, [sp, #4]
   12f84:	460b      	mov	r3, r1
   12f86:	f88d 3003 	strb.w	r3, [sp, #3]
   12f8a:	4623      	mov	r3, r4
   12f8c:	4619      	mov	r1, r3
   12f8e:	481a      	ldr	r0, [pc, #104]	; (12ff8 <OnBoardLed::SetAll(unsigned char)+0x7c>)
   12f90:	f003 fcb0 	bl	168f4 <__cyg_profile_func_enter>
  {
    for (uint8_t i = 0; i < 4; i++)
   12f94:	2300      	movs	r3, #0
   12f96:	f88d 300f 	strb.w	r3, [sp, #15]
   12f9a:	f89d 300f 	ldrb.w	r3, [sp, #15]
   12f9e:	2b03      	cmp	r3, #3
   12fa0:	d822      	bhi.n	12fe8 <OnBoardLed::SetAll(unsigned char)+0x6c>
    {
      if ((value >> i) & 1)
   12fa2:	f89d 2003 	ldrb.w	r2, [sp, #3]
   12fa6:	f89d 300f 	ldrb.w	r3, [sp, #15]
   12faa:	fa42 f303 	asr.w	r3, r2, r3
   12fae:	f003 0301 	and.w	r3, r3, #1
   12fb2:	2b00      	cmp	r3, #0
   12fb4:	d009      	beq.n	12fca <OnBoardLed::SetAll(unsigned char)+0x4e>
      {
        Set(i, LightState::kOn);
   12fb6:	9b01      	ldr	r3, [sp, #4]
   12fb8:	681b      	ldr	r3, [r3, #0]
   12fba:	330c      	adds	r3, #12
   12fbc:	681b      	ldr	r3, [r3, #0]
   12fbe:	f89d 100f 	ldrb.w	r1, [sp, #15]
   12fc2:	2201      	movs	r2, #1
   12fc4:	9801      	ldr	r0, [sp, #4]
   12fc6:	4798      	blx	r3
   12fc8:	e008      	b.n	12fdc <OnBoardLed::SetAll(unsigned char)+0x60>
      }
      else
      {
        Set(i, LightState::kOff);
   12fca:	9b01      	ldr	r3, [sp, #4]
   12fcc:	681b      	ldr	r3, [r3, #0]
   12fce:	330c      	adds	r3, #12
   12fd0:	681b      	ldr	r3, [r3, #0]
   12fd2:	f89d 100f 	ldrb.w	r1, [sp, #15]
   12fd6:	2200      	movs	r2, #0
   12fd8:	9801      	ldr	r0, [sp, #4]
   12fda:	4798      	blx	r3
    for (uint8_t i = 0; i < 4; i++)
   12fdc:	f89d 300f 	ldrb.w	r3, [sp, #15]
   12fe0:	3301      	adds	r3, #1
   12fe2:	f88d 300f 	strb.w	r3, [sp, #15]
   12fe6:	e7d8      	b.n	12f9a <OnBoardLed::SetAll(unsigned char)+0x1e>
   12fe8:	4623      	mov	r3, r4
   12fea:	4619      	mov	r1, r3
   12fec:	4802      	ldr	r0, [pc, #8]	; (12ff8 <OnBoardLed::SetAll(unsigned char)+0x7c>)
   12fee:	f003 fc95 	bl	1691c <__cyg_profile_func_exit>
      }
    }
  }
   12ff2:	bf00      	nop
   12ff4:	b004      	add	sp, #16
   12ff6:	bd10      	pop	{r4, pc}
   12ff8:	00012f7d 	.word	0x00012f7d

00012ffc <OnBoardLed::GetStates()>:
  // This function will return the states of LED0-LED3, going from bit 0
  // represnting LED 0, to bit 3 representing LED3. Only the four least
  // significant bits will be used. The four most significant bits will be 0s.
  uint8_t GetStates(void) override
   12ffc:	b530      	push	{r4, r5, lr}
   12ffe:	b085      	sub	sp, #20
   13000:	4675      	mov	r5, lr
   13002:	9001      	str	r0, [sp, #4]
   13004:	462b      	mov	r3, r5
   13006:	4619      	mov	r1, r3
   13008:	4819      	ldr	r0, [pc, #100]	; (13070 <OnBoardLed::GetStates()+0x74>)
   1300a:	f003 fc73 	bl	168f4 <__cyg_profile_func_enter>
  {
    uint32_t led_states = 0x0000;
   1300e:	2300      	movs	r3, #0
   13010:	9303      	str	r3, [sp, #12]
    for (uint8_t i = 0; i < 4; i++)
   13012:	2300      	movs	r3, #0
   13014:	f88d 300b 	strb.w	r3, [sp, #11]
   13018:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1301c:	2b03      	cmp	r3, #3
   1301e:	d81b      	bhi.n	13058 <OnBoardLed::GetStates()+0x5c>
    {
      led_states |= led[i].Read() << i;
   13020:	f89d 200b 	ldrb.w	r2, [sp, #11]
   13024:	4613      	mov	r3, r2
   13026:	009b      	lsls	r3, r3, #2
   13028:	4413      	add	r3, r2
   1302a:	009b      	lsls	r3, r3, #2
   1302c:	9a01      	ldr	r2, [sp, #4]
   1302e:	4413      	add	r3, r2
   13030:	3304      	adds	r3, #4
   13032:	4618      	mov	r0, r3
   13034:	f7ff fb9c 	bl	12770 <Gpio::Read()>
   13038:	4603      	mov	r3, r0
   1303a:	461a      	mov	r2, r3
   1303c:	f89d 300b 	ldrb.w	r3, [sp, #11]
   13040:	fa02 f303 	lsl.w	r3, r2, r3
   13044:	461a      	mov	r2, r3
   13046:	9b03      	ldr	r3, [sp, #12]
   13048:	4313      	orrs	r3, r2
   1304a:	9303      	str	r3, [sp, #12]
    for (uint8_t i = 0; i < 4; i++)
   1304c:	f89d 300b 	ldrb.w	r3, [sp, #11]
   13050:	3301      	adds	r3, #1
   13052:	f88d 300b 	strb.w	r3, [sp, #11]
   13056:	e7df      	b.n	13018 <OnBoardLed::GetStates()+0x1c>
    }
    return static_cast<uint8_t>(led_states);
   13058:	9b03      	ldr	r3, [sp, #12]
   1305a:	b2dc      	uxtb	r4, r3
   1305c:	462b      	mov	r3, r5
   1305e:	4619      	mov	r1, r3
   13060:	4803      	ldr	r0, [pc, #12]	; (13070 <OnBoardLed::GetStates()+0x74>)
   13062:	f003 fc5b 	bl	1691c <__cyg_profile_func_exit>
   13066:	4623      	mov	r3, r4
  }
   13068:	4618      	mov	r0, r3
   1306a:	b005      	add	sp, #20
   1306c:	bd30      	pop	{r4, r5, pc}
   1306e:	bf00      	nop
   13070:	00012ffd 	.word	0x00012ffd

00013074 <SspInterface::SspInterface()>:
class SspInterface
   13074:	b530      	push	{r4, r5, lr}
   13076:	b083      	sub	sp, #12
   13078:	4675      	mov	r5, lr
   1307a:	9001      	str	r0, [sp, #4]
   1307c:	462b      	mov	r3, r5
   1307e:	4619      	mov	r1, r3
   13080:	4807      	ldr	r0, [pc, #28]	; (130a0 <SspInterface::SspInterface()+0x2c>)
   13082:	f003 fc37 	bl	168f4 <__cyg_profile_func_enter>
   13086:	4a07      	ldr	r2, [pc, #28]	; (130a4 <SspInterface::SspInterface()+0x30>)
   13088:	9b01      	ldr	r3, [sp, #4]
   1308a:	601a      	str	r2, [r3, #0]
   1308c:	9c01      	ldr	r4, [sp, #4]
   1308e:	462b      	mov	r3, r5
   13090:	4619      	mov	r1, r3
   13092:	4803      	ldr	r0, [pc, #12]	; (130a0 <SspInterface::SspInterface()+0x2c>)
   13094:	f003 fc42 	bl	1691c <__cyg_profile_func_exit>
   13098:	4623      	mov	r3, r4
   1309a:	4618      	mov	r0, r3
   1309c:	b003      	add	sp, #12
   1309e:	bd30      	pop	{r4, r5, pc}
   130a0:	00013075 	.word	0x00013075
   130a4:	0001d614 	.word	0x0001d614

000130a8 <PinInterface::PinInterface(PinInterface const&)>:
class PinInterface
   130a8:	b530      	push	{r4, r5, lr}
   130aa:	b083      	sub	sp, #12
   130ac:	4675      	mov	r5, lr
   130ae:	9001      	str	r0, [sp, #4]
   130b0:	9100      	str	r1, [sp, #0]
   130b2:	462b      	mov	r3, r5
   130b4:	4619      	mov	r1, r3
   130b6:	4808      	ldr	r0, [pc, #32]	; (130d8 <PinInterface::PinInterface(PinInterface const&)+0x30>)
   130b8:	f003 fc1c 	bl	168f4 <__cyg_profile_func_enter>
   130bc:	4a07      	ldr	r2, [pc, #28]	; (130dc <PinInterface::PinInterface(PinInterface const&)+0x34>)
   130be:	9b01      	ldr	r3, [sp, #4]
   130c0:	601a      	str	r2, [r3, #0]
   130c2:	9c01      	ldr	r4, [sp, #4]
   130c4:	462b      	mov	r3, r5
   130c6:	4619      	mov	r1, r3
   130c8:	4803      	ldr	r0, [pc, #12]	; (130d8 <PinInterface::PinInterface(PinInterface const&)+0x30>)
   130ca:	f003 fc27 	bl	1691c <__cyg_profile_func_exit>
   130ce:	4623      	mov	r3, r4
   130d0:	4618      	mov	r0, r3
   130d2:	b003      	add	sp, #12
   130d4:	bd30      	pop	{r4, r5, pc}
   130d6:	bf00      	nop
   130d8:	000130a9 	.word	0x000130a9
   130dc:	0001d764 	.word	0x0001d764

000130e0 <Pin::Pin(Pin const&)>:
class Pin : public PinInterface
   130e0:	b530      	push	{r4, r5, lr}
   130e2:	b083      	sub	sp, #12
   130e4:	4675      	mov	r5, lr
   130e6:	9001      	str	r0, [sp, #4]
   130e8:	9100      	str	r1, [sp, #0]
   130ea:	462b      	mov	r3, r5
   130ec:	4619      	mov	r1, r3
   130ee:	480f      	ldr	r0, [pc, #60]	; (1312c <Pin::Pin(Pin const&)+0x4c>)
   130f0:	f003 fc00 	bl	168f4 <__cyg_profile_func_enter>
   130f4:	9b01      	ldr	r3, [sp, #4]
   130f6:	9a00      	ldr	r2, [sp, #0]
   130f8:	4611      	mov	r1, r2
   130fa:	4618      	mov	r0, r3
   130fc:	f7ff ffd4 	bl	130a8 <PinInterface::PinInterface(PinInterface const&)>
   13100:	4a0b      	ldr	r2, [pc, #44]	; (13130 <Pin::Pin(Pin const&)+0x50>)
   13102:	9b01      	ldr	r3, [sp, #4]
   13104:	601a      	str	r2, [r3, #0]
   13106:	9b00      	ldr	r3, [sp, #0]
   13108:	791a      	ldrb	r2, [r3, #4]
   1310a:	9b01      	ldr	r3, [sp, #4]
   1310c:	711a      	strb	r2, [r3, #4]
   1310e:	9b00      	ldr	r3, [sp, #0]
   13110:	795a      	ldrb	r2, [r3, #5]
   13112:	9b01      	ldr	r3, [sp, #4]
   13114:	715a      	strb	r2, [r3, #5]
   13116:	9c01      	ldr	r4, [sp, #4]
   13118:	462b      	mov	r3, r5
   1311a:	4619      	mov	r1, r3
   1311c:	4803      	ldr	r0, [pc, #12]	; (1312c <Pin::Pin(Pin const&)+0x4c>)
   1311e:	f003 fbfd 	bl	1691c <__cyg_profile_func_exit>
   13122:	4623      	mov	r3, r4
   13124:	4618      	mov	r0, r3
   13126:	b003      	add	sp, #12
   13128:	bd30      	pop	{r4, r5, pc}
   1312a:	bf00      	nop
   1312c:	000130e1 	.word	0x000130e1
   13130:	0001d728 	.word	0x0001d728

00013134 <Ssp::Ssp(Ssp::Peripheral)>:
  explicit constexpr Ssp(Peripheral set_pssp)
   13134:	b530      	push	{r4, r5, lr}
   13136:	b083      	sub	sp, #12
   13138:	4675      	mov	r5, lr
   1313a:	9001      	str	r0, [sp, #4]
   1313c:	9100      	str	r1, [sp, #0]
   1313e:	462b      	mov	r3, r5
   13140:	4619      	mov	r1, r3
   13142:	4831      	ldr	r0, [pc, #196]	; (13208 <Ssp::Ssp(Ssp::Peripheral)+0xd4>)
   13144:	f003 fbd6 	bl	168f4 <__cyg_profile_func_enter>
        pssp_(set_pssp)
   13148:	9b01      	ldr	r3, [sp, #4]
   1314a:	4618      	mov	r0, r3
   1314c:	f7ff ff92 	bl	13074 <SspInterface::SspInterface()>
   13150:	9b01      	ldr	r3, [sp, #4]
   13152:	3304      	adds	r3, #4
   13154:	4618      	mov	r0, r3
   13156:	f7fe fa2f 	bl	115b8 <Lpc40xxSystemController::Lpc40xxSystemController()>
   1315a:	4a2c      	ldr	r2, [pc, #176]	; (1320c <Ssp::Ssp(Ssp::Peripheral)+0xd8>)
   1315c:	9b01      	ldr	r3, [sp, #4]
   1315e:	601a      	str	r2, [r3, #0]
   13160:	4a2b      	ldr	r2, [pc, #172]	; (13210 <Ssp::Ssp(Ssp::Peripheral)+0xdc>)
   13162:	9b01      	ldr	r3, [sp, #4]
   13164:	605a      	str	r2, [r3, #4]
   13166:	9b01      	ldr	r3, [sp, #4]
   13168:	f103 0214 	add.w	r2, r3, #20
   1316c:	9b01      	ldr	r3, [sp, #4]
   1316e:	609a      	str	r2, [r3, #8]
   13170:	9b01      	ldr	r3, [sp, #4]
   13172:	f103 021c 	add.w	r2, r3, #28
   13176:	9b01      	ldr	r3, [sp, #4]
   13178:	60da      	str	r2, [r3, #12]
   1317a:	9b01      	ldr	r3, [sp, #4]
   1317c:	f103 0224 	add.w	r2, r3, #36	; 0x24
   13180:	9b01      	ldr	r3, [sp, #4]
   13182:	611a      	str	r2, [r3, #16]
   13184:	9b01      	ldr	r3, [sp, #4]
   13186:	f103 0414 	add.w	r4, r3, #20
        mosi_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kMosi]),
   1318a:	9800      	ldr	r0, [sp, #0]
   1318c:	f7fd fab6 	bl	106fc <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   13190:	4602      	mov	r2, r0
        pssp_(set_pssp)
   13192:	4613      	mov	r3, r2
   13194:	005b      	lsls	r3, r3, #1
   13196:	4413      	add	r3, r2
   13198:	00db      	lsls	r3, r3, #3
   1319a:	4a1e      	ldr	r2, [pc, #120]	; (13214 <Ssp::Ssp(Ssp::Peripheral)+0xe0>)
   1319c:	4413      	add	r3, r2
   1319e:	4619      	mov	r1, r3
   131a0:	4620      	mov	r0, r4
   131a2:	f7ff ff9d 	bl	130e0 <Pin::Pin(Pin const&)>
   131a6:	9b01      	ldr	r3, [sp, #4]
   131a8:	f103 041c 	add.w	r4, r3, #28
        miso_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kMiso]),
   131ac:	9800      	ldr	r0, [sp, #0]
   131ae:	f7fd faa5 	bl	106fc <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   131b2:	4602      	mov	r2, r0
        pssp_(set_pssp)
   131b4:	4613      	mov	r3, r2
   131b6:	005b      	lsls	r3, r3, #1
   131b8:	4413      	add	r3, r2
   131ba:	00db      	lsls	r3, r3, #3
   131bc:	3308      	adds	r3, #8
   131be:	4a15      	ldr	r2, [pc, #84]	; (13214 <Ssp::Ssp(Ssp::Peripheral)+0xe0>)
   131c0:	4413      	add	r3, r2
   131c2:	4619      	mov	r1, r3
   131c4:	4620      	mov	r0, r4
   131c6:	f7ff ff8b 	bl	130e0 <Pin::Pin(Pin const&)>
   131ca:	9b01      	ldr	r3, [sp, #4]
   131cc:	f103 0424 	add.w	r4, r3, #36	; 0x24
        sck_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kSck]),
   131d0:	9800      	ldr	r0, [sp, #0]
   131d2:	f7fd fa93 	bl	106fc <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   131d6:	4602      	mov	r2, r0
        pssp_(set_pssp)
   131d8:	4613      	mov	r3, r2
   131da:	005b      	lsls	r3, r3, #1
   131dc:	4413      	add	r3, r2
   131de:	00db      	lsls	r3, r3, #3
   131e0:	3310      	adds	r3, #16
   131e2:	4a0c      	ldr	r2, [pc, #48]	; (13214 <Ssp::Ssp(Ssp::Peripheral)+0xe0>)
   131e4:	4413      	add	r3, r2
   131e6:	4619      	mov	r1, r3
   131e8:	4620      	mov	r0, r4
   131ea:	f7ff ff79 	bl	130e0 <Pin::Pin(Pin const&)>
   131ee:	9b01      	ldr	r3, [sp, #4]
   131f0:	9a00      	ldr	r2, [sp, #0]
   131f2:	62da      	str	r2, [r3, #44]	; 0x2c
  }
   131f4:	9c01      	ldr	r4, [sp, #4]
   131f6:	462b      	mov	r3, r5
   131f8:	4619      	mov	r1, r3
   131fa:	4803      	ldr	r0, [pc, #12]	; (13208 <Ssp::Ssp(Ssp::Peripheral)+0xd4>)
   131fc:	f003 fb8e 	bl	1691c <__cyg_profile_func_exit>
   13200:	4623      	mov	r3, r4
   13202:	4618      	mov	r0, r3
   13204:	b003      	add	sp, #12
   13206:	bd30      	pop	{r4, r5, pc}
   13208:	00013135 	.word	0x00013135
   1320c:	0001d5c8 	.word	0x0001d5c8
   13210:	0001d5f0 	.word	0x0001d5f0
   13214:	0001d514 	.word	0x0001d514

00013218 <Ssp::Initialize()>:
  void Initialize() override
   13218:	b570      	push	{r4, r5, r6, lr}
   1321a:	b086      	sub	sp, #24
   1321c:	4676      	mov	r6, lr
   1321e:	9001      	str	r0, [sp, #4]
   13220:	4633      	mov	r3, r6
   13222:	4619      	mov	r1, r3
   13224:	4830      	ldr	r0, [pc, #192]	; (132e8 <Ssp::Initialize()+0xd0>)
   13226:	f003 fb65 	bl	168f4 <__cyg_profile_func_enter>
    uint32_t pssp = util::Value(pssp_);
   1322a:	9b01      	ldr	r3, [sp, #4]
   1322c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1322e:	4618      	mov	r0, r3
   13230:	f7fd fa64 	bl	106fc <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   13234:	4603      	mov	r3, r0
   13236:	9305      	str	r3, [sp, #20]
    PowerUpPeripheral(kPowerBit[pssp]);
   13238:	9b01      	ldr	r3, [sp, #4]
   1323a:	1d18      	adds	r0, r3, #4
   1323c:	9b01      	ldr	r3, [sp, #4]
   1323e:	685b      	ldr	r3, [r3, #4]
   13240:	3314      	adds	r3, #20
   13242:	681b      	ldr	r3, [r3, #0]
   13244:	9a05      	ldr	r2, [sp, #20]
   13246:	0092      	lsls	r2, r2, #2
   13248:	4928      	ldr	r1, [pc, #160]	; (132ec <Ssp::Initialize()+0xd4>)
   1324a:	440a      	add	r2, r1
   1324c:	4611      	mov	r1, r2
   1324e:	4798      	blx	r3
    mosi_->SetPinFunction(kPinSelect[pssp]);
   13250:	9b01      	ldr	r3, [sp, #4]
   13252:	6898      	ldr	r0, [r3, #8]
   13254:	9b01      	ldr	r3, [sp, #4]
   13256:	689b      	ldr	r3, [r3, #8]
   13258:	681b      	ldr	r3, [r3, #0]
   1325a:	681b      	ldr	r3, [r3, #0]
   1325c:	4924      	ldr	r1, [pc, #144]	; (132f0 <Ssp::Initialize()+0xd8>)
   1325e:	9a05      	ldr	r2, [sp, #20]
   13260:	440a      	add	r2, r1
   13262:	7812      	ldrb	r2, [r2, #0]
   13264:	4611      	mov	r1, r2
   13266:	4798      	blx	r3
    miso_->SetPinFunction(kPinSelect[pssp]);
   13268:	9b01      	ldr	r3, [sp, #4]
   1326a:	68d8      	ldr	r0, [r3, #12]
   1326c:	9b01      	ldr	r3, [sp, #4]
   1326e:	68db      	ldr	r3, [r3, #12]
   13270:	681b      	ldr	r3, [r3, #0]
   13272:	681b      	ldr	r3, [r3, #0]
   13274:	491e      	ldr	r1, [pc, #120]	; (132f0 <Ssp::Initialize()+0xd8>)
   13276:	9a05      	ldr	r2, [sp, #20]
   13278:	440a      	add	r2, r1
   1327a:	7812      	ldrb	r2, [r2, #0]
   1327c:	4611      	mov	r1, r2
   1327e:	4798      	blx	r3
    sck_->SetPinFunction(kPinSelect[pssp]);
   13280:	9b01      	ldr	r3, [sp, #4]
   13282:	6918      	ldr	r0, [r3, #16]
   13284:	9b01      	ldr	r3, [sp, #4]
   13286:	691b      	ldr	r3, [r3, #16]
   13288:	681b      	ldr	r3, [r3, #0]
   1328a:	681b      	ldr	r3, [r3, #0]
   1328c:	4918      	ldr	r1, [pc, #96]	; (132f0 <Ssp::Initialize()+0xd8>)
   1328e:	9a05      	ldr	r2, [sp, #20]
   13290:	440a      	add	r2, r1
   13292:	7812      	ldrb	r2, [r2, #0]
   13294:	4611      	mov	r1, r2
   13296:	4798      	blx	r3
    ssp_registers[pssp]->CR1 = bit::Set(ssp_registers[pssp]->CR1, kSspEnable);
   13298:	4a16      	ldr	r2, [pc, #88]	; (132f4 <Ssp::Initialize()+0xdc>)
   1329a:	9b05      	ldr	r3, [sp, #20]
   1329c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   132a0:	685b      	ldr	r3, [r3, #4]
   132a2:	4914      	ldr	r1, [pc, #80]	; (132f4 <Ssp::Initialize()+0xdc>)
   132a4:	9a05      	ldr	r2, [sp, #20]
   132a6:	f851 4022 	ldr.w	r4, [r1, r2, lsl #2]
   132aa:	9304      	str	r3, [sp, #16]
   132ac:	2301      	movs	r3, #1
   132ae:	9303      	str	r3, [sp, #12]
   132b0:	4633      	mov	r3, r6
   132b2:	4619      	mov	r1, r3
   132b4:	4810      	ldr	r0, [pc, #64]	; (132f8 <Ssp::Initialize()+0xe0>)
   132b6:	f003 fb1d 	bl	168f4 <__cyg_profile_func_enter>
  return target | (1 << position);
   132ba:	2201      	movs	r2, #1
   132bc:	9b03      	ldr	r3, [sp, #12]
   132be:	fa02 f303 	lsl.w	r3, r2, r3
   132c2:	461a      	mov	r2, r3
   132c4:	9b04      	ldr	r3, [sp, #16]
   132c6:	ea42 0503 	orr.w	r5, r2, r3
   132ca:	4633      	mov	r3, r6
   132cc:	4619      	mov	r1, r3
   132ce:	480a      	ldr	r0, [pc, #40]	; (132f8 <Ssp::Initialize()+0xe0>)
   132d0:	f003 fb24 	bl	1691c <__cyg_profile_func_exit>
   132d4:	6065      	str	r5, [r4, #4]
   132d6:	4633      	mov	r3, r6
   132d8:	4619      	mov	r1, r3
   132da:	4803      	ldr	r0, [pc, #12]	; (132e8 <Ssp::Initialize()+0xd0>)
   132dc:	f003 fb1e 	bl	1691c <__cyg_profile_func_exit>
  }
   132e0:	bf00      	nop
   132e2:	b006      	add	sp, #24
   132e4:	bd70      	pop	{r4, r5, r6, pc}
   132e6:	bf00      	nop
   132e8:	00013219 	.word	0x00013219
   132ec:	0001d55c 	.word	0x0001d55c
   132f0:	0001d510 	.word	0x0001d510
   132f4:	1000002c 	.word	0x1000002c
   132f8:	00014cd9 	.word	0x00014cd9

000132fc <Ssp::SetSpiMasterDefault()>:

  /// Sets up SSP peripheral as SPI master
  void SetSpiMasterDefault() override
   132fc:	b510      	push	{r4, lr}
   132fe:	b086      	sub	sp, #24
   13300:	4674      	mov	r4, lr
   13302:	9003      	str	r0, [sp, #12]
   13304:	4623      	mov	r3, r4
   13306:	4619      	mov	r1, r3
   13308:	4812      	ldr	r0, [pc, #72]	; (13354 <Ssp::SetSpiMasterDefault()+0x58>)
   1330a:	f003 faf3 	bl	168f4 <__cyg_profile_func_enter>
  {
    constexpr bool kHighPolarity  = 1;
   1330e:	2301      	movs	r3, #1
   13310:	f88d 3017 	strb.w	r3, [sp, #23]
    constexpr bool kPhase0        = 0;
   13314:	2300      	movs	r3, #0
   13316:	f88d 3016 	strb.w	r3, [sp, #22]
    constexpr uint8_t kScrDivider = 0;
   1331a:	2300      	movs	r3, #0
   1331c:	f88d 3015 	strb.w	r3, [sp, #21]
    constexpr uint8_t kPrescaler  = SJ2_SYSTEM_CLOCK_RATE_MHZ;
   13320:	2330      	movs	r3, #48	; 0x30
   13322:	f88d 3014 	strb.w	r3, [sp, #20]

    SetPeripheralMode(kMaster, kSpi, kEight);
   13326:	2307      	movs	r3, #7
   13328:	2200      	movs	r2, #0
   1332a:	2100      	movs	r1, #0
   1332c:	9803      	ldr	r0, [sp, #12]
   1332e:	f000 f85b 	bl	133e8 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)>
    SetClock(kHighPolarity, kPhase0, kScrDivider, kPrescaler);
   13332:	2330      	movs	r3, #48	; 0x30
   13334:	9300      	str	r3, [sp, #0]
   13336:	2300      	movs	r3, #0
   13338:	2200      	movs	r2, #0
   1333a:	2101      	movs	r1, #1
   1333c:	9803      	ldr	r0, [sp, #12]
   1333e:	f000 fa09 	bl	13754 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)>
   13342:	4623      	mov	r3, r4
   13344:	4619      	mov	r1, r3
   13346:	4803      	ldr	r0, [pc, #12]	; (13354 <Ssp::SetSpiMasterDefault()+0x58>)
   13348:	f003 fae8 	bl	1691c <__cyg_profile_func_exit>
  }
   1334c:	bf00      	nop
   1334e:	b006      	add	sp, #24
   13350:	bd10      	pop	{r4, pc}
   13352:	bf00      	nop
   13354:	000132fd 	.word	0x000132fd

00013358 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)>:
constexpr Type Value(Enum enum_type_value)
   13358:	b530      	push	{r4, r5, lr}
   1335a:	b083      	sub	sp, #12
   1335c:	4675      	mov	r5, lr
   1335e:	4603      	mov	r3, r0
   13360:	f88d 3007 	strb.w	r3, [sp, #7]
   13364:	462b      	mov	r3, r5
   13366:	4619      	mov	r1, r3
   13368:	4806      	ldr	r0, [pc, #24]	; (13384 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)+0x2c>)
   1336a:	f003 fac3 	bl	168f4 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   1336e:	f89d 4007 	ldrb.w	r4, [sp, #7]
   13372:	462b      	mov	r3, r5
   13374:	4619      	mov	r1, r3
   13376:	4803      	ldr	r0, [pc, #12]	; (13384 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)+0x2c>)
   13378:	f003 fad0 	bl	1691c <__cyg_profile_func_exit>
   1337c:	4623      	mov	r3, r4
}
   1337e:	4618      	mov	r0, r3
   13380:	b003      	add	sp, #12
   13382:	bd30      	pop	{r4, r5, pc}
   13384:	00013359 	.word	0x00013359

00013388 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)>:
constexpr Type Value(Enum enum_type_value)
   13388:	b530      	push	{r4, r5, lr}
   1338a:	b083      	sub	sp, #12
   1338c:	4675      	mov	r5, lr
   1338e:	4603      	mov	r3, r0
   13390:	f88d 3007 	strb.w	r3, [sp, #7]
   13394:	462b      	mov	r3, r5
   13396:	4619      	mov	r1, r3
   13398:	4806      	ldr	r0, [pc, #24]	; (133b4 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)+0x2c>)
   1339a:	f003 faab 	bl	168f4 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   1339e:	f89d 4007 	ldrb.w	r4, [sp, #7]
   133a2:	462b      	mov	r3, r5
   133a4:	4619      	mov	r1, r3
   133a6:	4803      	ldr	r0, [pc, #12]	; (133b4 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)+0x2c>)
   133a8:	f003 fab8 	bl	1691c <__cyg_profile_func_exit>
   133ac:	4623      	mov	r3, r4
}
   133ae:	4618      	mov	r0, r3
   133b0:	b003      	add	sp, #12
   133b2:	bd30      	pop	{r4, r5, pc}
   133b4:	00013389 	.word	0x00013389

000133b8 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)>:
constexpr Type Value(Enum enum_type_value)
   133b8:	b530      	push	{r4, r5, lr}
   133ba:	b083      	sub	sp, #12
   133bc:	4675      	mov	r5, lr
   133be:	4603      	mov	r3, r0
   133c0:	f88d 3007 	strb.w	r3, [sp, #7]
   133c4:	462b      	mov	r3, r5
   133c6:	4619      	mov	r1, r3
   133c8:	4806      	ldr	r0, [pc, #24]	; (133e4 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)+0x2c>)
   133ca:	f003 fa93 	bl	168f4 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   133ce:	f89d 4007 	ldrb.w	r4, [sp, #7]
   133d2:	462b      	mov	r3, r5
   133d4:	4619      	mov	r1, r3
   133d6:	4803      	ldr	r0, [pc, #12]	; (133e4 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)+0x2c>)
   133d8:	f003 faa0 	bl	1691c <__cyg_profile_func_exit>
   133dc:	4623      	mov	r3, r4
}
   133de:	4618      	mov	r0, r3
   133e0:	b003      	add	sp, #12
   133e2:	bd30      	pop	{r4, r5, pc}
   133e4:	000133b9 	.word	0x000133b9

000133e8 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)>:

  /// Sets the various modes for the Peripheral
  /// @param mode - master or slave mode
  /// @param frame - format for Peripheral data to use
  /// @param size - number of bits per frame
  void SetPeripheralMode(MasterSlaveMode mode, FrameMode frame,
   133e8:	b570      	push	{r4, r5, r6, lr}
   133ea:	b098      	sub	sp, #96	; 0x60
   133ec:	4674      	mov	r4, lr
   133ee:	9001      	str	r0, [sp, #4]
   133f0:	4608      	mov	r0, r1
   133f2:	4611      	mov	r1, r2
   133f4:	461a      	mov	r2, r3
   133f6:	4603      	mov	r3, r0
   133f8:	f88d 3003 	strb.w	r3, [sp, #3]
   133fc:	460b      	mov	r3, r1
   133fe:	f88d 3002 	strb.w	r3, [sp, #2]
   13402:	4613      	mov	r3, r2
   13404:	f88d 3001 	strb.w	r3, [sp, #1]
   13408:	4623      	mov	r3, r4
   1340a:	4619      	mov	r1, r3
   1340c:	4875      	ldr	r0, [pc, #468]	; (135e4 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x1fc>)
   1340e:	f003 fa71 	bl	168f4 <__cyg_profile_func_enter>
                         DataSize size) override
  {
    uint32_t pssp = util::Value(pssp_);
   13412:	9b01      	ldr	r3, [sp, #4]
   13414:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13416:	4618      	mov	r0, r3
   13418:	f7fd f970 	bl	106fc <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   1341c:	4603      	mov	r3, r0
   1341e:	9317      	str	r3, [sp, #92]	; 0x5c
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   13420:	9b01      	ldr	r3, [sp, #4]
   13422:	1d18      	adds	r0, r3, #4
   13424:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   13426:	009b      	lsls	r3, r3, #2
   13428:	4a6f      	ldr	r2, [pc, #444]	; (135e8 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x200>)
   1342a:	4413      	add	r3, r2
   1342c:	4619      	mov	r1, r3
   1342e:	f7fe f97f 	bl	11730 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>
    if (frame == kMicro)
   13432:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13436:	2b02      	cmp	r3, #2
   13438:	d102      	bne.n	13440 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x58>
    {
      size = kEight;
   1343a:	2307      	movs	r3, #7
   1343c:	f88d 3001 	strb.w	r3, [sp, #1]
    }
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, util::Value(size), kDataBit, 4);
   13440:	4a6a      	ldr	r2, [pc, #424]	; (135ec <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   13442:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   13444:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13448:	681e      	ldr	r6, [r3, #0]
   1344a:	f89d 3001 	ldrb.w	r3, [sp, #1]
   1344e:	4618      	mov	r0, r3
   13450:	f7ff ff82 	bl	13358 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)>
   13454:	4603      	mov	r3, r0
   13456:	4619      	mov	r1, r3
    ssp_registers[pssp]->CR0 =
   13458:	4a64      	ldr	r2, [pc, #400]	; (135ec <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   1345a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1345c:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   13460:	9608      	str	r6, [sp, #32]
   13462:	460b      	mov	r3, r1
   13464:	f88d 301f 	strb.w	r3, [sp, #31]
   13468:	2300      	movs	r3, #0
   1346a:	9306      	str	r3, [sp, #24]
   1346c:	2304      	movs	r3, #4
   1346e:	9305      	str	r3, [sp, #20]
   13470:	4623      	mov	r3, r4
   13472:	4619      	mov	r1, r3
   13474:	485e      	ldr	r0, [pc, #376]	; (135f0 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   13476:	f003 fa3d 	bl	168f4 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   1347a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1347e:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   13480:	2320      	movs	r3, #32
   13482:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   13484:	9b05      	ldr	r3, [sp, #20]
   13486:	f1c3 0320 	rsb	r3, r3, #32
   1348a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1348e:	fa22 f303 	lsr.w	r3, r2, r3
   13492:	9302      	str	r3, [sp, #8]
  target &= ~(mask << position);
   13494:	9a02      	ldr	r2, [sp, #8]
   13496:	9b06      	ldr	r3, [sp, #24]
   13498:	fa02 f303 	lsl.w	r3, r2, r3
   1349c:	43db      	mvns	r3, r3
   1349e:	9a08      	ldr	r2, [sp, #32]
   134a0:	4013      	ands	r3, r2
   134a2:	9308      	str	r3, [sp, #32]
  target |= (value & mask) << position;
   134a4:	f89d 201f 	ldrb.w	r2, [sp, #31]
   134a8:	9b02      	ldr	r3, [sp, #8]
   134aa:	401a      	ands	r2, r3
   134ac:	9b06      	ldr	r3, [sp, #24]
   134ae:	fa02 f303 	lsl.w	r3, r2, r3
   134b2:	9a08      	ldr	r2, [sp, #32]
   134b4:	4313      	orrs	r3, r2
   134b6:	9308      	str	r3, [sp, #32]
  return target;
   134b8:	9e08      	ldr	r6, [sp, #32]
   134ba:	4623      	mov	r3, r4
   134bc:	4619      	mov	r1, r3
   134be:	484c      	ldr	r0, [pc, #304]	; (135f0 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   134c0:	f003 fa2c 	bl	1691c <__cyg_profile_func_exit>
   134c4:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, util::Value(frame), kFrameBit, 2);
   134c6:	4a49      	ldr	r2, [pc, #292]	; (135ec <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   134c8:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   134ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   134ce:	681e      	ldr	r6, [r3, #0]
   134d0:	f89d 3002 	ldrb.w	r3, [sp, #2]
   134d4:	4618      	mov	r0, r3
   134d6:	f7ff ff57 	bl	13388 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)>
   134da:	4603      	mov	r3, r0
   134dc:	4619      	mov	r1, r3
    ssp_registers[pssp]->CR0 =
   134de:	4a43      	ldr	r2, [pc, #268]	; (135ec <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   134e0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   134e2:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   134e6:	960f      	str	r6, [sp, #60]	; 0x3c
   134e8:	460b      	mov	r3, r1
   134ea:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
   134ee:	2304      	movs	r3, #4
   134f0:	930d      	str	r3, [sp, #52]	; 0x34
   134f2:	2302      	movs	r3, #2
   134f4:	930c      	str	r3, [sp, #48]	; 0x30
   134f6:	4623      	mov	r3, r4
   134f8:	4619      	mov	r1, r3
   134fa:	483d      	ldr	r0, [pc, #244]	; (135f0 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   134fc:	f003 f9fa 	bl	168f4 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   13500:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   13504:	930b      	str	r3, [sp, #44]	; 0x2c
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   13506:	2320      	movs	r3, #32
   13508:	930a      	str	r3, [sp, #40]	; 0x28
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   1350a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1350c:	f1c3 0320 	rsb	r3, r3, #32
   13510:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   13514:	fa22 f303 	lsr.w	r3, r2, r3
   13518:	9309      	str	r3, [sp, #36]	; 0x24
  target &= ~(mask << position);
   1351a:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1351c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1351e:	fa02 f303 	lsl.w	r3, r2, r3
   13522:	43db      	mvns	r3, r3
   13524:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   13526:	4013      	ands	r3, r2
   13528:	930f      	str	r3, [sp, #60]	; 0x3c
  target |= (value & mask) << position;
   1352a:	f89d 203b 	ldrb.w	r2, [sp, #59]	; 0x3b
   1352e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   13530:	401a      	ands	r2, r3
   13532:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   13534:	fa02 f303 	lsl.w	r3, r2, r3
   13538:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   1353a:	4313      	orrs	r3, r2
   1353c:	930f      	str	r3, [sp, #60]	; 0x3c
  return target;
   1353e:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   13540:	4623      	mov	r3, r4
   13542:	4619      	mov	r1, r3
   13544:	482a      	ldr	r0, [pc, #168]	; (135f0 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   13546:	f003 f9e9 	bl	1691c <__cyg_profile_func_exit>
   1354a:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR1 = bit::Insert(
        ssp_registers[pssp]->CR1, util::Value(mode), kMasterModeBit, 1);
   1354c:	4a27      	ldr	r2, [pc, #156]	; (135ec <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   1354e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   13550:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13554:	685e      	ldr	r6, [r3, #4]
    ssp_registers[pssp]->CR1 = bit::Insert(
   13556:	f89d 3003 	ldrb.w	r3, [sp, #3]
   1355a:	4618      	mov	r0, r3
   1355c:	f7ff ff2c 	bl	133b8 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)>
   13560:	4603      	mov	r3, r0
   13562:	4619      	mov	r1, r3
   13564:	4a21      	ldr	r2, [pc, #132]	; (135ec <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   13566:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   13568:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   1356c:	9616      	str	r6, [sp, #88]	; 0x58
   1356e:	460b      	mov	r3, r1
   13570:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
   13574:	2302      	movs	r3, #2
   13576:	9314      	str	r3, [sp, #80]	; 0x50
   13578:	2301      	movs	r3, #1
   1357a:	9313      	str	r3, [sp, #76]	; 0x4c
   1357c:	4623      	mov	r3, r4
   1357e:	4619      	mov	r1, r3
   13580:	481b      	ldr	r0, [pc, #108]	; (135f0 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   13582:	f003 f9b7 	bl	168f4 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   13586:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1358a:	9312      	str	r3, [sp, #72]	; 0x48
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   1358c:	2320      	movs	r3, #32
   1358e:	9311      	str	r3, [sp, #68]	; 0x44
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   13590:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   13592:	f1c3 0320 	rsb	r3, r3, #32
   13596:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1359a:	fa22 f303 	lsr.w	r3, r2, r3
   1359e:	9310      	str	r3, [sp, #64]	; 0x40
  target &= ~(mask << position);
   135a0:	9a10      	ldr	r2, [sp, #64]	; 0x40
   135a2:	9b14      	ldr	r3, [sp, #80]	; 0x50
   135a4:	fa02 f303 	lsl.w	r3, r2, r3
   135a8:	43db      	mvns	r3, r3
   135aa:	9a16      	ldr	r2, [sp, #88]	; 0x58
   135ac:	4013      	ands	r3, r2
   135ae:	9316      	str	r3, [sp, #88]	; 0x58
  target |= (value & mask) << position;
   135b0:	f89d 2057 	ldrb.w	r2, [sp, #87]	; 0x57
   135b4:	9b10      	ldr	r3, [sp, #64]	; 0x40
   135b6:	401a      	ands	r2, r3
   135b8:	9b14      	ldr	r3, [sp, #80]	; 0x50
   135ba:	fa02 f303 	lsl.w	r3, r2, r3
   135be:	9a16      	ldr	r2, [sp, #88]	; 0x58
   135c0:	4313      	orrs	r3, r2
   135c2:	9316      	str	r3, [sp, #88]	; 0x58
  return target;
   135c4:	9e16      	ldr	r6, [sp, #88]	; 0x58
   135c6:	4623      	mov	r3, r4
   135c8:	4619      	mov	r1, r3
   135ca:	4809      	ldr	r0, [pc, #36]	; (135f0 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   135cc:	f003 f9a6 	bl	1691c <__cyg_profile_func_exit>
   135d0:	606e      	str	r6, [r5, #4]
   135d2:	4623      	mov	r3, r4
   135d4:	4619      	mov	r1, r3
   135d6:	4803      	ldr	r0, [pc, #12]	; (135e4 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x1fc>)
   135d8:	f003 f9a0 	bl	1691c <__cyg_profile_func_exit>
  }
   135dc:	bf00      	nop
   135de:	b018      	add	sp, #96	; 0x60
   135e0:	bd70      	pop	{r4, r5, r6, pc}
   135e2:	bf00      	nop
   135e4:	000133e9 	.word	0x000133e9
   135e8:	0001d55c 	.word	0x0001d55c
   135ec:	1000002c 	.word	0x1000002c
   135f0:	00014d15 	.word	0x00014d15

000135f4 <Ssp::GetPeripheralMode()>:
  /// Gets the Peripheral modes from registers
  /// @return - returns a 16-bit value as follows: 0000_000x 0xx0_xxxx
  ///       MasterSlaveMode = 1-bit @ bit 8
  ///       FrameMode       = 2-bit @ bit 5
  ///       DataSize        = 4-bit @ bit 0
  uint16_t GetPeripheralMode() override
   135f4:	b570      	push	{r4, r5, r6, lr}
   135f6:	b096      	sub	sp, #88	; 0x58
   135f8:	4674      	mov	r4, lr
   135fa:	9001      	str	r0, [sp, #4]
   135fc:	4623      	mov	r3, r4
   135fe:	4619      	mov	r1, r3
   13600:	4850      	ldr	r0, [pc, #320]	; (13744 <Ssp::GetPeripheralMode()+0x150>)
   13602:	f003 f977 	bl	168f4 <__cyg_profile_func_enter>
  {
    uint16_t return_val = 0;
   13606:	2300      	movs	r3, #0
   13608:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
    uint32_t pssp       = util::Value(pssp_);
   1360c:	9b01      	ldr	r3, [sp, #4]
   1360e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13610:	4618      	mov	r0, r3
   13612:	f7fd f873 	bl	106fc <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   13616:	4603      	mov	r3, r0
   13618:	9314      	str	r3, [sp, #80]	; 0x50
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   1361a:	9b01      	ldr	r3, [sp, #4]
   1361c:	1d18      	adds	r0, r3, #4
   1361e:	9b14      	ldr	r3, [sp, #80]	; 0x50
   13620:	009b      	lsls	r3, r3, #2
   13622:	4a49      	ldr	r2, [pc, #292]	; (13748 <Ssp::GetPeripheralMode()+0x154>)
   13624:	4413      	add	r3, r2
   13626:	4619      	mov	r1, r3
   13628:	f7fe f882 	bl	11730 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>

    return_val = static_cast<uint16_t>(
        (bit::Extract(ssp_registers[pssp]->CR0, kDataBit, 4)) +
   1362c:	4a47      	ldr	r2, [pc, #284]	; (1374c <Ssp::GetPeripheralMode()+0x158>)
   1362e:	9b14      	ldr	r3, [sp, #80]	; 0x50
   13630:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13634:	681b      	ldr	r3, [r3, #0]
   13636:	9307      	str	r3, [sp, #28]
   13638:	2300      	movs	r3, #0
   1363a:	9306      	str	r3, [sp, #24]
   1363c:	2304      	movs	r3, #4
   1363e:	9305      	str	r3, [sp, #20]
   13640:	4623      	mov	r3, r4
   13642:	4619      	mov	r1, r3
   13644:	4842      	ldr	r0, [pc, #264]	; (13750 <Ssp::GetPeripheralMode()+0x15c>)
   13646:	f003 f955 	bl	168f4 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   1364a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1364e:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   13650:	2320      	movs	r3, #32
   13652:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   13654:	9b05      	ldr	r3, [sp, #20]
   13656:	f1c3 0320 	rsb	r3, r3, #32
   1365a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1365e:	fa22 f303 	lsr.w	r3, r2, r3
   13662:	9302      	str	r3, [sp, #8]
  return (target >> position) & mask;
   13664:	9a07      	ldr	r2, [sp, #28]
   13666:	9b06      	ldr	r3, [sp, #24]
   13668:	40da      	lsrs	r2, r3
   1366a:	9b02      	ldr	r3, [sp, #8]
   1366c:	ea02 0503 	and.w	r5, r2, r3
   13670:	4623      	mov	r3, r4
   13672:	4619      	mov	r1, r3
   13674:	4836      	ldr	r0, [pc, #216]	; (13750 <Ssp::GetPeripheralMode()+0x15c>)
   13676:	f003 f951 	bl	1691c <__cyg_profile_func_exit>
   1367a:	b2ad      	uxth	r5, r5
        ((bit::Extract(ssp_registers[pssp]->CR0, kFrameBit, 2)) << 5) +
   1367c:	4a33      	ldr	r2, [pc, #204]	; (1374c <Ssp::GetPeripheralMode()+0x158>)
   1367e:	9b14      	ldr	r3, [sp, #80]	; 0x50
   13680:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13684:	681b      	ldr	r3, [r3, #0]
   13686:	930d      	str	r3, [sp, #52]	; 0x34
   13688:	2304      	movs	r3, #4
   1368a:	930c      	str	r3, [sp, #48]	; 0x30
   1368c:	2302      	movs	r3, #2
   1368e:	930b      	str	r3, [sp, #44]	; 0x2c
   13690:	4623      	mov	r3, r4
   13692:	4619      	mov	r1, r3
   13694:	482e      	ldr	r0, [pc, #184]	; (13750 <Ssp::GetPeripheralMode()+0x15c>)
   13696:	f003 f92d 	bl	168f4 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   1369a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1369e:	930a      	str	r3, [sp, #40]	; 0x28
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   136a0:	2320      	movs	r3, #32
   136a2:	9309      	str	r3, [sp, #36]	; 0x24
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   136a4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   136a6:	f1c3 0320 	rsb	r3, r3, #32
   136aa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   136ae:	fa22 f303 	lsr.w	r3, r2, r3
   136b2:	9308      	str	r3, [sp, #32]
  return (target >> position) & mask;
   136b4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   136b6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   136b8:	40da      	lsrs	r2, r3
   136ba:	9b08      	ldr	r3, [sp, #32]
   136bc:	ea02 0603 	and.w	r6, r2, r3
   136c0:	4623      	mov	r3, r4
   136c2:	4619      	mov	r1, r3
   136c4:	4822      	ldr	r0, [pc, #136]	; (13750 <Ssp::GetPeripheralMode()+0x15c>)
   136c6:	f003 f929 	bl	1691c <__cyg_profile_func_exit>
   136ca:	b2b3      	uxth	r3, r6
   136cc:	015b      	lsls	r3, r3, #5
   136ce:	b29b      	uxth	r3, r3
        (bit::Extract(ssp_registers[pssp]->CR0, kDataBit, 4)) +
   136d0:	442b      	add	r3, r5
   136d2:	b29d      	uxth	r5, r3
        ((bit::Extract(ssp_registers[pssp]->CR1, kMasterModeBit)) << 8));
   136d4:	4a1d      	ldr	r2, [pc, #116]	; (1374c <Ssp::GetPeripheralMode()+0x158>)
   136d6:	9b14      	ldr	r3, [sp, #80]	; 0x50
   136d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   136dc:	685b      	ldr	r3, [r3, #4]
   136de:	9313      	str	r3, [sp, #76]	; 0x4c
   136e0:	2302      	movs	r3, #2
   136e2:	9312      	str	r3, [sp, #72]	; 0x48
   136e4:	2301      	movs	r3, #1
   136e6:	9311      	str	r3, [sp, #68]	; 0x44
   136e8:	4623      	mov	r3, r4
   136ea:	4619      	mov	r1, r3
   136ec:	4818      	ldr	r0, [pc, #96]	; (13750 <Ssp::GetPeripheralMode()+0x15c>)
   136ee:	f003 f901 	bl	168f4 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   136f2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   136f6:	9310      	str	r3, [sp, #64]	; 0x40
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   136f8:	2320      	movs	r3, #32
   136fa:	930f      	str	r3, [sp, #60]	; 0x3c
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   136fc:	9b11      	ldr	r3, [sp, #68]	; 0x44
   136fe:	f1c3 0320 	rsb	r3, r3, #32
   13702:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   13706:	fa22 f303 	lsr.w	r3, r2, r3
   1370a:	930e      	str	r3, [sp, #56]	; 0x38
  return (target >> position) & mask;
   1370c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   1370e:	9b12      	ldr	r3, [sp, #72]	; 0x48
   13710:	40da      	lsrs	r2, r3
   13712:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   13714:	ea02 0603 	and.w	r6, r2, r3
   13718:	4623      	mov	r3, r4
   1371a:	4619      	mov	r1, r3
   1371c:	480c      	ldr	r0, [pc, #48]	; (13750 <Ssp::GetPeripheralMode()+0x15c>)
   1371e:	f003 f8fd 	bl	1691c <__cyg_profile_func_exit>
   13722:	b2b3      	uxth	r3, r6
   13724:	021b      	lsls	r3, r3, #8
   13726:	b29b      	uxth	r3, r3
    return_val = static_cast<uint16_t>(
   13728:	442b      	add	r3, r5
   1372a:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
    return return_val;
   1372e:	f8bd 5056 	ldrh.w	r5, [sp, #86]	; 0x56
   13732:	4623      	mov	r3, r4
   13734:	4619      	mov	r1, r3
   13736:	4803      	ldr	r0, [pc, #12]	; (13744 <Ssp::GetPeripheralMode()+0x150>)
   13738:	f003 f8f0 	bl	1691c <__cyg_profile_func_exit>
   1373c:	462b      	mov	r3, r5
  }
   1373e:	4618      	mov	r0, r3
   13740:	b016      	add	sp, #88	; 0x58
   13742:	bd70      	pop	{r4, r5, r6, pc}
   13744:	000135f5 	.word	0x000135f5
   13748:	0001d55c 	.word	0x0001d55c
   1374c:	1000002c 	.word	0x1000002c
   13750:	00014d89 	.word	0x00014d89

00013754 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)>:
  /// Sets the clock rate for the Peripheral
  /// @param polarity - maintain bus on clock 0=low or 1=high between frames
  /// @param phase - capture serial data on 0=first or 1=second clock cycle
  /// @param divider - see notes in SSP_Interface above
  /// @param prescaler - divides the PCLK, must be even value between 2-254
  void SetClock(bool polarity, bool phase, uint8_t divider,
   13754:	b570      	push	{r4, r5, r6, lr}
   13756:	b098      	sub	sp, #96	; 0x60
   13758:	4674      	mov	r4, lr
   1375a:	9001      	str	r0, [sp, #4]
   1375c:	4608      	mov	r0, r1
   1375e:	4611      	mov	r1, r2
   13760:	461a      	mov	r2, r3
   13762:	4603      	mov	r3, r0
   13764:	f88d 3003 	strb.w	r3, [sp, #3]
   13768:	460b      	mov	r3, r1
   1376a:	f88d 3002 	strb.w	r3, [sp, #2]
   1376e:	4613      	mov	r3, r2
   13770:	f88d 3001 	strb.w	r3, [sp, #1]
   13774:	4623      	mov	r3, r4
   13776:	4619      	mov	r1, r3
   13778:	486c      	ldr	r0, [pc, #432]	; (1392c <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1d8>)
   1377a:	f003 f8bb 	bl	168f4 <__cyg_profile_func_enter>
                uint8_t prescaler) override
  {
    uint32_t pssp = util::Value(pssp_);
   1377e:	9b01      	ldr	r3, [sp, #4]
   13780:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13782:	4618      	mov	r0, r3
   13784:	f7fc ffba 	bl	106fc <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   13788:	4603      	mov	r3, r0
   1378a:	9317      	str	r3, [sp, #92]	; 0x5c
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   1378c:	9b01      	ldr	r3, [sp, #4]
   1378e:	1d18      	adds	r0, r3, #4
   13790:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   13792:	009b      	lsls	r3, r3, #2
   13794:	4a66      	ldr	r2, [pc, #408]	; (13930 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1dc>)
   13796:	4413      	add	r3, r2
   13798:	4619      	mov	r1, r3
   1379a:	f7fd ffc9 	bl	11730 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>
    // first clear the appropriate registers
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, polarity, kPolarityBit, 1);
   1379e:	4a65      	ldr	r2, [pc, #404]	; (13934 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   137a0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   137a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   137a6:	681b      	ldr	r3, [r3, #0]
    ssp_registers[pssp]->CR0 =
   137a8:	4962      	ldr	r1, [pc, #392]	; (13934 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   137aa:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   137ac:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
   137b0:	9308      	str	r3, [sp, #32]
   137b2:	f89d 3003 	ldrb.w	r3, [sp, #3]
   137b6:	f88d 301f 	strb.w	r3, [sp, #31]
   137ba:	2306      	movs	r3, #6
   137bc:	9306      	str	r3, [sp, #24]
   137be:	2301      	movs	r3, #1
   137c0:	9305      	str	r3, [sp, #20]
   137c2:	4623      	mov	r3, r4
   137c4:	4619      	mov	r1, r3
   137c6:	485c      	ldr	r0, [pc, #368]	; (13938 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   137c8:	f003 f894 	bl	168f4 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   137cc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   137d0:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   137d2:	2320      	movs	r3, #32
   137d4:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   137d6:	9b05      	ldr	r3, [sp, #20]
   137d8:	f1c3 0320 	rsb	r3, r3, #32
   137dc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   137e0:	fa22 f303 	lsr.w	r3, r2, r3
   137e4:	9302      	str	r3, [sp, #8]
  target &= ~(mask << position);
   137e6:	9a02      	ldr	r2, [sp, #8]
   137e8:	9b06      	ldr	r3, [sp, #24]
   137ea:	fa02 f303 	lsl.w	r3, r2, r3
   137ee:	43db      	mvns	r3, r3
   137f0:	9a08      	ldr	r2, [sp, #32]
   137f2:	4013      	ands	r3, r2
   137f4:	9308      	str	r3, [sp, #32]
  target |= (value & mask) << position;
   137f6:	f89d 201f 	ldrb.w	r2, [sp, #31]
   137fa:	9b02      	ldr	r3, [sp, #8]
   137fc:	401a      	ands	r2, r3
   137fe:	9b06      	ldr	r3, [sp, #24]
   13800:	fa02 f303 	lsl.w	r3, r2, r3
   13804:	9a08      	ldr	r2, [sp, #32]
   13806:	4313      	orrs	r3, r2
   13808:	9308      	str	r3, [sp, #32]
  return target;
   1380a:	9e08      	ldr	r6, [sp, #32]
   1380c:	4623      	mov	r3, r4
   1380e:	4619      	mov	r1, r3
   13810:	4849      	ldr	r0, [pc, #292]	; (13938 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   13812:	f003 f883 	bl	1691c <__cyg_profile_func_exit>
   13816:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, phase, kPhaseBit, 1);
   13818:	4a46      	ldr	r2, [pc, #280]	; (13934 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   1381a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1381c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13820:	681b      	ldr	r3, [r3, #0]
    ssp_registers[pssp]->CR0 =
   13822:	4944      	ldr	r1, [pc, #272]	; (13934 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   13824:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   13826:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
   1382a:	930f      	str	r3, [sp, #60]	; 0x3c
   1382c:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13830:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
   13834:	2307      	movs	r3, #7
   13836:	930d      	str	r3, [sp, #52]	; 0x34
   13838:	2301      	movs	r3, #1
   1383a:	930c      	str	r3, [sp, #48]	; 0x30
   1383c:	4623      	mov	r3, r4
   1383e:	4619      	mov	r1, r3
   13840:	483d      	ldr	r0, [pc, #244]	; (13938 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   13842:	f003 f857 	bl	168f4 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   13846:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1384a:	930b      	str	r3, [sp, #44]	; 0x2c
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   1384c:	2320      	movs	r3, #32
   1384e:	930a      	str	r3, [sp, #40]	; 0x28
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   13850:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   13852:	f1c3 0320 	rsb	r3, r3, #32
   13856:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1385a:	fa22 f303 	lsr.w	r3, r2, r3
   1385e:	9309      	str	r3, [sp, #36]	; 0x24
  target &= ~(mask << position);
   13860:	9a09      	ldr	r2, [sp, #36]	; 0x24
   13862:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   13864:	fa02 f303 	lsl.w	r3, r2, r3
   13868:	43db      	mvns	r3, r3
   1386a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   1386c:	4013      	ands	r3, r2
   1386e:	930f      	str	r3, [sp, #60]	; 0x3c
  target |= (value & mask) << position;
   13870:	f89d 203b 	ldrb.w	r2, [sp, #59]	; 0x3b
   13874:	9b09      	ldr	r3, [sp, #36]	; 0x24
   13876:	401a      	ands	r2, r3
   13878:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1387a:	fa02 f303 	lsl.w	r3, r2, r3
   1387e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   13880:	4313      	orrs	r3, r2
   13882:	930f      	str	r3, [sp, #60]	; 0x3c
  return target;
   13884:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   13886:	4623      	mov	r3, r4
   13888:	4619      	mov	r1, r3
   1388a:	482b      	ldr	r0, [pc, #172]	; (13938 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   1388c:	f003 f846 	bl	1691c <__cyg_profile_func_exit>
   13890:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, divider, kDividerBit, 8);
   13892:	4a28      	ldr	r2, [pc, #160]	; (13934 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   13894:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   13896:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1389a:	681b      	ldr	r3, [r3, #0]
    ssp_registers[pssp]->CR0 =
   1389c:	4925      	ldr	r1, [pc, #148]	; (13934 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   1389e:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   138a0:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
   138a4:	9316      	str	r3, [sp, #88]	; 0x58
   138a6:	f89d 3001 	ldrb.w	r3, [sp, #1]
   138aa:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
   138ae:	2308      	movs	r3, #8
   138b0:	9314      	str	r3, [sp, #80]	; 0x50
   138b2:	2308      	movs	r3, #8
   138b4:	9313      	str	r3, [sp, #76]	; 0x4c
   138b6:	4623      	mov	r3, r4
   138b8:	4619      	mov	r1, r3
   138ba:	4820      	ldr	r0, [pc, #128]	; (1393c <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e8>)
   138bc:	f003 f81a 	bl	168f4 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   138c0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   138c4:	9312      	str	r3, [sp, #72]	; 0x48
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   138c6:	2320      	movs	r3, #32
   138c8:	9311      	str	r3, [sp, #68]	; 0x44
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   138ca:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   138cc:	f1c3 0320 	rsb	r3, r3, #32
   138d0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   138d4:	fa22 f303 	lsr.w	r3, r2, r3
   138d8:	9310      	str	r3, [sp, #64]	; 0x40
  target &= ~(mask << position);
   138da:	9a10      	ldr	r2, [sp, #64]	; 0x40
   138dc:	9b14      	ldr	r3, [sp, #80]	; 0x50
   138de:	fa02 f303 	lsl.w	r3, r2, r3
   138e2:	43db      	mvns	r3, r3
   138e4:	9a16      	ldr	r2, [sp, #88]	; 0x58
   138e6:	4013      	ands	r3, r2
   138e8:	9316      	str	r3, [sp, #88]	; 0x58
  target |= (value & mask) << position;
   138ea:	f89d 2057 	ldrb.w	r2, [sp, #87]	; 0x57
   138ee:	9b10      	ldr	r3, [sp, #64]	; 0x40
   138f0:	401a      	ands	r2, r3
   138f2:	9b14      	ldr	r3, [sp, #80]	; 0x50
   138f4:	fa02 f303 	lsl.w	r3, r2, r3
   138f8:	9a16      	ldr	r2, [sp, #88]	; 0x58
   138fa:	4313      	orrs	r3, r2
   138fc:	9316      	str	r3, [sp, #88]	; 0x58
  return target;
   138fe:	9e16      	ldr	r6, [sp, #88]	; 0x58
   13900:	4623      	mov	r3, r4
   13902:	4619      	mov	r1, r3
   13904:	480d      	ldr	r0, [pc, #52]	; (1393c <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e8>)
   13906:	f003 f809 	bl	1691c <__cyg_profile_func_exit>
   1390a:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CPSR = prescaler;
   1390c:	4a09      	ldr	r2, [pc, #36]	; (13934 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   1390e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   13910:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13914:	f89d 2070 	ldrb.w	r2, [sp, #112]	; 0x70
   13918:	611a      	str	r2, [r3, #16]
   1391a:	4623      	mov	r3, r4
   1391c:	4619      	mov	r1, r3
   1391e:	4803      	ldr	r0, [pc, #12]	; (1392c <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1d8>)
   13920:	f002 fffc 	bl	1691c <__cyg_profile_func_exit>
  }
   13924:	bf00      	nop
   13926:	b018      	add	sp, #96	; 0x60
   13928:	bd70      	pop	{r4, r5, r6, pc}
   1392a:	bf00      	nop
   1392c:	00013755 	.word	0x00013755
   13930:	0001d55c 	.word	0x0001d55c
   13934:	1000002c 	.word	0x1000002c
   13938:	00014ddd 	.word	0x00014ddd
   1393c:	00014d15 	.word	0x00014d15

00013940 <Ssp::GetClock()>:
  ///   0000_0000 0000_0x0x xxxx_xxxx xxxx_xxxx
  ///       polarity    = 1-bit @ bit 18
  ///       phase       = 1-bit @ bit 16
  ///       divider     = 8-bits @ bit 8
  ///       prescaler   = 8-bits @ bit 0
  uint32_t GetClock() override
   13940:	b570      	push	{r4, r5, r6, lr}
   13942:	b094      	sub	sp, #80	; 0x50
   13944:	4674      	mov	r4, lr
   13946:	9001      	str	r0, [sp, #4]
   13948:	4623      	mov	r3, r4
   1394a:	4619      	mov	r1, r3
   1394c:	4858      	ldr	r0, [pc, #352]	; (13ab0 <Ssp::GetClock()+0x170>)
   1394e:	f002 ffd1 	bl	168f4 <__cyg_profile_func_enter>
  {
    uint32_t return_val = 0;
   13952:	2300      	movs	r3, #0
   13954:	9313      	str	r3, [sp, #76]	; 0x4c
    uint32_t pssp       = util::Value(pssp_);
   13956:	9b01      	ldr	r3, [sp, #4]
   13958:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1395a:	4618      	mov	r0, r3
   1395c:	f7fc fece 	bl	106fc <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   13960:	4603      	mov	r3, r0
   13962:	9312      	str	r3, [sp, #72]	; 0x48
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   13964:	9b01      	ldr	r3, [sp, #4]
   13966:	1d18      	adds	r0, r3, #4
   13968:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1396a:	009b      	lsls	r3, r3, #2
   1396c:	4a51      	ldr	r2, [pc, #324]	; (13ab4 <Ssp::GetClock()+0x174>)
   1396e:	4413      	add	r3, r2
   13970:	4619      	mov	r1, r3
   13972:	f7fd fedd 	bl	11730 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>

    return_val =
        (bit::Extract(ssp_registers[pssp]->CPSR, kPrescalerBit, 8)) +
   13976:	4a50      	ldr	r2, [pc, #320]	; (13ab8 <Ssp::GetClock()+0x178>)
   13978:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1397a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1397e:	691b      	ldr	r3, [r3, #16]
   13980:	9307      	str	r3, [sp, #28]
   13982:	2300      	movs	r3, #0
   13984:	9306      	str	r3, [sp, #24]
   13986:	2308      	movs	r3, #8
   13988:	9305      	str	r3, [sp, #20]
   1398a:	4623      	mov	r3, r4
   1398c:	4619      	mov	r1, r3
   1398e:	484b      	ldr	r0, [pc, #300]	; (13abc <Ssp::GetClock()+0x17c>)
   13990:	f002 ffb0 	bl	168f4 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   13994:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   13998:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   1399a:	2320      	movs	r3, #32
   1399c:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   1399e:	9b05      	ldr	r3, [sp, #20]
   139a0:	f1c3 0320 	rsb	r3, r3, #32
   139a4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   139a8:	fa22 f303 	lsr.w	r3, r2, r3
   139ac:	9302      	str	r3, [sp, #8]
  return (target >> position) & mask;
   139ae:	9a07      	ldr	r2, [sp, #28]
   139b0:	9b06      	ldr	r3, [sp, #24]
   139b2:	40da      	lsrs	r2, r3
   139b4:	9b02      	ldr	r3, [sp, #8]
   139b6:	ea02 0503 	and.w	r5, r2, r3
   139ba:	4623      	mov	r3, r4
   139bc:	4619      	mov	r1, r3
   139be:	483f      	ldr	r0, [pc, #252]	; (13abc <Ssp::GetClock()+0x17c>)
   139c0:	f002 ffac 	bl	1691c <__cyg_profile_func_exit>
        ((bit::Extract(ssp_registers[pssp]->CR0, kDividerBit, 8)) << 8) +
   139c4:	4a3c      	ldr	r2, [pc, #240]	; (13ab8 <Ssp::GetClock()+0x178>)
   139c6:	9b12      	ldr	r3, [sp, #72]	; 0x48
   139c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   139cc:	681b      	ldr	r3, [r3, #0]
   139ce:	930d      	str	r3, [sp, #52]	; 0x34
   139d0:	2308      	movs	r3, #8
   139d2:	930c      	str	r3, [sp, #48]	; 0x30
   139d4:	2308      	movs	r3, #8
   139d6:	930b      	str	r3, [sp, #44]	; 0x2c
   139d8:	4623      	mov	r3, r4
   139da:	4619      	mov	r1, r3
   139dc:	4837      	ldr	r0, [pc, #220]	; (13abc <Ssp::GetClock()+0x17c>)
   139de:	f002 ff89 	bl	168f4 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   139e2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   139e6:	930a      	str	r3, [sp, #40]	; 0x28
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   139e8:	2320      	movs	r3, #32
   139ea:	9309      	str	r3, [sp, #36]	; 0x24
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   139ec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   139ee:	f1c3 0320 	rsb	r3, r3, #32
   139f2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   139f6:	fa22 f303 	lsr.w	r3, r2, r3
   139fa:	9308      	str	r3, [sp, #32]
  return (target >> position) & mask;
   139fc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   139fe:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   13a00:	40da      	lsrs	r2, r3
   13a02:	9b08      	ldr	r3, [sp, #32]
   13a04:	ea02 0603 	and.w	r6, r2, r3
   13a08:	4623      	mov	r3, r4
   13a0a:	4619      	mov	r1, r3
   13a0c:	482b      	ldr	r0, [pc, #172]	; (13abc <Ssp::GetClock()+0x17c>)
   13a0e:	f002 ff85 	bl	1691c <__cyg_profile_func_exit>
   13a12:	0233      	lsls	r3, r6, #8
        (bit::Extract(ssp_registers[pssp]->CPSR, kPrescalerBit, 8)) +
   13a14:	441d      	add	r5, r3
        ((bit::Read(ssp_registers[pssp]->CR0, kPhaseBit)) << 16) +
   13a16:	4a28      	ldr	r2, [pc, #160]	; (13ab8 <Ssp::GetClock()+0x178>)
   13a18:	9b12      	ldr	r3, [sp, #72]	; 0x48
   13a1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13a1e:	681b      	ldr	r3, [r3, #0]
   13a20:	930f      	str	r3, [sp, #60]	; 0x3c
   13a22:	2307      	movs	r3, #7
   13a24:	930e      	str	r3, [sp, #56]	; 0x38
   13a26:	4623      	mov	r3, r4
   13a28:	4619      	mov	r1, r3
   13a2a:	4825      	ldr	r0, [pc, #148]	; (13ac0 <Ssp::GetClock()+0x180>)
   13a2c:	f002 ff62 	bl	168f4 <__cyg_profile_func_enter>
  return static_cast<bool>(target & (1 << position));
   13a30:	2201      	movs	r2, #1
   13a32:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   13a34:	fa02 f303 	lsl.w	r3, r2, r3
   13a38:	461a      	mov	r2, r3
   13a3a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   13a3c:	4013      	ands	r3, r2
   13a3e:	2b00      	cmp	r3, #0
   13a40:	bf14      	ite	ne
   13a42:	2301      	movne	r3, #1
   13a44:	2300      	moveq	r3, #0
   13a46:	b2de      	uxtb	r6, r3
   13a48:	4623      	mov	r3, r4
   13a4a:	4619      	mov	r1, r3
   13a4c:	481c      	ldr	r0, [pc, #112]	; (13ac0 <Ssp::GetClock()+0x180>)
   13a4e:	f002 ff65 	bl	1691c <__cyg_profile_func_exit>
   13a52:	4633      	mov	r3, r6
   13a54:	041b      	lsls	r3, r3, #16
        ((bit::Extract(ssp_registers[pssp]->CR0, kDividerBit, 8)) << 8) +
   13a56:	441d      	add	r5, r3
        ((bit::Read(ssp_registers[pssp]->CR0, kPolarityBit)) << 18);
   13a58:	4a17      	ldr	r2, [pc, #92]	; (13ab8 <Ssp::GetClock()+0x178>)
   13a5a:	9b12      	ldr	r3, [sp, #72]	; 0x48
   13a5c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13a60:	681b      	ldr	r3, [r3, #0]
   13a62:	9311      	str	r3, [sp, #68]	; 0x44
   13a64:	2306      	movs	r3, #6
   13a66:	9310      	str	r3, [sp, #64]	; 0x40
   13a68:	4623      	mov	r3, r4
   13a6a:	4619      	mov	r1, r3
   13a6c:	4814      	ldr	r0, [pc, #80]	; (13ac0 <Ssp::GetClock()+0x180>)
   13a6e:	f002 ff41 	bl	168f4 <__cyg_profile_func_enter>
   13a72:	2201      	movs	r2, #1
   13a74:	9b10      	ldr	r3, [sp, #64]	; 0x40
   13a76:	fa02 f303 	lsl.w	r3, r2, r3
   13a7a:	461a      	mov	r2, r3
   13a7c:	9b11      	ldr	r3, [sp, #68]	; 0x44
   13a7e:	4013      	ands	r3, r2
   13a80:	2b00      	cmp	r3, #0
   13a82:	bf14      	ite	ne
   13a84:	2301      	movne	r3, #1
   13a86:	2300      	moveq	r3, #0
   13a88:	b2de      	uxtb	r6, r3
   13a8a:	4623      	mov	r3, r4
   13a8c:	4619      	mov	r1, r3
   13a8e:	480c      	ldr	r0, [pc, #48]	; (13ac0 <Ssp::GetClock()+0x180>)
   13a90:	f002 ff44 	bl	1691c <__cyg_profile_func_exit>
   13a94:	4633      	mov	r3, r6
   13a96:	049b      	lsls	r3, r3, #18
    return_val =
   13a98:	442b      	add	r3, r5
   13a9a:	9313      	str	r3, [sp, #76]	; 0x4c

    return return_val;
   13a9c:	9d13      	ldr	r5, [sp, #76]	; 0x4c
   13a9e:	4623      	mov	r3, r4
   13aa0:	4619      	mov	r1, r3
   13aa2:	4803      	ldr	r0, [pc, #12]	; (13ab0 <Ssp::GetClock()+0x170>)
   13aa4:	f002 ff3a 	bl	1691c <__cyg_profile_func_exit>
   13aa8:	462b      	mov	r3, r5
  }
   13aaa:	4618      	mov	r0, r3
   13aac:	b014      	add	sp, #80	; 0x50
   13aae:	bd70      	pop	{r4, r5, r6, pc}
   13ab0:	00013941 	.word	0x00013941
   13ab4:	0001d55c 	.word	0x0001d55c
   13ab8:	1000002c 	.word	0x1000002c
   13abc:	00014d89 	.word	0x00014d89
   13ac0:	00010f51 	.word	0x00010f51

00013ac4 <PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)>:
class PixelDisplayInterface
{
 public:
  SJ2_PACKED(struct) Color_t
  {
    Color_t(bool r, bool g, bool b, uint8_t a, uint8_t bits,
   13ac4:	b530      	push	{r4, r5, lr}
   13ac6:	b083      	sub	sp, #12
   13ac8:	4675      	mov	r5, lr
   13aca:	9001      	str	r0, [sp, #4]
   13acc:	4608      	mov	r0, r1
   13ace:	4611      	mov	r1, r2
   13ad0:	461a      	mov	r2, r3
   13ad2:	4603      	mov	r3, r0
   13ad4:	f88d 3003 	strb.w	r3, [sp, #3]
   13ad8:	460b      	mov	r3, r1
   13ada:	f88d 3002 	strb.w	r3, [sp, #2]
   13ade:	4613      	mov	r3, r2
   13ae0:	f88d 3001 	strb.w	r3, [sp, #1]
   13ae4:	462b      	mov	r3, r5
   13ae6:	4619      	mov	r1, r3
   13ae8:	481a      	ldr	r0, [pc, #104]	; (13b54 <PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)+0x90>)
   13aea:	f002 ff03 	bl	168f4 <__cyg_profile_func_enter>
          red(r),
          green(g),
          blue(b),
          padding(0),
          color_bits(bits),
          alpha(a)
   13aee:	9a01      	ldr	r2, [sp, #4]
   13af0:	7813      	ldrb	r3, [r2, #0]
   13af2:	f89d 1020 	ldrb.w	r1, [sp, #32]
   13af6:	f361 0300 	bfi	r3, r1, #0, #1
   13afa:	7013      	strb	r3, [r2, #0]
   13afc:	9a01      	ldr	r2, [sp, #4]
   13afe:	7813      	ldrb	r3, [r2, #0]
   13b00:	f89d 1003 	ldrb.w	r1, [sp, #3]
   13b04:	f361 0341 	bfi	r3, r1, #1, #1
   13b08:	7013      	strb	r3, [r2, #0]
   13b0a:	9a01      	ldr	r2, [sp, #4]
   13b0c:	7813      	ldrb	r3, [r2, #0]
   13b0e:	f89d 1002 	ldrb.w	r1, [sp, #2]
   13b12:	f361 0382 	bfi	r3, r1, #2, #1
   13b16:	7013      	strb	r3, [r2, #0]
   13b18:	9a01      	ldr	r2, [sp, #4]
   13b1a:	7813      	ldrb	r3, [r2, #0]
   13b1c:	f89d 1001 	ldrb.w	r1, [sp, #1]
   13b20:	f361 03c3 	bfi	r3, r1, #3, #1
   13b24:	7013      	strb	r3, [r2, #0]
   13b26:	9a01      	ldr	r2, [sp, #4]
   13b28:	7813      	ldrb	r3, [r2, #0]
   13b2a:	f36f 1307 	bfc	r3, #4, #4
   13b2e:	7013      	strb	r3, [r2, #0]
   13b30:	9b01      	ldr	r3, [sp, #4]
   13b32:	f89d 201c 	ldrb.w	r2, [sp, #28]
   13b36:	705a      	strb	r2, [r3, #1]
   13b38:	9b01      	ldr	r3, [sp, #4]
   13b3a:	f89d 2018 	ldrb.w	r2, [sp, #24]
   13b3e:	709a      	strb	r2, [r3, #2]
    {
    }
   13b40:	9c01      	ldr	r4, [sp, #4]
   13b42:	462b      	mov	r3, r5
   13b44:	4619      	mov	r1, r3
   13b46:	4803      	ldr	r0, [pc, #12]	; (13b54 <PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)+0x90>)
   13b48:	f002 fee8 	bl	1691c <__cyg_profile_func_exit>
   13b4c:	4623      	mov	r3, r4
   13b4e:	4618      	mov	r0, r3
   13b50:	b003      	add	sp, #12
   13b52:	bd30      	pop	{r4, r5, pc}
   13b54:	00013ac5 	.word	0x00013ac5

00013b58 <PixelDisplayInterface::Color_t::Color_t()>:
    Color_t()
   13b58:	b530      	push	{r4, r5, lr}
   13b5a:	b083      	sub	sp, #12
   13b5c:	4675      	mov	r5, lr
   13b5e:	9001      	str	r0, [sp, #4]
   13b60:	462b      	mov	r3, r5
   13b62:	4619      	mov	r1, r3
   13b64:	4815      	ldr	r0, [pc, #84]	; (13bbc <PixelDisplayInterface::Color_t::Color_t()+0x64>)
   13b66:	f002 fec5 	bl	168f4 <__cyg_profile_func_enter>
          red(false),
          green(false),
          blue(false),
          padding(0),
          color_bits(0),
          alpha(0)
   13b6a:	9a01      	ldr	r2, [sp, #4]
   13b6c:	7813      	ldrb	r3, [r2, #0]
   13b6e:	f36f 0300 	bfc	r3, #0, #1
   13b72:	7013      	strb	r3, [r2, #0]
   13b74:	9a01      	ldr	r2, [sp, #4]
   13b76:	7813      	ldrb	r3, [r2, #0]
   13b78:	f36f 0341 	bfc	r3, #1, #1
   13b7c:	7013      	strb	r3, [r2, #0]
   13b7e:	9a01      	ldr	r2, [sp, #4]
   13b80:	7813      	ldrb	r3, [r2, #0]
   13b82:	f36f 0382 	bfc	r3, #2, #1
   13b86:	7013      	strb	r3, [r2, #0]
   13b88:	9a01      	ldr	r2, [sp, #4]
   13b8a:	7813      	ldrb	r3, [r2, #0]
   13b8c:	f36f 03c3 	bfc	r3, #3, #1
   13b90:	7013      	strb	r3, [r2, #0]
   13b92:	9a01      	ldr	r2, [sp, #4]
   13b94:	7813      	ldrb	r3, [r2, #0]
   13b96:	f36f 1307 	bfc	r3, #4, #4
   13b9a:	7013      	strb	r3, [r2, #0]
   13b9c:	9b01      	ldr	r3, [sp, #4]
   13b9e:	2200      	movs	r2, #0
   13ba0:	705a      	strb	r2, [r3, #1]
   13ba2:	9b01      	ldr	r3, [sp, #4]
   13ba4:	2200      	movs	r2, #0
   13ba6:	709a      	strb	r2, [r3, #2]
    {
    }
   13ba8:	9c01      	ldr	r4, [sp, #4]
   13baa:	462b      	mov	r3, r5
   13bac:	4619      	mov	r1, r3
   13bae:	4803      	ldr	r0, [pc, #12]	; (13bbc <PixelDisplayInterface::Color_t::Color_t()+0x64>)
   13bb0:	f002 feb4 	bl	1691c <__cyg_profile_func_exit>
   13bb4:	4623      	mov	r3, r4
   13bb6:	4618      	mov	r0, r3
   13bb8:	b003      	add	sp, #12
   13bba:	bd30      	pop	{r4, r5, pc}
   13bbc:	00013b59 	.word	0x00013b59

00013bc0 <PixelDisplayInterface::Enable()>:
  /// @returns a color object with the available colors.
  virtual Color_t AvailableColors() = 0;
  /// Configure hardware peripherals and initialize external display hardware
  virtual void Initialize() = 0;
  /// Optional method to turn on display if applicable
  virtual void Enable() {}
   13bc0:	b510      	push	{r4, lr}
   13bc2:	b082      	sub	sp, #8
   13bc4:	4674      	mov	r4, lr
   13bc6:	9001      	str	r0, [sp, #4]
   13bc8:	4623      	mov	r3, r4
   13bca:	4619      	mov	r1, r3
   13bcc:	4805      	ldr	r0, [pc, #20]	; (13be4 <PixelDisplayInterface::Enable()+0x24>)
   13bce:	f002 fe91 	bl	168f4 <__cyg_profile_func_enter>
   13bd2:	4623      	mov	r3, r4
   13bd4:	4619      	mov	r1, r3
   13bd6:	4803      	ldr	r0, [pc, #12]	; (13be4 <PixelDisplayInterface::Enable()+0x24>)
   13bd8:	f002 fea0 	bl	1691c <__cyg_profile_func_exit>
   13bdc:	bf00      	nop
   13bde:	b002      	add	sp, #8
   13be0:	bd10      	pop	{r4, pc}
   13be2:	bf00      	nop
   13be4:	00013bc1 	.word	0x00013bc1

00013be8 <PixelDisplayInterface::Disable()>:
  /// Optional method to turn off display and potentially put it into a low
  /// power mode
  virtual void Disable() {}
   13be8:	b510      	push	{r4, lr}
   13bea:	b082      	sub	sp, #8
   13bec:	4674      	mov	r4, lr
   13bee:	9001      	str	r0, [sp, #4]
   13bf0:	4623      	mov	r3, r4
   13bf2:	4619      	mov	r1, r3
   13bf4:	4805      	ldr	r0, [pc, #20]	; (13c0c <PixelDisplayInterface::Disable()+0x24>)
   13bf6:	f002 fe7d 	bl	168f4 <__cyg_profile_func_enter>
   13bfa:	4623      	mov	r3, r4
   13bfc:	4619      	mov	r1, r3
   13bfe:	4803      	ldr	r0, [pc, #12]	; (13c0c <PixelDisplayInterface::Disable()+0x24>)
   13c00:	f002 fe8c 	bl	1691c <__cyg_profile_func_exit>
   13c04:	bf00      	nop
   13c06:	b002      	add	sp, #8
   13c08:	bd10      	pop	{r4, pc}
   13c0a:	bf00      	nop
   13c0c:	00013be9 	.word	0x00013be9

00013c10 <PixelDisplayInterface::Update()>:
  /// @param color the color of the pixel. May be ignored on monochrome screens.
  virtual void DrawPixel(int32_t x, int32_t y, Color_t color) = 0;
  /// Update screen to match framebuffer.
  /// Implementations of this method that do not use a framebuffer, possibly
  /// due to memory constrains, can refrain from implementing this function.
  virtual void Update() {}
   13c10:	b510      	push	{r4, lr}
   13c12:	b082      	sub	sp, #8
   13c14:	4674      	mov	r4, lr
   13c16:	9001      	str	r0, [sp, #4]
   13c18:	4623      	mov	r3, r4
   13c1a:	4619      	mov	r1, r3
   13c1c:	4805      	ldr	r0, [pc, #20]	; (13c34 <PixelDisplayInterface::Update()+0x24>)
   13c1e:	f002 fe69 	bl	168f4 <__cyg_profile_func_enter>
   13c22:	4623      	mov	r3, r4
   13c24:	4619      	mov	r1, r3
   13c26:	4803      	ldr	r0, [pc, #12]	; (13c34 <PixelDisplayInterface::Update()+0x24>)
   13c28:	f002 fe78 	bl	1691c <__cyg_profile_func_exit>
   13c2c:	bf00      	nop
   13c2e:	b002      	add	sp, #8
   13c30:	bd10      	pop	{r4, pc}
   13c32:	bf00      	nop
   13c34:	00013c11 	.word	0x00013c11

00013c38 <PixelDisplayInterface::PixelDisplayInterface()>:
class PixelDisplayInterface
   13c38:	b530      	push	{r4, r5, lr}
   13c3a:	b083      	sub	sp, #12
   13c3c:	4675      	mov	r5, lr
   13c3e:	9001      	str	r0, [sp, #4]
   13c40:	462b      	mov	r3, r5
   13c42:	4619      	mov	r1, r3
   13c44:	4807      	ldr	r0, [pc, #28]	; (13c64 <PixelDisplayInterface::PixelDisplayInterface()+0x2c>)
   13c46:	f002 fe55 	bl	168f4 <__cyg_profile_func_enter>
   13c4a:	4a07      	ldr	r2, [pc, #28]	; (13c68 <PixelDisplayInterface::PixelDisplayInterface()+0x30>)
   13c4c:	9b01      	ldr	r3, [sp, #4]
   13c4e:	601a      	str	r2, [r3, #0]
   13c50:	9c01      	ldr	r4, [sp, #4]
   13c52:	462b      	mov	r3, r5
   13c54:	4619      	mov	r1, r3
   13c56:	4803      	ldr	r0, [pc, #12]	; (13c64 <PixelDisplayInterface::PixelDisplayInterface()+0x2c>)
   13c58:	f002 fe60 	bl	1691c <__cyg_profile_func_exit>
   13c5c:	4623      	mov	r3, r4
   13c5e:	4618      	mov	r0, r3
   13c60:	b003      	add	sp, #12
   13c62:	bd30      	pop	{r4, r5, pc}
   13c64:	00013c39 	.word	0x00013c39
   13c68:	0001d59c 	.word	0x0001d59c

00013c6c <Ssd1306::Ssd1306()>:
  constexpr Ssd1306()
   13c6c:	b530      	push	{r4, r5, lr}
   13c6e:	b083      	sub	sp, #12
   13c70:	4675      	mov	r5, lr
   13c72:	9001      	str	r0, [sp, #4]
   13c74:	462b      	mov	r3, r5
   13c76:	4619      	mov	r1, r3
   13c78:	481f      	ldr	r0, [pc, #124]	; (13cf8 <Ssd1306::Ssd1306()+0x8c>)
   13c7a:	f002 fe3b 	bl	168f4 <__cyg_profile_func_enter>
        bitmap_{}
   13c7e:	9b01      	ldr	r3, [sp, #4]
   13c80:	4618      	mov	r0, r3
   13c82:	f7ff ffd9 	bl	13c38 <PixelDisplayInterface::PixelDisplayInterface()>
   13c86:	4a1d      	ldr	r2, [pc, #116]	; (13cfc <Ssd1306::Ssd1306()+0x90>)
   13c88:	9b01      	ldr	r3, [sp, #4]
   13c8a:	601a      	str	r2, [r3, #0]
      : ssp_(&ssp1_),
   13c8c:	9b01      	ldr	r3, [sp, #4]
   13c8e:	f103 0210 	add.w	r2, r3, #16
        bitmap_{}
   13c92:	9b01      	ldr	r3, [sp, #4]
   13c94:	605a      	str	r2, [r3, #4]
        cs_(&cs_gpio_),
   13c96:	9b01      	ldr	r3, [sp, #4]
   13c98:	f103 0240 	add.w	r2, r3, #64	; 0x40
        bitmap_{}
   13c9c:	9b01      	ldr	r3, [sp, #4]
   13c9e:	609a      	str	r2, [r3, #8]
        dc_(&dc_gpio_),
   13ca0:	9b01      	ldr	r3, [sp, #4]
   13ca2:	f103 0254 	add.w	r2, r3, #84	; 0x54
        bitmap_{}
   13ca6:	9b01      	ldr	r3, [sp, #4]
   13ca8:	60da      	str	r2, [r3, #12]
   13caa:	9b01      	ldr	r3, [sp, #4]
   13cac:	3310      	adds	r3, #16
   13cae:	2101      	movs	r1, #1
   13cb0:	4618      	mov	r0, r3
   13cb2:	f7ff fa3f 	bl	13134 <Ssp::Ssp(Ssp::Peripheral)>
   13cb6:	9b01      	ldr	r3, [sp, #4]
   13cb8:	3340      	adds	r3, #64	; 0x40
   13cba:	2216      	movs	r2, #22
   13cbc:	2101      	movs	r1, #1
   13cbe:	4618      	mov	r0, r3
   13cc0:	f7fe fc08 	bl	124d4 <Gpio::Gpio(unsigned char, unsigned char)>
   13cc4:	9b01      	ldr	r3, [sp, #4]
   13cc6:	3354      	adds	r3, #84	; 0x54
   13cc8:	2219      	movs	r2, #25
   13cca:	2101      	movs	r1, #1
   13ccc:	4618      	mov	r0, r3
   13cce:	f7fe fc01 	bl	124d4 <Gpio::Gpio(unsigned char, unsigned char)>
   13cd2:	9b01      	ldr	r3, [sp, #4]
   13cd4:	3368      	adds	r3, #104	; 0x68
   13cd6:	f240 62c1 	movw	r2, #1729	; 0x6c1
   13cda:	2100      	movs	r1, #0
   13cdc:	4618      	mov	r0, r3
   13cde:	f008 fe2b 	bl	1c938 <memset>
  }
   13ce2:	9c01      	ldr	r4, [sp, #4]
   13ce4:	462b      	mov	r3, r5
   13ce6:	4619      	mov	r1, r3
   13ce8:	4803      	ldr	r0, [pc, #12]	; (13cf8 <Ssd1306::Ssd1306()+0x8c>)
   13cea:	f002 fe17 	bl	1691c <__cyg_profile_func_exit>
   13cee:	4623      	mov	r3, r4
   13cf0:	4618      	mov	r0, r3
   13cf2:	b003      	add	sp, #12
   13cf4:	bd30      	pop	{r4, r5, pc}
   13cf6:	bf00      	nop
   13cf8:	00013c6d 	.word	0x00013c6d
   13cfc:	0001d570 	.word	0x0001d570

00013d00 <Ssd1306::GetWidth()>:
  size_t GetWidth() final override
   13d00:	b530      	push	{r4, r5, lr}
   13d02:	b083      	sub	sp, #12
   13d04:	4675      	mov	r5, lr
   13d06:	9001      	str	r0, [sp, #4]
   13d08:	462b      	mov	r3, r5
   13d0a:	4619      	mov	r1, r3
   13d0c:	4806      	ldr	r0, [pc, #24]	; (13d28 <Ssd1306::GetWidth()+0x28>)
   13d0e:	f002 fdf1 	bl	168f4 <__cyg_profile_func_enter>
    return kWidth;
   13d12:	2480      	movs	r4, #128	; 0x80
   13d14:	462b      	mov	r3, r5
   13d16:	4619      	mov	r1, r3
   13d18:	4803      	ldr	r0, [pc, #12]	; (13d28 <Ssd1306::GetWidth()+0x28>)
   13d1a:	f002 fdff 	bl	1691c <__cyg_profile_func_exit>
   13d1e:	4623      	mov	r3, r4
  }
   13d20:	4618      	mov	r0, r3
   13d22:	b003      	add	sp, #12
   13d24:	bd30      	pop	{r4, r5, pc}
   13d26:	bf00      	nop
   13d28:	00013d01 	.word	0x00013d01

00013d2c <Ssd1306::GetHeight()>:
  size_t GetHeight() final override
   13d2c:	b530      	push	{r4, r5, lr}
   13d2e:	b083      	sub	sp, #12
   13d30:	4675      	mov	r5, lr
   13d32:	9001      	str	r0, [sp, #4]
   13d34:	462b      	mov	r3, r5
   13d36:	4619      	mov	r1, r3
   13d38:	4806      	ldr	r0, [pc, #24]	; (13d54 <Ssd1306::GetHeight()+0x28>)
   13d3a:	f002 fddb 	bl	168f4 <__cyg_profile_func_enter>
    return kHeight;
   13d3e:	2440      	movs	r4, #64	; 0x40
   13d40:	462b      	mov	r3, r5
   13d42:	4619      	mov	r1, r3
   13d44:	4803      	ldr	r0, [pc, #12]	; (13d54 <Ssd1306::GetHeight()+0x28>)
   13d46:	f002 fde9 	bl	1691c <__cyg_profile_func_exit>
   13d4a:	4623      	mov	r3, r4
  }
   13d4c:	4618      	mov	r0, r3
   13d4e:	b003      	add	sp, #12
   13d50:	bd30      	pop	{r4, r5, pc}
   13d52:	bf00      	nop
   13d54:	00013d2d 	.word	0x00013d2d

00013d58 <Ssd1306::AvailableColors()>:
  Color_t AvailableColors() final override
   13d58:	b510      	push	{r4, lr}
   13d5a:	b088      	sub	sp, #32
   13d5c:	4674      	mov	r4, lr
   13d5e:	9005      	str	r0, [sp, #20]
   13d60:	4623      	mov	r3, r4
   13d62:	4619      	mov	r1, r3
   13d64:	4815      	ldr	r0, [pc, #84]	; (13dbc <Ssd1306::AvailableColors()+0x64>)
   13d66:	f002 fdc5 	bl	168f4 <__cyg_profile_func_enter>
    return Color_t(/* Red        = */ 1,
   13d6a:	a807      	add	r0, sp, #28
   13d6c:	2301      	movs	r3, #1
   13d6e:	9302      	str	r3, [sp, #8]
   13d70:	2301      	movs	r3, #1
   13d72:	9301      	str	r3, [sp, #4]
   13d74:	2301      	movs	r3, #1
   13d76:	9300      	str	r3, [sp, #0]
   13d78:	2301      	movs	r3, #1
   13d7a:	2201      	movs	r2, #1
   13d7c:	2101      	movs	r1, #1
   13d7e:	f7ff fea1 	bl	13ac4 <PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)>
                   /* Monochrome = */ true);
   13d82:	ab06      	add	r3, sp, #24
   13d84:	aa07      	add	r2, sp, #28
   13d86:	6812      	ldr	r2, [r2, #0]
   13d88:	4611      	mov	r1, r2
   13d8a:	8019      	strh	r1, [r3, #0]
   13d8c:	3302      	adds	r3, #2
   13d8e:	0c12      	lsrs	r2, r2, #16
   13d90:	701a      	strb	r2, [r3, #0]
   13d92:	4623      	mov	r3, r4
   13d94:	4619      	mov	r1, r3
   13d96:	4809      	ldr	r0, [pc, #36]	; (13dbc <Ssd1306::AvailableColors()+0x64>)
   13d98:	f002 fdc0 	bl	1691c <__cyg_profile_func_exit>
   13d9c:	2300      	movs	r3, #0
   13d9e:	f89d 2018 	ldrb.w	r2, [sp, #24]
   13da2:	f362 0307 	bfi	r3, r2, #0, #8
   13da6:	f89d 2019 	ldrb.w	r2, [sp, #25]
   13daa:	f362 230f 	bfi	r3, r2, #8, #8
   13dae:	f89d 201a 	ldrb.w	r2, [sp, #26]
   13db2:	f362 4317 	bfi	r3, r2, #16, #8
  }
   13db6:	4618      	mov	r0, r3
   13db8:	b008      	add	sp, #32
   13dba:	bd10      	pop	{r4, pc}
   13dbc:	00013d59 	.word	0x00013d59

00013dc0 <Ssd1306::InitializationPanel()>:

  void InitializationPanel()
   13dc0:	b510      	push	{r4, lr}
   13dc2:	b082      	sub	sp, #8
   13dc4:	4674      	mov	r4, lr
   13dc6:	9001      	str	r0, [sp, #4]
   13dc8:	4623      	mov	r3, r4
   13dca:	4619      	mov	r1, r3
   13dcc:	4837      	ldr	r0, [pc, #220]	; (13eac <Ssd1306::InitializationPanel()+0xec>)
   13dce:	f002 fd91 	bl	168f4 <__cyg_profile_func_enter>
  {
    // This sequence of commands was found in:
    //   datasheets/OLED-display/ER-OLED0.96-1_Series_Datasheet.pdf, page 15

    // turn off oled panel
    Write(0xAE, Transaction::kCommand);
   13dd2:	2301      	movs	r3, #1
   13dd4:	2200      	movs	r2, #0
   13dd6:	21ae      	movs	r1, #174	; 0xae
   13dd8:	9801      	ldr	r0, [sp, #4]
   13dda:	f7fc fd17 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // set display clock divide ratio/oscillator frequency
    // set divide ratio
    Write(0xD5'80, Transaction::kCommand, 2);
   13dde:	2302      	movs	r3, #2
   13de0:	2200      	movs	r2, #0
   13de2:	f24d 5180 	movw	r1, #54656	; 0xd580
   13de6:	9801      	ldr	r0, [sp, #4]
   13de8:	f7fc fd10 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // set multiplex ratio(1 to 64)
    // 1/64 duty
    Write(0xA8'3F, Transaction::kCommand, 2);
   13dec:	2302      	movs	r3, #2
   13dee:	2200      	movs	r2, #0
   13df0:	f64a 013f 	movw	r1, #43071	; 0xa83f
   13df4:	9801      	ldr	r0, [sp, #4]
   13df6:	f7fc fd09 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // set display offset = not offset
    Write(0xD3'00, Transaction::kCommand, 2);
   13dfa:	2302      	movs	r3, #2
   13dfc:	2200      	movs	r2, #0
   13dfe:	f44f 4153 	mov.w	r1, #54016	; 0xd300
   13e02:	9801      	ldr	r0, [sp, #4]
   13e04:	f7fc fd02 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Set display start line
    Write(0x40, Transaction::kCommand);
   13e08:	2301      	movs	r3, #1
   13e0a:	2200      	movs	r2, #0
   13e0c:	2140      	movs	r1, #64	; 0x40
   13e0e:	9801      	ldr	r0, [sp, #4]
   13e10:	f7fc fcfc 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Disable Charge Pump
    Write(0x8D'14, Transaction::kCommand, 2);
   13e14:	2302      	movs	r3, #2
   13e16:	2200      	movs	r2, #0
   13e18:	f648 5114 	movw	r1, #36116	; 0x8d14
   13e1c:	9801      	ldr	r0, [sp, #4]
   13e1e:	f7fc fcf5 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // set segment re-map 128 to 0
    Write(0xA1, Transaction::kCommand);
   13e22:	2301      	movs	r3, #1
   13e24:	2200      	movs	r2, #0
   13e26:	21a1      	movs	r1, #161	; 0xa1
   13e28:	9801      	ldr	r0, [sp, #4]
   13e2a:	f7fc fcef 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Set COM Output Scan Direction 64 to 0
    Write(0xC8, Transaction::kCommand);
   13e2e:	2301      	movs	r3, #1
   13e30:	2200      	movs	r2, #0
   13e32:	21c8      	movs	r1, #200	; 0xc8
   13e34:	9801      	ldr	r0, [sp, #4]
   13e36:	f7fc fce9 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // set com pins hardware configuration
    Write(0xDA'12, Transaction::kCommand, 2);
   13e3a:	2302      	movs	r3, #2
   13e3c:	2200      	movs	r2, #0
   13e3e:	f64d 2112 	movw	r1, #55826	; 0xda12
   13e42:	9801      	ldr	r0, [sp, #4]
   13e44:	f7fc fce2 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // set contrast control register
    Write(0x81'CF, Transaction::kCommand, 2);
   13e48:	2302      	movs	r3, #2
   13e4a:	2200      	movs	r2, #0
   13e4c:	f248 11cf 	movw	r1, #33231	; 0x81cf
   13e50:	9801      	ldr	r0, [sp, #4]
   13e52:	f7fc fcdb 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Set pre-charge period
    Write(0xD9'F1, Transaction::kCommand, 2);
   13e56:	2302      	movs	r3, #2
   13e58:	2200      	movs	r2, #0
   13e5a:	f64d 11f1 	movw	r1, #55793	; 0xd9f1
   13e5e:	9801      	ldr	r0, [sp, #4]
   13e60:	f7fc fcd4 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Set Vcomh
    Write(0xDB'40, Transaction::kCommand, 2);
   13e64:	2302      	movs	r3, #2
   13e66:	2200      	movs	r2, #0
   13e68:	f64d 3140 	movw	r1, #56128	; 0xdb40
   13e6c:	9801      	ldr	r0, [sp, #4]
   13e6e:	f7fc fccd 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    SetHorizontalAddressMode();
   13e72:	9801      	ldr	r0, [sp, #4]
   13e74:	f000 f85e 	bl	13f34 <Ssd1306::SetHorizontalAddressMode()>

    // Enable entire display
    Write(0xA4, Transaction::kCommand);
   13e78:	2301      	movs	r3, #1
   13e7a:	2200      	movs	r2, #0
   13e7c:	21a4      	movs	r1, #164	; 0xa4
   13e7e:	9801      	ldr	r0, [sp, #4]
   13e80:	f7fc fcc4 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Set display to normal colors
    Write(0xA6, Transaction::kCommand);
   13e84:	2301      	movs	r3, #1
   13e86:	2200      	movs	r2, #0
   13e88:	21a6      	movs	r1, #166	; 0xa6
   13e8a:	9801      	ldr	r0, [sp, #4]
   13e8c:	f7fc fcbe 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Set Display On
    Write(0xAF, Transaction::kCommand);
   13e90:	2301      	movs	r3, #1
   13e92:	2200      	movs	r2, #0
   13e94:	21af      	movs	r1, #175	; 0xaf
   13e96:	9801      	ldr	r0, [sp, #4]
   13e98:	f7fc fcb8 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>
   13e9c:	4623      	mov	r3, r4
   13e9e:	4619      	mov	r1, r3
   13ea0:	4802      	ldr	r0, [pc, #8]	; (13eac <Ssd1306::InitializationPanel()+0xec>)
   13ea2:	f002 fd3b 	bl	1691c <__cyg_profile_func_exit>
  }
   13ea6:	bf00      	nop
   13ea8:	b002      	add	sp, #8
   13eaa:	bd10      	pop	{r4, pc}
   13eac:	00013dc1 	.word	0x00013dc1

00013eb0 <Ssd1306::Initialize()>:

  void Initialize() final override
   13eb0:	b510      	push	{r4, lr}
   13eb2:	b084      	sub	sp, #16
   13eb4:	4674      	mov	r4, lr
   13eb6:	9003      	str	r0, [sp, #12]
   13eb8:	4623      	mov	r3, r4
   13eba:	4619      	mov	r1, r3
   13ebc:	481c      	ldr	r0, [pc, #112]	; (13f30 <Ssd1306::Initialize()+0x80>)
   13ebe:	f002 fd19 	bl	168f4 <__cyg_profile_func_enter>
  {
    cs_->SetAsOutput();
   13ec2:	9b03      	ldr	r3, [sp, #12]
   13ec4:	689b      	ldr	r3, [r3, #8]
   13ec6:	4618      	mov	r0, r3
   13ec8:	f7fe fb80 	bl	125cc <Gpio::SetAsOutput()>
    dc_->SetAsOutput();
   13ecc:	9b03      	ldr	r3, [sp, #12]
   13ece:	68db      	ldr	r3, [r3, #12]
   13ed0:	4618      	mov	r0, r3
   13ed2:	f7fe fb7b 	bl	125cc <Gpio::SetAsOutput()>
    cs_->SetHigh();
   13ed6:	9b03      	ldr	r3, [sp, #12]
   13ed8:	689b      	ldr	r3, [r3, #8]
   13eda:	4618      	mov	r0, r3
   13edc:	f7fc fb88 	bl	105f0 <Gpio::SetHigh()>
    dc_->SetHigh();
   13ee0:	9b03      	ldr	r3, [sp, #12]
   13ee2:	68db      	ldr	r3, [r3, #12]
   13ee4:	4618      	mov	r0, r3
   13ee6:	f7fc fb83 	bl	105f0 <Gpio::SetHigh()>

    ssp_->SetPeripheralMode(Ssp::MasterSlaveMode::kMaster, Ssp::FrameMode::kSpi,
   13eea:	9b03      	ldr	r3, [sp, #12]
   13eec:	6858      	ldr	r0, [r3, #4]
   13eee:	2307      	movs	r3, #7
   13ef0:	2200      	movs	r2, #0
   13ef2:	2100      	movs	r1, #0
   13ef4:	f7ff fa78 	bl	133e8 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)>
                            Ssp::DataSize::kEight);
    // Set speed to 1Mhz by dividing by 1 * ClockFrequencyInMHz.
    ssp_->SetClock(false, false, 1, config::kSystemClockRateMhz/3);
   13ef8:	9b03      	ldr	r3, [sp, #12]
   13efa:	6858      	ldr	r0, [r3, #4]
   13efc:	2310      	movs	r3, #16
   13efe:	9300      	str	r3, [sp, #0]
   13f00:	2301      	movs	r3, #1
   13f02:	2200      	movs	r2, #0
   13f04:	2100      	movs	r1, #0
   13f06:	f7ff fc25 	bl	13754 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)>
    ssp_->Initialize();
   13f0a:	9b03      	ldr	r3, [sp, #12]
   13f0c:	685b      	ldr	r3, [r3, #4]
   13f0e:	4618      	mov	r0, r3
   13f10:	f7ff f982 	bl	13218 <Ssp::Initialize()>

    Clear();
   13f14:	9803      	ldr	r0, [sp, #12]
   13f16:	f000 f837 	bl	13f88 <Ssd1306::Clear()>
    InitializationPanel();
   13f1a:	9803      	ldr	r0, [sp, #12]
   13f1c:	f7ff ff50 	bl	13dc0 <Ssd1306::InitializationPanel()>
   13f20:	4623      	mov	r3, r4
   13f22:	4619      	mov	r1, r3
   13f24:	4802      	ldr	r0, [pc, #8]	; (13f30 <Ssd1306::Initialize()+0x80>)
   13f26:	f002 fcf9 	bl	1691c <__cyg_profile_func_exit>
  }
   13f2a:	bf00      	nop
   13f2c:	b004      	add	sp, #16
   13f2e:	bd10      	pop	{r4, pc}
   13f30:	00013eb1 	.word	0x00013eb1

00013f34 <Ssd1306::SetHorizontalAddressMode()>:

  void SetHorizontalAddressMode()
   13f34:	b510      	push	{r4, lr}
   13f36:	b082      	sub	sp, #8
   13f38:	4674      	mov	r4, lr
   13f3a:	9001      	str	r0, [sp, #4]
   13f3c:	4623      	mov	r3, r4
   13f3e:	4619      	mov	r1, r3
   13f40:	480e      	ldr	r0, [pc, #56]	; (13f7c <Ssd1306::SetHorizontalAddressMode()+0x48>)
   13f42:	f002 fcd7 	bl	168f4 <__cyg_profile_func_enter>
  {
    // Set Addressing mode
    // Addressing mode = Horizontal Mode (0b00)
    Write(0x20'00, Transaction::kCommand, 2);
   13f46:	2302      	movs	r3, #2
   13f48:	2200      	movs	r2, #0
   13f4a:	f44f 5100 	mov.w	r1, #8192	; 0x2000
   13f4e:	9801      	ldr	r0, [sp, #4]
   13f50:	f7fc fc5c 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>
    // Set Column Addresses
    // Set Column Address start = Column 0
    // Set Column Address start = Column 127
    Write(0x21'00'7F, Transaction::kCommand, 3);
   13f54:	2303      	movs	r3, #3
   13f56:	2200      	movs	r2, #0
   13f58:	4909      	ldr	r1, [pc, #36]	; (13f80 <Ssd1306::SetHorizontalAddressMode()+0x4c>)
   13f5a:	9801      	ldr	r0, [sp, #4]
   13f5c:	f7fc fc56 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>
    // Set Page Addresses
    // Set Page Address start = Page 0
    // Set Page Address start = Page 7
    Write(0x22'00'07, Transaction::kCommand, 3);
   13f60:	2303      	movs	r3, #3
   13f62:	2200      	movs	r2, #0
   13f64:	4907      	ldr	r1, [pc, #28]	; (13f84 <Ssd1306::SetHorizontalAddressMode()+0x50>)
   13f66:	9801      	ldr	r0, [sp, #4]
   13f68:	f7fc fc50 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>
   13f6c:	4623      	mov	r3, r4
   13f6e:	4619      	mov	r1, r3
   13f70:	4802      	ldr	r0, [pc, #8]	; (13f7c <Ssd1306::SetHorizontalAddressMode()+0x48>)
   13f72:	f002 fcd3 	bl	1691c <__cyg_profile_func_exit>
  }
   13f76:	bf00      	nop
   13f78:	b002      	add	sp, #8
   13f7a:	bd10      	pop	{r4, pc}
   13f7c:	00013f35 	.word	0x00013f35
   13f80:	0021007f 	.word	0x0021007f
   13f84:	00220007 	.word	0x00220007

00013f88 <Ssd1306::Clear()>:
  /// Clears the internal bitmap_ to zero (or a user defined clear_value)
  void Clear() final override
   13f88:	b510      	push	{r4, lr}
   13f8a:	b082      	sub	sp, #8
   13f8c:	4674      	mov	r4, lr
   13f8e:	9001      	str	r0, [sp, #4]
   13f90:	4623      	mov	r3, r4
   13f92:	4619      	mov	r1, r3
   13f94:	4809      	ldr	r0, [pc, #36]	; (13fbc <Ssd1306::Clear()+0x34>)
   13f96:	f002 fcad 	bl	168f4 <__cyg_profile_func_enter>
  {
    memset(bitmap_, 0x00, sizeof(bitmap_));
   13f9a:	9b01      	ldr	r3, [sp, #4]
   13f9c:	3368      	adds	r3, #104	; 0x68
   13f9e:	f240 62c1 	movw	r2, #1729	; 0x6c1
   13fa2:	2100      	movs	r1, #0
   13fa4:	4618      	mov	r0, r3
   13fa6:	f008 fcc7 	bl	1c938 <memset>
   13faa:	4623      	mov	r3, r4
   13fac:	4619      	mov	r1, r3
   13fae:	4803      	ldr	r0, [pc, #12]	; (13fbc <Ssd1306::Clear()+0x34>)
   13fb0:	f002 fcb4 	bl	1691c <__cyg_profile_func_exit>
  }
   13fb4:	bf00      	nop
   13fb6:	b002      	add	sp, #8
   13fb8:	bd10      	pop	{r4, pc}
   13fba:	bf00      	nop
   13fbc:	00013f89 	.word	0x00013f89

00013fc0 <Ssd1306::DrawPixel(long, long, PixelDisplayInterface::Color_t)>:
  void Fill()
  {
    memset(bitmap_, 0xFF, sizeof(bitmap_));
  }
  void DrawPixel(int32_t x, int32_t y, Color_t color) final override
   13fc0:	b510      	push	{r4, lr}
   13fc2:	b08c      	sub	sp, #48	; 0x30
   13fc4:	4674      	mov	r4, lr
   13fc6:	9003      	str	r0, [sp, #12]
   13fc8:	9102      	str	r1, [sp, #8]
   13fca:	9201      	str	r2, [sp, #4]
   13fcc:	9300      	str	r3, [sp, #0]
   13fce:	4623      	mov	r3, r4
   13fd0:	4619      	mov	r1, r3
   13fd2:	481f      	ldr	r0, [pc, #124]	; (14050 <Ssd1306::DrawPixel(long, long, PixelDisplayInterface::Color_t)+0x90>)
   13fd4:	f002 fc8e 	bl	168f4 <__cyg_profile_func_enter>
  {
    // The 3 least significant bits hold the bit position within the byte
    uint32_t bit_position = y & 0b111;
   13fd8:	9b01      	ldr	r3, [sp, #4]
   13fda:	f003 0307 	and.w	r3, r3, #7
   13fde:	930b      	str	r3, [sp, #44]	; 0x2c
    // Each byte makes up a vertical column.
    // Shifting by 3, which also divides by 8 (the 8-bits of a column), will
    // be the row that we need to edit.
    uint32_t row = y >> 3;
   13fe0:	9b01      	ldr	r3, [sp, #4]
   13fe2:	10db      	asrs	r3, r3, #3
   13fe4:	930a      	str	r3, [sp, #40]	; 0x28
    // Mask to clear the bit
    uint32_t clear_mask = ~(1 << bit_position);
   13fe6:	2201      	movs	r2, #1
   13fe8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   13fea:	fa02 f303 	lsl.w	r3, r2, r3
   13fee:	43db      	mvns	r3, r3
   13ff0:	9309      	str	r3, [sp, #36]	; 0x24
    // Mask to set the bit, if color.alpha != 0
    bool pixel_is_on  = (color.alpha != 0);
   13ff2:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13ff6:	2b00      	cmp	r3, #0
   13ff8:	bf14      	ite	ne
   13ffa:	2301      	movne	r3, #1
   13ffc:	2300      	moveq	r3, #0
   13ffe:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    uint32_t set_mask = pixel_is_on << bit_position;
   14002:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
   14006:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   14008:	fa02 f303 	lsl.w	r3, r2, r3
   1400c:	9307      	str	r3, [sp, #28]
    // Address of the pixel column to edit
    uint8_t * pixel_column = &(bitmap_[row][x]);
   1400e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   14010:	4613      	mov	r3, r2
   14012:	015b      	lsls	r3, r3, #5
   14014:	4413      	add	r3, r2
   14016:	009b      	lsls	r3, r3, #2
   14018:	4413      	add	r3, r2
   1401a:	9a02      	ldr	r2, [sp, #8]
   1401c:	4413      	add	r3, r2
   1401e:	3368      	adds	r3, #104	; 0x68
   14020:	9a03      	ldr	r2, [sp, #12]
   14022:	4413      	add	r3, r2
   14024:	9306      	str	r3, [sp, #24]
    // Read pixel column and update the pixel
    uint32_t result = (*pixel_column & clear_mask) | set_mask;
   14026:	9b06      	ldr	r3, [sp, #24]
   14028:	781b      	ldrb	r3, [r3, #0]
   1402a:	461a      	mov	r2, r3
   1402c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1402e:	4013      	ands	r3, r2
   14030:	9a07      	ldr	r2, [sp, #28]
   14032:	4313      	orrs	r3, r2
   14034:	9305      	str	r3, [sp, #20]
    // Update pixel with the result of this operation
    *pixel_column = static_cast<uint8_t>(result);
   14036:	9b05      	ldr	r3, [sp, #20]
   14038:	b2da      	uxtb	r2, r3
   1403a:	9b06      	ldr	r3, [sp, #24]
   1403c:	701a      	strb	r2, [r3, #0]
   1403e:	4623      	mov	r3, r4
   14040:	4619      	mov	r1, r3
   14042:	4803      	ldr	r0, [pc, #12]	; (14050 <Ssd1306::DrawPixel(long, long, PixelDisplayInterface::Color_t)+0x90>)
   14044:	f002 fc6a 	bl	1691c <__cyg_profile_func_exit>
  }
   14048:	bf00      	nop
   1404a:	b00c      	add	sp, #48	; 0x30
   1404c:	bd10      	pop	{r4, pc}
   1404e:	bf00      	nop
   14050:	00013fc1 	.word	0x00013fc1

00014054 <Ssd1306::Update()>:
  /// Writes internal bitmap_ to the screen
  void Update() final override
   14054:	b510      	push	{r4, lr}
   14056:	b084      	sub	sp, #16
   14058:	4674      	mov	r4, lr
   1405a:	9001      	str	r0, [sp, #4]
   1405c:	4623      	mov	r3, r4
   1405e:	4619      	mov	r1, r3
   14060:	4818      	ldr	r0, [pc, #96]	; (140c4 <Ssd1306::Update()+0x70>)
   14062:	f002 fc47 	bl	168f4 <__cyg_profile_func_enter>
  {
    SetHorizontalAddressMode();
   14066:	9801      	ldr	r0, [sp, #4]
   14068:	f7ff ff64 	bl	13f34 <Ssd1306::SetHorizontalAddressMode()>
    for (size_t row = 0; row < kRows; row++)
   1406c:	2300      	movs	r3, #0
   1406e:	9303      	str	r3, [sp, #12]
   14070:	9b03      	ldr	r3, [sp, #12]
   14072:	2b07      	cmp	r3, #7
   14074:	d81e      	bhi.n	140b4 <Ssd1306::Update()+0x60>
    {
      for (size_t column = 0; column < kColumns; column++)
   14076:	2300      	movs	r3, #0
   14078:	9302      	str	r3, [sp, #8]
   1407a:	9b02      	ldr	r3, [sp, #8]
   1407c:	2b7f      	cmp	r3, #127	; 0x7f
   1407e:	d815      	bhi.n	140ac <Ssd1306::Update()+0x58>
      {
        Write(bitmap_[row][column], Transaction::kData);
   14080:	9901      	ldr	r1, [sp, #4]
   14082:	9a03      	ldr	r2, [sp, #12]
   14084:	4613      	mov	r3, r2
   14086:	015b      	lsls	r3, r3, #5
   14088:	4413      	add	r3, r2
   1408a:	009b      	lsls	r3, r3, #2
   1408c:	4413      	add	r3, r2
   1408e:	18ca      	adds	r2, r1, r3
   14090:	9b02      	ldr	r3, [sp, #8]
   14092:	4413      	add	r3, r2
   14094:	3368      	adds	r3, #104	; 0x68
   14096:	781b      	ldrb	r3, [r3, #0]
   14098:	4619      	mov	r1, r3
   1409a:	2301      	movs	r3, #1
   1409c:	2201      	movs	r2, #1
   1409e:	9801      	ldr	r0, [sp, #4]
   140a0:	f7fc fbb4 	bl	1080c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>
      for (size_t column = 0; column < kColumns; column++)
   140a4:	9b02      	ldr	r3, [sp, #8]
   140a6:	3301      	adds	r3, #1
   140a8:	9302      	str	r3, [sp, #8]
   140aa:	e7e6      	b.n	1407a <Ssd1306::Update()+0x26>
    for (size_t row = 0; row < kRows; row++)
   140ac:	9b03      	ldr	r3, [sp, #12]
   140ae:	3301      	adds	r3, #1
   140b0:	9303      	str	r3, [sp, #12]
   140b2:	e7dd      	b.n	14070 <Ssd1306::Update()+0x1c>
   140b4:	4623      	mov	r3, r4
   140b6:	4619      	mov	r1, r3
   140b8:	4802      	ldr	r0, [pc, #8]	; (140c4 <Ssd1306::Update()+0x70>)
   140ba:	f002 fc2f 	bl	1691c <__cyg_profile_func_exit>
      }
    }
  }
   140be:	bf00      	nop
   140c0:	b004      	add	sp, #16
   140c2:	bd10      	pop	{r4, pc}
   140c4:	00014055 	.word	0x00014055

000140c8 <Graphics::Graphics(PixelDisplayInterface*)>:
  explicit Graphics(PixelDisplayInterface * display)
   140c8:	b530      	push	{r4, r5, lr}
   140ca:	b083      	sub	sp, #12
   140cc:	4675      	mov	r5, lr
   140ce:	9001      	str	r0, [sp, #4]
   140d0:	9100      	str	r1, [sp, #0]
   140d2:	462b      	mov	r3, r5
   140d4:	4619      	mov	r1, r3
   140d6:	481e      	ldr	r0, [pc, #120]	; (14150 <Graphics::Graphics(PixelDisplayInterface*)+0x88>)
   140d8:	f002 fc0c 	bl	168f4 <__cyg_profile_func_enter>
      : display_(display), color_(), width_(0), height_(0)
   140dc:	9b01      	ldr	r3, [sp, #4]
   140de:	9a00      	ldr	r2, [sp, #0]
   140e0:	601a      	str	r2, [r3, #0]
   140e2:	9b01      	ldr	r3, [sp, #4]
   140e4:	3304      	adds	r3, #4
   140e6:	4618      	mov	r0, r3
   140e8:	f7ff fd36 	bl	13b58 <PixelDisplayInterface::Color_t::Color_t()>
   140ec:	9b01      	ldr	r3, [sp, #4]
   140ee:	2200      	movs	r2, #0
   140f0:	609a      	str	r2, [r3, #8]
   140f2:	9b01      	ldr	r3, [sp, #4]
   140f4:	2200      	movs	r2, #0
   140f6:	60da      	str	r2, [r3, #12]
    width_  = display->GetWidth();
   140f8:	9b00      	ldr	r3, [sp, #0]
   140fa:	681b      	ldr	r3, [r3, #0]
   140fc:	681b      	ldr	r3, [r3, #0]
   140fe:	9800      	ldr	r0, [sp, #0]
   14100:	4798      	blx	r3
   14102:	4602      	mov	r2, r0
   14104:	9b01      	ldr	r3, [sp, #4]
   14106:	609a      	str	r2, [r3, #8]
    height_ = display->GetHeight();
   14108:	9b00      	ldr	r3, [sp, #0]
   1410a:	681b      	ldr	r3, [r3, #0]
   1410c:	3304      	adds	r3, #4
   1410e:	681b      	ldr	r3, [r3, #0]
   14110:	9800      	ldr	r0, [sp, #0]
   14112:	4798      	blx	r3
   14114:	4602      	mov	r2, r0
   14116:	9b01      	ldr	r3, [sp, #4]
   14118:	60da      	str	r2, [r3, #12]
    color_  = display->AvailableColors();
   1411a:	9b00      	ldr	r3, [sp, #0]
   1411c:	681b      	ldr	r3, [r3, #0]
   1411e:	3308      	adds	r3, #8
   14120:	681b      	ldr	r3, [r3, #0]
   14122:	9c01      	ldr	r4, [sp, #4]
   14124:	9800      	ldr	r0, [sp, #0]
   14126:	4798      	blx	r3
   14128:	4603      	mov	r3, r0
   1412a:	461a      	mov	r2, r3
   1412c:	7122      	strb	r2, [r4, #4]
   1412e:	f3c3 2207 	ubfx	r2, r3, #8, #8
   14132:	7162      	strb	r2, [r4, #5]
   14134:	f3c3 4307 	ubfx	r3, r3, #16, #8
   14138:	71a3      	strb	r3, [r4, #6]
  }
   1413a:	9c01      	ldr	r4, [sp, #4]
   1413c:	462b      	mov	r3, r5
   1413e:	4619      	mov	r1, r3
   14140:	4803      	ldr	r0, [pc, #12]	; (14150 <Graphics::Graphics(PixelDisplayInterface*)+0x88>)
   14142:	f002 fbeb 	bl	1691c <__cyg_profile_func_exit>
   14146:	4623      	mov	r3, r4
   14148:	4618      	mov	r0, r3
   1414a:	b003      	add	sp, #12
   1414c:	bd30      	pop	{r4, r5, pc}
   1414e:	bf00      	nop
   14150:	000140c9 	.word	0x000140c9

00014154 <Graphics::DrawCharacter(long, long, char, bool)>:
  void DrawCharacter(int32_t x0, int32_t y0, char letter,
   14154:	b510      	push	{r4, lr}
   14156:	b08e      	sub	sp, #56	; 0x38
   14158:	4674      	mov	r4, lr
   1415a:	9007      	str	r0, [sp, #28]
   1415c:	9106      	str	r1, [sp, #24]
   1415e:	9205      	str	r2, [sp, #20]
   14160:	f88d 3013 	strb.w	r3, [sp, #19]
   14164:	4623      	mov	r3, r4
   14166:	4619      	mov	r1, r3
   14168:	4837      	ldr	r0, [pc, #220]	; (14248 <Graphics::DrawCharacter(long, long, char, bool)+0xf4>)
   1416a:	f002 fbc3 	bl	168f4 <__cyg_profile_func_enter>
    int32_t letter_position = static_cast<int32_t>(letter);
   1416e:	f89d 3013 	ldrb.w	r3, [sp, #19]
   14172:	930b      	str	r3, [sp, #44]	; 0x2c
    PixelDisplayInterface::Color_t foreground = color_;
   14174:	9a07      	ldr	r2, [sp, #28]
   14176:	ab0a      	add	r3, sp, #40	; 0x28
   14178:	3204      	adds	r2, #4
   1417a:	6812      	ldr	r2, [r2, #0]
   1417c:	4611      	mov	r1, r2
   1417e:	8019      	strh	r1, [r3, #0]
   14180:	3302      	adds	r3, #2
   14182:	0c12      	lsrs	r2, r2, #16
   14184:	701a      	strb	r2, [r3, #0]
        PixelDisplayInterface::Color_t(0, 0, 0, 0, 1, true);
   14186:	a809      	add	r0, sp, #36	; 0x24
   14188:	2301      	movs	r3, #1
   1418a:	9302      	str	r3, [sp, #8]
   1418c:	2301      	movs	r3, #1
   1418e:	9301      	str	r3, [sp, #4]
   14190:	2300      	movs	r3, #0
   14192:	9300      	str	r3, [sp, #0]
   14194:	2300      	movs	r3, #0
   14196:	2200      	movs	r2, #0
   14198:	2100      	movs	r1, #0
   1419a:	f7ff fc93 	bl	13ac4 <PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)>
    for (int32_t y = 0; y < 8; y++)
   1419e:	2300      	movs	r3, #0
   141a0:	930d      	str	r3, [sp, #52]	; 0x34
   141a2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   141a4:	2b07      	cmp	r3, #7
   141a6:	dc3d      	bgt.n	14224 <Graphics::DrawCharacter(long, long, char, bool)+0xd0>
      for (int32_t x = 0; x < 8; x++)
   141a8:	2300      	movs	r3, #0
   141aa:	930c      	str	r3, [sp, #48]	; 0x30
   141ac:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   141ae:	2b07      	cmp	r3, #7
   141b0:	dc34      	bgt.n	1421c <Graphics::DrawCharacter(long, long, char, bool)+0xc8>
        if (font8x8_basic[letter_position][y] & (1 << x))
   141b2:	4a26      	ldr	r2, [pc, #152]	; (1424c <Graphics::DrawCharacter(long, long, char, bool)+0xf8>)
   141b4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   141b6:	00db      	lsls	r3, r3, #3
   141b8:	441a      	add	r2, r3
   141ba:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   141bc:	4413      	add	r3, r2
   141be:	781b      	ldrb	r3, [r3, #0]
   141c0:	461a      	mov	r2, r3
   141c2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   141c4:	fa42 f303 	asr.w	r3, r2, r3
   141c8:	f003 0301 	and.w	r3, r3, #1
   141cc:	2b00      	cmp	r3, #0
   141ce:	d009      	beq.n	141e4 <Graphics::DrawCharacter(long, long, char, bool)+0x90>
          color_ = foreground;
   141d0:	9b07      	ldr	r3, [sp, #28]
   141d2:	3304      	adds	r3, #4
   141d4:	aa0a      	add	r2, sp, #40	; 0x28
   141d6:	6812      	ldr	r2, [r2, #0]
   141d8:	4611      	mov	r1, r2
   141da:	8019      	strh	r1, [r3, #0]
   141dc:	3302      	adds	r3, #2
   141de:	0c12      	lsrs	r2, r2, #16
   141e0:	701a      	strb	r2, [r3, #0]
   141e2:	e00c      	b.n	141fe <Graphics::DrawCharacter(long, long, char, bool)+0xaa>
        else if (fill_background)
   141e4:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   141e8:	2b00      	cmp	r3, #0
   141ea:	d008      	beq.n	141fe <Graphics::DrawCharacter(long, long, char, bool)+0xaa>
          color_ = background;
   141ec:	9b07      	ldr	r3, [sp, #28]
   141ee:	3304      	adds	r3, #4
   141f0:	aa09      	add	r2, sp, #36	; 0x24
   141f2:	6812      	ldr	r2, [r2, #0]
   141f4:	4611      	mov	r1, r2
   141f6:	8019      	strh	r1, [r3, #0]
   141f8:	3302      	adds	r3, #2
   141fa:	0c12      	lsrs	r2, r2, #16
   141fc:	701a      	strb	r2, [r3, #0]
        DrawPixel(x0 + x, y0 + y);
   141fe:	9a06      	ldr	r2, [sp, #24]
   14200:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   14202:	4413      	add	r3, r2
   14204:	4619      	mov	r1, r3
   14206:	9a05      	ldr	r2, [sp, #20]
   14208:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1420a:	4413      	add	r3, r2
   1420c:	461a      	mov	r2, r3
   1420e:	9807      	ldr	r0, [sp, #28]
   14210:	f000 f81e 	bl	14250 <Graphics::DrawPixel(unsigned long, unsigned long)>
      for (int32_t x = 0; x < 8; x++)
   14214:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   14216:	3301      	adds	r3, #1
   14218:	930c      	str	r3, [sp, #48]	; 0x30
   1421a:	e7c7      	b.n	141ac <Graphics::DrawCharacter(long, long, char, bool)+0x58>
    for (int32_t y = 0; y < 8; y++)
   1421c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1421e:	3301      	adds	r3, #1
   14220:	930d      	str	r3, [sp, #52]	; 0x34
   14222:	e7be      	b.n	141a2 <Graphics::DrawCharacter(long, long, char, bool)+0x4e>
    color_ = foreground;
   14224:	9b07      	ldr	r3, [sp, #28]
   14226:	3304      	adds	r3, #4
   14228:	aa0a      	add	r2, sp, #40	; 0x28
   1422a:	6812      	ldr	r2, [r2, #0]
   1422c:	4611      	mov	r1, r2
   1422e:	8019      	strh	r1, [r3, #0]
   14230:	3302      	adds	r3, #2
   14232:	0c12      	lsrs	r2, r2, #16
   14234:	701a      	strb	r2, [r3, #0]
   14236:	4623      	mov	r3, r4
   14238:	4619      	mov	r1, r3
   1423a:	4803      	ldr	r0, [pc, #12]	; (14248 <Graphics::DrawCharacter(long, long, char, bool)+0xf4>)
   1423c:	f002 fb6e 	bl	1691c <__cyg_profile_func_exit>
  }
   14240:	bf00      	nop
   14242:	b00e      	add	sp, #56	; 0x38
   14244:	bd10      	pop	{r4, pc}
   14246:	bf00      	nop
   14248:	00014155 	.word	0x00014155
   1424c:	10000078 	.word	0x10000078

00014250 <Graphics::DrawPixel(unsigned long, unsigned long)>:
  void DrawPixel(uint32_t x, uint32_t y)
   14250:	b530      	push	{r4, r5, lr}
   14252:	b085      	sub	sp, #20
   14254:	4675      	mov	r5, lr
   14256:	9003      	str	r0, [sp, #12]
   14258:	9102      	str	r1, [sp, #8]
   1425a:	9201      	str	r2, [sp, #4]
   1425c:	462b      	mov	r3, r5
   1425e:	4619      	mov	r1, r3
   14260:	4810      	ldr	r0, [pc, #64]	; (142a4 <Graphics::DrawPixel(unsigned long, unsigned long)+0x54>)
   14262:	f002 fb47 	bl	168f4 <__cyg_profile_func_enter>
    if (x <= width_ && y <= height_)
   14266:	9b03      	ldr	r3, [sp, #12]
   14268:	689b      	ldr	r3, [r3, #8]
   1426a:	9a02      	ldr	r2, [sp, #8]
   1426c:	429a      	cmp	r2, r3
   1426e:	d810      	bhi.n	14292 <Graphics::DrawPixel(unsigned long, unsigned long)+0x42>
   14270:	9b03      	ldr	r3, [sp, #12]
   14272:	68db      	ldr	r3, [r3, #12]
   14274:	9a01      	ldr	r2, [sp, #4]
   14276:	429a      	cmp	r2, r3
   14278:	d80b      	bhi.n	14292 <Graphics::DrawPixel(unsigned long, unsigned long)+0x42>
      display_->DrawPixel(x, y, color_);
   1427a:	9b03      	ldr	r3, [sp, #12]
   1427c:	6818      	ldr	r0, [r3, #0]
   1427e:	9b03      	ldr	r3, [sp, #12]
   14280:	681b      	ldr	r3, [r3, #0]
   14282:	681b      	ldr	r3, [r3, #0]
   14284:	331c      	adds	r3, #28
   14286:	681c      	ldr	r4, [r3, #0]
   14288:	9902      	ldr	r1, [sp, #8]
   1428a:	9a01      	ldr	r2, [sp, #4]
   1428c:	9b03      	ldr	r3, [sp, #12]
   1428e:	685b      	ldr	r3, [r3, #4]
   14290:	47a0      	blx	r4
   14292:	462b      	mov	r3, r5
   14294:	4619      	mov	r1, r3
   14296:	4803      	ldr	r0, [pc, #12]	; (142a4 <Graphics::DrawPixel(unsigned long, unsigned long)+0x54>)
   14298:	f002 fb40 	bl	1691c <__cyg_profile_func_exit>
  }
   1429c:	bf00      	nop
   1429e:	b005      	add	sp, #20
   142a0:	bd30      	pop	{r4, r5, pc}
   142a2:	bf00      	nop
   142a4:	00014251 	.word	0x00014251

000142a8 <OledTerminal::printf(char const*, ...)>:

  int printf(const char * format, ...)  // NOLINT
   142a8:	b40e      	push	{r1, r2, r3}
   142aa:	b530      	push	{r4, r5, lr}
   142ac:	b0c6      	sub	sp, #280	; 0x118
   142ae:	4675      	mov	r5, lr
   142b0:	ab01      	add	r3, sp, #4
   142b2:	6018      	str	r0, [r3, #0]
   142b4:	462b      	mov	r3, r5
   142b6:	4619      	mov	r1, r3
   142b8:	4850      	ldr	r0, [pc, #320]	; (143fc <OledTerminal::printf(char const*, ...)+0x154>)
   142ba:	f002 fb1b 	bl	168f4 <__cyg_profile_func_enter>
  {
    char buffer[256];

    va_list args;
    va_start(args, format);
   142be:	aa4a      	add	r2, sp, #296	; 0x128
   142c0:	ab02      	add	r3, sp, #8
   142c2:	601a      	str	r2, [r3, #0]
    size_t characters = vsnprintf(buffer, sizeof(buffer), format, args);
   142c4:	ab02      	add	r3, sp, #8
   142c6:	a803      	add	r0, sp, #12
   142c8:	681b      	ldr	r3, [r3, #0]
   142ca:	9a49      	ldr	r2, [sp, #292]	; 0x124
   142cc:	f44f 7180 	mov.w	r1, #256	; 0x100
   142d0:	f004 fad4 	bl	1887c <vsnprintf>
   142d4:	4603      	mov	r3, r0
   142d6:	9344      	str	r3, [sp, #272]	; 0x110
    va_end(args);

    size_t pos = 0;
   142d8:	2300      	movs	r3, #0
   142da:	9345      	str	r3, [sp, #276]	; 0x114
    for (; pos < characters; pos++)
   142dc:	9a45      	ldr	r2, [sp, #276]	; 0x114
   142de:	9b44      	ldr	r3, [sp, #272]	; 0x110
   142e0:	429a      	cmp	r2, r3
   142e2:	d253      	bcs.n	1438c <OledTerminal::printf(char const*, ...)+0xe4>
    {
      char character = buffer[pos];
   142e4:	aa03      	add	r2, sp, #12
   142e6:	9b45      	ldr	r3, [sp, #276]	; 0x114
   142e8:	4413      	add	r3, r2
   142ea:	781b      	ldrb	r3, [r3, #0]
   142ec:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
      switch (character)
   142f0:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   142f4:	2b0a      	cmp	r3, #10
   142f6:	d10e      	bne.n	14316 <OledTerminal::printf(char const*, ...)+0x6e>
      {
        case '\n':
          column_ = 0;
   142f8:	ab01      	add	r3, sp, #4
   142fa:	681b      	ldr	r3, [r3, #0]
   142fc:	2200      	movs	r2, #0
   142fe:	f8c3 2740 	str.w	r2, [r3, #1856]	; 0x740
          row_++;
   14302:	ab01      	add	r3, sp, #4
   14304:	681b      	ldr	r3, [r3, #0]
   14306:	f8d3 373c 	ldr.w	r3, [r3, #1852]	; 0x73c
   1430a:	1c5a      	adds	r2, r3, #1
   1430c:	ab01      	add	r3, sp, #4
   1430e:	681b      	ldr	r3, [r3, #0]
   14310:	f8c3 273c 	str.w	r2, [r3, #1852]	; 0x73c
          break;
   14314:	e036      	b.n	14384 <OledTerminal::printf(char const*, ...)+0xdc>
        default:
          terminal_[(row_ + row_start_) % kMaxRows][column_] = character;
   14316:	ab01      	add	r3, sp, #4
   14318:	681b      	ldr	r3, [r3, #0]
   1431a:	f8d3 273c 	ldr.w	r2, [r3, #1852]	; 0x73c
   1431e:	ab01      	add	r3, sp, #4
   14320:	681b      	ldr	r3, [r3, #0]
   14322:	f8d3 3744 	ldr.w	r3, [r3, #1860]	; 0x744
   14326:	4413      	add	r3, r2
   14328:	f003 0207 	and.w	r2, r3, #7
   1432c:	ab01      	add	r3, sp, #4
   1432e:	681b      	ldr	r3, [r3, #0]
   14330:	f8d3 3740 	ldr.w	r3, [r3, #1856]	; 0x740
   14334:	a901      	add	r1, sp, #4
   14336:	6809      	ldr	r1, [r1, #0]
   14338:	0112      	lsls	r2, r2, #4
   1433a:	440a      	add	r2, r1
   1433c:	4413      	add	r3, r2
   1433e:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
   14342:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
   14346:	701a      	strb	r2, [r3, #0]
          column_++;
   14348:	ab01      	add	r3, sp, #4
   1434a:	681b      	ldr	r3, [r3, #0]
   1434c:	f8d3 3740 	ldr.w	r3, [r3, #1856]	; 0x740
   14350:	1c5a      	adds	r2, r3, #1
   14352:	ab01      	add	r3, sp, #4
   14354:	681b      	ldr	r3, [r3, #0]
   14356:	f8c3 2740 	str.w	r2, [r3, #1856]	; 0x740
          if (column_ >= kMaxColumns)
   1435a:	ab01      	add	r3, sp, #4
   1435c:	681b      	ldr	r3, [r3, #0]
   1435e:	f8d3 3740 	ldr.w	r3, [r3, #1856]	; 0x740
   14362:	2b0f      	cmp	r3, #15
   14364:	d90d      	bls.n	14382 <OledTerminal::printf(char const*, ...)+0xda>
          {
            column_ = 0;
   14366:	ab01      	add	r3, sp, #4
   14368:	681b      	ldr	r3, [r3, #0]
   1436a:	2200      	movs	r2, #0
   1436c:	f8c3 2740 	str.w	r2, [r3, #1856]	; 0x740
            row_++;
   14370:	ab01      	add	r3, sp, #4
   14372:	681b      	ldr	r3, [r3, #0]
   14374:	f8d3 373c 	ldr.w	r3, [r3, #1852]	; 0x73c
   14378:	1c5a      	adds	r2, r3, #1
   1437a:	ab01      	add	r3, sp, #4
   1437c:	681b      	ldr	r3, [r3, #0]
   1437e:	f8c3 273c 	str.w	r2, [r3, #1852]	; 0x73c
          }
          break;
   14382:	bf00      	nop
    for (; pos < characters; pos++)
   14384:	9b45      	ldr	r3, [sp, #276]	; 0x114
   14386:	3301      	adds	r3, #1
   14388:	9345      	str	r3, [sp, #276]	; 0x114
   1438a:	e7a7      	b.n	142dc <OledTerminal::printf(char const*, ...)+0x34>
      }
    }
    Update();
   1438c:	ab01      	add	r3, sp, #4
   1438e:	6818      	ldr	r0, [r3, #0]
   14390:	f000 f85a 	bl	14448 <OledTerminal::Update()>
    if (row_ >= kMaxRows)
   14394:	ab01      	add	r3, sp, #4
   14396:	681b      	ldr	r3, [r3, #0]
   14398:	f8d3 373c 	ldr.w	r3, [r3, #1852]	; 0x73c
   1439c:	2b07      	cmp	r3, #7
   1439e:	d91f      	bls.n	143e0 <OledTerminal::printf(char const*, ...)+0x138>
    {
      row_start_ = (row_start_ + 1) % kMaxRows;
   143a0:	ab01      	add	r3, sp, #4
   143a2:	681b      	ldr	r3, [r3, #0]
   143a4:	f8d3 3744 	ldr.w	r3, [r3, #1860]	; 0x744
   143a8:	3301      	adds	r3, #1
   143aa:	f003 0207 	and.w	r2, r3, #7
   143ae:	ab01      	add	r3, sp, #4
   143b0:	681b      	ldr	r3, [r3, #0]
   143b2:	f8c3 2744 	str.w	r2, [r3, #1860]	; 0x744
      row_       = kMaxRows - 1;
   143b6:	ab01      	add	r3, sp, #4
   143b8:	681b      	ldr	r3, [r3, #0]
   143ba:	2207      	movs	r2, #7
   143bc:	f8c3 273c 	str.w	r2, [r3, #1852]	; 0x73c
      ClearRow((row_ + row_start_) % kMaxRows);
   143c0:	ab01      	add	r3, sp, #4
   143c2:	681b      	ldr	r3, [r3, #0]
   143c4:	f8d3 273c 	ldr.w	r2, [r3, #1852]	; 0x73c
   143c8:	ab01      	add	r3, sp, #4
   143ca:	681b      	ldr	r3, [r3, #0]
   143cc:	f8d3 3744 	ldr.w	r3, [r3, #1860]	; 0x744
   143d0:	4413      	add	r3, r2
   143d2:	f003 0207 	and.w	r2, r3, #7
   143d6:	ab01      	add	r3, sp, #4
   143d8:	4611      	mov	r1, r2
   143da:	6818      	ldr	r0, [r3, #0]
   143dc:	f000 f882 	bl	144e4 <OledTerminal::ClearRow(unsigned int)>
    }
    return pos;
   143e0:	9c45      	ldr	r4, [sp, #276]	; 0x114
   143e2:	462b      	mov	r3, r5
   143e4:	4619      	mov	r1, r3
   143e6:	4805      	ldr	r0, [pc, #20]	; (143fc <OledTerminal::printf(char const*, ...)+0x154>)
   143e8:	f002 fa98 	bl	1691c <__cyg_profile_func_exit>
   143ec:	4623      	mov	r3, r4
  }
   143ee:	4618      	mov	r0, r3
   143f0:	b046      	add	sp, #280	; 0x118
   143f2:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   143f6:	b003      	add	sp, #12
   143f8:	4770      	bx	lr
   143fa:	bf00      	nop
   143fc:	000142a9 	.word	0x000142a9

00014400 <OledTerminal::SetCursor(unsigned int, unsigned int)>:
  OledTerminal & SetCursor(size_t x, size_t y)
   14400:	b530      	push	{r4, r5, lr}
   14402:	b085      	sub	sp, #20
   14404:	4675      	mov	r5, lr
   14406:	9003      	str	r0, [sp, #12]
   14408:	9102      	str	r1, [sp, #8]
   1440a:	9201      	str	r2, [sp, #4]
   1440c:	462b      	mov	r3, r5
   1440e:	4619      	mov	r1, r3
   14410:	480c      	ldr	r0, [pc, #48]	; (14444 <OledTerminal::SetCursor(unsigned int, unsigned int)+0x44>)
   14412:	f002 fa6f 	bl	168f4 <__cyg_profile_func_enter>
  {
    column_    = x;
   14416:	9b03      	ldr	r3, [sp, #12]
   14418:	9a02      	ldr	r2, [sp, #8]
   1441a:	f8c3 2740 	str.w	r2, [r3, #1856]	; 0x740
    row_       = y;
   1441e:	9b03      	ldr	r3, [sp, #12]
   14420:	9a01      	ldr	r2, [sp, #4]
   14422:	f8c3 273c 	str.w	r2, [r3, #1852]	; 0x73c
    row_start_ = 0;
   14426:	9b03      	ldr	r3, [sp, #12]
   14428:	2200      	movs	r2, #0
   1442a:	f8c3 2744 	str.w	r2, [r3, #1860]	; 0x744
    return *this;
   1442e:	9c03      	ldr	r4, [sp, #12]
   14430:	462b      	mov	r3, r5
   14432:	4619      	mov	r1, r3
   14434:	4803      	ldr	r0, [pc, #12]	; (14444 <OledTerminal::SetCursor(unsigned int, unsigned int)+0x44>)
   14436:	f002 fa71 	bl	1691c <__cyg_profile_func_exit>
   1443a:	4623      	mov	r3, r4
  }
   1443c:	4618      	mov	r0, r3
   1443e:	b005      	add	sp, #20
   14440:	bd30      	pop	{r4, r5, pc}
   14442:	bf00      	nop
   14444:	00014401 	.word	0x00014401

00014448 <OledTerminal::Update()>:
  OledTerminal & MoveToLineStart()
  {
    column_ = 0;
    return *this;
  }
  OledTerminal & Update()
   14448:	b530      	push	{r4, r5, lr}
   1444a:	b089      	sub	sp, #36	; 0x24
   1444c:	4675      	mov	r5, lr
   1444e:	9003      	str	r0, [sp, #12]
   14450:	462b      	mov	r3, r5
   14452:	4619      	mov	r1, r3
   14454:	4822      	ldr	r0, [pc, #136]	; (144e0 <OledTerminal::Update()+0x98>)
   14456:	f002 fa4d 	bl	168f4 <__cyg_profile_func_enter>
  {
    for (size_t i = 0; i < kMaxRows; i++)
   1445a:	2300      	movs	r3, #0
   1445c:	9307      	str	r3, [sp, #28]
   1445e:	9b07      	ldr	r3, [sp, #28]
   14460:	2b07      	cmp	r3, #7
   14462:	d82c      	bhi.n	144be <OledTerminal::Update()+0x76>
    {
      for (size_t j = 0; j < kMaxColumns; j++)
   14464:	2300      	movs	r3, #0
   14466:	9306      	str	r3, [sp, #24]
   14468:	9b06      	ldr	r3, [sp, #24]
   1446a:	2b0f      	cmp	r3, #15
   1446c:	d823      	bhi.n	144b6 <OledTerminal::Update()+0x6e>
      {
        size_t x = j * kCharacterWidth;
   1446e:	9b06      	ldr	r3, [sp, #24]
   14470:	00db      	lsls	r3, r3, #3
   14472:	9305      	str	r3, [sp, #20]
        size_t y = i * kCharacterHeight;
   14474:	9b07      	ldr	r3, [sp, #28]
   14476:	00db      	lsls	r3, r3, #3
   14478:	9304      	str	r3, [sp, #16]
        graphics_.DrawCharacter(x, y,
   1447a:	9b03      	ldr	r3, [sp, #12]
   1447c:	f203 702c 	addw	r0, r3, #1836	; 0x72c
   14480:	9905      	ldr	r1, [sp, #20]
   14482:	9c04      	ldr	r4, [sp, #16]
                                terminal_[(i + row_start_) % kMaxRows][j]);
   14484:	9b03      	ldr	r3, [sp, #12]
   14486:	f8d3 2744 	ldr.w	r2, [r3, #1860]	; 0x744
   1448a:	9b07      	ldr	r3, [sp, #28]
   1448c:	4413      	add	r3, r2
   1448e:	f003 0307 	and.w	r3, r3, #7
        graphics_.DrawCharacter(x, y,
   14492:	9a03      	ldr	r2, [sp, #12]
   14494:	011b      	lsls	r3, r3, #4
   14496:	441a      	add	r2, r3
   14498:	9b06      	ldr	r3, [sp, #24]
   1449a:	4413      	add	r3, r2
   1449c:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
   144a0:	781a      	ldrb	r2, [r3, #0]
   144a2:	2301      	movs	r3, #1
   144a4:	9300      	str	r3, [sp, #0]
   144a6:	4613      	mov	r3, r2
   144a8:	4622      	mov	r2, r4
   144aa:	f7ff fe53 	bl	14154 <Graphics::DrawCharacter(long, long, char, bool)>
      for (size_t j = 0; j < kMaxColumns; j++)
   144ae:	9b06      	ldr	r3, [sp, #24]
   144b0:	3301      	adds	r3, #1
   144b2:	9306      	str	r3, [sp, #24]
   144b4:	e7d8      	b.n	14468 <OledTerminal::Update()+0x20>
    for (size_t i = 0; i < kMaxRows; i++)
   144b6:	9b07      	ldr	r3, [sp, #28]
   144b8:	3301      	adds	r3, #1
   144ba:	9307      	str	r3, [sp, #28]
   144bc:	e7cf      	b.n	1445e <OledTerminal::Update()+0x16>
      }
    }
    graphics_.Update();
   144be:	9b03      	ldr	r3, [sp, #12]
   144c0:	f203 732c 	addw	r3, r3, #1836	; 0x72c
   144c4:	4618      	mov	r0, r3
   144c6:	f7fc fa0f 	bl	108e8 <Graphics::Update()>
    return *this;
   144ca:	9c03      	ldr	r4, [sp, #12]
   144cc:	462b      	mov	r3, r5
   144ce:	4619      	mov	r1, r3
   144d0:	4803      	ldr	r0, [pc, #12]	; (144e0 <OledTerminal::Update()+0x98>)
   144d2:	f002 fa23 	bl	1691c <__cyg_profile_func_exit>
   144d6:	4623      	mov	r3, r4
  }
   144d8:	4618      	mov	r0, r3
   144da:	b009      	add	sp, #36	; 0x24
   144dc:	bd30      	pop	{r4, r5, pc}
   144de:	bf00      	nop
   144e0:	00014449 	.word	0x00014449

000144e4 <OledTerminal::ClearRow(unsigned int)>:
  void ClearRow(size_t row_location)
   144e4:	b510      	push	{r4, lr}
   144e6:	b084      	sub	sp, #16
   144e8:	4674      	mov	r4, lr
   144ea:	9001      	str	r0, [sp, #4]
   144ec:	9100      	str	r1, [sp, #0]
   144ee:	4623      	mov	r3, r4
   144f0:	4619      	mov	r1, r3
   144f2:	480f      	ldr	r0, [pc, #60]	; (14530 <OledTerminal::ClearRow(unsigned int)+0x4c>)
   144f4:	f002 f9fe 	bl	168f4 <__cyg_profile_func_enter>
  {
    for (size_t i = 0; i < kMaxColumns; i++)
   144f8:	2300      	movs	r3, #0
   144fa:	9303      	str	r3, [sp, #12]
   144fc:	9b03      	ldr	r3, [sp, #12]
   144fe:	2b0f      	cmp	r3, #15
   14500:	d80d      	bhi.n	1451e <OledTerminal::ClearRow(unsigned int)+0x3a>
    {
      terminal_[row_location][i] = ' ';
   14502:	9a01      	ldr	r2, [sp, #4]
   14504:	9b00      	ldr	r3, [sp, #0]
   14506:	011b      	lsls	r3, r3, #4
   14508:	441a      	add	r2, r3
   1450a:	9b03      	ldr	r3, [sp, #12]
   1450c:	4413      	add	r3, r2
   1450e:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
   14512:	2220      	movs	r2, #32
   14514:	701a      	strb	r2, [r3, #0]
    for (size_t i = 0; i < kMaxColumns; i++)
   14516:	9b03      	ldr	r3, [sp, #12]
   14518:	3301      	adds	r3, #1
   1451a:	9303      	str	r3, [sp, #12]
   1451c:	e7ee      	b.n	144fc <OledTerminal::ClearRow(unsigned int)+0x18>
   1451e:	4623      	mov	r3, r4
   14520:	4619      	mov	r1, r3
   14522:	4803      	ldr	r0, [pc, #12]	; (14530 <OledTerminal::ClearRow(unsigned int)+0x4c>)
   14524:	f002 f9fa 	bl	1691c <__cyg_profile_func_exit>
    }
  }
   14528:	bf00      	nop
   1452a:	b004      	add	sp, #16
   1452c:	bd10      	pop	{r4, pc}
   1452e:	bf00      	nop
   14530:	000144e5 	.word	0x000144e5

00014534 <OledTerminal::Clear()>:
  void Clear()
   14534:	b510      	push	{r4, lr}
   14536:	b082      	sub	sp, #8
   14538:	4674      	mov	r4, lr
   1453a:	9001      	str	r0, [sp, #4]
   1453c:	4623      	mov	r3, r4
   1453e:	4619      	mov	r1, r3
   14540:	4811      	ldr	r0, [pc, #68]	; (14588 <OledTerminal::Clear()+0x54>)
   14542:	f002 f9d7 	bl	168f4 <__cyg_profile_func_enter>
  {
    graphics_.Clear();
   14546:	9b01      	ldr	r3, [sp, #4]
   14548:	f203 732c 	addw	r3, r3, #1836	; 0x72c
   1454c:	4618      	mov	r0, r3
   1454e:	f7fc f9e7 	bl	10920 <Graphics::Clear()>
    memset(terminal_, '\0', sizeof(terminal_));
   14552:	9b01      	ldr	r3, [sp, #4]
   14554:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
   14558:	2280      	movs	r2, #128	; 0x80
   1455a:	2100      	movs	r1, #0
   1455c:	4618      	mov	r0, r3
   1455e:	f008 f9eb 	bl	1c938 <memset>
    SetCursor(0, 0);
   14562:	2200      	movs	r2, #0
   14564:	2100      	movs	r1, #0
   14566:	9801      	ldr	r0, [sp, #4]
   14568:	f7ff ff4a 	bl	14400 <OledTerminal::SetCursor(unsigned int, unsigned int)>
    graphics_.Update();
   1456c:	9b01      	ldr	r3, [sp, #4]
   1456e:	f203 732c 	addw	r3, r3, #1836	; 0x72c
   14572:	4618      	mov	r0, r3
   14574:	f7fc f9b8 	bl	108e8 <Graphics::Update()>
   14578:	4623      	mov	r3, r4
   1457a:	4619      	mov	r1, r3
   1457c:	4802      	ldr	r0, [pc, #8]	; (14588 <OledTerminal::Clear()+0x54>)
   1457e:	f002 f9cd 	bl	1691c <__cyg_profile_func_exit>
  }
   14582:	bf00      	nop
   14584:	b002      	add	sp, #8
   14586:	bd10      	pop	{r4, pc}
   14588:	00014535 	.word	0x00014535

0001458c <OledTerminal::OledTerminal()>:
class OledTerminal
   1458c:	b530      	push	{r4, r5, lr}
   1458e:	b083      	sub	sp, #12
   14590:	4675      	mov	r5, lr
   14592:	9001      	str	r0, [sp, #4]
   14594:	462b      	mov	r3, r5
   14596:	4619      	mov	r1, r3
   14598:	4816      	ldr	r0, [pc, #88]	; (145f4 <OledTerminal::OledTerminal()+0x68>)
   1459a:	f002 f9ab 	bl	168f4 <__cyg_profile_func_enter>
   1459e:	9b01      	ldr	r3, [sp, #4]
   145a0:	4618      	mov	r0, r3
   145a2:	f7ff fb63 	bl	13c6c <Ssd1306::Ssd1306()>
   145a6:	9b01      	ldr	r3, [sp, #4]
   145a8:	f203 732c 	addw	r3, r3, #1836	; 0x72c
   145ac:	9a01      	ldr	r2, [sp, #4]
   145ae:	4611      	mov	r1, r2
   145b0:	4618      	mov	r0, r3
   145b2:	f7ff fd89 	bl	140c8 <Graphics::Graphics(PixelDisplayInterface*)>
   145b6:	9b01      	ldr	r3, [sp, #4]
   145b8:	2200      	movs	r2, #0
   145ba:	f8c3 273c 	str.w	r2, [r3, #1852]	; 0x73c
   145be:	9b01      	ldr	r3, [sp, #4]
   145c0:	2200      	movs	r2, #0
   145c2:	f8c3 2740 	str.w	r2, [r3, #1856]	; 0x740
   145c6:	9b01      	ldr	r3, [sp, #4]
   145c8:	2200      	movs	r2, #0
   145ca:	f8c3 2744 	str.w	r2, [r3, #1860]	; 0x744
   145ce:	9b01      	ldr	r3, [sp, #4]
   145d0:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
   145d4:	2280      	movs	r2, #128	; 0x80
   145d6:	2100      	movs	r1, #0
   145d8:	4618      	mov	r0, r3
   145da:	f008 f9ad 	bl	1c938 <memset>
   145de:	9c01      	ldr	r4, [sp, #4]
   145e0:	462b      	mov	r3, r5
   145e2:	4619      	mov	r1, r3
   145e4:	4803      	ldr	r0, [pc, #12]	; (145f4 <OledTerminal::OledTerminal()+0x68>)
   145e6:	f002 f999 	bl	1691c <__cyg_profile_func_exit>
   145ea:	4623      	mov	r3, r4
   145ec:	4618      	mov	r0, r3
   145ee:	b003      	add	sp, #12
   145f0:	bd30      	pop	{r4, r5, pc}
   145f2:	bf00      	nop
   145f4:	0001458d 	.word	0x0001458d

000145f8 <MP3_Decoder::MP3_Decoder()>:
#include "utility/time.hpp"
#include "L3_Application/oled_terminal.hpp"
class MP3_Decoder{
    public:
        
        MP3_Decoder(){}
   145f8:	b530      	push	{r4, r5, lr}
   145fa:	b083      	sub	sp, #12
   145fc:	4675      	mov	r5, lr
   145fe:	9001      	str	r0, [sp, #4]
   14600:	462b      	mov	r3, r5
   14602:	4619      	mov	r1, r3
   14604:	4816      	ldr	r0, [pc, #88]	; (14660 <MP3_Decoder::MP3_Decoder()+0x68>)
   14606:	f002 f975 	bl	168f4 <__cyg_profile_func_enter>
   1460a:	9b01      	ldr	r3, [sp, #4]
   1460c:	2202      	movs	r2, #2
   1460e:	701a      	strb	r2, [r3, #0]
   14610:	9b01      	ldr	r3, [sp, #4]
   14612:	2201      	movs	r2, #1
   14614:	705a      	strb	r2, [r3, #1]
   14616:	9b01      	ldr	r3, [sp, #4]
   14618:	2204      	movs	r2, #4
   1461a:	709a      	strb	r2, [r3, #2]
   1461c:	9b01      	ldr	r3, [sp, #4]
   1461e:	2200      	movs	r2, #0
   14620:	70da      	strb	r2, [r3, #3]
   14622:	9b01      	ldr	r3, [sp, #4]
   14624:	220a      	movs	r2, #10
   14626:	711a      	strb	r2, [r3, #4]
   14628:	9b01      	ldr	r3, [sp, #4]
   1462a:	22fa      	movs	r2, #250	; 0xfa
   1462c:	80da      	strh	r2, [r3, #6]
   1462e:	9b01      	ldr	r3, [sp, #4]
   14630:	2264      	movs	r2, #100	; 0x64
   14632:	811a      	strh	r2, [r3, #8]
   14634:	9b01      	ldr	r3, [sp, #4]
   14636:	2228      	movs	r2, #40	; 0x28
   14638:	815a      	strh	r2, [r3, #10]
   1463a:	9b01      	ldr	r3, [sp, #4]
   1463c:	f240 1201 	movw	r2, #257	; 0x101
   14640:	819a      	strh	r2, [r3, #12]
   14642:	9b01      	ldr	r3, [sp, #4]
   14644:	3310      	adds	r3, #16
   14646:	4618      	mov	r0, r3
   14648:	f7ff ffa0 	bl	1458c <OledTerminal::OledTerminal()>
   1464c:	9c01      	ldr	r4, [sp, #4]
   1464e:	462b      	mov	r3, r5
   14650:	4619      	mov	r1, r3
   14652:	4803      	ldr	r0, [pc, #12]	; (14660 <MP3_Decoder::MP3_Decoder()+0x68>)
   14654:	f002 f962 	bl	1691c <__cyg_profile_func_exit>
   14658:	4623      	mov	r3, r4
   1465a:	4618      	mov	r0, r3
   1465c:	b003      	add	sp, #12
   1465e:	bd30      	pop	{r4, r5, pc}
   14660:	000145f9 	.word	0x000145f9

00014664 <SW3ISR()>:
LabGPIO S2(0, 30);
LabGPIO S1(1, 15);
LabGPIO S0(1, 19);
OledTerminal tt;
void SW3ISR()	//ISR switch between playing and pause music
{
   14664:	b510      	push	{r4, lr}
   14666:	4674      	mov	r4, lr
   14668:	4623      	mov	r3, r4
   1466a:	4619      	mov	r1, r3
   1466c:	4824      	ldr	r0, [pc, #144]	; (14700 <SW3ISR()+0x9c>)
   1466e:	f002 f941 	bl	168f4 <__cyg_profile_func_enter>
	switch(mp3.currentGPIOstate)
   14672:	4b24      	ldr	r3, [pc, #144]	; (14704 <SW3ISR()+0xa0>)
   14674:	781b      	ldrb	r3, [r3, #0]
   14676:	2b01      	cmp	r3, #1
   14678:	d00d      	beq.n	14696 <SW3ISR()+0x32>
   1467a:	2b02      	cmp	r3, #2
   1467c:	d01f      	beq.n	146be <SW3ISR()+0x5a>
   1467e:	2b00      	cmp	r3, #0
   14680:	d12d      	bne.n	146de <SW3ISR()+0x7a>
	{
		case mp3.GPIOstate::kTrack:
            mp3.songIndex -= 1; //play the previous song
   14682:	4b20      	ldr	r3, [pc, #128]	; (14704 <SW3ISR()+0xa0>)
   14684:	78db      	ldrb	r3, [r3, #3]
   14686:	3b01      	subs	r3, #1
   14688:	b2da      	uxtb	r2, r3
   1468a:	4b1e      	ldr	r3, [pc, #120]	; (14704 <SW3ISR()+0xa0>)
   1468c:	70da      	strb	r2, [r3, #3]
            mp3.currentGPIOfunction = mp3.GPIOfunction::kBackTrack;
   1468e:	4b1d      	ldr	r3, [pc, #116]	; (14704 <SW3ISR()+0xa0>)
   14690:	2202      	movs	r2, #2
   14692:	709a      	strb	r2, [r3, #2]
			break;
   14694:	e027      	b.n	146e6 <SW3ISR()+0x82>
		case mp3.GPIOstate::kVolume:
        if(mp3.volume-10 < 0){
   14696:	4b1b      	ldr	r3, [pc, #108]	; (14704 <SW3ISR()+0xa0>)
   14698:	895b      	ldrh	r3, [r3, #10]
   1469a:	3b0a      	subs	r3, #10
   1469c:	2b00      	cmp	r3, #0
   1469e:	da04      	bge.n	146aa <SW3ISR()+0x46>
            mp3.volume = mp3.MinVol;
   146a0:	4b18      	ldr	r3, [pc, #96]	; (14704 <SW3ISR()+0xa0>)
   146a2:	891a      	ldrh	r2, [r3, #8]
   146a4:	4b17      	ldr	r3, [pc, #92]	; (14704 <SW3ISR()+0xa0>)
   146a6:	815a      	strh	r2, [r3, #10]
   146a8:	e005      	b.n	146b6 <SW3ISR()+0x52>
        }
        else{
            mp3.volume -= 10; //reduce the volume
   146aa:	4b16      	ldr	r3, [pc, #88]	; (14704 <SW3ISR()+0xa0>)
   146ac:	895b      	ldrh	r3, [r3, #10]
   146ae:	3b0a      	subs	r3, #10
   146b0:	b29a      	uxth	r2, r3
   146b2:	4b14      	ldr	r3, [pc, #80]	; (14704 <SW3ISR()+0xa0>)
   146b4:	815a      	strh	r2, [r3, #10]
        }
            mp3.currentGPIOfunction = mp3.GPIOfunction::kVolumeDown;
   146b6:	4b13      	ldr	r3, [pc, #76]	; (14704 <SW3ISR()+0xa0>)
   146b8:	2201      	movs	r2, #1
   146ba:	709a      	strb	r2, [r3, #2]
			break;
   146bc:	e013      	b.n	146e6 <SW3ISR()+0x82>
        case mp3.GPIOstate::kPlayback:
            switch(mp3.currentPlayState){
   146be:	4b11      	ldr	r3, [pc, #68]	; (14704 <SW3ISR()+0xa0>)
   146c0:	785b      	ldrb	r3, [r3, #1]
   146c2:	2b00      	cmp	r3, #0
   146c4:	d006      	beq.n	146d4 <SW3ISR()+0x70>
   146c6:	2b01      	cmp	r3, #1
   146c8:	d000      	beq.n	146cc <SW3ISR()+0x68>
                    break;
                case mp3.playState::kPause: //resume the song
                    mp3.currentPlayState = mp3.playState::kPlay;
                    break;
            }
        break;
   146ca:	e00c      	b.n	146e6 <SW3ISR()+0x82>
                    mp3.currentPlayState = mp3.playState::kPause;
   146cc:	4b0d      	ldr	r3, [pc, #52]	; (14704 <SW3ISR()+0xa0>)
   146ce:	2200      	movs	r2, #0
   146d0:	705a      	strb	r2, [r3, #1]
                    break;
   146d2:	e003      	b.n	146dc <SW3ISR()+0x78>
                    mp3.currentPlayState = mp3.playState::kPlay;
   146d4:	4b0b      	ldr	r3, [pc, #44]	; (14704 <SW3ISR()+0xa0>)
   146d6:	2201      	movs	r2, #1
   146d8:	705a      	strb	r2, [r3, #1]
                    break;
   146da:	bf00      	nop
        break;
   146dc:	e003      	b.n	146e6 <SW3ISR()+0x82>
        default:
            mp3.currentGPIOfunction = mp3.GPIOfunction::kIDLE;
   146de:	4b09      	ldr	r3, [pc, #36]	; (14704 <SW3ISR()+0xa0>)
   146e0:	2204      	movs	r2, #4
   146e2:	709a      	strb	r2, [r3, #2]
        break;
   146e4:	bf00      	nop
	}
    LPC_GPIOINT->IO0IntClr |= 1 << 29;
   146e6:	4b08      	ldr	r3, [pc, #32]	; (14708 <SW3ISR()+0xa4>)
   146e8:	68db      	ldr	r3, [r3, #12]
   146ea:	4a07      	ldr	r2, [pc, #28]	; (14708 <SW3ISR()+0xa4>)
   146ec:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   146f0:	60d3      	str	r3, [r2, #12]
   146f2:	4623      	mov	r3, r4
   146f4:	4619      	mov	r1, r3
   146f6:	4802      	ldr	r0, [pc, #8]	; (14700 <SW3ISR()+0x9c>)
   146f8:	f002 f910 	bl	1691c <__cyg_profile_func_exit>
}
   146fc:	bf00      	nop
   146fe:	bd10      	pop	{r4, pc}
   14700:	00014665 	.word	0x00014665
   14704:	100008bc 	.word	0x100008bc
   14708:	40028080 	.word	0x40028080

0001470c <SW2ISR()>:

void SW2ISR()	//ISR switch between volume control and track control state with SW1 and SW0
{
   1470c:	b510      	push	{r4, lr}
   1470e:	4674      	mov	r4, lr
   14710:	4623      	mov	r3, r4
   14712:	4619      	mov	r1, r3
   14714:	481c      	ldr	r0, [pc, #112]	; (14788 <SW2ISR()+0x7c>)
   14716:	f002 f8ed 	bl	168f4 <__cyg_profile_func_enter>
	switch(mp3.currentGPIOstate)
   1471a:	4b1c      	ldr	r3, [pc, #112]	; (1478c <SW2ISR()+0x80>)
   1471c:	781b      	ldrb	r3, [r3, #0]
   1471e:	2b00      	cmp	r3, #0
   14720:	d002      	beq.n	14728 <SW2ISR()+0x1c>
   14722:	2b01      	cmp	r3, #1
   14724:	d00a      	beq.n	1473c <SW2ISR()+0x30>
   14726:	e01d      	b.n	14764 <SW2ISR()+0x58>
	{
		case mp3.GPIOstate::kTrack:
            mp3.songIndex += 1; //play the next song
   14728:	4b18      	ldr	r3, [pc, #96]	; (1478c <SW2ISR()+0x80>)
   1472a:	78db      	ldrb	r3, [r3, #3]
   1472c:	3301      	adds	r3, #1
   1472e:	b2da      	uxtb	r2, r3
   14730:	4b16      	ldr	r3, [pc, #88]	; (1478c <SW2ISR()+0x80>)
   14732:	70da      	strb	r2, [r3, #3]
            mp3.currentGPIOfunction = mp3.GPIOfunction::kNextTrack;
   14734:	4b15      	ldr	r3, [pc, #84]	; (1478c <SW2ISR()+0x80>)
   14736:	2203      	movs	r2, #3
   14738:	709a      	strb	r2, [r3, #2]
			break;
   1473a:	e017      	b.n	1476c <SW2ISR()+0x60>
		case mp3.GPIOstate::kVolume:
            if(mp3.volume+10 < 0){
   1473c:	4b13      	ldr	r3, [pc, #76]	; (1478c <SW2ISR()+0x80>)
   1473e:	895b      	ldrh	r3, [r3, #10]
   14740:	330a      	adds	r3, #10
   14742:	2b00      	cmp	r3, #0
   14744:	da04      	bge.n	14750 <SW2ISR()+0x44>
                mp3.volume = mp3.MaxVol;
   14746:	4b11      	ldr	r3, [pc, #68]	; (1478c <SW2ISR()+0x80>)
   14748:	88da      	ldrh	r2, [r3, #6]
   1474a:	4b10      	ldr	r3, [pc, #64]	; (1478c <SW2ISR()+0x80>)
   1474c:	815a      	strh	r2, [r3, #10]
   1474e:	e005      	b.n	1475c <SW2ISR()+0x50>
            }
            else{
                mp3.volume += 10; //increase the volume
   14750:	4b0e      	ldr	r3, [pc, #56]	; (1478c <SW2ISR()+0x80>)
   14752:	895b      	ldrh	r3, [r3, #10]
   14754:	330a      	adds	r3, #10
   14756:	b29a      	uxth	r2, r3
   14758:	4b0c      	ldr	r3, [pc, #48]	; (1478c <SW2ISR()+0x80>)
   1475a:	815a      	strh	r2, [r3, #10]
            }
            
            mp3.currentGPIOfunction = mp3.GPIOfunction::kVolumeUp;
   1475c:	4b0b      	ldr	r3, [pc, #44]	; (1478c <SW2ISR()+0x80>)
   1475e:	2200      	movs	r2, #0
   14760:	709a      	strb	r2, [r3, #2]
			break;
   14762:	e003      	b.n	1476c <SW2ISR()+0x60>
        default:
            mp3.currentGPIOfunction = mp3.GPIOfunction::kIDLE;
   14764:	4b09      	ldr	r3, [pc, #36]	; (1478c <SW2ISR()+0x80>)
   14766:	2204      	movs	r2, #4
   14768:	709a      	strb	r2, [r3, #2]
            break;
   1476a:	bf00      	nop
	}
    LPC_GPIOINT->IO0IntClr |= 1 << 30;
   1476c:	4b08      	ldr	r3, [pc, #32]	; (14790 <SW2ISR()+0x84>)
   1476e:	68db      	ldr	r3, [r3, #12]
   14770:	4a07      	ldr	r2, [pc, #28]	; (14790 <SW2ISR()+0x84>)
   14772:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   14776:	60d3      	str	r3, [r2, #12]
   14778:	4623      	mov	r3, r4
   1477a:	4619      	mov	r1, r3
   1477c:	4802      	ldr	r0, [pc, #8]	; (14788 <SW2ISR()+0x7c>)
   1477e:	f002 f8cd 	bl	1691c <__cyg_profile_func_exit>
}
   14782:	bf00      	nop
   14784:	bd10      	pop	{r4, pc}
   14786:	bf00      	nop
   14788:	0001470d 	.word	0x0001470d
   1478c:	100008bc 	.word	0x100008bc
   14790:	40028080 	.word	0x40028080

00014794 <timerScanISR()>:

void timerScanISR()
{
   14794:	b510      	push	{r4, lr}
   14796:	4674      	mov	r4, lr
   14798:	4623      	mov	r3, r4
   1479a:	4619      	mov	r1, r3
   1479c:	4831      	ldr	r0, [pc, #196]	; (14864 <timerScanISR()+0xd0>)
   1479e:	f002 f8a9 	bl	168f4 <__cyg_profile_func_enter>
	switch (mp3.currentGPIOstate)
   147a2:	4b31      	ldr	r3, [pc, #196]	; (14868 <timerScanISR()+0xd4>)
   147a4:	781b      	ldrb	r3, [r3, #0]
   147a6:	2b01      	cmp	r3, #1
   147a8:	d01d      	beq.n	147e6 <timerScanISR()+0x52>
   147aa:	2b02      	cmp	r3, #2
   147ac:	d034      	beq.n	14818 <timerScanISR()+0x84>
   147ae:	2b00      	cmp	r3, #0
   147b0:	d000      	beq.n	147b4 <timerScanISR()+0x20>
                mp3.oled.printf("Track control state\n");
				mp3.currentGPIOstate = mp3.GPIOstate::kTrack;
			}
            break;
        default:
			break;
   147b2:	e04f      	b.n	14854 <timerScanISR()+0xc0>
			if (S1.ReadBool())
   147b4:	482d      	ldr	r0, [pc, #180]	; (1486c <timerScanISR()+0xd8>)
   147b6:	f000 fddb 	bl	15370 <LabGPIO::ReadBool()>
   147ba:	4603      	mov	r3, r0
   147bc:	2b00      	cmp	r3, #0
   147be:	d044      	beq.n	1484a <timerScanISR()+0xb6>
				led.Off(1);
   147c0:	2101      	movs	r1, #1
   147c2:	482b      	ldr	r0, [pc, #172]	; (14870 <timerScanISR()+0xdc>)
   147c4:	f7fe fb0c 	bl	12de0 <OnBoardLed::Off(unsigned char)>
                led.Off(0);		
   147c8:	2100      	movs	r1, #0
   147ca:	4829      	ldr	r0, [pc, #164]	; (14870 <timerScanISR()+0xdc>)
   147cc:	f7fe fb08 	bl	12de0 <OnBoardLed::Off(unsigned char)>
                mp3.oled.Clear();
   147d0:	4828      	ldr	r0, [pc, #160]	; (14874 <timerScanISR()+0xe0>)
   147d2:	f7ff feaf 	bl	14534 <OledTerminal::Clear()>
                mp3.oled.printf("Volume control state\n");								//the toggle lets the user know if their button registered
   147d6:	4928      	ldr	r1, [pc, #160]	; (14878 <timerScanISR()+0xe4>)
   147d8:	4826      	ldr	r0, [pc, #152]	; (14874 <timerScanISR()+0xe0>)
   147da:	f7ff fd65 	bl	142a8 <OledTerminal::printf(char const*, ...)>
				mp3.currentGPIOstate = mp3.GPIOstate::kVolume;
   147de:	4b22      	ldr	r3, [pc, #136]	; (14868 <timerScanISR()+0xd4>)
   147e0:	2201      	movs	r2, #1
   147e2:	701a      	strb	r2, [r3, #0]
			break;
   147e4:	e031      	b.n	1484a <timerScanISR()+0xb6>
			if (S1.ReadBool())
   147e6:	4821      	ldr	r0, [pc, #132]	; (1486c <timerScanISR()+0xd8>)
   147e8:	f000 fdc2 	bl	15370 <LabGPIO::ReadBool()>
   147ec:	4603      	mov	r3, r0
   147ee:	2b00      	cmp	r3, #0
   147f0:	d02d      	beq.n	1484e <timerScanISR()+0xba>
                led.Off(1);
   147f2:	2101      	movs	r1, #1
   147f4:	481e      	ldr	r0, [pc, #120]	; (14870 <timerScanISR()+0xdc>)
   147f6:	f7fe faf3 	bl	12de0 <OnBoardLed::Off(unsigned char)>
				led.On(0);
   147fa:	2100      	movs	r1, #0
   147fc:	481c      	ldr	r0, [pc, #112]	; (14870 <timerScanISR()+0xdc>)
   147fe:	f7fe faaf 	bl	12d60 <OnBoardLed::On(unsigned char)>
                mp3.oled.Clear();
   14802:	481c      	ldr	r0, [pc, #112]	; (14874 <timerScanISR()+0xe0>)
   14804:	f7ff fe96 	bl	14534 <OledTerminal::Clear()>
                mp3.oled.printf("Playback control state\n");
   14808:	491c      	ldr	r1, [pc, #112]	; (1487c <timerScanISR()+0xe8>)
   1480a:	481a      	ldr	r0, [pc, #104]	; (14874 <timerScanISR()+0xe0>)
   1480c:	f7ff fd4c 	bl	142a8 <OledTerminal::printf(char const*, ...)>
				mp3.currentGPIOstate = mp3.GPIOstate::kPlayback;
   14810:	4b15      	ldr	r3, [pc, #84]	; (14868 <timerScanISR()+0xd4>)
   14812:	2202      	movs	r2, #2
   14814:	701a      	strb	r2, [r3, #0]
			break;
   14816:	e01a      	b.n	1484e <timerScanISR()+0xba>
            if (S1.ReadBool())
   14818:	4814      	ldr	r0, [pc, #80]	; (1486c <timerScanISR()+0xd8>)
   1481a:	f000 fda9 	bl	15370 <LabGPIO::ReadBool()>
   1481e:	4603      	mov	r3, r0
   14820:	2b00      	cmp	r3, #0
   14822:	d016      	beq.n	14852 <timerScanISR()+0xbe>
				led.On(1);
   14824:	2101      	movs	r1, #1
   14826:	4812      	ldr	r0, [pc, #72]	; (14870 <timerScanISR()+0xdc>)
   14828:	f7fe fa9a 	bl	12d60 <OnBoardLed::On(unsigned char)>
                led.On(0);
   1482c:	2100      	movs	r1, #0
   1482e:	4810      	ldr	r0, [pc, #64]	; (14870 <timerScanISR()+0xdc>)
   14830:	f7fe fa96 	bl	12d60 <OnBoardLed::On(unsigned char)>
                mp3.oled.Clear();
   14834:	480f      	ldr	r0, [pc, #60]	; (14874 <timerScanISR()+0xe0>)
   14836:	f7ff fe7d 	bl	14534 <OledTerminal::Clear()>
                mp3.oled.printf("Track control state\n");
   1483a:	4911      	ldr	r1, [pc, #68]	; (14880 <timerScanISR()+0xec>)
   1483c:	480d      	ldr	r0, [pc, #52]	; (14874 <timerScanISR()+0xe0>)
   1483e:	f7ff fd33 	bl	142a8 <OledTerminal::printf(char const*, ...)>
				mp3.currentGPIOstate = mp3.GPIOstate::kTrack;
   14842:	4b09      	ldr	r3, [pc, #36]	; (14868 <timerScanISR()+0xd4>)
   14844:	2200      	movs	r2, #0
   14846:	701a      	strb	r2, [r3, #0]
            break;
   14848:	e003      	b.n	14852 <timerScanISR()+0xbe>
			break;
   1484a:	bf00      	nop
   1484c:	e002      	b.n	14854 <timerScanISR()+0xc0>
			break;
   1484e:	bf00      	nop
   14850:	e000      	b.n	14854 <timerScanISR()+0xc0>
            break;
   14852:	bf00      	nop
   14854:	4623      	mov	r3, r4
   14856:	4619      	mov	r1, r3
   14858:	4802      	ldr	r0, [pc, #8]	; (14864 <timerScanISR()+0xd0>)
   1485a:	f002 f85f 	bl	1691c <__cyg_profile_func_exit>
	}
}
   1485e:	bf00      	nop
   14860:	bd10      	pop	{r4, pc}
   14862:	bf00      	nop
   14864:	00014795 	.word	0x00014795
   14868:	100008bc 	.word	0x100008bc
   1486c:	10002700 	.word	0x10002700
   14870:	10000478 	.word	0x10000478
   14874:	100008cc 	.word	0x100008cc
   14878:	0001d374 	.word	0x0001d374
   1487c:	0001d38c 	.word	0x0001d38c
   14880:	0001d3a4 	.word	0x0001d3a4

00014884 <play(void*)>:

void play(void *){
   14884:	b500      	push	{lr}
   14886:	b085      	sub	sp, #20
   14888:	4673      	mov	r3, lr
   1488a:	9001      	str	r0, [sp, #4]
   1488c:	4619      	mov	r1, r3
   1488e:	487b      	ldr	r0, [pc, #492]	; (14a7c <play(void*)+0x1f8>)
   14890:	f002 f830 	bl	168f4 <__cyg_profile_func_enter>
    int update = 0;
   14894:	2300      	movs	r3, #0
   14896:	9303      	str	r3, [sp, #12]
    while(1){
        mp3.oled.Clear();
   14898:	4879      	ldr	r0, [pc, #484]	; (14a80 <play(void*)+0x1fc>)
   1489a:	f7ff fe4b 	bl	14534 <OledTerminal::Clear()>
        mp3.oled.printf("Playing: \n%s\n\n", mp3.songlist[mp3.songIndex]);
   1489e:	4b79      	ldr	r3, [pc, #484]	; (14a84 <play(void*)+0x200>)
   148a0:	78db      	ldrb	r3, [r3, #3]
   148a2:	021b      	lsls	r3, r3, #8
   148a4:	f503 63fb 	add.w	r3, r3, #2008	; 0x7d8
   148a8:	4a76      	ldr	r2, [pc, #472]	; (14a84 <play(void*)+0x200>)
   148aa:	4413      	add	r3, r2
   148ac:	461a      	mov	r2, r3
   148ae:	4976      	ldr	r1, [pc, #472]	; (14a88 <play(void*)+0x204>)
   148b0:	4873      	ldr	r0, [pc, #460]	; (14a80 <play(void*)+0x1fc>)
   148b2:	f7ff fcf9 	bl	142a8 <OledTerminal::printf(char const*, ...)>
        mp3.currentPlayState = mp3.playState::kPlay;
   148b6:	4b73      	ldr	r3, [pc, #460]	; (14a84 <play(void*)+0x200>)
   148b8:	2201      	movs	r2, #1
   148ba:	705a      	strb	r2, [r3, #1]
        while(!f_eof(&dir)){
   148bc:	4b73      	ldr	r3, [pc, #460]	; (14a8c <play(void*)+0x208>)
   148be:	695a      	ldr	r2, [r3, #20]
   148c0:	4b72      	ldr	r3, [pc, #456]	; (14a8c <play(void*)+0x208>)
   148c2:	68db      	ldr	r3, [r3, #12]
   148c4:	429a      	cmp	r2, r3
   148c6:	d0e7      	beq.n	14898 <play(void*)+0x14>
            f_read(&dir, buff, 2048, &br);
   148c8:	4b71      	ldr	r3, [pc, #452]	; (14a90 <play(void*)+0x20c>)
   148ca:	f44f 6200 	mov.w	r2, #2048	; 0x800
   148ce:	4971      	ldr	r1, [pc, #452]	; (14a94 <play(void*)+0x210>)
   148d0:	486e      	ldr	r0, [pc, #440]	; (14a8c <play(void*)+0x208>)
   148d2:	f007 faf7 	bl	1bec4 <f_read>
            while(chunk_count < sizeof(buff)/32){
   148d6:	4b70      	ldr	r3, [pc, #448]	; (14a98 <play(void*)+0x214>)
   148d8:	781b      	ldrb	r3, [r3, #0]
   148da:	2b3f      	cmp	r3, #63	; 0x3f
   148dc:	f200 80c9 	bhi.w	14a72 <play(void*)+0x1ee>
                byte_count = chunk_count * 32;
   148e0:	4b6d      	ldr	r3, [pc, #436]	; (14a98 <play(void*)+0x214>)
   148e2:	781b      	ldrb	r3, [r3, #0]
   148e4:	b29b      	uxth	r3, r3
   148e6:	015b      	lsls	r3, r3, #5
   148e8:	b29a      	uxth	r2, r3
   148ea:	4b6c      	ldr	r3, [pc, #432]	; (14a9c <play(void*)+0x218>)
   148ec:	801a      	strh	r2, [r3, #0]
                while(!mp3.waitDREQ());
   148ee:	4865      	ldr	r0, [pc, #404]	; (14a84 <play(void*)+0x200>)
   148f0:	f7fc fa3a 	bl	10d68 <MP3_Decoder::waitDREQ()>
   148f4:	4603      	mov	r3, r0
   148f6:	f083 0301 	eor.w	r3, r3, #1
   148fa:	b2db      	uxtb	r3, r3
   148fc:	2b00      	cmp	r3, #0
   148fe:	d000      	beq.n	14902 <play(void*)+0x7e>
   14900:	e7f5      	b.n	148ee <play(void*)+0x6a>
                mp3.DataWrite(buff, 32, byte_count);
   14902:	4b66      	ldr	r3, [pc, #408]	; (14a9c <play(void*)+0x218>)
   14904:	881b      	ldrh	r3, [r3, #0]
   14906:	2220      	movs	r2, #32
   14908:	4962      	ldr	r1, [pc, #392]	; (14a94 <play(void*)+0x210>)
   1490a:	485e      	ldr	r0, [pc, #376]	; (14a84 <play(void*)+0x200>)
   1490c:	f7fc f950 	bl	10bb0 <MP3_Decoder::DataWrite(unsigned char*, unsigned char, unsigned long)>
                chunk_count++;
   14910:	4b61      	ldr	r3, [pc, #388]	; (14a98 <play(void*)+0x214>)
   14912:	781b      	ldrb	r3, [r3, #0]
   14914:	3301      	adds	r3, #1
   14916:	b2da      	uxtb	r2, r3
   14918:	4b5f      	ldr	r3, [pc, #380]	; (14a98 <play(void*)+0x214>)
   1491a:	701a      	strb	r2, [r3, #0]
                
                switch (mp3.currentPlayState)
   1491c:	4b59      	ldr	r3, [pc, #356]	; (14a84 <play(void*)+0x200>)
   1491e:	785b      	ldrb	r3, [r3, #1]
   14920:	2b00      	cmp	r3, #0
   14922:	f000 809f 	beq.w	14a64 <play(void*)+0x1e0>
   14926:	2b01      	cmp	r3, #1
   14928:	f040 80a2 	bne.w	14a70 <play(void*)+0x1ec>
			    {
                    
                    case mp3.playState::kPlay:
                        switch (mp3.currentGPIOfunction)
   1492c:	4b55      	ldr	r3, [pc, #340]	; (14a84 <play(void*)+0x200>)
   1492e:	789b      	ldrb	r3, [r3, #2]
   14930:	2b03      	cmp	r3, #3
   14932:	f200 8095 	bhi.w	14a60 <play(void*)+0x1dc>
   14936:	a201      	add	r2, pc, #4	; (adr r2, 1493c <play(void*)+0xb8>)
   14938:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   1493c:	0001494d 	.word	0x0001494d
   14940:	0001496d 	.word	0x0001496d
   14944:	0001498d 	.word	0x0001498d
   14948:	000149f5 	.word	0x000149f5
                        {
                            case mp3.GPIOfunction::kVolumeUp:
                                mp3.WriteRegister(mp3.VOL, mp3.volume * mp3.VOLUME_OFFSET);
   1494c:	4b4d      	ldr	r3, [pc, #308]	; (14a84 <play(void*)+0x200>)
   1494e:	895a      	ldrh	r2, [r3, #10]
   14950:	4b4c      	ldr	r3, [pc, #304]	; (14a84 <play(void*)+0x200>)
   14952:	899b      	ldrh	r3, [r3, #12]
   14954:	fb12 f303 	smulbb	r3, r2, r3
   14958:	b29b      	uxth	r3, r3
   1495a:	461a      	mov	r2, r3
   1495c:	210b      	movs	r1, #11
   1495e:	4849      	ldr	r0, [pc, #292]	; (14a84 <play(void*)+0x200>)
   14960:	f7fc f8d8 	bl	10b14 <MP3_Decoder::WriteRegister(unsigned char, unsigned short)>
                                mp3.currentGPIOfunction = mp3.GPIOfunction::kIDLE;
   14964:	4b47      	ldr	r3, [pc, #284]	; (14a84 <play(void*)+0x200>)
   14966:	2204      	movs	r2, #4
   14968:	709a      	strb	r2, [r3, #2]
                                break;
   1496a:	e07a      	b.n	14a62 <play(void*)+0x1de>
                            case mp3.GPIOfunction::kVolumeDown:
                                mp3.WriteRegister(mp3.VOL, mp3.volume * mp3.VOLUME_OFFSET);
   1496c:	4b45      	ldr	r3, [pc, #276]	; (14a84 <play(void*)+0x200>)
   1496e:	895a      	ldrh	r2, [r3, #10]
   14970:	4b44      	ldr	r3, [pc, #272]	; (14a84 <play(void*)+0x200>)
   14972:	899b      	ldrh	r3, [r3, #12]
   14974:	fb12 f303 	smulbb	r3, r2, r3
   14978:	b29b      	uxth	r3, r3
   1497a:	461a      	mov	r2, r3
   1497c:	210b      	movs	r1, #11
   1497e:	4841      	ldr	r0, [pc, #260]	; (14a84 <play(void*)+0x200>)
   14980:	f7fc f8c8 	bl	10b14 <MP3_Decoder::WriteRegister(unsigned char, unsigned short)>
                                mp3.currentGPIOfunction = mp3.GPIOfunction::kIDLE;
   14984:	4b3f      	ldr	r3, [pc, #252]	; (14a84 <play(void*)+0x200>)
   14986:	2204      	movs	r2, #4
   14988:	709a      	strb	r2, [r3, #2]
                                break;
   1498a:	e06a      	b.n	14a62 <play(void*)+0x1de>
                            case mp3.GPIOfunction::kBackTrack:
                                if(mp3.songIndex <= 0)mp3.songIndex = mp3.maxSong;
   1498c:	4b3d      	ldr	r3, [pc, #244]	; (14a84 <play(void*)+0x200>)
   1498e:	78db      	ldrb	r3, [r3, #3]
   14990:	2b00      	cmp	r3, #0
   14992:	d104      	bne.n	1499e <play(void*)+0x11a>
   14994:	4b3b      	ldr	r3, [pc, #236]	; (14a84 <play(void*)+0x200>)
   14996:	791a      	ldrb	r2, [r3, #4]
   14998:	4b3a      	ldr	r3, [pc, #232]	; (14a84 <play(void*)+0x200>)
   1499a:	70da      	strb	r2, [r3, #3]
   1499c:	e005      	b.n	149aa <play(void*)+0x126>
                                else mp3.songIndex--;
   1499e:	4b39      	ldr	r3, [pc, #228]	; (14a84 <play(void*)+0x200>)
   149a0:	78db      	ldrb	r3, [r3, #3]
   149a2:	3b01      	subs	r3, #1
   149a4:	b2da      	uxtb	r2, r3
   149a6:	4b37      	ldr	r3, [pc, #220]	; (14a84 <play(void*)+0x200>)
   149a8:	70da      	strb	r2, [r3, #3]
                                //oled.Clear();
                                f_close(&dir);
   149aa:	4838      	ldr	r0, [pc, #224]	; (14a8c <play(void*)+0x208>)
   149ac:	f007 fc58 	bl	1c260 <f_close>
                                // close sd file
                                mp3.SoftReset();
   149b0:	4834      	ldr	r0, [pc, #208]	; (14a84 <play(void*)+0x200>)
   149b2:	f7fc f96f 	bl	10c94 <MP3_Decoder::SoftReset()>
                                //init function to start the next song
                                f_open(&dir, mp3.songlist[mp3.songIndex], FA_READ);
   149b6:	4b33      	ldr	r3, [pc, #204]	; (14a84 <play(void*)+0x200>)
   149b8:	78db      	ldrb	r3, [r3, #3]
   149ba:	021b      	lsls	r3, r3, #8
   149bc:	f503 63fb 	add.w	r3, r3, #2008	; 0x7d8
   149c0:	4a30      	ldr	r2, [pc, #192]	; (14a84 <play(void*)+0x200>)
   149c2:	4413      	add	r3, r2
   149c4:	2201      	movs	r2, #1
   149c6:	4619      	mov	r1, r3
   149c8:	4830      	ldr	r0, [pc, #192]	; (14a8c <play(void*)+0x208>)
   149ca:	f007 f8df 	bl	1bb8c <f_open>
                                mp3.oled.Clear();
   149ce:	482c      	ldr	r0, [pc, #176]	; (14a80 <play(void*)+0x1fc>)
   149d0:	f7ff fdb0 	bl	14534 <OledTerminal::Clear()>
                                mp3.oled.printf("Playing: \n%s\n", mp3.songlist[mp3.songIndex]);
   149d4:	4b2b      	ldr	r3, [pc, #172]	; (14a84 <play(void*)+0x200>)
   149d6:	78db      	ldrb	r3, [r3, #3]
   149d8:	021b      	lsls	r3, r3, #8
   149da:	f503 63fb 	add.w	r3, r3, #2008	; 0x7d8
   149de:	4a29      	ldr	r2, [pc, #164]	; (14a84 <play(void*)+0x200>)
   149e0:	4413      	add	r3, r2
   149e2:	461a      	mov	r2, r3
   149e4:	492e      	ldr	r1, [pc, #184]	; (14aa0 <play(void*)+0x21c>)
   149e6:	4826      	ldr	r0, [pc, #152]	; (14a80 <play(void*)+0x1fc>)
   149e8:	f7ff fc5e 	bl	142a8 <OledTerminal::printf(char const*, ...)>
                                mp3.currentGPIOfunction = mp3.GPIOfunction::kIDLE;
   149ec:	4b25      	ldr	r3, [pc, #148]	; (14a84 <play(void*)+0x200>)
   149ee:	2204      	movs	r2, #4
   149f0:	709a      	strb	r2, [r3, #2]
                                break;
   149f2:	e036      	b.n	14a62 <play(void*)+0x1de>
                            case mp3.GPIOfunction::kNextTrack:
                                //oled.Clear();
                                if (mp3.songIndex+1 >= mp3.maxSong)mp3.songIndex = 0;
   149f4:	4b23      	ldr	r3, [pc, #140]	; (14a84 <play(void*)+0x200>)
   149f6:	78db      	ldrb	r3, [r3, #3]
   149f8:	3301      	adds	r3, #1
   149fa:	4a22      	ldr	r2, [pc, #136]	; (14a84 <play(void*)+0x200>)
   149fc:	7912      	ldrb	r2, [r2, #4]
   149fe:	4293      	cmp	r3, r2
   14a00:	db03      	blt.n	14a0a <play(void*)+0x186>
   14a02:	4b20      	ldr	r3, [pc, #128]	; (14a84 <play(void*)+0x200>)
   14a04:	2200      	movs	r2, #0
   14a06:	70da      	strb	r2, [r3, #3]
   14a08:	e005      	b.n	14a16 <play(void*)+0x192>
                                else mp3.songIndex++;
   14a0a:	4b1e      	ldr	r3, [pc, #120]	; (14a84 <play(void*)+0x200>)
   14a0c:	78db      	ldrb	r3, [r3, #3]
   14a0e:	3301      	adds	r3, #1
   14a10:	b2da      	uxtb	r2, r3
   14a12:	4b1c      	ldr	r3, [pc, #112]	; (14a84 <play(void*)+0x200>)
   14a14:	70da      	strb	r2, [r3, #3]
                                f_close(&dir);
   14a16:	481d      	ldr	r0, [pc, #116]	; (14a8c <play(void*)+0x208>)
   14a18:	f007 fc22 	bl	1c260 <f_close>
                                // close sd file
                                mp3.SoftReset();
   14a1c:	4819      	ldr	r0, [pc, #100]	; (14a84 <play(void*)+0x200>)
   14a1e:	f7fc f939 	bl	10c94 <MP3_Decoder::SoftReset()>
                                //init function to start the next song
                                f_open(&dir, mp3.songlist[mp3.songIndex], FA_READ);
   14a22:	4b18      	ldr	r3, [pc, #96]	; (14a84 <play(void*)+0x200>)
   14a24:	78db      	ldrb	r3, [r3, #3]
   14a26:	021b      	lsls	r3, r3, #8
   14a28:	f503 63fb 	add.w	r3, r3, #2008	; 0x7d8
   14a2c:	4a15      	ldr	r2, [pc, #84]	; (14a84 <play(void*)+0x200>)
   14a2e:	4413      	add	r3, r2
   14a30:	2201      	movs	r2, #1
   14a32:	4619      	mov	r1, r3
   14a34:	4815      	ldr	r0, [pc, #84]	; (14a8c <play(void*)+0x208>)
   14a36:	f007 f8a9 	bl	1bb8c <f_open>
                                mp3.oled.Clear();
   14a3a:	4811      	ldr	r0, [pc, #68]	; (14a80 <play(void*)+0x1fc>)
   14a3c:	f7ff fd7a 	bl	14534 <OledTerminal::Clear()>
                                mp3.oled.printf("Playing: \n%s\n", mp3.songlist[mp3.songIndex]);
   14a40:	4b10      	ldr	r3, [pc, #64]	; (14a84 <play(void*)+0x200>)
   14a42:	78db      	ldrb	r3, [r3, #3]
   14a44:	021b      	lsls	r3, r3, #8
   14a46:	f503 63fb 	add.w	r3, r3, #2008	; 0x7d8
   14a4a:	4a0e      	ldr	r2, [pc, #56]	; (14a84 <play(void*)+0x200>)
   14a4c:	4413      	add	r3, r2
   14a4e:	461a      	mov	r2, r3
   14a50:	4913      	ldr	r1, [pc, #76]	; (14aa0 <play(void*)+0x21c>)
   14a52:	480b      	ldr	r0, [pc, #44]	; (14a80 <play(void*)+0x1fc>)
   14a54:	f7ff fc28 	bl	142a8 <OledTerminal::printf(char const*, ...)>
                                mp3.currentGPIOfunction = mp3.GPIOfunction::kIDLE;
   14a58:	4b0a      	ldr	r3, [pc, #40]	; (14a84 <play(void*)+0x200>)
   14a5a:	2204      	movs	r2, #4
   14a5c:	709a      	strb	r2, [r3, #2]
                                break;
   14a5e:	e000      	b.n	14a62 <play(void*)+0x1de>
                            default:
                                break;
   14a60:	bf00      	nop
                        }
                        break;
   14a62:	e005      	b.n	14a70 <play(void*)+0x1ec>
                    case mp3.playState::kPause:
                        while (mp3.currentPlayState == mp3.playState::kPause);	//pause until state changes
   14a64:	4b07      	ldr	r3, [pc, #28]	; (14a84 <play(void*)+0x200>)
   14a66:	785b      	ldrb	r3, [r3, #1]
   14a68:	2b00      	cmp	r3, #0
   14a6a:	d100      	bne.n	14a6e <play(void*)+0x1ea>
   14a6c:	e7fa      	b.n	14a64 <play(void*)+0x1e0>
                        break;
   14a6e:	bf00      	nop
            while(chunk_count < sizeof(buff)/32){
   14a70:	e731      	b.n	148d6 <play(void*)+0x52>
			    }
            }
            chunk_count = 0;
   14a72:	4b09      	ldr	r3, [pc, #36]	; (14a98 <play(void*)+0x214>)
   14a74:	2200      	movs	r2, #0
   14a76:	701a      	strb	r2, [r3, #0]
        while(!f_eof(&dir)){
   14a78:	e720      	b.n	148bc <play(void*)+0x38>
   14a7a:	bf00      	nop
   14a7c:	00014885 	.word	0x00014885
   14a80:	100008cc 	.word	0x100008cc
   14a84:	100008bc 	.word	0x100008bc
   14a88:	0001d3bc 	.word	0x0001d3bc
   14a8c:	10001cc4 	.word	0x10001cc4
   14a90:	10001eec 	.word	0x10001eec
   14a94:	10001ef4 	.word	0x10001ef4
   14a98:	10001ef0 	.word	0x10001ef0
   14a9c:	10001ef2 	.word	0x10001ef2
   14aa0:	0001d3cc 	.word	0x0001d3cc

00014aa4 <main>:
            
        }
        
    }
}
int main(){   
   14aa4:	b500      	push	{lr}
   14aa6:	b089      	sub	sp, #36	; 0x24
   14aa8:	4673      	mov	r3, lr
   14aaa:	4619      	mov	r1, r3
   14aac:	483c      	ldr	r0, [pc, #240]	; (14ba0 <main+0xfc>)
   14aae:	f001 ff21 	bl	168f4 <__cyg_profile_func_enter>
    bool success = mp3.initialize();
   14ab2:	483c      	ldr	r0, [pc, #240]	; (14ba4 <main+0x100>)
   14ab4:	f7fb ff76 	bl	109a4 <MP3_Decoder::initialize()>
   14ab8:	4603      	mov	r3, r0
   14aba:	f88d 301f 	strb.w	r3, [sp, #31]
    mp3.HardReset();
   14abe:	4839      	ldr	r0, [pc, #228]	; (14ba4 <main+0x100>)
   14ac0:	f7fc f8b2 	bl	10c28 <MP3_Decoder::HardReset()>
    char path[10];
    led.Initialize();
   14ac4:	4838      	ldr	r0, [pc, #224]	; (14ba8 <main+0x104>)
   14ac6:	f7fe f913 	bl	12cf0 <OnBoardLed::Initialize()>
    S3.AttachInterruptHandler(SW3ISR, LabGPIO::Edge::kRising);
   14aca:	2201      	movs	r2, #1
   14acc:	4937      	ldr	r1, [pc, #220]	; (14bac <main+0x108>)
   14ace:	4838      	ldr	r0, [pc, #224]	; (14bb0 <main+0x10c>)
   14ad0:	f000 fcfe 	bl	154d0 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)>
    S2.AttachInterruptHandler(SW2ISR, LabGPIO::Edge::kRising);
   14ad4:	2201      	movs	r2, #1
   14ad6:	4937      	ldr	r1, [pc, #220]	; (14bb4 <main+0x110>)
   14ad8:	4837      	ldr	r0, [pc, #220]	; (14bb8 <main+0x114>)
   14ada:	f000 fcf9 	bl	154d0 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)>
    S3.EnableInterrupts();
   14ade:	f000 fcdd 	bl	1549c <LabGPIO::EnableInterrupts()>
    S2.EnableInterrupts();
   14ae2:	f000 fcdb 	bl	1549c <LabGPIO::EnableInterrupts()>
    fres = f_mount(&tester, "", 0);
   14ae6:	2200      	movs	r2, #0
   14ae8:	4934      	ldr	r1, [pc, #208]	; (14bbc <main+0x118>)
   14aea:	4835      	ldr	r0, [pc, #212]	; (14bc0 <main+0x11c>)
   14aec:	f007 f800 	bl	1baf0 <f_mount>
   14af0:	4603      	mov	r3, r0
   14af2:	461a      	mov	r2, r3
   14af4:	4b33      	ldr	r3, [pc, #204]	; (14bc4 <main+0x120>)
   14af6:	701a      	strb	r2, [r3, #0]
    if(fres == FR_OK){
   14af8:	4b32      	ldr	r3, [pc, #200]	; (14bc4 <main+0x120>)
   14afa:	781b      	ldrb	r3, [r3, #0]
   14afc:	2b00      	cmp	r3, #0
   14afe:	d10b      	bne.n	14b18 <main+0x74>
        strcpy(path, "/");
   14b00:	ab05      	add	r3, sp, #20
   14b02:	222f      	movs	r2, #47	; 0x2f
   14b04:	801a      	strh	r2, [r3, #0]
        fres = mp3.scan_files(path);
   14b06:	ab05      	add	r3, sp, #20
   14b08:	4619      	mov	r1, r3
   14b0a:	4826      	ldr	r0, [pc, #152]	; (14ba4 <main+0x100>)
   14b0c:	f7fc f948 	bl	10da0 <MP3_Decoder::scan_files(char*)>
   14b10:	4603      	mov	r3, r0
   14b12:	461a      	mov	r2, r3
   14b14:	4b2b      	ldr	r3, [pc, #172]	; (14bc4 <main+0x120>)
   14b16:	701a      	strb	r2, [r3, #0]
    }
    
    fres = f_open(&dir, mp3.songlist[mp3.songIndex], FA_READ);
   14b18:	4b22      	ldr	r3, [pc, #136]	; (14ba4 <main+0x100>)
   14b1a:	78db      	ldrb	r3, [r3, #3]
   14b1c:	021b      	lsls	r3, r3, #8
   14b1e:	f503 63fb 	add.w	r3, r3, #2008	; 0x7d8
   14b22:	4a20      	ldr	r2, [pc, #128]	; (14ba4 <main+0x100>)
   14b24:	4413      	add	r3, r2
   14b26:	2201      	movs	r2, #1
   14b28:	4619      	mov	r1, r3
   14b2a:	4827      	ldr	r0, [pc, #156]	; (14bc8 <main+0x124>)
   14b2c:	f007 f82e 	bl	1bb8c <f_open>
   14b30:	4603      	mov	r3, r0
   14b32:	461a      	mov	r2, r3
   14b34:	4b23      	ldr	r3, [pc, #140]	; (14bc4 <main+0x120>)
   14b36:	701a      	strb	r2, [r3, #0]
    if(fres == FR_OK){
   14b38:	4b22      	ldr	r3, [pc, #136]	; (14bc4 <main+0x120>)
   14b3a:	781b      	ldrb	r3, [r3, #0]
   14b3c:	2b00      	cmp	r3, #0
   14b3e:	d12d      	bne.n	14b9c <main+0xf8>
        while(!mp3.waitDREQ());
   14b40:	4818      	ldr	r0, [pc, #96]	; (14ba4 <main+0x100>)
   14b42:	f7fc f911 	bl	10d68 <MP3_Decoder::waitDREQ()>
   14b46:	4603      	mov	r3, r0
   14b48:	f083 0301 	eor.w	r3, r3, #1
   14b4c:	b2db      	uxtb	r3, r3
   14b4e:	2b00      	cmp	r3, #0
   14b50:	d000      	beq.n	14b54 <main+0xb0>
   14b52:	e7f5      	b.n	14b40 <main+0x9c>
        Timer timerScan(TimerInterface::kTimer1);
   14b54:	4b1d      	ldr	r3, [pc, #116]	; (14bcc <main+0x128>)
   14b56:	9302      	str	r3, [sp, #8]
   14b58:	4b1d      	ldr	r3, [pc, #116]	; (14bd0 <main+0x12c>)
   14b5a:	9303      	str	r3, [sp, #12]
   14b5c:	2301      	movs	r3, #1
   14b5e:	f88d 3010 	strb.w	r3, [sp, #16]
        timerScan.Initialize(1'000'000,timerScanISR);
   14b62:	a802      	add	r0, sp, #8
   14b64:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   14b68:	4a1a      	ldr	r2, [pc, #104]	; (14bd4 <main+0x130>)
   14b6a:	491b      	ldr	r1, [pc, #108]	; (14bd8 <main+0x134>)
   14b6c:	f7fd fb4c 	bl	12208 <Timer::Initialize(unsigned long, void (*)(), long)>
        timerScan.SetTimer(1'000'000,Timer::TimerIsrCondition::kInterruptRestart); //1'000'000 or 750'000 for the speed
   14b70:	a802      	add	r0, sp, #8
   14b72:	2300      	movs	r3, #0
   14b74:	2203      	movs	r2, #3
   14b76:	4918      	ldr	r1, [pc, #96]	; (14bd8 <main+0x134>)
   14b78:	f7fd fbf8 	bl	1236c <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)>
        xTaskCreate(play, "play", 1024, NULL, 5, NULL);
   14b7c:	2300      	movs	r3, #0
   14b7e:	9301      	str	r3, [sp, #4]
   14b80:	2305      	movs	r3, #5
   14b82:	9300      	str	r3, [sp, #0]
   14b84:	2300      	movs	r3, #0
   14b86:	f44f 6280 	mov.w	r2, #1024	; 0x400
   14b8a:	4914      	ldr	r1, [pc, #80]	; (14bdc <main+0x138>)
   14b8c:	4814      	ldr	r0, [pc, #80]	; (14be0 <main+0x13c>)
   14b8e:	f001 ff92 	bl	16ab6 <xTaskCreate>
        vTaskStartScheduler();
   14b92:	f002 f8bf 	bl	16d14 <vTaskStartScheduler>
        printf("Opened track successfully!\n");
   14b96:	4813      	ldr	r0, [pc, #76]	; (14be4 <main+0x140>)
   14b98:	f001 fe7c 	bl	16894 <puts>
    }

    
    while(true);
   14b9c:	e7fe      	b.n	14b9c <main+0xf8>
   14b9e:	bf00      	nop
   14ba0:	00014aa5 	.word	0x00014aa5
   14ba4:	100008bc 	.word	0x100008bc
   14ba8:	10000478 	.word	0x10000478
   14bac:	00014665 	.word	0x00014665
   14bb0:	100026f8 	.word	0x100026f8
   14bb4:	0001470d 	.word	0x0001470d
   14bb8:	100026fc 	.word	0x100026fc
   14bbc:	0001d3dc 	.word	0x0001d3dc
   14bc0:	10001a94 	.word	0x10001a94
   14bc4:	100026f4 	.word	0x100026f4
   14bc8:	10001cc4 	.word	0x10001cc4
   14bcc:	0001d6f0 	.word	0x0001d6f0
   14bd0:	0001d704 	.word	0x0001d704
   14bd4:	00014795 	.word	0x00014795
   14bd8:	000f4240 	.word	0x000f4240
   14bdc:	0001d3e0 	.word	0x0001d3e0
   14be0:	00014885 	.word	0x00014885
   14be4:	0001d3e8 	.word	0x0001d3e8

00014be8 <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()>:
  static void TimerHandler()
   14be8:	b510      	push	{r4, lr}
   14bea:	4674      	mov	r4, lr
   14bec:	4623      	mov	r3, r4
   14bee:	4619      	mov	r1, r3
   14bf0:	480a      	ldr	r0, [pc, #40]	; (14c1c <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()+0x34>)
   14bf2:	f001 fe7f 	bl	168f4 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   14bf6:	2000      	movs	r0, #0
   14bf8:	f7fd faee 	bl	121d8 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   14bfc:	4603      	mov	r3, r0
   14bfe:	461a      	mov	r2, r3
   14c00:	4b07      	ldr	r3, [pc, #28]	; (14c20 <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()+0x38>)
   14c02:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14c06:	4798      	blx	r3
    ClearInterrupts<port>();
   14c08:	f000 f922 	bl	14e50 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()>
   14c0c:	4623      	mov	r3, r4
   14c0e:	4619      	mov	r1, r3
   14c10:	4802      	ldr	r0, [pc, #8]	; (14c1c <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()+0x34>)
   14c12:	f001 fe83 	bl	1691c <__cyg_profile_func_exit>
  }
   14c16:	bf00      	nop
   14c18:	bd10      	pop	{r4, pc}
   14c1a:	bf00      	nop
   14c1c:	00014be9 	.word	0x00014be9
   14c20:	100007ac 	.word	0x100007ac

00014c24 <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()>:
  static void TimerHandler()
   14c24:	b510      	push	{r4, lr}
   14c26:	4674      	mov	r4, lr
   14c28:	4623      	mov	r3, r4
   14c2a:	4619      	mov	r1, r3
   14c2c:	480a      	ldr	r0, [pc, #40]	; (14c58 <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()+0x34>)
   14c2e:	f001 fe61 	bl	168f4 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   14c32:	2001      	movs	r0, #1
   14c34:	f7fd fad0 	bl	121d8 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   14c38:	4603      	mov	r3, r0
   14c3a:	461a      	mov	r2, r3
   14c3c:	4b07      	ldr	r3, [pc, #28]	; (14c5c <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()+0x38>)
   14c3e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14c42:	4798      	blx	r3
    ClearInterrupts<port>();
   14c44:	f000 f954 	bl	14ef0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()>
   14c48:	4623      	mov	r3, r4
   14c4a:	4619      	mov	r1, r3
   14c4c:	4802      	ldr	r0, [pc, #8]	; (14c58 <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()+0x34>)
   14c4e:	f001 fe65 	bl	1691c <__cyg_profile_func_exit>
  }
   14c52:	bf00      	nop
   14c54:	bd10      	pop	{r4, pc}
   14c56:	bf00      	nop
   14c58:	00014c25 	.word	0x00014c25
   14c5c:	100007ac 	.word	0x100007ac

00014c60 <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()>:
  static void TimerHandler()
   14c60:	b510      	push	{r4, lr}
   14c62:	4674      	mov	r4, lr
   14c64:	4623      	mov	r3, r4
   14c66:	4619      	mov	r1, r3
   14c68:	480a      	ldr	r0, [pc, #40]	; (14c94 <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()+0x34>)
   14c6a:	f001 fe43 	bl	168f4 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   14c6e:	2002      	movs	r0, #2
   14c70:	f7fd fab2 	bl	121d8 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   14c74:	4603      	mov	r3, r0
   14c76:	461a      	mov	r2, r3
   14c78:	4b07      	ldr	r3, [pc, #28]	; (14c98 <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()+0x38>)
   14c7a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14c7e:	4798      	blx	r3
    ClearInterrupts<port>();
   14c80:	f000 f986 	bl	14f90 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()>
   14c84:	4623      	mov	r3, r4
   14c86:	4619      	mov	r1, r3
   14c88:	4802      	ldr	r0, [pc, #8]	; (14c94 <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()+0x34>)
   14c8a:	f001 fe47 	bl	1691c <__cyg_profile_func_exit>
  }
   14c8e:	bf00      	nop
   14c90:	bd10      	pop	{r4, pc}
   14c92:	bf00      	nop
   14c94:	00014c61 	.word	0x00014c61
   14c98:	100007ac 	.word	0x100007ac

00014c9c <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()>:
  static void TimerHandler()
   14c9c:	b510      	push	{r4, lr}
   14c9e:	4674      	mov	r4, lr
   14ca0:	4623      	mov	r3, r4
   14ca2:	4619      	mov	r1, r3
   14ca4:	480a      	ldr	r0, [pc, #40]	; (14cd0 <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()+0x34>)
   14ca6:	f001 fe25 	bl	168f4 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   14caa:	2003      	movs	r0, #3
   14cac:	f7fd fa94 	bl	121d8 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   14cb0:	4603      	mov	r3, r0
   14cb2:	461a      	mov	r2, r3
   14cb4:	4b07      	ldr	r3, [pc, #28]	; (14cd4 <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()+0x38>)
   14cb6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14cba:	4798      	blx	r3
    ClearInterrupts<port>();
   14cbc:	f000 f9b8 	bl	15030 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()>
   14cc0:	4623      	mov	r3, r4
   14cc2:	4619      	mov	r1, r3
   14cc4:	4802      	ldr	r0, [pc, #8]	; (14cd0 <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()+0x34>)
   14cc6:	f001 fe29 	bl	1691c <__cyg_profile_func_exit>
  }
   14cca:	bf00      	nop
   14ccc:	bd10      	pop	{r4, pc}
   14cce:	bf00      	nop
   14cd0:	00014c9d 	.word	0x00014c9d
   14cd4:	100007ac 	.word	0x100007ac

00014cd8 <unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)>:
constexpr T Set(T target, uint32_t position)
   14cd8:	b530      	push	{r4, r5, lr}
   14cda:	b083      	sub	sp, #12
   14cdc:	4675      	mov	r5, lr
   14cde:	9001      	str	r0, [sp, #4]
   14ce0:	9100      	str	r1, [sp, #0]
   14ce2:	462b      	mov	r3, r5
   14ce4:	4619      	mov	r1, r3
   14ce6:	480a      	ldr	r0, [pc, #40]	; (14d10 <unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)+0x38>)
   14ce8:	f001 fe04 	bl	168f4 <__cyg_profile_func_enter>
  return target | (1 << position);
   14cec:	2201      	movs	r2, #1
   14cee:	9b00      	ldr	r3, [sp, #0]
   14cf0:	fa02 f303 	lsl.w	r3, r2, r3
   14cf4:	461a      	mov	r2, r3
   14cf6:	9b01      	ldr	r3, [sp, #4]
   14cf8:	ea42 0403 	orr.w	r4, r2, r3
   14cfc:	462b      	mov	r3, r5
   14cfe:	4619      	mov	r1, r3
   14d00:	4803      	ldr	r0, [pc, #12]	; (14d10 <unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)+0x38>)
   14d02:	f001 fe0b 	bl	1691c <__cyg_profile_func_exit>
   14d06:	4623      	mov	r3, r4
}
   14d08:	4618      	mov	r0, r3
   14d0a:	b003      	add	sp, #12
   14d0c:	bd30      	pop	{r4, r5, pc}
   14d0e:	bf00      	nop
   14d10:	00014cd9 	.word	0x00014cd9

00014d14 <unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)>:
constexpr T Insert(T target, U value, uint32_t position, uint32_t width = 1)
   14d14:	b530      	push	{r4, r5, lr}
   14d16:	b089      	sub	sp, #36	; 0x24
   14d18:	4675      	mov	r5, lr
   14d1a:	9003      	str	r0, [sp, #12]
   14d1c:	9201      	str	r2, [sp, #4]
   14d1e:	9300      	str	r3, [sp, #0]
   14d20:	460b      	mov	r3, r1
   14d22:	f88d 300b 	strb.w	r3, [sp, #11]
   14d26:	462b      	mov	r3, r5
   14d28:	4619      	mov	r1, r3
   14d2a:	4816      	ldr	r0, [pc, #88]	; (14d84 <unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)+0x70>)
   14d2c:	f001 fde2 	bl	168f4 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   14d30:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   14d34:	9307      	str	r3, [sp, #28]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   14d36:	2320      	movs	r3, #32
   14d38:	9306      	str	r3, [sp, #24]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   14d3a:	9b00      	ldr	r3, [sp, #0]
   14d3c:	f1c3 0320 	rsb	r3, r3, #32
   14d40:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   14d44:	fa22 f303 	lsr.w	r3, r2, r3
   14d48:	9305      	str	r3, [sp, #20]
  target &= ~(mask << position);
   14d4a:	9a05      	ldr	r2, [sp, #20]
   14d4c:	9b01      	ldr	r3, [sp, #4]
   14d4e:	fa02 f303 	lsl.w	r3, r2, r3
   14d52:	43db      	mvns	r3, r3
   14d54:	9a03      	ldr	r2, [sp, #12]
   14d56:	4013      	ands	r3, r2
   14d58:	9303      	str	r3, [sp, #12]
  target |= (value & mask) << position;
   14d5a:	f89d 200b 	ldrb.w	r2, [sp, #11]
   14d5e:	9b05      	ldr	r3, [sp, #20]
   14d60:	401a      	ands	r2, r3
   14d62:	9b01      	ldr	r3, [sp, #4]
   14d64:	fa02 f303 	lsl.w	r3, r2, r3
   14d68:	9a03      	ldr	r2, [sp, #12]
   14d6a:	4313      	orrs	r3, r2
   14d6c:	9303      	str	r3, [sp, #12]
  return target;
   14d6e:	9c03      	ldr	r4, [sp, #12]
   14d70:	462b      	mov	r3, r5
   14d72:	4619      	mov	r1, r3
   14d74:	4803      	ldr	r0, [pc, #12]	; (14d84 <unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)+0x70>)
   14d76:	f001 fdd1 	bl	1691c <__cyg_profile_func_exit>
   14d7a:	4623      	mov	r3, r4
}
   14d7c:	4618      	mov	r0, r3
   14d7e:	b009      	add	sp, #36	; 0x24
   14d80:	bd30      	pop	{r4, r5, pc}
   14d82:	bf00      	nop
   14d84:	00014d15 	.word	0x00014d15

00014d88 <unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)>:
constexpr T Extract(T target, uint32_t position, uint32_t width = 1)
   14d88:	b530      	push	{r4, r5, lr}
   14d8a:	b089      	sub	sp, #36	; 0x24
   14d8c:	4675      	mov	r5, lr
   14d8e:	9003      	str	r0, [sp, #12]
   14d90:	9102      	str	r1, [sp, #8]
   14d92:	9201      	str	r2, [sp, #4]
   14d94:	462b      	mov	r3, r5
   14d96:	4619      	mov	r1, r3
   14d98:	480f      	ldr	r0, [pc, #60]	; (14dd8 <unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)+0x50>)
   14d9a:	f001 fdab 	bl	168f4 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   14d9e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   14da2:	9307      	str	r3, [sp, #28]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   14da4:	2320      	movs	r3, #32
   14da6:	9306      	str	r3, [sp, #24]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   14da8:	9b01      	ldr	r3, [sp, #4]
   14daa:	f1c3 0320 	rsb	r3, r3, #32
   14dae:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   14db2:	fa22 f303 	lsr.w	r3, r2, r3
   14db6:	9305      	str	r3, [sp, #20]
  return (target >> position) & mask;
   14db8:	9a03      	ldr	r2, [sp, #12]
   14dba:	9b02      	ldr	r3, [sp, #8]
   14dbc:	40da      	lsrs	r2, r3
   14dbe:	9b05      	ldr	r3, [sp, #20]
   14dc0:	ea02 0403 	and.w	r4, r2, r3
   14dc4:	462b      	mov	r3, r5
   14dc6:	4619      	mov	r1, r3
   14dc8:	4803      	ldr	r0, [pc, #12]	; (14dd8 <unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)+0x50>)
   14dca:	f001 fda7 	bl	1691c <__cyg_profile_func_exit>
   14dce:	4623      	mov	r3, r4
}
   14dd0:	4618      	mov	r0, r3
   14dd2:	b009      	add	sp, #36	; 0x24
   14dd4:	bd30      	pop	{r4, r5, pc}
   14dd6:	bf00      	nop
   14dd8:	00014d89 	.word	0x00014d89

00014ddc <unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)>:
constexpr T Insert(T target, U value, uint32_t position, uint32_t width = 1)
   14ddc:	b530      	push	{r4, r5, lr}
   14dde:	b089      	sub	sp, #36	; 0x24
   14de0:	4675      	mov	r5, lr
   14de2:	9003      	str	r0, [sp, #12]
   14de4:	9201      	str	r2, [sp, #4]
   14de6:	9300      	str	r3, [sp, #0]
   14de8:	460b      	mov	r3, r1
   14dea:	f88d 300b 	strb.w	r3, [sp, #11]
   14dee:	462b      	mov	r3, r5
   14df0:	4619      	mov	r1, r3
   14df2:	4816      	ldr	r0, [pc, #88]	; (14e4c <unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)+0x70>)
   14df4:	f001 fd7e 	bl	168f4 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   14df8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   14dfc:	9307      	str	r3, [sp, #28]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   14dfe:	2320      	movs	r3, #32
   14e00:	9306      	str	r3, [sp, #24]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   14e02:	9b00      	ldr	r3, [sp, #0]
   14e04:	f1c3 0320 	rsb	r3, r3, #32
   14e08:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   14e0c:	fa22 f303 	lsr.w	r3, r2, r3
   14e10:	9305      	str	r3, [sp, #20]
  target &= ~(mask << position);
   14e12:	9a05      	ldr	r2, [sp, #20]
   14e14:	9b01      	ldr	r3, [sp, #4]
   14e16:	fa02 f303 	lsl.w	r3, r2, r3
   14e1a:	43db      	mvns	r3, r3
   14e1c:	9a03      	ldr	r2, [sp, #12]
   14e1e:	4013      	ands	r3, r2
   14e20:	9303      	str	r3, [sp, #12]
  target |= (value & mask) << position;
   14e22:	f89d 200b 	ldrb.w	r2, [sp, #11]
   14e26:	9b05      	ldr	r3, [sp, #20]
   14e28:	401a      	ands	r2, r3
   14e2a:	9b01      	ldr	r3, [sp, #4]
   14e2c:	fa02 f303 	lsl.w	r3, r2, r3
   14e30:	9a03      	ldr	r2, [sp, #12]
   14e32:	4313      	orrs	r3, r2
   14e34:	9303      	str	r3, [sp, #12]
  return target;
   14e36:	9c03      	ldr	r4, [sp, #12]
   14e38:	462b      	mov	r3, r5
   14e3a:	4619      	mov	r1, r3
   14e3c:	4803      	ldr	r0, [pc, #12]	; (14e4c <unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)+0x70>)
   14e3e:	f001 fd6d 	bl	1691c <__cyg_profile_func_exit>
   14e42:	4623      	mov	r3, r4
}
   14e44:	4618      	mov	r0, r3
   14e46:	b009      	add	sp, #36	; 0x24
   14e48:	bd30      	pop	{r4, r5, pc}
   14e4a:	bf00      	nop
   14e4c:	00014ddd 	.word	0x00014ddd

00014e50 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()>:
  static void ClearInterrupts()
   14e50:	b510      	push	{r4, lr}
   14e52:	b082      	sub	sp, #8
   14e54:	4674      	mov	r4, lr
   14e56:	4623      	mov	r3, r4
   14e58:	4619      	mov	r1, r3
   14e5a:	4823      	ldr	r0, [pc, #140]	; (14ee8 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x98>)
   14e5c:	f001 fd4a 	bl	168f4 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   14e60:	2300      	movs	r3, #0
   14e62:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   14e66:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14e6a:	4a20      	ldr	r2, [pc, #128]	; (14eec <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14e6c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14e70:	681a      	ldr	r2, [r3, #0]
   14e72:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14e76:	491d      	ldr	r1, [pc, #116]	; (14eec <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14e78:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14e7c:	f042 0201 	orr.w	r2, r2, #1
   14e80:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   14e82:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14e86:	4a19      	ldr	r2, [pc, #100]	; (14eec <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14e88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14e8c:	681a      	ldr	r2, [r3, #0]
   14e8e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14e92:	4916      	ldr	r1, [pc, #88]	; (14eec <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14e94:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14e98:	f042 0202 	orr.w	r2, r2, #2
   14e9c:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   14e9e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14ea2:	4a12      	ldr	r2, [pc, #72]	; (14eec <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14ea4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14ea8:	681a      	ldr	r2, [r3, #0]
   14eaa:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14eae:	490f      	ldr	r1, [pc, #60]	; (14eec <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14eb0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14eb4:	f042 0204 	orr.w	r2, r2, #4
   14eb8:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   14eba:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14ebe:	4a0b      	ldr	r2, [pc, #44]	; (14eec <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14ec0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14ec4:	681a      	ldr	r2, [r3, #0]
   14ec6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14eca:	4908      	ldr	r1, [pc, #32]	; (14eec <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14ecc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14ed0:	f042 0208 	orr.w	r2, r2, #8
   14ed4:	601a      	str	r2, [r3, #0]
   14ed6:	4623      	mov	r3, r4
   14ed8:	4619      	mov	r1, r3
   14eda:	4803      	ldr	r0, [pc, #12]	; (14ee8 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x98>)
   14edc:	f001 fd1e 	bl	1691c <__cyg_profile_func_exit>
  }
   14ee0:	bf00      	nop
   14ee2:	b002      	add	sp, #8
   14ee4:	bd10      	pop	{r4, pc}
   14ee6:	bf00      	nop
   14ee8:	00014e51 	.word	0x00014e51
   14eec:	10000004 	.word	0x10000004

00014ef0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()>:
  static void ClearInterrupts()
   14ef0:	b510      	push	{r4, lr}
   14ef2:	b082      	sub	sp, #8
   14ef4:	4674      	mov	r4, lr
   14ef6:	4623      	mov	r3, r4
   14ef8:	4619      	mov	r1, r3
   14efa:	4823      	ldr	r0, [pc, #140]	; (14f88 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x98>)
   14efc:	f001 fcfa 	bl	168f4 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   14f00:	2301      	movs	r3, #1
   14f02:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   14f06:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14f0a:	4a20      	ldr	r2, [pc, #128]	; (14f8c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   14f0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14f10:	681a      	ldr	r2, [r3, #0]
   14f12:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14f16:	491d      	ldr	r1, [pc, #116]	; (14f8c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   14f18:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14f1c:	f042 0201 	orr.w	r2, r2, #1
   14f20:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   14f22:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14f26:	4a19      	ldr	r2, [pc, #100]	; (14f8c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   14f28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14f2c:	681a      	ldr	r2, [r3, #0]
   14f2e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14f32:	4916      	ldr	r1, [pc, #88]	; (14f8c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   14f34:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14f38:	f042 0202 	orr.w	r2, r2, #2
   14f3c:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   14f3e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14f42:	4a12      	ldr	r2, [pc, #72]	; (14f8c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   14f44:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14f48:	681a      	ldr	r2, [r3, #0]
   14f4a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14f4e:	490f      	ldr	r1, [pc, #60]	; (14f8c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   14f50:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14f54:	f042 0204 	orr.w	r2, r2, #4
   14f58:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   14f5a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14f5e:	4a0b      	ldr	r2, [pc, #44]	; (14f8c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   14f60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14f64:	681a      	ldr	r2, [r3, #0]
   14f66:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14f6a:	4908      	ldr	r1, [pc, #32]	; (14f8c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   14f6c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14f70:	f042 0208 	orr.w	r2, r2, #8
   14f74:	601a      	str	r2, [r3, #0]
   14f76:	4623      	mov	r3, r4
   14f78:	4619      	mov	r1, r3
   14f7a:	4803      	ldr	r0, [pc, #12]	; (14f88 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x98>)
   14f7c:	f001 fcce 	bl	1691c <__cyg_profile_func_exit>
  }
   14f80:	bf00      	nop
   14f82:	b002      	add	sp, #8
   14f84:	bd10      	pop	{r4, pc}
   14f86:	bf00      	nop
   14f88:	00014ef1 	.word	0x00014ef1
   14f8c:	10000004 	.word	0x10000004

00014f90 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()>:
  static void ClearInterrupts()
   14f90:	b510      	push	{r4, lr}
   14f92:	b082      	sub	sp, #8
   14f94:	4674      	mov	r4, lr
   14f96:	4623      	mov	r3, r4
   14f98:	4619      	mov	r1, r3
   14f9a:	4823      	ldr	r0, [pc, #140]	; (15028 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x98>)
   14f9c:	f001 fcaa 	bl	168f4 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   14fa0:	2302      	movs	r3, #2
   14fa2:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   14fa6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14faa:	4a20      	ldr	r2, [pc, #128]	; (1502c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   14fac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14fb0:	681a      	ldr	r2, [r3, #0]
   14fb2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14fb6:	491d      	ldr	r1, [pc, #116]	; (1502c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   14fb8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14fbc:	f042 0201 	orr.w	r2, r2, #1
   14fc0:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   14fc2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14fc6:	4a19      	ldr	r2, [pc, #100]	; (1502c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   14fc8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14fcc:	681a      	ldr	r2, [r3, #0]
   14fce:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14fd2:	4916      	ldr	r1, [pc, #88]	; (1502c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   14fd4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14fd8:	f042 0202 	orr.w	r2, r2, #2
   14fdc:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   14fde:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14fe2:	4a12      	ldr	r2, [pc, #72]	; (1502c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   14fe4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14fe8:	681a      	ldr	r2, [r3, #0]
   14fea:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14fee:	490f      	ldr	r1, [pc, #60]	; (1502c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   14ff0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14ff4:	f042 0204 	orr.w	r2, r2, #4
   14ff8:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   14ffa:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14ffe:	4a0b      	ldr	r2, [pc, #44]	; (1502c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   15000:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15004:	681a      	ldr	r2, [r3, #0]
   15006:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1500a:	4908      	ldr	r1, [pc, #32]	; (1502c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   1500c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   15010:	f042 0208 	orr.w	r2, r2, #8
   15014:	601a      	str	r2, [r3, #0]
   15016:	4623      	mov	r3, r4
   15018:	4619      	mov	r1, r3
   1501a:	4803      	ldr	r0, [pc, #12]	; (15028 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x98>)
   1501c:	f001 fc7e 	bl	1691c <__cyg_profile_func_exit>
  }
   15020:	bf00      	nop
   15022:	b002      	add	sp, #8
   15024:	bd10      	pop	{r4, pc}
   15026:	bf00      	nop
   15028:	00014f91 	.word	0x00014f91
   1502c:	10000004 	.word	0x10000004

00015030 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()>:
  static void ClearInterrupts()
   15030:	b510      	push	{r4, lr}
   15032:	b082      	sub	sp, #8
   15034:	4674      	mov	r4, lr
   15036:	4623      	mov	r3, r4
   15038:	4619      	mov	r1, r3
   1503a:	4823      	ldr	r0, [pc, #140]	; (150c8 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x98>)
   1503c:	f001 fc5a 	bl	168f4 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   15040:	2303      	movs	r3, #3
   15042:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   15046:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1504a:	4a20      	ldr	r2, [pc, #128]	; (150cc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   1504c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15050:	681a      	ldr	r2, [r3, #0]
   15052:	f89d 3007 	ldrb.w	r3, [sp, #7]
   15056:	491d      	ldr	r1, [pc, #116]	; (150cc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   15058:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   1505c:	f042 0201 	orr.w	r2, r2, #1
   15060:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   15062:	f89d 3007 	ldrb.w	r3, [sp, #7]
   15066:	4a19      	ldr	r2, [pc, #100]	; (150cc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   15068:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1506c:	681a      	ldr	r2, [r3, #0]
   1506e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   15072:	4916      	ldr	r1, [pc, #88]	; (150cc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   15074:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   15078:	f042 0202 	orr.w	r2, r2, #2
   1507c:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   1507e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   15082:	4a12      	ldr	r2, [pc, #72]	; (150cc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   15084:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15088:	681a      	ldr	r2, [r3, #0]
   1508a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1508e:	490f      	ldr	r1, [pc, #60]	; (150cc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   15090:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   15094:	f042 0204 	orr.w	r2, r2, #4
   15098:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   1509a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1509e:	4a0b      	ldr	r2, [pc, #44]	; (150cc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   150a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   150a4:	681a      	ldr	r2, [r3, #0]
   150a6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   150aa:	4908      	ldr	r1, [pc, #32]	; (150cc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   150ac:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   150b0:	f042 0208 	orr.w	r2, r2, #8
   150b4:	601a      	str	r2, [r3, #0]
   150b6:	4623      	mov	r3, r4
   150b8:	4619      	mov	r1, r3
   150ba:	4803      	ldr	r0, [pc, #12]	; (150c8 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x98>)
   150bc:	f001 fc2e 	bl	1691c <__cyg_profile_func_exit>
  }
   150c0:	bf00      	nop
   150c2:	b002      	add	sp, #8
   150c4:	bd10      	pop	{r4, pc}
   150c6:	bf00      	nop
   150c8:	00015031 	.word	0x00015031
   150cc:	10000004 	.word	0x10000004

000150d0 <__static_initialization_and_destruction_0(int, int)>:
   150d0:	b510      	push	{r4, lr}
   150d2:	b082      	sub	sp, #8
   150d4:	4674      	mov	r4, lr
   150d6:	9001      	str	r0, [sp, #4]
   150d8:	9100      	str	r1, [sp, #0]
   150da:	4623      	mov	r3, r4
   150dc:	4619      	mov	r1, r3
   150de:	4843      	ldr	r0, [pc, #268]	; (151ec <__static_initialization_and_destruction_0(int, int)+0x11c>)
   150e0:	f001 fc08 	bl	168f4 <__cyg_profile_func_enter>
   150e4:	9b01      	ldr	r3, [sp, #4]
   150e6:	2b01      	cmp	r3, #1
   150e8:	d177      	bne.n	151da <__static_initialization_and_destruction_0(int, int)+0x10a>
   150ea:	9b00      	ldr	r3, [sp, #0]
   150ec:	f64f 72ff 	movw	r2, #65535	; 0xffff
   150f0:	4293      	cmp	r3, r2
   150f2:	d172      	bne.n	151da <__static_initialization_and_destruction_0(int, int)+0x10a>
  inline static volatile uint32_t * match[4][4] = {
   150f4:	4b3e      	ldr	r3, [pc, #248]	; (151f0 <__static_initialization_and_destruction_0(int, int)+0x120>)
   150f6:	681b      	ldr	r3, [r3, #0]
   150f8:	f003 0301 	and.w	r3, r3, #1
   150fc:	2b00      	cmp	r3, #0
   150fe:	d152      	bne.n	151a6 <__static_initialization_and_destruction_0(int, int)+0xd6>
   15100:	4b3b      	ldr	r3, [pc, #236]	; (151f0 <__static_initialization_and_destruction_0(int, int)+0x120>)
   15102:	2201      	movs	r2, #1
   15104:	601a      	str	r2, [r3, #0]
    [kTimer0] = { &tim_register[0]->MR0, &tim_register[0]->MR1,
   15106:	4b3b      	ldr	r3, [pc, #236]	; (151f4 <__static_initialization_and_destruction_0(int, int)+0x124>)
   15108:	681b      	ldr	r3, [r3, #0]
   1510a:	3318      	adds	r3, #24
  };
   1510c:	4a3a      	ldr	r2, [pc, #232]	; (151f8 <__static_initialization_and_destruction_0(int, int)+0x128>)
   1510e:	6013      	str	r3, [r2, #0]
    [kTimer0] = { &tim_register[0]->MR0, &tim_register[0]->MR1,
   15110:	4b38      	ldr	r3, [pc, #224]	; (151f4 <__static_initialization_and_destruction_0(int, int)+0x124>)
   15112:	681b      	ldr	r3, [r3, #0]
   15114:	331c      	adds	r3, #28
  };
   15116:	4a38      	ldr	r2, [pc, #224]	; (151f8 <__static_initialization_and_destruction_0(int, int)+0x128>)
   15118:	6053      	str	r3, [r2, #4]
                  &tim_register[0]->MR2, &tim_register[0]->MR3 },
   1511a:	4b36      	ldr	r3, [pc, #216]	; (151f4 <__static_initialization_and_destruction_0(int, int)+0x124>)
   1511c:	681b      	ldr	r3, [r3, #0]
   1511e:	3320      	adds	r3, #32
  };
   15120:	4a35      	ldr	r2, [pc, #212]	; (151f8 <__static_initialization_and_destruction_0(int, int)+0x128>)
   15122:	6093      	str	r3, [r2, #8]
                  &tim_register[0]->MR2, &tim_register[0]->MR3 },
   15124:	4b33      	ldr	r3, [pc, #204]	; (151f4 <__static_initialization_and_destruction_0(int, int)+0x124>)
   15126:	681b      	ldr	r3, [r3, #0]
   15128:	3324      	adds	r3, #36	; 0x24
  };
   1512a:	4a33      	ldr	r2, [pc, #204]	; (151f8 <__static_initialization_and_destruction_0(int, int)+0x128>)
   1512c:	60d3      	str	r3, [r2, #12]
    [kTimer1] = { &tim_register[1]->MR0, &tim_register[1]->MR1,
   1512e:	4b31      	ldr	r3, [pc, #196]	; (151f4 <__static_initialization_and_destruction_0(int, int)+0x124>)
   15130:	685b      	ldr	r3, [r3, #4]
   15132:	3318      	adds	r3, #24
  };
   15134:	4a30      	ldr	r2, [pc, #192]	; (151f8 <__static_initialization_and_destruction_0(int, int)+0x128>)
   15136:	6113      	str	r3, [r2, #16]
    [kTimer1] = { &tim_register[1]->MR0, &tim_register[1]->MR1,
   15138:	4b2e      	ldr	r3, [pc, #184]	; (151f4 <__static_initialization_and_destruction_0(int, int)+0x124>)
   1513a:	685b      	ldr	r3, [r3, #4]
   1513c:	331c      	adds	r3, #28
  };
   1513e:	4a2e      	ldr	r2, [pc, #184]	; (151f8 <__static_initialization_and_destruction_0(int, int)+0x128>)
   15140:	6153      	str	r3, [r2, #20]
                  &tim_register[1]->MR2, &tim_register[1]->MR3 },
   15142:	4b2c      	ldr	r3, [pc, #176]	; (151f4 <__static_initialization_and_destruction_0(int, int)+0x124>)
   15144:	685b      	ldr	r3, [r3, #4]
   15146:	3320      	adds	r3, #32
  };
   15148:	4a2b      	ldr	r2, [pc, #172]	; (151f8 <__static_initialization_and_destruction_0(int, int)+0x128>)
   1514a:	6193      	str	r3, [r2, #24]
                  &tim_register[1]->MR2, &tim_register[1]->MR3 },
   1514c:	4b29      	ldr	r3, [pc, #164]	; (151f4 <__static_initialization_and_destruction_0(int, int)+0x124>)
   1514e:	685b      	ldr	r3, [r3, #4]
   15150:	3324      	adds	r3, #36	; 0x24
  };
   15152:	4a29      	ldr	r2, [pc, #164]	; (151f8 <__static_initialization_and_destruction_0(int, int)+0x128>)
   15154:	61d3      	str	r3, [r2, #28]
    [kTimer2] = { &tim_register[2]->MR0, &tim_register[2]->MR1,
   15156:	4b27      	ldr	r3, [pc, #156]	; (151f4 <__static_initialization_and_destruction_0(int, int)+0x124>)
   15158:	689b      	ldr	r3, [r3, #8]
   1515a:	3318      	adds	r3, #24
  };
   1515c:	4a26      	ldr	r2, [pc, #152]	; (151f8 <__static_initialization_and_destruction_0(int, int)+0x128>)
   1515e:	6213      	str	r3, [r2, #32]
    [kTimer2] = { &tim_register[2]->MR0, &tim_register[2]->MR1,
   15160:	4b24      	ldr	r3, [pc, #144]	; (151f4 <__static_initialization_and_destruction_0(int, int)+0x124>)
   15162:	689b      	ldr	r3, [r3, #8]
   15164:	331c      	adds	r3, #28
  };
   15166:	4a24      	ldr	r2, [pc, #144]	; (151f8 <__static_initialization_and_destruction_0(int, int)+0x128>)
   15168:	6253      	str	r3, [r2, #36]	; 0x24
                  &tim_register[2]->MR2, &tim_register[2]->MR3 },
   1516a:	4b22      	ldr	r3, [pc, #136]	; (151f4 <__static_initialization_and_destruction_0(int, int)+0x124>)
   1516c:	689b      	ldr	r3, [r3, #8]
   1516e:	3320      	adds	r3, #32
  };
   15170:	4a21      	ldr	r2, [pc, #132]	; (151f8 <__static_initialization_and_destruction_0(int, int)+0x128>)
   15172:	6293      	str	r3, [r2, #40]	; 0x28
                  &tim_register[2]->MR2, &tim_register[2]->MR3 },
   15174:	4b1f      	ldr	r3, [pc, #124]	; (151f4 <__static_initialization_and_destruction_0(int, int)+0x124>)
   15176:	689b      	ldr	r3, [r3, #8]
   15178:	3324      	adds	r3, #36	; 0x24
  };
   1517a:	4a1f      	ldr	r2, [pc, #124]	; (151f8 <__static_initialization_and_destruction_0(int, int)+0x128>)
   1517c:	62d3      	str	r3, [r2, #44]	; 0x2c
    [kTimer3] = { &tim_register[3]->MR0, &tim_register[3]->MR1,
   1517e:	4b1d      	ldr	r3, [pc, #116]	; (151f4 <__static_initialization_and_destruction_0(int, int)+0x124>)
   15180:	68db      	ldr	r3, [r3, #12]
   15182:	3318      	adds	r3, #24
  };
   15184:	4a1c      	ldr	r2, [pc, #112]	; (151f8 <__static_initialization_and_destruction_0(int, int)+0x128>)
   15186:	6313      	str	r3, [r2, #48]	; 0x30
    [kTimer3] = { &tim_register[3]->MR0, &tim_register[3]->MR1,
   15188:	4b1a      	ldr	r3, [pc, #104]	; (151f4 <__static_initialization_and_destruction_0(int, int)+0x124>)
   1518a:	68db      	ldr	r3, [r3, #12]
   1518c:	331c      	adds	r3, #28
  };
   1518e:	4a1a      	ldr	r2, [pc, #104]	; (151f8 <__static_initialization_and_destruction_0(int, int)+0x128>)
   15190:	6353      	str	r3, [r2, #52]	; 0x34
                  &tim_register[3]->MR2, &tim_register[3]->MR3 }
   15192:	4b18      	ldr	r3, [pc, #96]	; (151f4 <__static_initialization_and_destruction_0(int, int)+0x124>)
   15194:	68db      	ldr	r3, [r3, #12]
   15196:	3320      	adds	r3, #32
  };
   15198:	4a17      	ldr	r2, [pc, #92]	; (151f8 <__static_initialization_and_destruction_0(int, int)+0x128>)
   1519a:	6393      	str	r3, [r2, #56]	; 0x38
                  &tim_register[3]->MR2, &tim_register[3]->MR3 }
   1519c:	4b15      	ldr	r3, [pc, #84]	; (151f4 <__static_initialization_and_destruction_0(int, int)+0x124>)
   1519e:	68db      	ldr	r3, [r3, #12]
   151a0:	3324      	adds	r3, #36	; 0x24
  };
   151a2:	4a15      	ldr	r2, [pc, #84]	; (151f8 <__static_initialization_and_destruction_0(int, int)+0x128>)
   151a4:	63d3      	str	r3, [r2, #60]	; 0x3c
MP3_Decoder mp3;
   151a6:	4815      	ldr	r0, [pc, #84]	; (151fc <__static_initialization_and_destruction_0(int, int)+0x12c>)
   151a8:	f7ff fa26 	bl	145f8 <MP3_Decoder::MP3_Decoder()>
LabGPIO S3(0, 29);
   151ac:	221d      	movs	r2, #29
   151ae:	2100      	movs	r1, #0
   151b0:	4813      	ldr	r0, [pc, #76]	; (15200 <__static_initialization_and_destruction_0(int, int)+0x130>)
   151b2:	f7fb f8db 	bl	1036c <LabGPIO::LabGPIO(unsigned char, unsigned char)>
LabGPIO S2(0, 30);
   151b6:	221e      	movs	r2, #30
   151b8:	2100      	movs	r1, #0
   151ba:	4812      	ldr	r0, [pc, #72]	; (15204 <__static_initialization_and_destruction_0(int, int)+0x134>)
   151bc:	f7fb f8d6 	bl	1036c <LabGPIO::LabGPIO(unsigned char, unsigned char)>
LabGPIO S1(1, 15);
   151c0:	220f      	movs	r2, #15
   151c2:	2101      	movs	r1, #1
   151c4:	4810      	ldr	r0, [pc, #64]	; (15208 <__static_initialization_and_destruction_0(int, int)+0x138>)
   151c6:	f7fb f8d1 	bl	1036c <LabGPIO::LabGPIO(unsigned char, unsigned char)>
LabGPIO S0(1, 19);
   151ca:	2213      	movs	r2, #19
   151cc:	2101      	movs	r1, #1
   151ce:	480f      	ldr	r0, [pc, #60]	; (1520c <__static_initialization_and_destruction_0(int, int)+0x13c>)
   151d0:	f7fb f8cc 	bl	1036c <LabGPIO::LabGPIO(unsigned char, unsigned char)>
OledTerminal tt;
   151d4:	480e      	ldr	r0, [pc, #56]	; (15210 <__static_initialization_and_destruction_0(int, int)+0x140>)
   151d6:	f7ff f9d9 	bl	1458c <OledTerminal::OledTerminal()>
   151da:	4623      	mov	r3, r4
   151dc:	4619      	mov	r1, r3
   151de:	4803      	ldr	r0, [pc, #12]	; (151ec <__static_initialization_and_destruction_0(int, int)+0x11c>)
   151e0:	f001 fb9c 	bl	1691c <__cyg_profile_func_exit>
   151e4:	bf00      	nop
   151e6:	b002      	add	sp, #8
   151e8:	bd10      	pop	{r4, pc}
   151ea:	bf00      	nop
   151ec:	000150d1 	.word	0x000150d1
   151f0:	100007a8 	.word	0x100007a8
   151f4:	10000004 	.word	0x10000004
   151f8:	100006e8 	.word	0x100006e8
   151fc:	100008bc 	.word	0x100008bc
   15200:	100026f8 	.word	0x100026f8
   15204:	100026fc 	.word	0x100026fc
   15208:	10002700 	.word	0x10002700
   1520c:	10002704 	.word	0x10002704
   15210:	10002708 	.word	0x10002708

00015214 <_GLOBAL__sub_I_mp3>:
   15214:	b510      	push	{r4, lr}
   15216:	4674      	mov	r4, lr
   15218:	4623      	mov	r3, r4
   1521a:	4619      	mov	r1, r3
   1521c:	4806      	ldr	r0, [pc, #24]	; (15238 <_GLOBAL__sub_I_mp3+0x24>)
   1521e:	f001 fb69 	bl	168f4 <__cyg_profile_func_enter>
   15222:	f64f 71ff 	movw	r1, #65535	; 0xffff
   15226:	2001      	movs	r0, #1
   15228:	f7ff ff52 	bl	150d0 <__static_initialization_and_destruction_0(int, int)>
   1522c:	4623      	mov	r3, r4
   1522e:	4619      	mov	r1, r3
   15230:	4801      	ldr	r0, [pc, #4]	; (15238 <_GLOBAL__sub_I_mp3+0x24>)
   15232:	f001 fb73 	bl	1691c <__cyg_profile_func_exit>
   15236:	bd10      	pop	{r4, pc}
   15238:	00015215 	.word	0x00015215

0001523c <LabGPIO::SetAsInput()>:

    if((GetPort()==1) & (GetPin()==15 | GetPin()==19)){
        LPC_IOCON->P1_15 |= 0b01 << 3;
    }
}
void LabGPIO::SetAsInput(){
   1523c:	b510      	push	{r4, lr}
   1523e:	b082      	sub	sp, #8
   15240:	4674      	mov	r4, lr
   15242:	9001      	str	r0, [sp, #4]
   15244:	4623      	mov	r3, r4
   15246:	4619      	mov	r1, r3
   15248:	4810      	ldr	r0, [pc, #64]	; (1528c <LabGPIO::SetAsInput()+0x50>)
   1524a:	f001 fb53 	bl	168f4 <__cyg_profile_func_enter>
    ports[gpio_port]->DIR &= ~(1 << gpio_pin);
   1524e:	9b01      	ldr	r3, [sp, #4]
   15250:	781b      	ldrb	r3, [r3, #0]
   15252:	461a      	mov	r2, r3
   15254:	4b0e      	ldr	r3, [pc, #56]	; (15290 <LabGPIO::SetAsInput()+0x54>)
   15256:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1525a:	681a      	ldr	r2, [r3, #0]
   1525c:	9b01      	ldr	r3, [sp, #4]
   1525e:	785b      	ldrb	r3, [r3, #1]
   15260:	4619      	mov	r1, r3
   15262:	2301      	movs	r3, #1
   15264:	408b      	lsls	r3, r1
   15266:	43db      	mvns	r3, r3
   15268:	4619      	mov	r1, r3
   1526a:	9b01      	ldr	r3, [sp, #4]
   1526c:	781b      	ldrb	r3, [r3, #0]
   1526e:	4618      	mov	r0, r3
   15270:	4b07      	ldr	r3, [pc, #28]	; (15290 <LabGPIO::SetAsInput()+0x54>)
   15272:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   15276:	400a      	ands	r2, r1
   15278:	601a      	str	r2, [r3, #0]
   1527a:	4623      	mov	r3, r4
   1527c:	4619      	mov	r1, r3
   1527e:	4803      	ldr	r0, [pc, #12]	; (1528c <LabGPIO::SetAsInput()+0x50>)
   15280:	f001 fb4c 	bl	1691c <__cyg_profile_func_exit>
}
   15284:	bf00      	nop
   15286:	b002      	add	sp, #8
   15288:	bd10      	pop	{r4, pc}
   1528a:	bf00      	nop
   1528c:	0001523d 	.word	0x0001523d
   15290:	100004cc 	.word	0x100004cc

00015294 <LabGPIO::SetAsOutput()>:
void LabGPIO::SetAsOutput(){
   15294:	b510      	push	{r4, lr}
   15296:	b082      	sub	sp, #8
   15298:	4674      	mov	r4, lr
   1529a:	9001      	str	r0, [sp, #4]
   1529c:	4623      	mov	r3, r4
   1529e:	4619      	mov	r1, r3
   152a0:	480f      	ldr	r0, [pc, #60]	; (152e0 <LabGPIO::SetAsOutput()+0x4c>)
   152a2:	f001 fb27 	bl	168f4 <__cyg_profile_func_enter>
    ports[gpio_port]->DIR |= 1 << gpio_pin;
   152a6:	9b01      	ldr	r3, [sp, #4]
   152a8:	781b      	ldrb	r3, [r3, #0]
   152aa:	461a      	mov	r2, r3
   152ac:	4b0d      	ldr	r3, [pc, #52]	; (152e4 <LabGPIO::SetAsOutput()+0x50>)
   152ae:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   152b2:	681a      	ldr	r2, [r3, #0]
   152b4:	9b01      	ldr	r3, [sp, #4]
   152b6:	785b      	ldrb	r3, [r3, #1]
   152b8:	4619      	mov	r1, r3
   152ba:	2301      	movs	r3, #1
   152bc:	408b      	lsls	r3, r1
   152be:	4619      	mov	r1, r3
   152c0:	9b01      	ldr	r3, [sp, #4]
   152c2:	781b      	ldrb	r3, [r3, #0]
   152c4:	4618      	mov	r0, r3
   152c6:	4b07      	ldr	r3, [pc, #28]	; (152e4 <LabGPIO::SetAsOutput()+0x50>)
   152c8:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   152cc:	430a      	orrs	r2, r1
   152ce:	601a      	str	r2, [r3, #0]
   152d0:	4623      	mov	r3, r4
   152d2:	4619      	mov	r1, r3
   152d4:	4802      	ldr	r0, [pc, #8]	; (152e0 <LabGPIO::SetAsOutput()+0x4c>)
   152d6:	f001 fb21 	bl	1691c <__cyg_profile_func_exit>
}
   152da:	bf00      	nop
   152dc:	b002      	add	sp, #8
   152de:	bd10      	pop	{r4, pc}
   152e0:	00015295 	.word	0x00015295
   152e4:	100004cc 	.word	0x100004cc

000152e8 <LabGPIO::SetHigh()>:
void LabGPIO::SetDirection(Direction dir){
    (dir == Direction::kOutput) ? SetAsOutput() : SetAsInput();
}
void LabGPIO::SetHigh(){
   152e8:	b510      	push	{r4, lr}
   152ea:	b082      	sub	sp, #8
   152ec:	4674      	mov	r4, lr
   152ee:	9001      	str	r0, [sp, #4]
   152f0:	4623      	mov	r3, r4
   152f2:	4619      	mov	r1, r3
   152f4:	480b      	ldr	r0, [pc, #44]	; (15324 <LabGPIO::SetHigh()+0x3c>)
   152f6:	f001 fafd 	bl	168f4 <__cyg_profile_func_enter>
    ports[gpio_port]->SET = 1 << gpio_pin;
   152fa:	9b01      	ldr	r3, [sp, #4]
   152fc:	785b      	ldrb	r3, [r3, #1]
   152fe:	461a      	mov	r2, r3
   15300:	2301      	movs	r3, #1
   15302:	fa03 f202 	lsl.w	r2, r3, r2
   15306:	9b01      	ldr	r3, [sp, #4]
   15308:	781b      	ldrb	r3, [r3, #0]
   1530a:	4619      	mov	r1, r3
   1530c:	4b06      	ldr	r3, [pc, #24]	; (15328 <LabGPIO::SetHigh()+0x40>)
   1530e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   15312:	619a      	str	r2, [r3, #24]
   15314:	4623      	mov	r3, r4
   15316:	4619      	mov	r1, r3
   15318:	4802      	ldr	r0, [pc, #8]	; (15324 <LabGPIO::SetHigh()+0x3c>)
   1531a:	f001 faff 	bl	1691c <__cyg_profile_func_exit>
}
   1531e:	bf00      	nop
   15320:	b002      	add	sp, #8
   15322:	bd10      	pop	{r4, pc}
   15324:	000152e9 	.word	0x000152e9
   15328:	100004cc 	.word	0x100004cc

0001532c <LabGPIO::SetLow()>:
void LabGPIO::SetLow(){
   1532c:	b510      	push	{r4, lr}
   1532e:	b082      	sub	sp, #8
   15330:	4674      	mov	r4, lr
   15332:	9001      	str	r0, [sp, #4]
   15334:	4623      	mov	r3, r4
   15336:	4619      	mov	r1, r3
   15338:	480b      	ldr	r0, [pc, #44]	; (15368 <LabGPIO::SetLow()+0x3c>)
   1533a:	f001 fadb 	bl	168f4 <__cyg_profile_func_enter>
    ports[gpio_port]->CLR = 1 << gpio_pin;
   1533e:	9b01      	ldr	r3, [sp, #4]
   15340:	785b      	ldrb	r3, [r3, #1]
   15342:	461a      	mov	r2, r3
   15344:	2301      	movs	r3, #1
   15346:	fa03 f202 	lsl.w	r2, r3, r2
   1534a:	9b01      	ldr	r3, [sp, #4]
   1534c:	781b      	ldrb	r3, [r3, #0]
   1534e:	4619      	mov	r1, r3
   15350:	4b06      	ldr	r3, [pc, #24]	; (1536c <LabGPIO::SetLow()+0x40>)
   15352:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   15356:	61da      	str	r2, [r3, #28]
   15358:	4623      	mov	r3, r4
   1535a:	4619      	mov	r1, r3
   1535c:	4802      	ldr	r0, [pc, #8]	; (15368 <LabGPIO::SetLow()+0x3c>)
   1535e:	f001 fadd 	bl	1691c <__cyg_profile_func_exit>
}
   15362:	bf00      	nop
   15364:	b002      	add	sp, #8
   15366:	bd10      	pop	{r4, pc}
   15368:	0001532d 	.word	0x0001532d
   1536c:	100004cc 	.word	0x100004cc

00015370 <LabGPIO::ReadBool()>:
}
LabGPIO::State LabGPIO::Read(){
    State s;
    return (ports[gpio_port]->PIN & 1 << gpio_pin) ? s = State::kHigh : s = State::kLow; 
}
bool LabGPIO::ReadBool(){
   15370:	b530      	push	{r4, r5, lr}
   15372:	b083      	sub	sp, #12
   15374:	4675      	mov	r5, lr
   15376:	9001      	str	r0, [sp, #4]
   15378:	462b      	mov	r3, r5
   1537a:	4619      	mov	r1, r3
   1537c:	480e      	ldr	r0, [pc, #56]	; (153b8 <LabGPIO::ReadBool()+0x48>)
   1537e:	f001 fab9 	bl	168f4 <__cyg_profile_func_enter>
    return (ports[gpio_port]->PIN & 1 << gpio_pin); 
   15382:	9b01      	ldr	r3, [sp, #4]
   15384:	781b      	ldrb	r3, [r3, #0]
   15386:	461a      	mov	r2, r3
   15388:	4b0c      	ldr	r3, [pc, #48]	; (153bc <LabGPIO::ReadBool()+0x4c>)
   1538a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1538e:	695b      	ldr	r3, [r3, #20]
   15390:	9a01      	ldr	r2, [sp, #4]
   15392:	7852      	ldrb	r2, [r2, #1]
   15394:	4611      	mov	r1, r2
   15396:	2201      	movs	r2, #1
   15398:	408a      	lsls	r2, r1
   1539a:	4013      	ands	r3, r2
   1539c:	2b00      	cmp	r3, #0
   1539e:	bf14      	ite	ne
   153a0:	2301      	movne	r3, #1
   153a2:	2300      	moveq	r3, #0
   153a4:	b2dc      	uxtb	r4, r3
   153a6:	462b      	mov	r3, r5
   153a8:	4619      	mov	r1, r3
   153aa:	4803      	ldr	r0, [pc, #12]	; (153b8 <LabGPIO::ReadBool()+0x48>)
   153ac:	f001 fab6 	bl	1691c <__cyg_profile_func_exit>
   153b0:	4623      	mov	r3, r4
}
   153b2:	4618      	mov	r0, r3
   153b4:	b003      	add	sp, #12
   153b6:	bd30      	pop	{r4, r5, pc}
   153b8:	00015371 	.word	0x00015371
   153bc:	100004cc 	.word	0x100004cc

000153c0 <LabGPIO::GPIOInterruptHandler()>:
void LabGPIO::GPIOInterruptHandler(){
   153c0:	b510      	push	{r4, lr}
   153c2:	b082      	sub	sp, #8
   153c4:	4674      	mov	r4, lr
   153c6:	4623      	mov	r3, r4
   153c8:	4619      	mov	r1, r3
   153ca:	4831      	ldr	r0, [pc, #196]	; (15490 <LabGPIO::GPIOInterruptHandler()+0xd0>)
   153cc:	f001 fa92 	bl	168f4 <__cyg_profile_func_enter>
    uint8_t port = 0, pin;
   153d0:	2300      	movs	r3, #0
   153d2:	f88d 3007 	strb.w	r3, [sp, #7]
    if(LPC_GPIOINT->IO0IntStatF | LPC_GPIOINT->IO0IntStatR){
   153d6:	4b2f      	ldr	r3, [pc, #188]	; (15494 <LabGPIO::GPIOInterruptHandler()+0xd4>)
   153d8:	689a      	ldr	r2, [r3, #8]
   153da:	4b2e      	ldr	r3, [pc, #184]	; (15494 <LabGPIO::GPIOInterruptHandler()+0xd4>)
   153dc:	685b      	ldr	r3, [r3, #4]
   153de:	4313      	orrs	r3, r2
   153e0:	2b00      	cmp	r3, #0
   153e2:	bf14      	ite	ne
   153e4:	2301      	movne	r3, #1
   153e6:	2300      	moveq	r3, #0
   153e8:	b2db      	uxtb	r3, r3
   153ea:	2b00      	cmp	r3, #0
   153ec:	d024      	beq.n	15438 <LabGPIO::GPIOInterruptHandler()+0x78>
        port = 0;
   153ee:	2300      	movs	r3, #0
   153f0:	f88d 3007 	strb.w	r3, [sp, #7]
        pin = __builtin_ctz((LPC_GPIOINT->IO0IntStatR) | (LPC_GPIOINT->IO0IntStatF));  
   153f4:	4b27      	ldr	r3, [pc, #156]	; (15494 <LabGPIO::GPIOInterruptHandler()+0xd4>)
   153f6:	685a      	ldr	r2, [r3, #4]
   153f8:	4b26      	ldr	r3, [pc, #152]	; (15494 <LabGPIO::GPIOInterruptHandler()+0xd4>)
   153fa:	689b      	ldr	r3, [r3, #8]
   153fc:	4313      	orrs	r3, r2
   153fe:	fa93 f3a3 	rbit	r3, r3
   15402:	fab3 f383 	clz	r3, r3
   15406:	f88d 3006 	strb.w	r3, [sp, #6]
        LPC_GPIOINT->IO0IntClr &= ~(1 << pin);  
   1540a:	4b22      	ldr	r3, [pc, #136]	; (15494 <LabGPIO::GPIOInterruptHandler()+0xd4>)
   1540c:	68db      	ldr	r3, [r3, #12]
   1540e:	f89d 2006 	ldrb.w	r2, [sp, #6]
   15412:	2101      	movs	r1, #1
   15414:	fa01 f202 	lsl.w	r2, r1, r2
   15418:	43d2      	mvns	r2, r2
   1541a:	4611      	mov	r1, r2
   1541c:	4a1d      	ldr	r2, [pc, #116]	; (15494 <LabGPIO::GPIOInterruptHandler()+0xd4>)
   1541e:	400b      	ands	r3, r1
   15420:	60d3      	str	r3, [r2, #12]
        isr_map[port][pin]();
   15422:	f89d 2007 	ldrb.w	r2, [sp, #7]
   15426:	f89d 3006 	ldrb.w	r3, [sp, #6]
   1542a:	491b      	ldr	r1, [pc, #108]	; (15498 <LabGPIO::GPIOInterruptHandler()+0xd8>)
   1542c:	0152      	lsls	r2, r2, #5
   1542e:	4413      	add	r3, r2
   15430:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   15434:	4798      	blx	r3
   15436:	e023      	b.n	15480 <LabGPIO::GPIOInterruptHandler()+0xc0>
    }
    else {
        port = 2;
   15438:	2302      	movs	r3, #2
   1543a:	f88d 3007 	strb.w	r3, [sp, #7]
        pin = __builtin_ctz((LPC_GPIOINT->IO2IntStatR) | (LPC_GPIOINT->IO2IntStatF));
   1543e:	4b15      	ldr	r3, [pc, #84]	; (15494 <LabGPIO::GPIOInterruptHandler()+0xd4>)
   15440:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   15442:	4b14      	ldr	r3, [pc, #80]	; (15494 <LabGPIO::GPIOInterruptHandler()+0xd4>)
   15444:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   15446:	4313      	orrs	r3, r2
   15448:	fa93 f3a3 	rbit	r3, r3
   1544c:	fab3 f383 	clz	r3, r3
   15450:	f88d 3006 	strb.w	r3, [sp, #6]
        LPC_GPIOINT->IO2IntClr &= ~(1 << pin);
   15454:	4b0f      	ldr	r3, [pc, #60]	; (15494 <LabGPIO::GPIOInterruptHandler()+0xd4>)
   15456:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15458:	f89d 2006 	ldrb.w	r2, [sp, #6]
   1545c:	2101      	movs	r1, #1
   1545e:	fa01 f202 	lsl.w	r2, r1, r2
   15462:	43d2      	mvns	r2, r2
   15464:	4611      	mov	r1, r2
   15466:	4a0b      	ldr	r2, [pc, #44]	; (15494 <LabGPIO::GPIOInterruptHandler()+0xd4>)
   15468:	400b      	ands	r3, r1
   1546a:	62d3      	str	r3, [r2, #44]	; 0x2c
        isr_map[port][pin]();
   1546c:	f89d 2007 	ldrb.w	r2, [sp, #7]
   15470:	f89d 3006 	ldrb.w	r3, [sp, #6]
   15474:	4908      	ldr	r1, [pc, #32]	; (15498 <LabGPIO::GPIOInterruptHandler()+0xd8>)
   15476:	0152      	lsls	r2, r2, #5
   15478:	4413      	add	r3, r2
   1547a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   1547e:	4798      	blx	r3
   15480:	4623      	mov	r3, r4
   15482:	4619      	mov	r1, r3
   15484:	4802      	ldr	r0, [pc, #8]	; (15490 <LabGPIO::GPIOInterruptHandler()+0xd0>)
   15486:	f001 fa49 	bl	1691c <__cyg_profile_func_exit>
    }
    
    

}
   1548a:	bf00      	nop
   1548c:	b002      	add	sp, #8
   1548e:	bd10      	pop	{r4, pc}
   15490:	000153c1 	.word	0x000153c1
   15494:	40028080 	.word	0x40028080
   15498:	10002ed0 	.word	0x10002ed0

0001549c <LabGPIO::EnableInterrupts()>:
void LabGPIO::EnableInterrupts(){
   1549c:	b510      	push	{r4, lr}
   1549e:	4674      	mov	r4, lr
   154a0:	4623      	mov	r3, r4
   154a2:	4619      	mov	r1, r3
   154a4:	4808      	ldr	r0, [pc, #32]	; (154c8 <LabGPIO::EnableInterrupts()+0x2c>)
   154a6:	f001 fa25 	bl	168f4 <__cyg_profile_func_enter>
    RegisterIsr(GPIO_IRQn, GPIOInterruptHandler);
   154aa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   154ae:	2201      	movs	r2, #1
   154b0:	4906      	ldr	r1, [pc, #24]	; (154cc <LabGPIO::EnableInterrupts()+0x30>)
   154b2:	2026      	movs	r0, #38	; 0x26
   154b4:	f001 f8ca 	bl	1664c <RegisterIsr(IRQn, void (*)(), bool, long)>
   154b8:	4623      	mov	r3, r4
   154ba:	4619      	mov	r1, r3
   154bc:	4802      	ldr	r0, [pc, #8]	; (154c8 <LabGPIO::EnableInterrupts()+0x2c>)
   154be:	f001 fa2d 	bl	1691c <__cyg_profile_func_exit>
}
   154c2:	bf00      	nop
   154c4:	bd10      	pop	{r4, pc}
   154c6:	bf00      	nop
   154c8:	0001549d 	.word	0x0001549d
   154cc:	000153c1 	.word	0x000153c1

000154d0 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)>:
void LabGPIO::AttachInterruptHandler(IsrPointer isr, Edge edge){
   154d0:	b510      	push	{r4, lr}
   154d2:	b084      	sub	sp, #16
   154d4:	4674      	mov	r4, lr
   154d6:	9003      	str	r0, [sp, #12]
   154d8:	9102      	str	r1, [sp, #8]
   154da:	9201      	str	r2, [sp, #4]
   154dc:	4623      	mov	r3, r4
   154de:	4619      	mov	r1, r3
   154e0:	485f      	ldr	r0, [pc, #380]	; (15660 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x190>)
   154e2:	f001 fa07 	bl	168f4 <__cyg_profile_func_enter>
   LabGPIO::isr_map[gpio_port][gpio_pin] = isr; //place function pointer into isr_map
   154e6:	9b03      	ldr	r3, [sp, #12]
   154e8:	781b      	ldrb	r3, [r3, #0]
   154ea:	4618      	mov	r0, r3
   154ec:	9b03      	ldr	r3, [sp, #12]
   154ee:	785b      	ldrb	r3, [r3, #1]
   154f0:	461a      	mov	r2, r3
   154f2:	495c      	ldr	r1, [pc, #368]	; (15664 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x194>)
   154f4:	0143      	lsls	r3, r0, #5
   154f6:	4413      	add	r3, r2
   154f8:	9a02      	ldr	r2, [sp, #8]
   154fa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if(edge == Edge::kRising){
   154fe:	9b01      	ldr	r3, [sp, #4]
   15500:	2b01      	cmp	r3, #1
   15502:	d11b      	bne.n	1553c <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x6c>
        if(gpio_port == 0){
   15504:	9b03      	ldr	r3, [sp, #12]
   15506:	781b      	ldrb	r3, [r3, #0]
   15508:	2b00      	cmp	r3, #0
   1550a:	d10b      	bne.n	15524 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x54>
            LPC_GPIOINT->IO0IntEnR |= 1 << gpio_pin;
   1550c:	4b56      	ldr	r3, [pc, #344]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   1550e:	691b      	ldr	r3, [r3, #16]
   15510:	9a03      	ldr	r2, [sp, #12]
   15512:	7852      	ldrb	r2, [r2, #1]
   15514:	4611      	mov	r1, r2
   15516:	2201      	movs	r2, #1
   15518:	408a      	lsls	r2, r1
   1551a:	4611      	mov	r1, r2
   1551c:	4a52      	ldr	r2, [pc, #328]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   1551e:	430b      	orrs	r3, r1
   15520:	6113      	str	r3, [r2, #16]
   15522:	e094      	b.n	1564e <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x17e>
        }
        else {
            LPC_GPIOINT->IO2IntEnR |= 1 << gpio_pin;
   15524:	4b50      	ldr	r3, [pc, #320]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   15526:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   15528:	9a03      	ldr	r2, [sp, #12]
   1552a:	7852      	ldrb	r2, [r2, #1]
   1552c:	4611      	mov	r1, r2
   1552e:	2201      	movs	r2, #1
   15530:	408a      	lsls	r2, r1
   15532:	4611      	mov	r1, r2
   15534:	4a4c      	ldr	r2, [pc, #304]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   15536:	430b      	orrs	r3, r1
   15538:	6313      	str	r3, [r2, #48]	; 0x30
   1553a:	e088      	b.n	1564e <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x17e>
        }
    }
    else if(edge == Edge::kFalling){
   1553c:	9b01      	ldr	r3, [sp, #4]
   1553e:	2b02      	cmp	r3, #2
   15540:	d11b      	bne.n	1557a <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0xaa>
        if(gpio_port == 0){
   15542:	9b03      	ldr	r3, [sp, #12]
   15544:	781b      	ldrb	r3, [r3, #0]
   15546:	2b00      	cmp	r3, #0
   15548:	d10b      	bne.n	15562 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x92>
            LPC_GPIOINT->IO0IntEnF |= 1 << gpio_pin;
   1554a:	4b47      	ldr	r3, [pc, #284]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   1554c:	695b      	ldr	r3, [r3, #20]
   1554e:	9a03      	ldr	r2, [sp, #12]
   15550:	7852      	ldrb	r2, [r2, #1]
   15552:	4611      	mov	r1, r2
   15554:	2201      	movs	r2, #1
   15556:	408a      	lsls	r2, r1
   15558:	4611      	mov	r1, r2
   1555a:	4a43      	ldr	r2, [pc, #268]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   1555c:	430b      	orrs	r3, r1
   1555e:	6153      	str	r3, [r2, #20]
   15560:	e075      	b.n	1564e <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x17e>
        }
        else {
            LPC_GPIOINT->IO2IntEnF |= 1 << gpio_pin;
   15562:	4b41      	ldr	r3, [pc, #260]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   15564:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   15566:	9a03      	ldr	r2, [sp, #12]
   15568:	7852      	ldrb	r2, [r2, #1]
   1556a:	4611      	mov	r1, r2
   1556c:	2201      	movs	r2, #1
   1556e:	408a      	lsls	r2, r1
   15570:	4611      	mov	r1, r2
   15572:	4a3d      	ldr	r2, [pc, #244]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   15574:	430b      	orrs	r3, r1
   15576:	6353      	str	r3, [r2, #52]	; 0x34
   15578:	e069      	b.n	1564e <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x17e>
        }
    }
    else if(edge == Edge::kBoth){
   1557a:	9b01      	ldr	r3, [sp, #4]
   1557c:	2b03      	cmp	r3, #3
   1557e:	d131      	bne.n	155e4 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x114>
        if(gpio_port == 0){
   15580:	9b03      	ldr	r3, [sp, #12]
   15582:	781b      	ldrb	r3, [r3, #0]
   15584:	2b00      	cmp	r3, #0
   15586:	d116      	bne.n	155b6 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0xe6>
            (LPC_GPIOINT->IO0IntEnF |= 1 << gpio_pin) & (LPC_GPIOINT->IO0IntEnR |= 1 << gpio_pin);
   15588:	4b37      	ldr	r3, [pc, #220]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   1558a:	695b      	ldr	r3, [r3, #20]
   1558c:	9a03      	ldr	r2, [sp, #12]
   1558e:	7852      	ldrb	r2, [r2, #1]
   15590:	4611      	mov	r1, r2
   15592:	2201      	movs	r2, #1
   15594:	408a      	lsls	r2, r1
   15596:	4611      	mov	r1, r2
   15598:	4a33      	ldr	r2, [pc, #204]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   1559a:	430b      	orrs	r3, r1
   1559c:	6153      	str	r3, [r2, #20]
   1559e:	4b32      	ldr	r3, [pc, #200]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   155a0:	691b      	ldr	r3, [r3, #16]
   155a2:	9a03      	ldr	r2, [sp, #12]
   155a4:	7852      	ldrb	r2, [r2, #1]
   155a6:	4611      	mov	r1, r2
   155a8:	2201      	movs	r2, #1
   155aa:	408a      	lsls	r2, r1
   155ac:	4611      	mov	r1, r2
   155ae:	4a2e      	ldr	r2, [pc, #184]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   155b0:	430b      	orrs	r3, r1
   155b2:	6113      	str	r3, [r2, #16]
   155b4:	e04b      	b.n	1564e <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x17e>
        }
        else {
            (LPC_GPIOINT->IO2IntEnF |= 1 << gpio_pin) & (LPC_GPIOINT->IO2IntEnR |= 1 << gpio_pin);
   155b6:	4b2c      	ldr	r3, [pc, #176]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   155b8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   155ba:	9a03      	ldr	r2, [sp, #12]
   155bc:	7852      	ldrb	r2, [r2, #1]
   155be:	4611      	mov	r1, r2
   155c0:	2201      	movs	r2, #1
   155c2:	408a      	lsls	r2, r1
   155c4:	4611      	mov	r1, r2
   155c6:	4a28      	ldr	r2, [pc, #160]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   155c8:	430b      	orrs	r3, r1
   155ca:	6353      	str	r3, [r2, #52]	; 0x34
   155cc:	4b26      	ldr	r3, [pc, #152]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   155ce:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   155d0:	9a03      	ldr	r2, [sp, #12]
   155d2:	7852      	ldrb	r2, [r2, #1]
   155d4:	4611      	mov	r1, r2
   155d6:	2201      	movs	r2, #1
   155d8:	408a      	lsls	r2, r1
   155da:	4611      	mov	r1, r2
   155dc:	4a22      	ldr	r2, [pc, #136]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   155de:	430b      	orrs	r3, r1
   155e0:	6313      	str	r3, [r2, #48]	; 0x30
   155e2:	e034      	b.n	1564e <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x17e>
        }
    }
    else
    {
        if(gpio_port == 0){
   155e4:	9b03      	ldr	r3, [sp, #12]
   155e6:	781b      	ldrb	r3, [r3, #0]
   155e8:	2b00      	cmp	r3, #0
   155ea:	d118      	bne.n	1561e <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x14e>
            (LPC_GPIOINT->IO0IntEnF &= ~(1 << gpio_pin)) & (LPC_GPIOINT->IO0IntEnR &= ~(1 << gpio_pin));
   155ec:	4b1e      	ldr	r3, [pc, #120]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   155ee:	695b      	ldr	r3, [r3, #20]
   155f0:	9a03      	ldr	r2, [sp, #12]
   155f2:	7852      	ldrb	r2, [r2, #1]
   155f4:	4611      	mov	r1, r2
   155f6:	2201      	movs	r2, #1
   155f8:	408a      	lsls	r2, r1
   155fa:	43d2      	mvns	r2, r2
   155fc:	4611      	mov	r1, r2
   155fe:	4a1a      	ldr	r2, [pc, #104]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   15600:	400b      	ands	r3, r1
   15602:	6153      	str	r3, [r2, #20]
   15604:	4b18      	ldr	r3, [pc, #96]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   15606:	691b      	ldr	r3, [r3, #16]
   15608:	9a03      	ldr	r2, [sp, #12]
   1560a:	7852      	ldrb	r2, [r2, #1]
   1560c:	4611      	mov	r1, r2
   1560e:	2201      	movs	r2, #1
   15610:	408a      	lsls	r2, r1
   15612:	43d2      	mvns	r2, r2
   15614:	4611      	mov	r1, r2
   15616:	4a14      	ldr	r2, [pc, #80]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   15618:	400b      	ands	r3, r1
   1561a:	6113      	str	r3, [r2, #16]
   1561c:	e017      	b.n	1564e <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x17e>
        }
        else {
            (LPC_GPIOINT->IO2IntEnF &= ~(1 << gpio_pin)) & (LPC_GPIOINT->IO2IntEnR &= ~(1 << gpio_pin));
   1561e:	4b12      	ldr	r3, [pc, #72]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   15620:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   15622:	9a03      	ldr	r2, [sp, #12]
   15624:	7852      	ldrb	r2, [r2, #1]
   15626:	4611      	mov	r1, r2
   15628:	2201      	movs	r2, #1
   1562a:	408a      	lsls	r2, r1
   1562c:	43d2      	mvns	r2, r2
   1562e:	4611      	mov	r1, r2
   15630:	4a0d      	ldr	r2, [pc, #52]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   15632:	400b      	ands	r3, r1
   15634:	6353      	str	r3, [r2, #52]	; 0x34
   15636:	4b0c      	ldr	r3, [pc, #48]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   15638:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   1563a:	9a03      	ldr	r2, [sp, #12]
   1563c:	7852      	ldrb	r2, [r2, #1]
   1563e:	4611      	mov	r1, r2
   15640:	2201      	movs	r2, #1
   15642:	408a      	lsls	r2, r1
   15644:	43d2      	mvns	r2, r2
   15646:	4611      	mov	r1, r2
   15648:	4a07      	ldr	r2, [pc, #28]	; (15668 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x198>)
   1564a:	400b      	ands	r3, r1
   1564c:	6313      	str	r3, [r2, #48]	; 0x30
   1564e:	4623      	mov	r3, r4
   15650:	4619      	mov	r1, r3
   15652:	4803      	ldr	r0, [pc, #12]	; (15660 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x190>)
   15654:	f001 f962 	bl	1691c <__cyg_profile_func_exit>
        }
    }
    
}
   15658:	bf00      	nop
   1565a:	b004      	add	sp, #16
   1565c:	bd10      	pop	{r4, pc}
   1565e:	bf00      	nop
   15660:	000154d1 	.word	0x000154d1
   15664:	10002ed0 	.word	0x10002ed0
   15668:	40028080 	.word	0x40028080

0001566c <SetUptimeFunction(unsigned long long (*)())>:
{
   1566c:	b510      	push	{r4, lr}
   1566e:	b082      	sub	sp, #8
   15670:	4674      	mov	r4, lr
   15672:	9001      	str	r0, [sp, #4]
   15674:	4623      	mov	r3, r4
   15676:	4619      	mov	r1, r3
   15678:	4806      	ldr	r0, [pc, #24]	; (15694 <SetUptimeFunction(unsigned long long (*)())+0x28>)
   1567a:	f001 f93b 	bl	168f4 <__cyg_profile_func_enter>
  Uptime = uptime_function;
   1567e:	4a06      	ldr	r2, [pc, #24]	; (15698 <SetUptimeFunction(unsigned long long (*)())+0x2c>)
   15680:	9b01      	ldr	r3, [sp, #4]
   15682:	6013      	str	r3, [r2, #0]
   15684:	4623      	mov	r3, r4
   15686:	4619      	mov	r1, r3
   15688:	4802      	ldr	r0, [pc, #8]	; (15694 <SetUptimeFunction(unsigned long long (*)())+0x28>)
   1568a:	f001 f947 	bl	1691c <__cyg_profile_func_exit>
}
   1568e:	bf00      	nop
   15690:	b002      	add	sp, #8
   15692:	bd10      	pop	{r4, pc}
   15694:	0001566d 	.word	0x0001566d
   15698:	10000000 	.word	0x10000000

0001569c <SystemTimer::DisableTimer()>:
  /// system_timer_isr defaults to nullptr. The actual SystemTickHandler should
  /// check if the isr is set to nullptr, and if it is, turn off the timer, if
  /// set a proper function then execute it.
  inline static IsrPointer system_timer_isr = nullptr;
  /// WARNING: Doing so will most likely disable FreeRTOS
  static void DisableTimer()
   1569c:	b510      	push	{r4, lr}
   1569e:	4674      	mov	r4, lr
   156a0:	4623      	mov	r3, r4
   156a2:	4619      	mov	r1, r3
   156a4:	480a      	ldr	r0, [pc, #40]	; (156d0 <SystemTimer::DisableTimer()+0x34>)
   156a6:	f001 f925 	bl	168f4 <__cyg_profile_func_enter>
  {
    sys_tick->LOAD = 0;
   156aa:	4b0a      	ldr	r3, [pc, #40]	; (156d4 <SystemTimer::DisableTimer()+0x38>)
   156ac:	681b      	ldr	r3, [r3, #0]
   156ae:	2200      	movs	r2, #0
   156b0:	605a      	str	r2, [r3, #4]
    sys_tick->VAL  = 0;
   156b2:	4b08      	ldr	r3, [pc, #32]	; (156d4 <SystemTimer::DisableTimer()+0x38>)
   156b4:	681b      	ldr	r3, [r3, #0]
   156b6:	2200      	movs	r2, #0
   156b8:	609a      	str	r2, [r3, #8]
    sys_tick->CTRL = 0;
   156ba:	4b06      	ldr	r3, [pc, #24]	; (156d4 <SystemTimer::DisableTimer()+0x38>)
   156bc:	681b      	ldr	r3, [r3, #0]
   156be:	2200      	movs	r2, #0
   156c0:	601a      	str	r2, [r3, #0]
   156c2:	4623      	mov	r3, r4
   156c4:	4619      	mov	r1, r3
   156c6:	4802      	ldr	r0, [pc, #8]	; (156d0 <SystemTimer::DisableTimer()+0x34>)
   156c8:	f001 f928 	bl	1691c <__cyg_profile_func_exit>
  }
   156cc:	bf00      	nop
   156ce:	bd10      	pop	{r4, pc}
   156d0:	0001569d 	.word	0x0001569d
   156d4:	100004e4 	.word	0x100004e4

000156d8 <SystemTimer::SystemTimerHandler()>:
  static void SystemTimerHandler()
   156d8:	b510      	push	{r4, lr}
   156da:	4674      	mov	r4, lr
   156dc:	4623      	mov	r3, r4
   156de:	4619      	mov	r1, r3
   156e0:	4808      	ldr	r0, [pc, #32]	; (15704 <SystemTimer::SystemTimerHandler()+0x2c>)
   156e2:	f001 f907 	bl	168f4 <__cyg_profile_func_enter>
  {
    // This assumes that SysTickHandler is called every millisecond.
    // Changing that frequency will distort the milliseconds time.
    if (system_timer_isr != nullptr)
   156e6:	4b08      	ldr	r3, [pc, #32]	; (15708 <SystemTimer::SystemTimerHandler()+0x30>)
   156e8:	681b      	ldr	r3, [r3, #0]
   156ea:	2b00      	cmp	r3, #0
   156ec:	d002      	beq.n	156f4 <SystemTimer::SystemTimerHandler()+0x1c>
    {
      system_timer_isr();
   156ee:	4b06      	ldr	r3, [pc, #24]	; (15708 <SystemTimer::SystemTimerHandler()+0x30>)
   156f0:	681b      	ldr	r3, [r3, #0]
   156f2:	4798      	blx	r3
   156f4:	4623      	mov	r3, r4
   156f6:	4619      	mov	r1, r3
   156f8:	4802      	ldr	r0, [pc, #8]	; (15704 <SystemTimer::SystemTimerHandler()+0x2c>)
   156fa:	f001 f90f 	bl	1691c <__cyg_profile_func_exit>
    }
  }
   156fe:	bf00      	nop
   15700:	bd10      	pop	{r4, pc}
   15702:	bf00      	nop
   15704:	000156d9 	.word	0x000156d9
   15708:	10002fd0 	.word	0x10002fd0

0001570c <SystemTimer::SetIsrFunction(void (*)())>:
  constexpr SystemTimer() {}
  void SetIsrFunction(IsrPointer isr) override
   1570c:	b510      	push	{r4, lr}
   1570e:	b082      	sub	sp, #8
   15710:	4674      	mov	r4, lr
   15712:	9001      	str	r0, [sp, #4]
   15714:	9100      	str	r1, [sp, #0]
   15716:	4623      	mov	r3, r4
   15718:	4619      	mov	r1, r3
   1571a:	4807      	ldr	r0, [pc, #28]	; (15738 <SystemTimer::SetIsrFunction(void (*)())+0x2c>)
   1571c:	f001 f8ea 	bl	168f4 <__cyg_profile_func_enter>
  {
    system_timer_isr = isr;
   15720:	4a06      	ldr	r2, [pc, #24]	; (1573c <SystemTimer::SetIsrFunction(void (*)())+0x30>)
   15722:	9b00      	ldr	r3, [sp, #0]
   15724:	6013      	str	r3, [r2, #0]
   15726:	4623      	mov	r3, r4
   15728:	4619      	mov	r1, r3
   1572a:	4803      	ldr	r0, [pc, #12]	; (15738 <SystemTimer::SetIsrFunction(void (*)())+0x2c>)
   1572c:	f001 f8f6 	bl	1691c <__cyg_profile_func_exit>
  }
   15730:	bf00      	nop
   15732:	b002      	add	sp, #8
   15734:	bd10      	pop	{r4, pc}
   15736:	bf00      	nop
   15738:	0001570d 	.word	0x0001570d
   1573c:	10002fd0 	.word	0x10002fd0

00015740 <SystemTimer::StartTimer()>:
  bool StartTimer() override
   15740:	b530      	push	{r4, r5, lr}
   15742:	b085      	sub	sp, #20
   15744:	4675      	mov	r5, lr
   15746:	9001      	str	r0, [sp, #4]
   15748:	462b      	mov	r3, r5
   1574a:	4619      	mov	r1, r3
   1574c:	4820      	ldr	r0, [pc, #128]	; (157d0 <SystemTimer::StartTimer()+0x90>)
   1574e:	f001 f8d1 	bl	168f4 <__cyg_profile_func_enter>
  {
    bool successful = false;
   15752:	2300      	movs	r3, #0
   15754:	f88d 300f 	strb.w	r3, [sp, #15]
    if (sys_tick->LOAD != 0)
   15758:	4b1e      	ldr	r3, [pc, #120]	; (157d4 <SystemTimer::StartTimer()+0x94>)
   1575a:	681b      	ldr	r3, [r3, #0]
   1575c:	685b      	ldr	r3, [r3, #4]
   1575e:	2b00      	cmp	r3, #0
   15760:	bf14      	ite	ne
   15762:	2301      	movne	r3, #1
   15764:	2300      	moveq	r3, #0
   15766:	b2db      	uxtb	r3, r3
   15768:	2b00      	cmp	r3, #0
   1576a:	d01e      	beq.n	157aa <SystemTimer::StartTimer()+0x6a>
    {
      sys_tick->VAL = 0;
   1576c:	4b19      	ldr	r3, [pc, #100]	; (157d4 <SystemTimer::StartTimer()+0x94>)
   1576e:	681b      	ldr	r3, [r3, #0]
   15770:	2200      	movs	r2, #0
   15772:	609a      	str	r2, [r3, #8]
      sys_tick->CTRL |= (1 << ControlBitMap::kTickInterupt);
   15774:	4b17      	ldr	r3, [pc, #92]	; (157d4 <SystemTimer::StartTimer()+0x94>)
   15776:	681b      	ldr	r3, [r3, #0]
   15778:	681a      	ldr	r2, [r3, #0]
   1577a:	4b16      	ldr	r3, [pc, #88]	; (157d4 <SystemTimer::StartTimer()+0x94>)
   1577c:	681b      	ldr	r3, [r3, #0]
   1577e:	f042 0202 	orr.w	r2, r2, #2
   15782:	601a      	str	r2, [r3, #0]
      sys_tick->CTRL |= (1 << ControlBitMap::kEnableCounter);
   15784:	4b13      	ldr	r3, [pc, #76]	; (157d4 <SystemTimer::StartTimer()+0x94>)
   15786:	681b      	ldr	r3, [r3, #0]
   15788:	681a      	ldr	r2, [r3, #0]
   1578a:	4b12      	ldr	r3, [pc, #72]	; (157d4 <SystemTimer::StartTimer()+0x94>)
   1578c:	681b      	ldr	r3, [r3, #0]
   1578e:	f042 0201 	orr.w	r2, r2, #1
   15792:	601a      	str	r2, [r3, #0]
      sys_tick->CTRL |= (1 << ControlBitMap::kClkSource);
   15794:	4b0f      	ldr	r3, [pc, #60]	; (157d4 <SystemTimer::StartTimer()+0x94>)
   15796:	681b      	ldr	r3, [r3, #0]
   15798:	681a      	ldr	r2, [r3, #0]
   1579a:	4b0e      	ldr	r3, [pc, #56]	; (157d4 <SystemTimer::StartTimer()+0x94>)
   1579c:	681b      	ldr	r3, [r3, #0]
   1579e:	f042 0204 	orr.w	r2, r2, #4
   157a2:	601a      	str	r2, [r3, #0]
      successful = true;
   157a4:	2301      	movs	r3, #1
   157a6:	f88d 300f 	strb.w	r3, [sp, #15]
    }
    RegisterIsr(SysTick_IRQn, SystemTimerHandler);
   157aa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   157ae:	2201      	movs	r2, #1
   157b0:	4909      	ldr	r1, [pc, #36]	; (157d8 <SystemTimer::StartTimer()+0x98>)
   157b2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   157b6:	f000 ff49 	bl	1664c <RegisterIsr(IRQn, void (*)(), bool, long)>
    return successful;
   157ba:	f89d 400f 	ldrb.w	r4, [sp, #15]
   157be:	462b      	mov	r3, r5
   157c0:	4619      	mov	r1, r3
   157c2:	4803      	ldr	r0, [pc, #12]	; (157d0 <SystemTimer::StartTimer()+0x90>)
   157c4:	f001 f8aa 	bl	1691c <__cyg_profile_func_exit>
   157c8:	4623      	mov	r3, r4
  }
   157ca:	4618      	mov	r0, r3
   157cc:	b005      	add	sp, #20
   157ce:	bd30      	pop	{r4, r5, pc}
   157d0:	00015741 	.word	0x00015741
   157d4:	100004e4 	.word	0x100004e4
   157d8:	000156d9 	.word	0x000156d9

000157dc <SystemTimer::SetTickFrequency(unsigned long)>:
  ///          remainder will be returned.
  ///          If the freqency supplied is less then 2Hz, the function will
  ///          return without changing any hardware.
  ///          If the reload value exceeds the SysTick_LOAD_RELOAD_Msk, the
  ///          returned value is the SysTick_LOAD_RELOAD_Msk.
  uint32_t SetTickFrequency(uint32_t frequency) override
   157dc:	b530      	push	{r4, r5, lr}
   157de:	b085      	sub	sp, #20
   157e0:	4675      	mov	r5, lr
   157e2:	9001      	str	r0, [sp, #4]
   157e4:	9100      	str	r1, [sp, #0]
   157e6:	462b      	mov	r3, r5
   157e8:	4619      	mov	r1, r3
   157ea:	481f      	ldr	r0, [pc, #124]	; (15868 <SystemTimer::SetTickFrequency(unsigned long)+0x8c>)
   157ec:	f001 f882 	bl	168f4 <__cyg_profile_func_enter>
  {
    if (frequency <= 1)
   157f0:	9b00      	ldr	r3, [sp, #0]
   157f2:	2b01      	cmp	r3, #1
   157f4:	d801      	bhi.n	157fa <SystemTimer::SetTickFrequency(unsigned long)+0x1e>
    {
      return 0;
   157f6:	2400      	movs	r4, #0
   157f8:	e02d      	b.n	15856 <SystemTimer::SetTickFrequency(unsigned long)+0x7a>
    }
    uint32_t reload_value = (GetSystemFrequency() / frequency) - 1;
   157fa:	9b01      	ldr	r3, [sp, #4]
   157fc:	1d1a      	adds	r2, r3, #4
   157fe:	9b01      	ldr	r3, [sp, #4]
   15800:	685b      	ldr	r3, [r3, #4]
   15802:	330c      	adds	r3, #12
   15804:	681b      	ldr	r3, [r3, #0]
   15806:	4610      	mov	r0, r2
   15808:	4798      	blx	r3
   1580a:	4602      	mov	r2, r0
   1580c:	9b00      	ldr	r3, [sp, #0]
   1580e:	fbb2 f3f3 	udiv	r3, r2, r3
   15812:	3b01      	subs	r3, #1
   15814:	9303      	str	r3, [sp, #12]
    int remainder         = (GetSystemFrequency() % frequency);
   15816:	9b01      	ldr	r3, [sp, #4]
   15818:	1d1a      	adds	r2, r3, #4
   1581a:	9b01      	ldr	r3, [sp, #4]
   1581c:	685b      	ldr	r3, [r3, #4]
   1581e:	330c      	adds	r3, #12
   15820:	681b      	ldr	r3, [r3, #0]
   15822:	4610      	mov	r0, r2
   15824:	4798      	blx	r3
   15826:	4603      	mov	r3, r0
   15828:	9a00      	ldr	r2, [sp, #0]
   1582a:	fbb3 f2f2 	udiv	r2, r3, r2
   1582e:	9900      	ldr	r1, [sp, #0]
   15830:	fb01 f202 	mul.w	r2, r1, r2
   15834:	1a9b      	subs	r3, r3, r2
   15836:	9302      	str	r3, [sp, #8]
    if (reload_value > SysTick_LOAD_RELOAD_Msk)
   15838:	9b03      	ldr	r3, [sp, #12]
   1583a:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
   1583e:	d305      	bcc.n	1584c <SystemTimer::SetTickFrequency(unsigned long)+0x70>
    {
      reload_value = SysTick_LOAD_RELOAD_Msk;
   15840:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
   15844:	9303      	str	r3, [sp, #12]
      remainder    = SysTick_LOAD_RELOAD_Msk;
   15846:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
   1584a:	9302      	str	r3, [sp, #8]
    }
    sys_tick->LOAD = reload_value;
   1584c:	4b07      	ldr	r3, [pc, #28]	; (1586c <SystemTimer::SetTickFrequency(unsigned long)+0x90>)
   1584e:	681b      	ldr	r3, [r3, #0]
   15850:	9a03      	ldr	r2, [sp, #12]
   15852:	605a      	str	r2, [r3, #4]
    return remainder;
   15854:	9c02      	ldr	r4, [sp, #8]
   15856:	462b      	mov	r3, r5
   15858:	4619      	mov	r1, r3
   1585a:	4803      	ldr	r0, [pc, #12]	; (15868 <SystemTimer::SetTickFrequency(unsigned long)+0x8c>)
   1585c:	f001 f85e 	bl	1691c <__cyg_profile_func_exit>
   15860:	4623      	mov	r3, r4
  }
   15862:	4618      	mov	r0, r3
   15864:	b005      	add	sp, #20
   15866:	bd30      	pop	{r4, r5, pc}
   15868:	000157dd 	.word	0x000157dd
   1586c:	100004e4 	.word	0x100004e4

00015870 <Timer::DoNothingIsr()>:
  static void DoNothingIsr() {}
   15870:	b510      	push	{r4, lr}
   15872:	4674      	mov	r4, lr
   15874:	4623      	mov	r3, r4
   15876:	4619      	mov	r1, r3
   15878:	4804      	ldr	r0, [pc, #16]	; (1588c <Timer::DoNothingIsr()+0x1c>)
   1587a:	f001 f83b 	bl	168f4 <__cyg_profile_func_enter>
   1587e:	4623      	mov	r3, r4
   15880:	4619      	mov	r1, r3
   15882:	4802      	ldr	r0, [pc, #8]	; (1588c <Timer::DoNothingIsr()+0x1c>)
   15884:	f001 f84a 	bl	1691c <__cyg_profile_func_exit>
   15888:	bf00      	nop
   1588a:	bd10      	pop	{r4, pc}
   1588c:	00015871 	.word	0x00015871

00015890 <Uart::SetBaudRate(unsigned long)>:
  constexpr Uart(Channels mode, PinInterface * tx_pin, PinInterface * rx_pin)
      : channel_(static_cast<uint8_t>(mode)), tx_(tx_pin), rx_(rx_pin)
  {
  }

  void SetBaudRate(uint32_t baud_rate) override
   15890:	b510      	push	{r4, lr}
   15892:	b088      	sub	sp, #32
   15894:	4674      	mov	r4, lr
   15896:	9001      	str	r0, [sp, #4]
   15898:	9100      	str	r1, [sp, #0]
   1589a:	4623      	mov	r3, r4
   1589c:	4619      	mov	r1, r3
   1589e:	482d      	ldr	r0, [pc, #180]	; (15954 <Uart::SetBaudRate(unsigned long)+0xc4>)
   158a0:	f001 f828 	bl	168f4 <__cyg_profile_func_enter>
  {
    constexpr uint8_t kDlabBit = (1 << 7);
   158a4:	2380      	movs	r3, #128	; 0x80
   158a6:	f88d 301f 	strb.w	r3, [sp, #31]
    float baudrate             = static_cast<float>(baud_rate);
   158aa:	9b00      	ldr	r3, [sp, #0]
   158ac:	ee07 3a90 	vmov	s15, r3
   158b0:	eef8 7a67 	vcvt.f32.u32	s15, s15
   158b4:	edcd 7a06 	vstr	s15, [sp, #24]
    UartCalibration_t dividers = GenerateUartCalibration(baudrate);
   158b8:	ab02      	add	r3, sp, #8
   158ba:	ed9d 0a06 	vldr	s0, [sp, #24]
   158be:	9901      	ldr	r1, [sp, #4]
   158c0:	4618      	mov	r0, r3
   158c2:	f000 fb2d 	bl	15f20 <Uart::GenerateUartCalibration(float)>

    uint8_t dlm = static_cast<uint8_t>((dividers.divide_latch >> 8) & 0xFF);
   158c6:	9b02      	ldr	r3, [sp, #8]
   158c8:	0a1b      	lsrs	r3, r3, #8
   158ca:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8_t dll = static_cast<uint8_t>(dividers.divide_latch & 0xFF);
   158ce:	9b02      	ldr	r3, [sp, #8]
   158d0:	f88d 3016 	strb.w	r3, [sp, #22]
    uint8_t fdr = static_cast<uint8_t>((dividers.multiply & 0xF) << 4 |
   158d4:	9b04      	ldr	r3, [sp, #16]
   158d6:	b2db      	uxtb	r3, r3
   158d8:	011b      	lsls	r3, r3, #4
   158da:	b2da      	uxtb	r2, r3
                                       (dividers.divide_add & 0xF));
   158dc:	9b03      	ldr	r3, [sp, #12]
   158de:	b2db      	uxtb	r3, r3
   158e0:	f003 030f 	and.w	r3, r3, #15
   158e4:	b2db      	uxtb	r3, r3
    uint8_t fdr = static_cast<uint8_t>((dividers.multiply & 0xF) << 4 |
   158e6:	4313      	orrs	r3, r2
   158e8:	f88d 3015 	strb.w	r3, [sp, #21]

    // Set baud rate
    uart[channel_]->LCR = kDlabBit;
   158ec:	9b01      	ldr	r3, [sp, #4]
   158ee:	7a1b      	ldrb	r3, [r3, #8]
   158f0:	461a      	mov	r2, r3
   158f2:	4b19      	ldr	r3, [pc, #100]	; (15958 <Uart::SetBaudRate(unsigned long)+0xc8>)
   158f4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   158f8:	2280      	movs	r2, #128	; 0x80
   158fa:	731a      	strb	r2, [r3, #12]
    uart[channel_]->DLM = dlm;
   158fc:	9b01      	ldr	r3, [sp, #4]
   158fe:	7a1b      	ldrb	r3, [r3, #8]
   15900:	461a      	mov	r2, r3
   15902:	4b15      	ldr	r3, [pc, #84]	; (15958 <Uart::SetBaudRate(unsigned long)+0xc8>)
   15904:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   15908:	f89d 2017 	ldrb.w	r2, [sp, #23]
   1590c:	711a      	strb	r2, [r3, #4]
    uart[channel_]->DLL = dll;
   1590e:	9b01      	ldr	r3, [sp, #4]
   15910:	7a1b      	ldrb	r3, [r3, #8]
   15912:	461a      	mov	r2, r3
   15914:	4b10      	ldr	r3, [pc, #64]	; (15958 <Uart::SetBaudRate(unsigned long)+0xc8>)
   15916:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1591a:	f89d 2016 	ldrb.w	r2, [sp, #22]
   1591e:	701a      	strb	r2, [r3, #0]
    uart[channel_]->FDR = fdr;
   15920:	9b01      	ldr	r3, [sp, #4]
   15922:	7a1b      	ldrb	r3, [r3, #8]
   15924:	461a      	mov	r2, r3
   15926:	4b0c      	ldr	r3, [pc, #48]	; (15958 <Uart::SetBaudRate(unsigned long)+0xc8>)
   15928:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1592c:	f89d 2015 	ldrb.w	r2, [sp, #21]
   15930:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    uart[channel_]->LCR = kStandardUart;
   15934:	9b01      	ldr	r3, [sp, #4]
   15936:	7a1b      	ldrb	r3, [r3, #8]
   15938:	461a      	mov	r2, r3
   1593a:	4b07      	ldr	r3, [pc, #28]	; (15958 <Uart::SetBaudRate(unsigned long)+0xc8>)
   1593c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   15940:	2203      	movs	r2, #3
   15942:	731a      	strb	r2, [r3, #12]
   15944:	4623      	mov	r3, r4
   15946:	4619      	mov	r1, r3
   15948:	4802      	ldr	r0, [pc, #8]	; (15954 <Uart::SetBaudRate(unsigned long)+0xc4>)
   1594a:	f000 ffe7 	bl	1691c <__cyg_profile_func_exit>
  }
   1594e:	bf00      	nop
   15950:	b008      	add	sp, #32
   15952:	bd10      	pop	{r4, pc}
   15954:	00015891 	.word	0x00015891
   15958:	100004e8 	.word	0x100004e8

0001595c <Uart::Initialize(unsigned long)>:

  bool Initialize(uint32_t baud_rate) override
   1595c:	b530      	push	{r4, r5, lr}
   1595e:	b085      	sub	sp, #20
   15960:	4675      	mov	r5, lr
   15962:	9001      	str	r0, [sp, #4]
   15964:	9100      	str	r1, [sp, #0]
   15966:	462b      	mov	r3, r5
   15968:	4619      	mov	r1, r3
   1596a:	4830      	ldr	r0, [pc, #192]	; (15a2c <Uart::Initialize(unsigned long)+0xd0>)
   1596c:	f000 ffc2 	bl	168f4 <__cyg_profile_func_enter>
  {
    constexpr uint8_t kFIFOEnableAndReset = 0b111;
   15970:	2307      	movs	r3, #7
   15972:	f88d 300f 	strb.w	r3, [sp, #15]
    // Powering the port
    PowerUpPeripheral(kPowerbit[channel_]);
   15976:	9b01      	ldr	r3, [sp, #4]
   15978:	1d18      	adds	r0, r3, #4
   1597a:	9b01      	ldr	r3, [sp, #4]
   1597c:	685b      	ldr	r3, [r3, #4]
   1597e:	3314      	adds	r3, #20
   15980:	681b      	ldr	r3, [r3, #0]
   15982:	9a01      	ldr	r2, [sp, #4]
   15984:	7a12      	ldrb	r2, [r2, #8]
   15986:	0092      	lsls	r2, r2, #2
   15988:	4929      	ldr	r1, [pc, #164]	; (15a30 <Uart::Initialize(unsigned long)+0xd4>)
   1598a:	440a      	add	r2, r1
   1598c:	4611      	mov	r1, r2
   1598e:	4798      	blx	r3
    // Setting the pin functions and modes
    rx_->SetPinFunction(kRxUartPortFunction[channel_]);
   15990:	9b01      	ldr	r3, [sp, #4]
   15992:	6918      	ldr	r0, [r3, #16]
   15994:	9b01      	ldr	r3, [sp, #4]
   15996:	691b      	ldr	r3, [r3, #16]
   15998:	681b      	ldr	r3, [r3, #0]
   1599a:	681b      	ldr	r3, [r3, #0]
   1599c:	9a01      	ldr	r2, [sp, #4]
   1599e:	7a12      	ldrb	r2, [r2, #8]
   159a0:	4611      	mov	r1, r2
   159a2:	4a24      	ldr	r2, [pc, #144]	; (15a34 <Uart::Initialize(unsigned long)+0xd8>)
   159a4:	5c52      	ldrb	r2, [r2, r1]
   159a6:	4611      	mov	r1, r2
   159a8:	4798      	blx	r3
    tx_->SetPinFunction(kTxUartPortFunction[channel_]);
   159aa:	9b01      	ldr	r3, [sp, #4]
   159ac:	68d8      	ldr	r0, [r3, #12]
   159ae:	9b01      	ldr	r3, [sp, #4]
   159b0:	68db      	ldr	r3, [r3, #12]
   159b2:	681b      	ldr	r3, [r3, #0]
   159b4:	681b      	ldr	r3, [r3, #0]
   159b6:	9a01      	ldr	r2, [sp, #4]
   159b8:	7a12      	ldrb	r2, [r2, #8]
   159ba:	4611      	mov	r1, r2
   159bc:	4a1e      	ldr	r2, [pc, #120]	; (15a38 <Uart::Initialize(unsigned long)+0xdc>)
   159be:	5c52      	ldrb	r2, [r2, r1]
   159c0:	4611      	mov	r1, r2
   159c2:	4798      	blx	r3
    rx_->SetMode(PinInterface::Mode::kPullUp);
   159c4:	9b01      	ldr	r3, [sp, #4]
   159c6:	691a      	ldr	r2, [r3, #16]
   159c8:	9b01      	ldr	r3, [sp, #4]
   159ca:	691b      	ldr	r3, [r3, #16]
   159cc:	681b      	ldr	r3, [r3, #0]
   159ce:	3304      	adds	r3, #4
   159d0:	681b      	ldr	r3, [r3, #0]
   159d2:	2102      	movs	r1, #2
   159d4:	4610      	mov	r0, r2
   159d6:	4798      	blx	r3
    tx_->SetMode(PinInterface::Mode::kPullUp);
   159d8:	9b01      	ldr	r3, [sp, #4]
   159da:	68da      	ldr	r2, [r3, #12]
   159dc:	9b01      	ldr	r3, [sp, #4]
   159de:	68db      	ldr	r3, [r3, #12]
   159e0:	681b      	ldr	r3, [r3, #0]
   159e2:	3304      	adds	r3, #4
   159e4:	681b      	ldr	r3, [r3, #0]
   159e6:	2102      	movs	r1, #2
   159e8:	4610      	mov	r0, r2
   159ea:	4798      	blx	r3
    // Baud rate setting
    SetBaudRate(baud_rate);
   159ec:	9900      	ldr	r1, [sp, #0]
   159ee:	9801      	ldr	r0, [sp, #4]
   159f0:	f7ff ff4e 	bl	15890 <Uart::SetBaudRate(unsigned long)>
    uart[channel_]->FCR |= kFIFOEnableAndReset;
   159f4:	9b01      	ldr	r3, [sp, #4]
   159f6:	7a1b      	ldrb	r3, [r3, #8]
   159f8:	461a      	mov	r2, r3
   159fa:	4b10      	ldr	r3, [pc, #64]	; (15a3c <Uart::Initialize(unsigned long)+0xe0>)
   159fc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   15a00:	7a1b      	ldrb	r3, [r3, #8]
   15a02:	b2da      	uxtb	r2, r3
   15a04:	9b01      	ldr	r3, [sp, #4]
   15a06:	7a1b      	ldrb	r3, [r3, #8]
   15a08:	4619      	mov	r1, r3
   15a0a:	4b0c      	ldr	r3, [pc, #48]	; (15a3c <Uart::Initialize(unsigned long)+0xe0>)
   15a0c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   15a10:	f042 0207 	orr.w	r2, r2, #7
   15a14:	b2d2      	uxtb	r2, r2
   15a16:	721a      	strb	r2, [r3, #8]
    return true;
   15a18:	2401      	movs	r4, #1
   15a1a:	462b      	mov	r3, r5
   15a1c:	4619      	mov	r1, r3
   15a1e:	4803      	ldr	r0, [pc, #12]	; (15a2c <Uart::Initialize(unsigned long)+0xd0>)
   15a20:	f000 ff7c 	bl	1691c <__cyg_profile_func_exit>
   15a24:	4623      	mov	r3, r4
  }
   15a26:	4618      	mov	r0, r3
   15a28:	b005      	add	sp, #20
   15a2a:	bd30      	pop	{r4, r5, pc}
   15a2c:	0001595d 	.word	0x0001595d
   15a30:	0001e070 	.word	0x0001e070
   15a34:	0001e06c 	.word	0x0001e06c
   15a38:	0001e068 	.word	0x0001e068
   15a3c:	100004e8 	.word	0x100004e8

00015a40 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const>:

  void Send(uint8_t data) override
  {
    uart[channel_]->THR              = data;
    auto wait_for_transfer_to_finish = [this]() -> bool {
   15a40:	b530      	push	{r4, r5, lr}
   15a42:	b083      	sub	sp, #12
   15a44:	4675      	mov	r5, lr
   15a46:	9001      	str	r0, [sp, #4]
   15a48:	462b      	mov	r3, r5
   15a4a:	4619      	mov	r1, r3
   15a4c:	480d      	ldr	r0, [pc, #52]	; (15a84 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const+0x44>)
   15a4e:	f000 ff51 	bl	168f4 <__cyg_profile_func_enter>
   15a52:	9b01      	ldr	r3, [sp, #4]
   15a54:	681b      	ldr	r3, [r3, #0]
      return (uart[channel_]->LSR & (1 << 5));
   15a56:	7a1b      	ldrb	r3, [r3, #8]
   15a58:	461a      	mov	r2, r3
   15a5a:	4b0b      	ldr	r3, [pc, #44]	; (15a88 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const+0x48>)
   15a5c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   15a60:	7d1b      	ldrb	r3, [r3, #20]
   15a62:	b2db      	uxtb	r3, r3
   15a64:	f003 0320 	and.w	r3, r3, #32
   15a68:	2b00      	cmp	r3, #0
   15a6a:	bf14      	ite	ne
   15a6c:	2301      	movne	r3, #1
   15a6e:	2300      	moveq	r3, #0
   15a70:	b2dc      	uxtb	r4, r3
   15a72:	462b      	mov	r3, r5
   15a74:	4619      	mov	r1, r3
   15a76:	4803      	ldr	r0, [pc, #12]	; (15a84 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const+0x44>)
   15a78:	f000 ff50 	bl	1691c <__cyg_profile_func_exit>
   15a7c:	4623      	mov	r3, r4
    };
   15a7e:	4618      	mov	r0, r3
   15a80:	b003      	add	sp, #12
   15a82:	bd30      	pop	{r4, r5, pc}
   15a84:	00015a41 	.word	0x00015a41
   15a88:	100004e8 	.word	0x100004e8

00015a8c <Uart::Send(unsigned char)>:
  void Send(uint8_t data) override
   15a8c:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   15a90:	b08a      	sub	sp, #40	; 0x28
   15a92:	4675      	mov	r5, lr
   15a94:	9001      	str	r0, [sp, #4]
   15a96:	460b      	mov	r3, r1
   15a98:	f88d 3003 	strb.w	r3, [sp, #3]
   15a9c:	462b      	mov	r3, r5
   15a9e:	4619      	mov	r1, r3
   15aa0:	4831      	ldr	r0, [pc, #196]	; (15b68 <Uart::Send(unsigned char)+0xdc>)
   15aa2:	f000 ff27 	bl	168f4 <__cyg_profile_func_enter>
    uart[channel_]->THR              = data;
   15aa6:	9b01      	ldr	r3, [sp, #4]
   15aa8:	7a1b      	ldrb	r3, [r3, #8]
   15aaa:	461a      	mov	r2, r3
   15aac:	4b2f      	ldr	r3, [pc, #188]	; (15b6c <Uart::Send(unsigned char)+0xe0>)
   15aae:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   15ab2:	f89d 2003 	ldrb.w	r2, [sp, #3]
   15ab6:	701a      	strb	r2, [r3, #0]
    };
   15ab8:	9b01      	ldr	r3, [sp, #4]
   15aba:	9304      	str	r3, [sp, #16]
   15abc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   15ac0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   15ac4:	e9cd 3408 	strd	r3, r4, [sp, #32]
   15ac8:	9b04      	ldr	r3, [sp, #16]
   15aca:	9303      	str	r3, [sp, #12]
   15acc:	462b      	mov	r3, r5
   15ace:	4619      	mov	r1, r3
   15ad0:	4827      	ldr	r0, [pc, #156]	; (15b70 <Uart::Send(unsigned char)+0xe4>)
   15ad2:	f000 ff0f 	bl	168f4 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   15ad6:	f04f 0300 	mov.w	r3, #0
   15ada:	f04f 0400 	mov.w	r4, #0
   15ade:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   15ae2:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   15ae6:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   15aea:	bf08      	it	eq
   15aec:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   15af0:	d106      	bne.n	15b00 <Uart::Send(unsigned char)+0x74>
    timeout_time = kMaxWait;
   15af2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   15af6:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   15afa:	e9cd 3406 	strd	r3, r4, [sp, #24]
   15afe:	e00b      	b.n	15b18 <Uart::Send(unsigned char)+0x8c>
    timeout_time = Milliseconds() + timeout;
   15b00:	f7fa fcae 	bl	10460 <Milliseconds()>
   15b04:	460a      	mov	r2, r1
   15b06:	4601      	mov	r1, r0
   15b08:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   15b0c:	eb13 0b01 	adds.w	fp, r3, r1
   15b10:	eb44 0c02 	adc.w	ip, r4, r2
   15b14:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   15b18:	2301      	movs	r3, #1
   15b1a:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   15b1c:	f7fa fca0 	bl	10460 <Milliseconds()>
   15b20:	460a      	mov	r2, r1
   15b22:	4601      	mov	r1, r0
   15b24:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   15b28:	42a2      	cmp	r2, r4
   15b2a:	bf08      	it	eq
   15b2c:	4299      	cmpeq	r1, r3
   15b2e:	bf34      	ite	cc
   15b30:	2301      	movcc	r3, #1
   15b32:	2300      	movcs	r3, #0
   15b34:	b2db      	uxtb	r3, r3
   15b36:	2b00      	cmp	r3, #0
   15b38:	d008      	beq.n	15b4c <Uart::Send(unsigned char)+0xc0>
    if (is_done())
   15b3a:	ab03      	add	r3, sp, #12
   15b3c:	4618      	mov	r0, r3
   15b3e:	f7ff ff7f 	bl	15a40 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const>
   15b42:	4603      	mov	r3, r0
   15b44:	2b00      	cmp	r3, #0
   15b46:	d0e9      	beq.n	15b1c <Uart::Send(unsigned char)+0x90>
      status = Status::kSuccess;
   15b48:	2300      	movs	r3, #0
   15b4a:	9305      	str	r3, [sp, #20]
   15b4c:	462b      	mov	r3, r5
   15b4e:	4619      	mov	r1, r3
   15b50:	4807      	ldr	r0, [pc, #28]	; (15b70 <Uart::Send(unsigned char)+0xe4>)
   15b52:	f000 fee3 	bl	1691c <__cyg_profile_func_exit>
   15b56:	462b      	mov	r3, r5
   15b58:	4619      	mov	r1, r3
   15b5a:	4803      	ldr	r0, [pc, #12]	; (15b68 <Uart::Send(unsigned char)+0xdc>)
   15b5c:	f000 fede 	bl	1691c <__cyg_profile_func_exit>
    Wait(kMaxWait, wait_for_transfer_to_finish);
  }
   15b60:	bf00      	nop
   15b62:	b00a      	add	sp, #40	; 0x28
   15b64:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   15b68:	00015a8d 	.word	0x00015a8d
   15b6c:	100004e8 	.word	0x100004e8
   15b70:	00016325 	.word	0x00016325

00015b74 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const>:

  uint8_t Receive([[maybe_unused]] uint32_t timeout = 0x7FFFFFFF) override
  {
    uint8_t receiver   = '\xFF';
    auto byte_recieved = [this]() -> bool {
   15b74:	b530      	push	{r4, r5, lr}
   15b76:	b083      	sub	sp, #12
   15b78:	4675      	mov	r5, lr
   15b7a:	9001      	str	r0, [sp, #4]
   15b7c:	462b      	mov	r3, r5
   15b7e:	4619      	mov	r1, r3
   15b80:	480d      	ldr	r0, [pc, #52]	; (15bb8 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const+0x44>)
   15b82:	f000 feb7 	bl	168f4 <__cyg_profile_func_enter>
   15b86:	9b01      	ldr	r3, [sp, #4]
   15b88:	681b      	ldr	r3, [r3, #0]
      return (uart[channel_]->LSR & (1 << 0));
   15b8a:	7a1b      	ldrb	r3, [r3, #8]
   15b8c:	461a      	mov	r2, r3
   15b8e:	4b0b      	ldr	r3, [pc, #44]	; (15bbc <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const+0x48>)
   15b90:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   15b94:	7d1b      	ldrb	r3, [r3, #20]
   15b96:	b2db      	uxtb	r3, r3
   15b98:	f003 0301 	and.w	r3, r3, #1
   15b9c:	2b00      	cmp	r3, #0
   15b9e:	bf14      	ite	ne
   15ba0:	2301      	movne	r3, #1
   15ba2:	2300      	moveq	r3, #0
   15ba4:	b2dc      	uxtb	r4, r3
   15ba6:	462b      	mov	r3, r5
   15ba8:	4619      	mov	r1, r3
   15baa:	4803      	ldr	r0, [pc, #12]	; (15bb8 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const+0x44>)
   15bac:	f000 feb6 	bl	1691c <__cyg_profile_func_exit>
   15bb0:	4623      	mov	r3, r4
    };
   15bb2:	4618      	mov	r0, r3
   15bb4:	b003      	add	sp, #12
   15bb6:	bd30      	pop	{r4, r5, pc}
   15bb8:	00015b75 	.word	0x00015b75
   15bbc:	100004e8 	.word	0x100004e8

00015bc0 <Uart::Receive(unsigned long)>:
  uint8_t Receive([[maybe_unused]] uint32_t timeout = 0x7FFFFFFF) override
   15bc0:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   15bc4:	b08c      	sub	sp, #48	; 0x30
   15bc6:	4675      	mov	r5, lr
   15bc8:	9001      	str	r0, [sp, #4]
   15bca:	9100      	str	r1, [sp, #0]
   15bcc:	462b      	mov	r3, r5
   15bce:	4619      	mov	r1, r3
   15bd0:	4836      	ldr	r0, [pc, #216]	; (15cac <Uart::Receive(unsigned long)+0xec>)
   15bd2:	f000 fe8f 	bl	168f4 <__cyg_profile_func_enter>
    uint8_t receiver   = '\xFF';
   15bd6:	23ff      	movs	r3, #255	; 0xff
   15bd8:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    };
   15bdc:	9b01      	ldr	r3, [sp, #4]
   15bde:	9304      	str	r3, [sp, #16]

    Status status = Wait(timeout, byte_recieved);
   15be0:	9b00      	ldr	r3, [sp, #0]
   15be2:	f04f 0400 	mov.w	r4, #0
   15be6:	e9cd 3408 	strd	r3, r4, [sp, #32]
   15bea:	9b04      	ldr	r3, [sp, #16]
   15bec:	9303      	str	r3, [sp, #12]
   15bee:	462b      	mov	r3, r5
   15bf0:	4619      	mov	r1, r3
   15bf2:	482f      	ldr	r0, [pc, #188]	; (15cb0 <Uart::Receive(unsigned long)+0xf0>)
   15bf4:	f000 fe7e 	bl	168f4 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   15bf8:	f04f 0300 	mov.w	r3, #0
   15bfc:	f04f 0400 	mov.w	r4, #0
   15c00:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   15c04:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   15c08:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   15c0c:	bf08      	it	eq
   15c0e:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   15c12:	d106      	bne.n	15c22 <Uart::Receive(unsigned long)+0x62>
    timeout_time = kMaxWait;
   15c14:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   15c18:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   15c1c:	e9cd 3406 	strd	r3, r4, [sp, #24]
   15c20:	e00b      	b.n	15c3a <Uart::Receive(unsigned long)+0x7a>
    timeout_time = Milliseconds() + timeout;
   15c22:	f7fa fc1d 	bl	10460 <Milliseconds()>
   15c26:	460a      	mov	r2, r1
   15c28:	4601      	mov	r1, r0
   15c2a:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   15c2e:	eb13 0b01 	adds.w	fp, r3, r1
   15c32:	eb44 0c02 	adc.w	ip, r4, r2
   15c36:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   15c3a:	2301      	movs	r3, #1
   15c3c:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   15c3e:	f7fa fc0f 	bl	10460 <Milliseconds()>
   15c42:	460a      	mov	r2, r1
   15c44:	4601      	mov	r1, r0
   15c46:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   15c4a:	42a2      	cmp	r2, r4
   15c4c:	bf08      	it	eq
   15c4e:	4299      	cmpeq	r1, r3
   15c50:	bf34      	ite	cc
   15c52:	2301      	movcc	r3, #1
   15c54:	2300      	movcs	r3, #0
   15c56:	b2db      	uxtb	r3, r3
   15c58:	2b00      	cmp	r3, #0
   15c5a:	d008      	beq.n	15c6e <Uart::Receive(unsigned long)+0xae>
    if (is_done())
   15c5c:	ab03      	add	r3, sp, #12
   15c5e:	4618      	mov	r0, r3
   15c60:	f7ff ff88 	bl	15b74 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const>
   15c64:	4603      	mov	r3, r0
   15c66:	2b00      	cmp	r3, #0
   15c68:	d0e9      	beq.n	15c3e <Uart::Receive(unsigned long)+0x7e>
      status = Status::kSuccess;
   15c6a:	2300      	movs	r3, #0
   15c6c:	9305      	str	r3, [sp, #20]
  return status;
   15c6e:	9c05      	ldr	r4, [sp, #20]
   15c70:	462b      	mov	r3, r5
   15c72:	4619      	mov	r1, r3
   15c74:	480e      	ldr	r0, [pc, #56]	; (15cb0 <Uart::Receive(unsigned long)+0xf0>)
   15c76:	f000 fe51 	bl	1691c <__cyg_profile_func_exit>
   15c7a:	940a      	str	r4, [sp, #40]	; 0x28

    if (status == Status::kSuccess)
   15c7c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15c7e:	2b00      	cmp	r3, #0
   15c80:	d108      	bne.n	15c94 <Uart::Receive(unsigned long)+0xd4>
    {
      receiver = static_cast<uint8_t>(uart[channel_]->RBR);
   15c82:	9b01      	ldr	r3, [sp, #4]
   15c84:	7a1b      	ldrb	r3, [r3, #8]
   15c86:	461a      	mov	r2, r3
   15c88:	4b0a      	ldr	r3, [pc, #40]	; (15cb4 <Uart::Receive(unsigned long)+0xf4>)
   15c8a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   15c8e:	781b      	ldrb	r3, [r3, #0]
   15c90:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    }
    return receiver;
   15c94:	f89d 402f 	ldrb.w	r4, [sp, #47]	; 0x2f
   15c98:	462b      	mov	r3, r5
   15c9a:	4619      	mov	r1, r3
   15c9c:	4803      	ldr	r0, [pc, #12]	; (15cac <Uart::Receive(unsigned long)+0xec>)
   15c9e:	f000 fe3d 	bl	1691c <__cyg_profile_func_exit>
   15ca2:	4623      	mov	r3, r4
  }
   15ca4:	4618      	mov	r0, r3
   15ca6:	b00c      	add	sp, #48	; 0x30
   15ca8:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   15cac:	00015bc1 	.word	0x00015bc1
   15cb0:	000163cd 	.word	0x000163cd
   15cb4:	100004e8 	.word	0x100004e8

00015cb8 <Uart::FindClosestFractional(float)>:

 private:
  UartCalibration_t FindClosestFractional(float decimal)
   15cb8:	b510      	push	{r4, lr}
   15cba:	b08a      	sub	sp, #40	; 0x28
   15cbc:	4674      	mov	r4, lr
   15cbe:	9003      	str	r0, [sp, #12]
   15cc0:	9102      	str	r1, [sp, #8]
   15cc2:	ed8d 0a01 	vstr	s0, [sp, #4]
   15cc6:	4623      	mov	r3, r4
   15cc8:	4619      	mov	r1, r3
   15cca:	4838      	ldr	r0, [pc, #224]	; (15dac <Uart::FindClosestFractional(float)+0xf4>)
   15ccc:	f000 fe12 	bl	168f4 <__cyg_profile_func_enter>
  {
    UartCalibration_t result;
   15cd0:	9b03      	ldr	r3, [sp, #12]
   15cd2:	2200      	movs	r2, #0
   15cd4:	601a      	str	r2, [r3, #0]
   15cd6:	9b03      	ldr	r3, [sp, #12]
   15cd8:	2200      	movs	r2, #0
   15cda:	605a      	str	r2, [r3, #4]
   15cdc:	9b03      	ldr	r3, [sp, #12]
   15cde:	2201      	movs	r2, #1
   15ce0:	609a      	str	r2, [r3, #8]
    bool finished = false;
   15ce2:	2300      	movs	r3, #0
   15ce4:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    for (int div = 0; div < 15 && !finished; div++)
   15ce8:	2300      	movs	r3, #0
   15cea:	9308      	str	r3, [sp, #32]
   15cec:	9b08      	ldr	r3, [sp, #32]
   15cee:	2b0e      	cmp	r3, #14
   15cf0:	dc52      	bgt.n	15d98 <Uart::FindClosestFractional(float)+0xe0>
   15cf2:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   15cf6:	2b00      	cmp	r3, #0
   15cf8:	d14e      	bne.n	15d98 <Uart::FindClosestFractional(float)+0xe0>
    {
      for (int mul = div + 1; mul < 15 && !finished; mul++)
   15cfa:	9b08      	ldr	r3, [sp, #32]
   15cfc:	3301      	adds	r3, #1
   15cfe:	9307      	str	r3, [sp, #28]
   15d00:	9b07      	ldr	r3, [sp, #28]
   15d02:	2b0e      	cmp	r3, #14
   15d04:	dc44      	bgt.n	15d90 <Uart::FindClosestFractional(float)+0xd8>
   15d06:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   15d0a:	2b00      	cmp	r3, #0
   15d0c:	d140      	bne.n	15d90 <Uart::FindClosestFractional(float)+0xd8>
      {
        float divf         = static_cast<float>(div);
   15d0e:	9b08      	ldr	r3, [sp, #32]
   15d10:	ee07 3a90 	vmov	s15, r3
   15d14:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   15d18:	edcd 7a06 	vstr	s15, [sp, #24]
        float mulf         = static_cast<float>(mul);
   15d1c:	9b07      	ldr	r3, [sp, #28]
   15d1e:	ee07 3a90 	vmov	s15, r3
   15d22:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   15d26:	edcd 7a05 	vstr	s15, [sp, #20]
        float test_decimal = 1.0f + divf / mulf;
   15d2a:	eddd 6a06 	vldr	s13, [sp, #24]
   15d2e:	ed9d 7a05 	vldr	s14, [sp, #20]
   15d32:	eec6 7a87 	vdiv.f32	s15, s13, s14
   15d36:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   15d3a:	ee77 7a87 	vadd.f32	s15, s15, s14
   15d3e:	edcd 7a04 	vstr	s15, [sp, #16]
        if (decimal <= test_decimal + kThreshold &&
   15d42:	eddd 7a04 	vldr	s15, [sp, #16]
   15d46:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 15db0 <Uart::FindClosestFractional(float)+0xf8>
   15d4a:	ee77 7a87 	vadd.f32	s15, s15, s14
   15d4e:	ed9d 7a01 	vldr	s14, [sp, #4]
   15d52:	eeb4 7ae7 	vcmpe.f32	s14, s15
   15d56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   15d5a:	d815      	bhi.n	15d88 <Uart::FindClosestFractional(float)+0xd0>
            decimal >= test_decimal - kThreshold)
   15d5c:	eddd 7a04 	vldr	s15, [sp, #16]
   15d60:	ed9f 7a13 	vldr	s14, [pc, #76]	; 15db0 <Uart::FindClosestFractional(float)+0xf8>
   15d64:	ee77 7ac7 	vsub.f32	s15, s15, s14
        if (decimal <= test_decimal + kThreshold &&
   15d68:	ed9d 7a01 	vldr	s14, [sp, #4]
   15d6c:	eeb4 7ae7 	vcmpe.f32	s14, s15
   15d70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   15d74:	db08      	blt.n	15d88 <Uart::FindClosestFractional(float)+0xd0>
        {
          result.divide_add = div;
   15d76:	9a08      	ldr	r2, [sp, #32]
   15d78:	9b03      	ldr	r3, [sp, #12]
   15d7a:	605a      	str	r2, [r3, #4]
          result.multiply   = mul;
   15d7c:	9a07      	ldr	r2, [sp, #28]
   15d7e:	9b03      	ldr	r3, [sp, #12]
   15d80:	609a      	str	r2, [r3, #8]
          finished          = true;
   15d82:	2301      	movs	r3, #1
   15d84:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
      for (int mul = div + 1; mul < 15 && !finished; mul++)
   15d88:	9b07      	ldr	r3, [sp, #28]
   15d8a:	3301      	adds	r3, #1
   15d8c:	9307      	str	r3, [sp, #28]
   15d8e:	e7b7      	b.n	15d00 <Uart::FindClosestFractional(float)+0x48>
    for (int div = 0; div < 15 && !finished; div++)
   15d90:	9b08      	ldr	r3, [sp, #32]
   15d92:	3301      	adds	r3, #1
   15d94:	9308      	str	r3, [sp, #32]
   15d96:	e7a9      	b.n	15cec <Uart::FindClosestFractional(float)+0x34>
        }
      }
    }
    return result;
   15d98:	bf00      	nop
   15d9a:	4623      	mov	r3, r4
   15d9c:	4619      	mov	r1, r3
   15d9e:	4803      	ldr	r0, [pc, #12]	; (15dac <Uart::FindClosestFractional(float)+0xf4>)
   15da0:	f000 fdbc 	bl	1691c <__cyg_profile_func_exit>
   15da4:	bf00      	nop
  }
   15da6:	9803      	ldr	r0, [sp, #12]
   15da8:	b00a      	add	sp, #40	; 0x28
   15daa:	bd10      	pop	{r4, pc}
   15dac:	00015cb9 	.word	0x00015cb9
   15db0:	3d4ccccd 	.word	0x3d4ccccd

00015db4 <Uart::DividerEstimate(float, float)>:

  float DividerEstimate(float baud_rate, float fraction_estimate = 1)
   15db4:	b510      	push	{r4, lr}
   15db6:	ed2d 8b02 	vpush	{d8}
   15dba:	b086      	sub	sp, #24
   15dbc:	4674      	mov	r4, lr
   15dbe:	9003      	str	r0, [sp, #12]
   15dc0:	ed8d 0a02 	vstr	s0, [sp, #8]
   15dc4:	edcd 0a01 	vstr	s1, [sp, #4]
   15dc8:	4623      	mov	r3, r4
   15dca:	4619      	mov	r1, r3
   15dcc:	4815      	ldr	r0, [pc, #84]	; (15e24 <Uart::DividerEstimate(float, float)+0x70>)
   15dce:	f000 fd91 	bl	168f4 <__cyg_profile_func_enter>
  {
    float clock_frequency = static_cast<float>(GetPeripheralFrequency());
   15dd2:	9b03      	ldr	r3, [sp, #12]
   15dd4:	1d1a      	adds	r2, r3, #4
   15dd6:	9b03      	ldr	r3, [sp, #12]
   15dd8:	685b      	ldr	r3, [r3, #4]
   15dda:	3310      	adds	r3, #16
   15ddc:	681b      	ldr	r3, [r3, #0]
   15dde:	4610      	mov	r0, r2
   15de0:	4798      	blx	r3
   15de2:	ee07 0a90 	vmov	s15, r0
   15de6:	eef8 7a67 	vcvt.f32.u32	s15, s15
   15dea:	edcd 7a05 	vstr	s15, [sp, #20]
    return clock_frequency / (16.0f * baud_rate * fraction_estimate);
   15dee:	eddd 7a02 	vldr	s15, [sp, #8]
   15df2:	eeb3 7a00 	vmov.f32	s14, #48	; 0x41800000  16.0
   15df6:	ee27 7a87 	vmul.f32	s14, s15, s14
   15dfa:	eddd 7a01 	vldr	s15, [sp, #4]
   15dfe:	ee67 7a27 	vmul.f32	s15, s14, s15
   15e02:	ed9d 7a05 	vldr	s14, [sp, #20]
   15e06:	ee87 8a27 	vdiv.f32	s16, s14, s15
   15e0a:	4623      	mov	r3, r4
   15e0c:	4619      	mov	r1, r3
   15e0e:	4805      	ldr	r0, [pc, #20]	; (15e24 <Uart::DividerEstimate(float, float)+0x70>)
   15e10:	f000 fd84 	bl	1691c <__cyg_profile_func_exit>
   15e14:	eef0 7a48 	vmov.f32	s15, s16
  }
   15e18:	eeb0 0a67 	vmov.f32	s0, s15
   15e1c:	b006      	add	sp, #24
   15e1e:	ecbd 8b02 	vpop	{d8}
   15e22:	bd10      	pop	{r4, pc}
   15e24:	00015db5 	.word	0x00015db5

00015e28 <Uart::FractionalEstimate(float, float)>:

  float FractionalEstimate(float baud_rate, float divider)
   15e28:	b510      	push	{r4, lr}
   15e2a:	ed2d 8b02 	vpush	{d8}
   15e2e:	b086      	sub	sp, #24
   15e30:	4674      	mov	r4, lr
   15e32:	9003      	str	r0, [sp, #12]
   15e34:	ed8d 0a02 	vstr	s0, [sp, #8]
   15e38:	edcd 0a01 	vstr	s1, [sp, #4]
   15e3c:	4623      	mov	r3, r4
   15e3e:	4619      	mov	r1, r3
   15e40:	4815      	ldr	r0, [pc, #84]	; (15e98 <Uart::FractionalEstimate(float, float)+0x70>)
   15e42:	f000 fd57 	bl	168f4 <__cyg_profile_func_enter>
  {
    float clock_frequency = static_cast<float>(GetPeripheralFrequency());
   15e46:	9b03      	ldr	r3, [sp, #12]
   15e48:	1d1a      	adds	r2, r3, #4
   15e4a:	9b03      	ldr	r3, [sp, #12]
   15e4c:	685b      	ldr	r3, [r3, #4]
   15e4e:	3310      	adds	r3, #16
   15e50:	681b      	ldr	r3, [r3, #0]
   15e52:	4610      	mov	r0, r2
   15e54:	4798      	blx	r3
   15e56:	ee07 0a90 	vmov	s15, r0
   15e5a:	eef8 7a67 	vcvt.f32.u32	s15, s15
   15e5e:	edcd 7a05 	vstr	s15, [sp, #20]
    return clock_frequency / (16.0f * baud_rate * divider);
   15e62:	eddd 7a02 	vldr	s15, [sp, #8]
   15e66:	eeb3 7a00 	vmov.f32	s14, #48	; 0x41800000  16.0
   15e6a:	ee27 7a87 	vmul.f32	s14, s15, s14
   15e6e:	eddd 7a01 	vldr	s15, [sp, #4]
   15e72:	ee67 7a27 	vmul.f32	s15, s14, s15
   15e76:	ed9d 7a05 	vldr	s14, [sp, #20]
   15e7a:	ee87 8a27 	vdiv.f32	s16, s14, s15
   15e7e:	4623      	mov	r3, r4
   15e80:	4619      	mov	r1, r3
   15e82:	4805      	ldr	r0, [pc, #20]	; (15e98 <Uart::FractionalEstimate(float, float)+0x70>)
   15e84:	f000 fd4a 	bl	1691c <__cyg_profile_func_exit>
   15e88:	eef0 7a48 	vmov.f32	s15, s16
  }
   15e8c:	eeb0 0a67 	vmov.f32	s0, s15
   15e90:	b006      	add	sp, #24
   15e92:	ecbd 8b02 	vpop	{d8}
   15e96:	bd10      	pop	{r4, pc}
   15e98:	00015e29 	.word	0x00015e29

00015e9c <Uart::IsDecmial(float)>:

  bool IsDecmial(float value)
   15e9c:	b530      	push	{r4, r5, lr}
   15e9e:	b087      	sub	sp, #28
   15ea0:	4675      	mov	r5, lr
   15ea2:	9001      	str	r0, [sp, #4]
   15ea4:	ed8d 0a00 	vstr	s0, [sp]
   15ea8:	462b      	mov	r3, r5
   15eaa:	4619      	mov	r1, r3
   15eac:	4819      	ldr	r0, [pc, #100]	; (15f14 <Uart::IsDecmial(float)+0x78>)
   15eae:	f000 fd21 	bl	168f4 <__cyg_profile_func_enter>
  {
    bool result         = false;
   15eb2:	2300      	movs	r3, #0
   15eb4:	f88d 3017 	strb.w	r3, [sp, #23]
    float rounded_value = roundf(value);
   15eb8:	ed9d 0a00 	vldr	s0, [sp]
   15ebc:	f006 fb00 	bl	1c4c0 <roundf>
   15ec0:	ed8d 0a04 	vstr	s0, [sp, #16]
    float error         = value - rounded_value;
   15ec4:	ed9d 7a00 	vldr	s14, [sp]
   15ec8:	eddd 7a04 	vldr	s15, [sp, #16]
   15ecc:	ee77 7a67 	vsub.f32	s15, s14, s15
   15ed0:	edcd 7a03 	vstr	s15, [sp, #12]
    if (-kThreshold <= error && error <= kThreshold)
   15ed4:	eddd 7a03 	vldr	s15, [sp, #12]
   15ed8:	ed9f 7a0f 	vldr	s14, [pc, #60]	; 15f18 <Uart::IsDecmial(float)+0x7c>
   15edc:	eef4 7ac7 	vcmpe.f32	s15, s14
   15ee0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   15ee4:	db0b      	blt.n	15efe <Uart::IsDecmial(float)+0x62>
   15ee6:	eddd 7a03 	vldr	s15, [sp, #12]
   15eea:	ed9f 7a0c 	vldr	s14, [pc, #48]	; 15f1c <Uart::IsDecmial(float)+0x80>
   15eee:	eef4 7ac7 	vcmpe.f32	s15, s14
   15ef2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   15ef6:	d802      	bhi.n	15efe <Uart::IsDecmial(float)+0x62>
    {
      result = true;
   15ef8:	2301      	movs	r3, #1
   15efa:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return result;
   15efe:	f89d 4017 	ldrb.w	r4, [sp, #23]
   15f02:	462b      	mov	r3, r5
   15f04:	4619      	mov	r1, r3
   15f06:	4803      	ldr	r0, [pc, #12]	; (15f14 <Uart::IsDecmial(float)+0x78>)
   15f08:	f000 fd08 	bl	1691c <__cyg_profile_func_exit>
   15f0c:	4623      	mov	r3, r4
  }
   15f0e:	4618      	mov	r0, r3
   15f10:	b007      	add	sp, #28
   15f12:	bd30      	pop	{r4, r5, pc}
   15f14:	00015e9d 	.word	0x00015e9d
   15f18:	bd4ccccd 	.word	0xbd4ccccd
   15f1c:	3d4ccccd 	.word	0x3d4ccccd

00015f20 <Uart::GenerateUartCalibration(float)>:

  UartCalibration_t GenerateUartCalibration(float baud_rate)
   15f20:	b530      	push	{r4, r5, lr}
   15f22:	b08f      	sub	sp, #60	; 0x3c
   15f24:	4675      	mov	r5, lr
   15f26:	9007      	str	r0, [sp, #28]
   15f28:	9106      	str	r1, [sp, #24]
   15f2a:	ed8d 0a05 	vstr	s0, [sp, #20]
   15f2e:	462b      	mov	r3, r5
   15f30:	4619      	mov	r1, r3
   15f32:	4874      	ldr	r0, [pc, #464]	; (16104 <Uart::GenerateUartCalibration(float)+0x1e4>)
   15f34:	f000 fcde 	bl	168f4 <__cyg_profile_func_enter>
  {
    States state = States::kCalculateIntegerDivideLatch;
   15f38:	2300      	movs	r3, #0
   15f3a:	930d      	str	r3, [sp, #52]	; 0x34
    UartCalibration_t uart_calibration;
   15f3c:	9b07      	ldr	r3, [sp, #28]
   15f3e:	2200      	movs	r2, #0
   15f40:	601a      	str	r2, [r3, #0]
   15f42:	9b07      	ldr	r3, [sp, #28]
   15f44:	2200      	movs	r2, #0
   15f46:	605a      	str	r2, [r3, #4]
   15f48:	9b07      	ldr	r3, [sp, #28]
   15f4a:	2201      	movs	r2, #1
   15f4c:	609a      	str	r2, [r3, #8]
    float divide_estimate = 0;
   15f4e:	f04f 0300 	mov.w	r3, #0
   15f52:	930c      	str	r3, [sp, #48]	; 0x30
    float decimal         = 1.5;
   15f54:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
   15f58:	930b      	str	r3, [sp, #44]	; 0x2c
    float div             = 1;
   15f5a:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   15f5e:	930a      	str	r3, [sp, #40]	; 0x28
    float mul             = 2;
   15f60:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   15f64:	9309      	str	r3, [sp, #36]	; 0x24
    while (state != States::kDone)
   15f66:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   15f68:	2b04      	cmp	r3, #4
   15f6a:	f000 80c1 	beq.w	160f0 <Uart::GenerateUartCalibration(float)+0x1d0>
    {
      switch (state)
   15f6e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   15f70:	2b04      	cmp	r3, #4
   15f72:	f200 80bb 	bhi.w	160ec <Uart::GenerateUartCalibration(float)+0x1cc>
   15f76:	a201      	add	r2, pc, #4	; (adr r2, 15f7c <Uart::GenerateUartCalibration(float)+0x5c>)
   15f78:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   15f7c:	00015f91 	.word	0x00015f91
   15f80:	00015fed 	.word	0x00015fed
   15f84:	0001604d 	.word	0x0001604d
   15f88:	000160bd 	.word	0x000160bd
   15f8c:	000160ed 	.word	0x000160ed
      {
        case States::kCalculateIntegerDivideLatch:
        {
          divide_estimate = DividerEstimate(baud_rate);
   15f90:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
   15f94:	ed9d 0a05 	vldr	s0, [sp, #20]
   15f98:	9806      	ldr	r0, [sp, #24]
   15f9a:	f7ff ff0b 	bl	15db4 <Uart::DividerEstimate(float, float)>
   15f9e:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
          if (divide_estimate < 1.0f)
   15fa2:	eddd 7a0c 	vldr	s15, [sp, #48]	; 0x30
   15fa6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   15faa:	eef4 7ac7 	vcmpe.f32	s15, s14
   15fae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   15fb2:	d505      	bpl.n	15fc0 <Uart::GenerateUartCalibration(float)+0xa0>
          {
            uart_calibration.divide_latch = 0;
   15fb4:	9b07      	ldr	r3, [sp, #28]
   15fb6:	2200      	movs	r2, #0
   15fb8:	601a      	str	r2, [r3, #0]
            state                         = States::kDone;
   15fba:	2304      	movs	r3, #4
   15fbc:	930d      	str	r3, [sp, #52]	; 0x34
          }
          else
          {
            state = States::kCalculateDivideLatchWithDecimal;
          }
          break;
   15fbe:	e096      	b.n	160ee <Uart::GenerateUartCalibration(float)+0x1ce>
          else if (IsDecmial(divide_estimate))
   15fc0:	ed9d 0a0c 	vldr	s0, [sp, #48]	; 0x30
   15fc4:	9806      	ldr	r0, [sp, #24]
   15fc6:	f7ff ff69 	bl	15e9c <Uart::IsDecmial(float)>
   15fca:	4603      	mov	r3, r0
   15fcc:	2b00      	cmp	r3, #0
   15fce:	d00a      	beq.n	15fe6 <Uart::GenerateUartCalibration(float)+0xc6>
                static_cast<uint32_t>(divide_estimate);
   15fd0:	eddd 7a0c 	vldr	s15, [sp, #48]	; 0x30
   15fd4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   15fd8:	ee17 2a90 	vmov	r2, s15
            uart_calibration.divide_latch =
   15fdc:	9b07      	ldr	r3, [sp, #28]
   15fde:	601a      	str	r2, [r3, #0]
            state = States::kDone;
   15fe0:	2304      	movs	r3, #4
   15fe2:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   15fe4:	e083      	b.n	160ee <Uart::GenerateUartCalibration(float)+0x1ce>
            state = States::kCalculateDivideLatchWithDecimal;
   15fe6:	2301      	movs	r3, #1
   15fe8:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   15fea:	e080      	b.n	160ee <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kCalculateDivideLatchWithDecimal:
        {
          divide_estimate = roundf(DividerEstimate(baud_rate, decimal));
   15fec:	eddd 0a0b 	vldr	s1, [sp, #44]	; 0x2c
   15ff0:	ed9d 0a05 	vldr	s0, [sp, #20]
   15ff4:	9806      	ldr	r0, [sp, #24]
   15ff6:	f7ff fedd 	bl	15db4 <Uart::DividerEstimate(float, float)>
   15ffa:	eef0 7a40 	vmov.f32	s15, s0
   15ffe:	eeb0 0a67 	vmov.f32	s0, s15
   16002:	f006 fa5d 	bl	1c4c0 <roundf>
   16006:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
          decimal         = FractionalEstimate(baud_rate, divide_estimate);
   1600a:	eddd 0a0c 	vldr	s1, [sp, #48]	; 0x30
   1600e:	ed9d 0a05 	vldr	s0, [sp, #20]
   16012:	9806      	ldr	r0, [sp, #24]
   16014:	f7ff ff08 	bl	15e28 <Uart::FractionalEstimate(float, float)>
   16018:	ed8d 0a0b 	vstr	s0, [sp, #44]	; 0x2c
          if (1.1f <= decimal && decimal <= 1.9f)
   1601c:	eddd 7a0b 	vldr	s15, [sp, #44]	; 0x2c
   16020:	ed9f 7a39 	vldr	s14, [pc, #228]	; 16108 <Uart::GenerateUartCalibration(float)+0x1e8>
   16024:	eef4 7ac7 	vcmpe.f32	s15, s14
   16028:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1602c:	db0b      	blt.n	16046 <Uart::GenerateUartCalibration(float)+0x126>
   1602e:	eddd 7a0b 	vldr	s15, [sp, #44]	; 0x2c
   16032:	ed9f 7a36 	vldr	s14, [pc, #216]	; 1610c <Uart::GenerateUartCalibration(float)+0x1ec>
   16036:	eef4 7ac7 	vcmpe.f32	s15, s14
   1603a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1603e:	d802      	bhi.n	16046 <Uart::GenerateUartCalibration(float)+0x126>
          {
            state = States::kGenerateFractionFromDecimal;
   16040:	2303      	movs	r3, #3
   16042:	930d      	str	r3, [sp, #52]	; 0x34
          }
          else
          {
            state = States::kDecimalFailedGenerateNewDecimal;
          }
          break;
   16044:	e053      	b.n	160ee <Uart::GenerateUartCalibration(float)+0x1ce>
            state = States::kDecimalFailedGenerateNewDecimal;
   16046:	2302      	movs	r3, #2
   16048:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   1604a:	e050      	b.n	160ee <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kDecimalFailedGenerateNewDecimal:
        {
          mul += 1;
   1604c:	eddd 7a09 	vldr	s15, [sp, #36]	; 0x24
   16050:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   16054:	ee77 7a87 	vadd.f32	s15, s15, s14
   16058:	edcd 7a09 	vstr	s15, [sp, #36]	; 0x24

          if (div > 15)
   1605c:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
   16060:	eeb2 7a0e 	vmov.f32	s14, #46	; 0x41700000  15.0
   16064:	eef4 7ac7 	vcmpe.f32	s15, s14
   16068:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1606c:	dd02      	ble.n	16074 <Uart::GenerateUartCalibration(float)+0x154>
          {
            state = States::kDone;
   1606e:	2304      	movs	r3, #4
   16070:	930d      	str	r3, [sp, #52]	; 0x34
            break;
   16072:	e03c      	b.n	160ee <Uart::GenerateUartCalibration(float)+0x1ce>
          }
          else if (mul > 15)
   16074:	eddd 7a09 	vldr	s15, [sp, #36]	; 0x24
   16078:	eeb2 7a0e 	vmov.f32	s14, #46	; 0x41700000  15.0
   1607c:	eef4 7ac7 	vcmpe.f32	s15, s14
   16080:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16084:	dd0f      	ble.n	160a6 <Uart::GenerateUartCalibration(float)+0x186>
          {
            div += 1;
   16086:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
   1608a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   1608e:	ee77 7a87 	vadd.f32	s15, s15, s14
   16092:	edcd 7a0a 	vstr	s15, [sp, #40]	; 0x28
            mul = div + 1;
   16096:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
   1609a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   1609e:	ee77 7a87 	vadd.f32	s15, s15, s14
   160a2:	edcd 7a09 	vstr	s15, [sp, #36]	; 0x24
          }
          decimal = div / mul;
   160a6:	eddd 6a0a 	vldr	s13, [sp, #40]	; 0x28
   160aa:	ed9d 7a09 	vldr	s14, [sp, #36]	; 0x24
   160ae:	eec6 7a87 	vdiv.f32	s15, s13, s14
   160b2:	edcd 7a0b 	vstr	s15, [sp, #44]	; 0x2c
          state   = States::kCalculateDivideLatchWithDecimal;
   160b6:	2301      	movs	r3, #1
   160b8:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   160ba:	e018      	b.n	160ee <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kGenerateFractionFromDecimal:
        {
          uart_calibration = FindClosestFractional(decimal);
   160bc:	9c07      	ldr	r4, [sp, #28]
   160be:	466b      	mov	r3, sp
   160c0:	ed9d 0a0b 	vldr	s0, [sp, #44]	; 0x2c
   160c4:	9906      	ldr	r1, [sp, #24]
   160c6:	4618      	mov	r0, r3
   160c8:	f7ff fdf6 	bl	15cb8 <Uart::FindClosestFractional(float)>
   160cc:	466b      	mov	r3, sp
   160ce:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   160d2:	e884 0007 	stmia.w	r4, {r0, r1, r2}
          uart_calibration.divide_latch =
              static_cast<uint32_t>(divide_estimate);
   160d6:	eddd 7a0c 	vldr	s15, [sp, #48]	; 0x30
   160da:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   160de:	ee17 2a90 	vmov	r2, s15
          uart_calibration.divide_latch =
   160e2:	9b07      	ldr	r3, [sp, #28]
   160e4:	601a      	str	r2, [r3, #0]
          state = States::kDone;
   160e6:	2304      	movs	r3, #4
   160e8:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   160ea:	e000      	b.n	160ee <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kDone: { break;
        }
        default: { break;
   160ec:	bf00      	nop
    while (state != States::kDone)
   160ee:	e73a      	b.n	15f66 <Uart::GenerateUartCalibration(float)+0x46>
        }
      }
    }
    return uart_calibration;
   160f0:	bf00      	nop
   160f2:	462b      	mov	r3, r5
   160f4:	4619      	mov	r1, r3
   160f6:	4803      	ldr	r0, [pc, #12]	; (16104 <Uart::GenerateUartCalibration(float)+0x1e4>)
   160f8:	f000 fc10 	bl	1691c <__cyg_profile_func_exit>
   160fc:	bf00      	nop
  }
   160fe:	9807      	ldr	r0, [sp, #28]
   16100:	b00f      	add	sp, #60	; 0x3c
   16102:	bd30      	pop	{r4, r5, pc}
   16104:	00015f21 	.word	0x00015f21
   16108:	3f8ccccd 	.word	0x3f8ccccd
   1610c:	3ff33333 	.word	0x3ff33333

00016110 <(anonymous namespace)::Lpc40xxUptime()>:
{
   16110:	b538      	push	{r3, r4, r5, lr}
   16112:	4675      	mov	r5, lr
   16114:	462b      	mov	r3, r5
   16116:	4619      	mov	r1, r3
   16118:	480a      	ldr	r0, [pc, #40]	; (16144 <(anonymous namespace)::Lpc40xxUptime()+0x34>)
   1611a:	f000 fbeb 	bl	168f4 <__cyg_profile_func_enter>
    return tim_register[channel_]->TC;
   1611e:	4b0a      	ldr	r3, [pc, #40]	; (16148 <(anonymous namespace)::Lpc40xxUptime()+0x38>)
   16120:	7a1b      	ldrb	r3, [r3, #8]
   16122:	461a      	mov	r2, r3
   16124:	4b09      	ldr	r3, [pc, #36]	; (1614c <(anonymous namespace)::Lpc40xxUptime()+0x3c>)
   16126:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1612a:	689c      	ldr	r4, [r3, #8]
   1612c:	462b      	mov	r3, r5
   1612e:	4619      	mov	r1, r3
   16130:	4804      	ldr	r0, [pc, #16]	; (16144 <(anonymous namespace)::Lpc40xxUptime()+0x34>)
   16132:	f000 fbf3 	bl	1691c <__cyg_profile_func_exit>
  return timer0.GetTimer();
   16136:	4623      	mov	r3, r4
   16138:	f04f 0400 	mov.w	r4, #0
}
   1613c:	4618      	mov	r0, r3
   1613e:	4621      	mov	r1, r4
   16140:	bd38      	pop	{r3, r4, r5, pc}
   16142:	bf00      	nop
   16144:	00012465 	.word	0x00012465
   16148:	10000558 	.word	0x10000558
   1614c:	10000004 	.word	0x10000004

00016150 <UptimeRTOS>:
{
   16150:	b538      	push	{r3, r4, r5, lr}
   16152:	4675      	mov	r5, lr
   16154:	462b      	mov	r3, r5
   16156:	4619      	mov	r1, r3
   16158:	480a      	ldr	r0, [pc, #40]	; (16184 <UptimeRTOS+0x34>)
   1615a:	f000 fbcb 	bl	168f4 <__cyg_profile_func_enter>
   1615e:	4b0a      	ldr	r3, [pc, #40]	; (16188 <UptimeRTOS+0x38>)
   16160:	7a1b      	ldrb	r3, [r3, #8]
   16162:	461a      	mov	r2, r3
   16164:	4b09      	ldr	r3, [pc, #36]	; (1618c <UptimeRTOS+0x3c>)
   16166:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1616a:	689c      	ldr	r4, [r3, #8]
   1616c:	462b      	mov	r3, r5
   1616e:	4619      	mov	r1, r3
   16170:	4804      	ldr	r0, [pc, #16]	; (16184 <UptimeRTOS+0x34>)
   16172:	f000 fbd3 	bl	1691c <__cyg_profile_func_exit>
  return timer0.GetTimer();
   16176:	4623      	mov	r3, r4
   16178:	f04f 0400 	mov.w	r4, #0
}
   1617c:	4618      	mov	r0, r3
   1617e:	4621      	mov	r1, r4
   16180:	bd38      	pop	{r3, r4, r5, pc}
   16182:	bf00      	nop
   16184:	00012465 	.word	0x00012465
   16188:	10000558 	.word	0x10000558
   1618c:	10000004 	.word	0x10000004

00016190 <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])>:
   *  @brief  Return the size of an array.
   *  @param  __array  Array.
   */
  template <typename _Tp, size_t _Nm>
    constexpr size_t
    size(const _Tp (&/*__array*/)[_Nm]) noexcept
   16190:	b530      	push	{r4, r5, lr}
   16192:	b083      	sub	sp, #12
   16194:	4675      	mov	r5, lr
   16196:	9001      	str	r0, [sp, #4]
   16198:	462b      	mov	r3, r5
   1619a:	4619      	mov	r1, r3
   1619c:	4806      	ldr	r0, [pc, #24]	; (161b8 <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])+0x28>)
   1619e:	f000 fba9 	bl	168f4 <__cyg_profile_func_enter>
    { return _Nm; }
   161a2:	2450      	movs	r4, #80	; 0x50
   161a4:	462b      	mov	r3, r5
   161a6:	4619      	mov	r1, r3
   161a8:	4803      	ldr	r0, [pc, #12]	; (161b8 <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])+0x28>)
   161aa:	f000 fbb7 	bl	1691c <__cyg_profile_func_exit>
   161ae:	4623      	mov	r3, r4
   161b0:	4618      	mov	r0, r3
   161b2:	b003      	add	sp, #12
   161b4:	bd30      	pop	{r4, r5, pc}
   161b6:	bf00      	nop
   161b8:	00016191 	.word	0x00016191

000161bc <vApplicationGetIdleTaskMemory>:
  {
   161bc:	b500      	push	{lr}
   161be:	b085      	sub	sp, #20
   161c0:	9003      	str	r0, [sp, #12]
   161c2:	9102      	str	r1, [sp, #8]
   161c4:	9201      	str	r2, [sp, #4]
    *ppx_idle_task_tcb_buffer   = &idle_task_tcb;
   161c6:	9b03      	ldr	r3, [sp, #12]
   161c8:	4a07      	ldr	r2, [pc, #28]	; (161e8 <vApplicationGetIdleTaskMemory+0x2c>)
   161ca:	601a      	str	r2, [r3, #0]
    *ppx_idle_task_stack_buffer = idle_task_stack;
   161cc:	9b02      	ldr	r3, [sp, #8]
   161ce:	4a07      	ldr	r2, [pc, #28]	; (161ec <vApplicationGetIdleTaskMemory+0x30>)
   161d0:	601a      	str	r2, [r3, #0]
    *pul_idle_task_stack_size   = std::size(idle_task_stack);
   161d2:	4806      	ldr	r0, [pc, #24]	; (161ec <vApplicationGetIdleTaskMemory+0x30>)
   161d4:	f7ff ffdc 	bl	16190 <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])>
   161d8:	4602      	mov	r2, r0
   161da:	9b01      	ldr	r3, [sp, #4]
   161dc:	601a      	str	r2, [r3, #0]
  }
   161de:	bf00      	nop
   161e0:	b005      	add	sp, #20
   161e2:	f85d fb04 	ldr.w	pc, [sp], #4
   161e6:	bf00      	nop
   161e8:	10002fd4 	.word	0x10002fd4
   161ec:	10003034 	.word	0x10003034

000161f0 <vPortSetupTimerInterrupt>:
  {
   161f0:	b508      	push	{r3, lr}
    system_timer.DisableTimer();
   161f2:	f7ff fa53 	bl	1569c <SystemTimer::DisableTimer()>
    system_timer.SetTickFrequency(config::kRtosFrequency);
   161f6:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   161fa:	4806      	ldr	r0, [pc, #24]	; (16214 <vPortSetupTimerInterrupt+0x24>)
   161fc:	f7ff faee 	bl	157dc <SystemTimer::SetTickFrequency(unsigned long)>
    system_timer.SetIsrFunction(xPortSysTickHandler);
   16200:	4905      	ldr	r1, [pc, #20]	; (16218 <vPortSetupTimerInterrupt+0x28>)
   16202:	4804      	ldr	r0, [pc, #16]	; (16214 <vPortSetupTimerInterrupt+0x24>)
   16204:	f7ff fa82 	bl	1570c <SystemTimer::SetIsrFunction(void (*)())>
    system_timer.StartTimer();
   16208:	4802      	ldr	r0, [pc, #8]	; (16214 <vPortSetupTimerInterrupt+0x24>)
   1620a:	f7ff fa99 	bl	15740 <SystemTimer::StartTimer()>
  }
   1620e:	bf00      	nop
   16210:	bd08      	pop	{r3, pc}
   16212:	bf00      	nop
   16214:	1000054c 	.word	0x1000054c
   16218:	00017449 	.word	0x00017449

0001621c <LowLevelInit()>:

void LowLevelInit()
{
   1621c:	b500      	push	{lr}
   1621e:	b083      	sub	sp, #12
  // Set the SystemTick frequency to the RTOS tick frequency
  // It is critical that this happens before you set the system_clock, since
  // The system_timer keeps the time that the system_clock uses to delay itself.
  system_timer.SetTickFrequency(config::kRtosFrequency);
   16220:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   16224:	4822      	ldr	r0, [pc, #136]	; (162b0 <LowLevelInit()+0x94>)
   16226:	f7ff fad9 	bl	157dc <SystemTimer::SetTickFrequency(unsigned long)>
  bool timer_started_successfully = system_timer.StartTimer();
   1622a:	4821      	ldr	r0, [pc, #132]	; (162b0 <LowLevelInit()+0x94>)
   1622c:	f7ff fa88 	bl	15740 <SystemTimer::StartTimer()>
   16230:	4603      	mov	r3, r0
   16232:	f88d 3007 	strb.w	r3, [sp, #7]
  SJ2_ASSERT_WARNING(timer_started_successfully,
   16236:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1623a:	f083 0301 	eor.w	r3, r3, #1
   1623e:	b2db      	uxtb	r3, r3
   16240:	2b00      	cmp	r3, #0
   16242:	d005      	beq.n	16250 <LowLevelInit()+0x34>
   16244:	23ad      	movs	r3, #173	; 0xad
   16246:	4a1b      	ldr	r2, [pc, #108]	; (162b4 <LowLevelInit()+0x98>)
   16248:	491b      	ldr	r1, [pc, #108]	; (162b8 <LowLevelInit()+0x9c>)
   1624a:	481c      	ldr	r0, [pc, #112]	; (162bc <LowLevelInit()+0xa0>)
   1624c:	f002 fac8 	bl	187e0 <printf>
                     "System Timer has FAILED to start!");
  // Set Clock Speed
  // SetClockFrequency will timeout return the offset between desire clockspeed
  // and actual clockspeed if the PLL doesn't get a frequency fix within a
  // defined timeout (see L1/system_clock.hpp:kDefaultTimeout)
  while (system_controller.SetClockFrequency(config::kSystemClockRateMhz) != 0)
   16250:	2130      	movs	r1, #48	; 0x30
   16252:	481b      	ldr	r0, [pc, #108]	; (162c0 <LowLevelInit()+0xa4>)
   16254:	f7fb f9c2 	bl	115dc <Lpc40xxSystemController::SetClockFrequency(unsigned char)>
   16258:	4603      	mov	r3, r0
   1625a:	2b00      	cmp	r3, #0
   1625c:	bf14      	ite	ne
   1625e:	2301      	movne	r3, #1
   16260:	2300      	moveq	r3, #0
   16262:	b2db      	uxtb	r3, r3
   16264:	2b00      	cmp	r3, #0
   16266:	d001      	beq.n	1626c <LowLevelInit()+0x50>
  {
    // Continually attempt to set the clock frequency to the desired until the
    // delta between desired and actual are 0.
    continue;
   16268:	bf00      	nop
  while (system_controller.SetClockFrequency(config::kSystemClockRateMhz) != 0)
   1626a:	e7f1      	b.n	16250 <LowLevelInit()+0x34>
  }
  // Enable Peripheral Clock and set its divider to 1 meaning the clock speed
  // fed to all peripherals will be 48Mhz.
  system_controller.SetPeripheralClockDivider(1);
   1626c:	2101      	movs	r1, #1
   1626e:	4814      	ldr	r0, [pc, #80]	; (162c0 <LowLevelInit()+0xa4>)
   16270:	f7fb f9fc 	bl	1166c <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)>
  // Set System Timer frequency again, since the clock speed has changed since
  // the last time we ran this.
  system_timer.DisableTimer();
   16274:	f7ff fa12 	bl	1569c <SystemTimer::DisableTimer()>
  system_timer.SetTickFrequency(config::kRtosFrequency);
   16278:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   1627c:	480c      	ldr	r0, [pc, #48]	; (162b0 <LowLevelInit()+0x94>)
   1627e:	f7ff faad 	bl	157dc <SystemTimer::SetTickFrequency(unsigned long)>
  system_timer.StartTimer();
   16282:	480b      	ldr	r0, [pc, #44]	; (162b0 <LowLevelInit()+0x94>)
   16284:	f7ff fa5c 	bl	15740 <SystemTimer::StartTimer()>
  // Set timer0 to 1 MHz (1,000,000 Hz) so that the timer increments every 1
  // micro second.
  timer0.Initialize(1'000'000);
   16288:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1628c:	4a0d      	ldr	r2, [pc, #52]	; (162c4 <LowLevelInit()+0xa8>)
   1628e:	490e      	ldr	r1, [pc, #56]	; (162c8 <LowLevelInit()+0xac>)
   16290:	480e      	ldr	r0, [pc, #56]	; (162cc <LowLevelInit()+0xb0>)
   16292:	f7fb ffb9 	bl	12208 <Timer::Initialize(unsigned long, void (*)(), long)>
  SetUptimeFunction(Lpc40xxUptime);
   16296:	480e      	ldr	r0, [pc, #56]	; (162d0 <LowLevelInit()+0xb4>)
   16298:	f7ff f9e8 	bl	1566c <SetUptimeFunction(unsigned long long (*)())>
  // Set UART0 baudrate, which is required for printf and scanf to work properly
  uart0.Initialize(config::kBaudRate);
   1629c:	f44f 4116 	mov.w	r1, #38400	; 0x9600
   162a0:	480c      	ldr	r0, [pc, #48]	; (162d4 <LowLevelInit()+0xb8>)
   162a2:	f7ff fb5b 	bl	1595c <Uart::Initialize(unsigned long)>
}
   162a6:	bf00      	nop
   162a8:	b003      	add	sp, #12
   162aa:	f85d fb04 	ldr.w	pc, [sp], #4
   162ae:	bf00      	nop
   162b0:	1000054c 	.word	0x1000054c
   162b4:	0001e100 	.word	0x0001e100
   162b8:	0001e080 	.word	0x0001e080
   162bc:	0001e008 	.word	0x0001e008
   162c0:	10000554 	.word	0x10000554
   162c4:	00015871 	.word	0x00015871
   162c8:	000f4240 	.word	0x000f4240
   162cc:	10000558 	.word	0x10000558
   162d0:	00016111 	.word	0x00016111
   162d4:	10000538 	.word	0x10000538

000162d8 <SystemInit>:

void SystemInit()
{
   162d8:	b508      	push	{r3, lr}
  // Transfer data section values from flash to RAM
  InitDataSection();
   162da:	f7f9 ff17 	bl	1010c <InitDataSection()>
  // Clear BSS section of RAM
  // This is required because the nano implementation of the standard C/C++
  // libraries assumes that the BSS section is initialized to 0.
  InitBssSection();
   162de:	f7f9 ff5d 	bl	1019c <InitBssSection()>
  // Enable FPU (F.loating P.oint U.nit)
  // System will crash if floating point operations occur without
  // Initializing the FPU.
  InitFpu();
   162e2:	f7f9 ff8b 	bl	101fc <InitFpu()>
  // Initialisation C++ libraries
  __libc_init_array();
   162e6:	f006 faf3 	bl	1c8d0 <__libc_init_array>
  // Run LowLevel System Initialization
  LowLevelInit();
   162ea:	f7ff ff97 	bl	1621c <LowLevelInit()>
}
   162ee:	bf00      	nop
   162f0:	bd08      	pop	{r3, pc}
   162f2:	Address 0x00000000000162f2 is out of bounds.


000162f4 <ResetIsr>:
// Sets up a simple runtime environment and initializes the C/C++ library.

extern "C"
{
  void ResetIsr(void)
  {
   162f4:	b580      	push	{r7, lr}
   162f6:	b084      	sub	sp, #16
   162f8:	af00      	add	r7, sp, #0
    // The Hyperload bootloader takes up stack space to execute. The Hyperload
    // bootloader function launches this ISR manually, but it never returns thus
    // it never cleans up the memory it uses. To get that memory back, we have
    // to manually move the stack pointers back to the top of stack.
    const uint32_t kTopOfStack = reinterpret_cast<intptr_t>(&StackTop);
   162fa:	4b09      	ldr	r3, [pc, #36]	; (16320 <ResetIsr+0x2c>)
   162fc:	60fb      	str	r3, [r7, #12]
   162fe:	68fb      	ldr	r3, [r7, #12]
   16300:	603b      	str	r3, [r7, #0]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
   16302:	683b      	ldr	r3, [r7, #0]
   16304:	f383 8809 	msr	PSP, r3
   16308:	68fb      	ldr	r3, [r7, #12]
   1630a:	607b      	str	r3, [r7, #4]

    \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
   1630c:	687b      	ldr	r3, [r7, #4]
   1630e:	f383 8808 	msr	MSP, r3
    __set_PSP(kTopOfStack);
    __set_MSP(kTopOfStack);

    SystemInit();
   16312:	f7ff ffe1 	bl	162d8 <SystemInit>
// #pragma ignored "-Wpedantic" to suppress main function call warning
#pragma GCC diagnostic push ignored "-Wpedantic"
    [[maybe_unused]] int32_t result = main();
   16316:	f7fe fbc5 	bl	14aa4 <main>
   1631a:	60b8      	str	r0, [r7, #8]
   1631c:	e7fe      	b.n	1631c <ResetIsr+0x28>
   1631e:	bf00      	nop
   16320:	10010000 	.word	0x10010000

00016324 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})>:
inline Status Wait(uint64_t timeout, F is_done)
   16324:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   16328:	b088      	sub	sp, #32
   1632a:	4675      	mov	r5, lr
   1632c:	e9cd 0102 	strd	r0, r1, [sp, #8]
   16330:	9201      	str	r2, [sp, #4]
   16332:	462b      	mov	r3, r5
   16334:	4619      	mov	r1, r3
   16336:	4824      	ldr	r0, [pc, #144]	; (163c8 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0xa4>)
   16338:	f000 fadc 	bl	168f4 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   1633c:	f04f 0300 	mov.w	r3, #0
   16340:	f04f 0400 	mov.w	r4, #0
   16344:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   16348:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   1634c:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   16350:	bf08      	it	eq
   16352:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   16356:	d106      	bne.n	16366 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x42>
    timeout_time = kMaxWait;
   16358:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1635c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   16360:	e9cd 3406 	strd	r3, r4, [sp, #24]
   16364:	e00b      	b.n	1637e <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x5a>
    timeout_time = Milliseconds() + timeout;
   16366:	f7fa f87b 	bl	10460 <Milliseconds()>
   1636a:	460a      	mov	r2, r1
   1636c:	4601      	mov	r1, r0
   1636e:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   16372:	eb13 0b01 	adds.w	fp, r3, r1
   16376:	eb44 0c02 	adc.w	ip, r4, r2
   1637a:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   1637e:	2301      	movs	r3, #1
   16380:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   16382:	f7fa f86d 	bl	10460 <Milliseconds()>
   16386:	460a      	mov	r2, r1
   16388:	4601      	mov	r1, r0
   1638a:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   1638e:	42a2      	cmp	r2, r4
   16390:	bf08      	it	eq
   16392:	4299      	cmpeq	r1, r3
   16394:	bf34      	ite	cc
   16396:	2301      	movcc	r3, #1
   16398:	2300      	movcs	r3, #0
   1639a:	b2db      	uxtb	r3, r3
   1639c:	2b00      	cmp	r3, #0
   1639e:	d008      	beq.n	163b2 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x8e>
    if (is_done())
   163a0:	ab01      	add	r3, sp, #4
   163a2:	4618      	mov	r0, r3
   163a4:	f7ff fb4c 	bl	15a40 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const>
   163a8:	4603      	mov	r3, r0
   163aa:	2b00      	cmp	r3, #0
   163ac:	d0e9      	beq.n	16382 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x5e>
      status = Status::kSuccess;
   163ae:	2300      	movs	r3, #0
   163b0:	9305      	str	r3, [sp, #20]
  return status;
   163b2:	9c05      	ldr	r4, [sp, #20]
   163b4:	462b      	mov	r3, r5
   163b6:	4619      	mov	r1, r3
   163b8:	4803      	ldr	r0, [pc, #12]	; (163c8 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0xa4>)
   163ba:	f000 faaf 	bl	1691c <__cyg_profile_func_exit>
   163be:	4623      	mov	r3, r4
}
   163c0:	4618      	mov	r0, r3
   163c2:	b008      	add	sp, #32
   163c4:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   163c8:	00016325 	.word	0x00016325

000163cc <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})>:
inline Status Wait(uint64_t timeout, F is_done)
   163cc:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   163d0:	b088      	sub	sp, #32
   163d2:	4675      	mov	r5, lr
   163d4:	e9cd 0102 	strd	r0, r1, [sp, #8]
   163d8:	9201      	str	r2, [sp, #4]
   163da:	462b      	mov	r3, r5
   163dc:	4619      	mov	r1, r3
   163de:	4824      	ldr	r0, [pc, #144]	; (16470 <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0xa4>)
   163e0:	f000 fa88 	bl	168f4 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   163e4:	f04f 0300 	mov.w	r3, #0
   163e8:	f04f 0400 	mov.w	r4, #0
   163ec:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   163f0:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   163f4:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   163f8:	bf08      	it	eq
   163fa:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   163fe:	d106      	bne.n	1640e <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x42>
    timeout_time = kMaxWait;
   16400:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   16404:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   16408:	e9cd 3406 	strd	r3, r4, [sp, #24]
   1640c:	e00b      	b.n	16426 <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x5a>
    timeout_time = Milliseconds() + timeout;
   1640e:	f7fa f827 	bl	10460 <Milliseconds()>
   16412:	460a      	mov	r2, r1
   16414:	4601      	mov	r1, r0
   16416:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   1641a:	eb13 0b01 	adds.w	fp, r3, r1
   1641e:	eb44 0c02 	adc.w	ip, r4, r2
   16422:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   16426:	2301      	movs	r3, #1
   16428:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   1642a:	f7fa f819 	bl	10460 <Milliseconds()>
   1642e:	460a      	mov	r2, r1
   16430:	4601      	mov	r1, r0
   16432:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   16436:	42a2      	cmp	r2, r4
   16438:	bf08      	it	eq
   1643a:	4299      	cmpeq	r1, r3
   1643c:	bf34      	ite	cc
   1643e:	2301      	movcc	r3, #1
   16440:	2300      	movcs	r3, #0
   16442:	b2db      	uxtb	r3, r3
   16444:	2b00      	cmp	r3, #0
   16446:	d008      	beq.n	1645a <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x8e>
    if (is_done())
   16448:	ab01      	add	r3, sp, #4
   1644a:	4618      	mov	r0, r3
   1644c:	f7ff fb92 	bl	15b74 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const>
   16450:	4603      	mov	r3, r0
   16452:	2b00      	cmp	r3, #0
   16454:	d0e9      	beq.n	1642a <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x5e>
      status = Status::kSuccess;
   16456:	2300      	movs	r3, #0
   16458:	9305      	str	r3, [sp, #20]
  return status;
   1645a:	9c05      	ldr	r4, [sp, #20]
   1645c:	462b      	mov	r3, r5
   1645e:	4619      	mov	r1, r3
   16460:	4803      	ldr	r0, [pc, #12]	; (16470 <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0xa4>)
   16462:	f000 fa5b 	bl	1691c <__cyg_profile_func_exit>
   16466:	4623      	mov	r3, r4
}
   16468:	4618      	mov	r0, r3
   1646a:	b008      	add	sp, #32
   1646c:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   16470:	000163cd 	.word	0x000163cd

00016474 <__static_initialization_and_destruction_0(int, int)>:
#pragma GCC diagnostic pop
    // main() shouldn't return, but if it does, we'll just enter an infinite
    // loop
    Halt();
  }
}
   16474:	b082      	sub	sp, #8
   16476:	9001      	str	r0, [sp, #4]
   16478:	9100      	str	r1, [sp, #0]
   1647a:	9b01      	ldr	r3, [sp, #4]
   1647c:	2b01      	cmp	r3, #1
   1647e:	d15d      	bne.n	1653c <__static_initialization_and_destruction_0(int, int)+0xc8>
   16480:	9b00      	ldr	r3, [sp, #0]
   16482:	f64f 72ff 	movw	r2, #65535	; 0xffff
   16486:	4293      	cmp	r3, r2
   16488:	d158      	bne.n	1653c <__static_initialization_and_destruction_0(int, int)+0xc8>
  inline static volatile uint32_t * match[4][4] = {
   1648a:	4b2e      	ldr	r3, [pc, #184]	; (16544 <__static_initialization_and_destruction_0(int, int)+0xd0>)
   1648c:	681b      	ldr	r3, [r3, #0]
   1648e:	f003 0301 	and.w	r3, r3, #1
   16492:	2b00      	cmp	r3, #0
   16494:	d152      	bne.n	1653c <__static_initialization_and_destruction_0(int, int)+0xc8>
   16496:	4b2b      	ldr	r3, [pc, #172]	; (16544 <__static_initialization_and_destruction_0(int, int)+0xd0>)
   16498:	2201      	movs	r2, #1
   1649a:	601a      	str	r2, [r3, #0]
    [kTimer0] = { &tim_register[0]->MR0, &tim_register[0]->MR1,
   1649c:	4b2a      	ldr	r3, [pc, #168]	; (16548 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   1649e:	681b      	ldr	r3, [r3, #0]
   164a0:	3318      	adds	r3, #24
  };
   164a2:	4a2a      	ldr	r2, [pc, #168]	; (1654c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   164a4:	6013      	str	r3, [r2, #0]
    [kTimer0] = { &tim_register[0]->MR0, &tim_register[0]->MR1,
   164a6:	4b28      	ldr	r3, [pc, #160]	; (16548 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   164a8:	681b      	ldr	r3, [r3, #0]
   164aa:	331c      	adds	r3, #28
  };
   164ac:	4a27      	ldr	r2, [pc, #156]	; (1654c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   164ae:	6053      	str	r3, [r2, #4]
                  &tim_register[0]->MR2, &tim_register[0]->MR3 },
   164b0:	4b25      	ldr	r3, [pc, #148]	; (16548 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   164b2:	681b      	ldr	r3, [r3, #0]
   164b4:	3320      	adds	r3, #32
  };
   164b6:	4a25      	ldr	r2, [pc, #148]	; (1654c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   164b8:	6093      	str	r3, [r2, #8]
                  &tim_register[0]->MR2, &tim_register[0]->MR3 },
   164ba:	4b23      	ldr	r3, [pc, #140]	; (16548 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   164bc:	681b      	ldr	r3, [r3, #0]
   164be:	3324      	adds	r3, #36	; 0x24
  };
   164c0:	4a22      	ldr	r2, [pc, #136]	; (1654c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   164c2:	60d3      	str	r3, [r2, #12]
    [kTimer1] = { &tim_register[1]->MR0, &tim_register[1]->MR1,
   164c4:	4b20      	ldr	r3, [pc, #128]	; (16548 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   164c6:	685b      	ldr	r3, [r3, #4]
   164c8:	3318      	adds	r3, #24
  };
   164ca:	4a20      	ldr	r2, [pc, #128]	; (1654c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   164cc:	6113      	str	r3, [r2, #16]
    [kTimer1] = { &tim_register[1]->MR0, &tim_register[1]->MR1,
   164ce:	4b1e      	ldr	r3, [pc, #120]	; (16548 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   164d0:	685b      	ldr	r3, [r3, #4]
   164d2:	331c      	adds	r3, #28
  };
   164d4:	4a1d      	ldr	r2, [pc, #116]	; (1654c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   164d6:	6153      	str	r3, [r2, #20]
                  &tim_register[1]->MR2, &tim_register[1]->MR3 },
   164d8:	4b1b      	ldr	r3, [pc, #108]	; (16548 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   164da:	685b      	ldr	r3, [r3, #4]
   164dc:	3320      	adds	r3, #32
  };
   164de:	4a1b      	ldr	r2, [pc, #108]	; (1654c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   164e0:	6193      	str	r3, [r2, #24]
                  &tim_register[1]->MR2, &tim_register[1]->MR3 },
   164e2:	4b19      	ldr	r3, [pc, #100]	; (16548 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   164e4:	685b      	ldr	r3, [r3, #4]
   164e6:	3324      	adds	r3, #36	; 0x24
  };
   164e8:	4a18      	ldr	r2, [pc, #96]	; (1654c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   164ea:	61d3      	str	r3, [r2, #28]
    [kTimer2] = { &tim_register[2]->MR0, &tim_register[2]->MR1,
   164ec:	4b16      	ldr	r3, [pc, #88]	; (16548 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   164ee:	689b      	ldr	r3, [r3, #8]
   164f0:	3318      	adds	r3, #24
  };
   164f2:	4a16      	ldr	r2, [pc, #88]	; (1654c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   164f4:	6213      	str	r3, [r2, #32]
    [kTimer2] = { &tim_register[2]->MR0, &tim_register[2]->MR1,
   164f6:	4b14      	ldr	r3, [pc, #80]	; (16548 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   164f8:	689b      	ldr	r3, [r3, #8]
   164fa:	331c      	adds	r3, #28
  };
   164fc:	4a13      	ldr	r2, [pc, #76]	; (1654c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   164fe:	6253      	str	r3, [r2, #36]	; 0x24
                  &tim_register[2]->MR2, &tim_register[2]->MR3 },
   16500:	4b11      	ldr	r3, [pc, #68]	; (16548 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   16502:	689b      	ldr	r3, [r3, #8]
   16504:	3320      	adds	r3, #32
  };
   16506:	4a11      	ldr	r2, [pc, #68]	; (1654c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   16508:	6293      	str	r3, [r2, #40]	; 0x28
                  &tim_register[2]->MR2, &tim_register[2]->MR3 },
   1650a:	4b0f      	ldr	r3, [pc, #60]	; (16548 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   1650c:	689b      	ldr	r3, [r3, #8]
   1650e:	3324      	adds	r3, #36	; 0x24
  };
   16510:	4a0e      	ldr	r2, [pc, #56]	; (1654c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   16512:	62d3      	str	r3, [r2, #44]	; 0x2c
    [kTimer3] = { &tim_register[3]->MR0, &tim_register[3]->MR1,
   16514:	4b0c      	ldr	r3, [pc, #48]	; (16548 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   16516:	68db      	ldr	r3, [r3, #12]
   16518:	3318      	adds	r3, #24
  };
   1651a:	4a0c      	ldr	r2, [pc, #48]	; (1654c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   1651c:	6313      	str	r3, [r2, #48]	; 0x30
    [kTimer3] = { &tim_register[3]->MR0, &tim_register[3]->MR1,
   1651e:	4b0a      	ldr	r3, [pc, #40]	; (16548 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   16520:	68db      	ldr	r3, [r3, #12]
   16522:	331c      	adds	r3, #28
  };
   16524:	4a09      	ldr	r2, [pc, #36]	; (1654c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   16526:	6353      	str	r3, [r2, #52]	; 0x34
                  &tim_register[3]->MR2, &tim_register[3]->MR3 }
   16528:	4b07      	ldr	r3, [pc, #28]	; (16548 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   1652a:	68db      	ldr	r3, [r3, #12]
   1652c:	3320      	adds	r3, #32
  };
   1652e:	4a07      	ldr	r2, [pc, #28]	; (1654c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   16530:	6393      	str	r3, [r2, #56]	; 0x38
                  &tim_register[3]->MR2, &tim_register[3]->MR3 }
   16532:	4b05      	ldr	r3, [pc, #20]	; (16548 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   16534:	68db      	ldr	r3, [r3, #12]
   16536:	3324      	adds	r3, #36	; 0x24
  };
   16538:	4a04      	ldr	r2, [pc, #16]	; (1654c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   1653a:	63d3      	str	r3, [r2, #60]	; 0x3c
   1653c:	bf00      	nop
   1653e:	b002      	add	sp, #8
   16540:	4770      	bx	lr
   16542:	bf00      	nop
   16544:	100007a8 	.word	0x100007a8
   16548:	10000004 	.word	0x10000004
   1654c:	100006e8 	.word	0x100006e8

00016550 <_GLOBAL__sub_I_UptimeRTOS>:
   16550:	b508      	push	{r3, lr}
   16552:	f64f 71ff 	movw	r1, #65535	; 0xffff
   16556:	2001      	movs	r0, #1
   16558:	f7ff ff8c 	bl	16474 <__static_initialization_and_destruction_0(int, int)>
   1655c:	bd08      	pop	{r3, pc}
   1655e:	Address 0x000000000001655e is out of bounds.


00016560 <NVIC_EnableIRQ>:
  \brief   Enable External Interrupt
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
   16560:	b082      	sub	sp, #8
   16562:	4603      	mov	r3, r0
   16564:	f88d 3007 	strb.w	r3, [sp, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   16568:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   1656c:	f003 021f 	and.w	r2, r3, #31
   16570:	4905      	ldr	r1, [pc, #20]	; (16588 <NVIC_EnableIRQ+0x28>)
   16572:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   16576:	095b      	lsrs	r3, r3, #5
   16578:	2001      	movs	r0, #1
   1657a:	fa00 f202 	lsl.w	r2, r0, r2
   1657e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   16582:	bf00      	nop
   16584:	b002      	add	sp, #8
   16586:	4770      	bx	lr
   16588:	e000e100 	.word	0xe000e100

0001658c <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
   1658c:	b082      	sub	sp, #8
   1658e:	4603      	mov	r3, r0
   16590:	9100      	str	r1, [sp, #0]
   16592:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) < 0)
   16596:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   1659a:	2b00      	cmp	r3, #0
   1659c:	da0c      	bge.n	165b8 <NVIC_SetPriority+0x2c>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1659e:	9b00      	ldr	r3, [sp, #0]
   165a0:	b2da      	uxtb	r2, r3
   165a2:	490d      	ldr	r1, [pc, #52]	; (165d8 <NVIC_SetPriority+0x4c>)
   165a4:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   165a8:	f003 030f 	and.w	r3, r3, #15
   165ac:	3b04      	subs	r3, #4
   165ae:	0152      	lsls	r2, r2, #5
   165b0:	b2d2      	uxtb	r2, r2
   165b2:	440b      	add	r3, r1
   165b4:	761a      	strb	r2, [r3, #24]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
   165b6:	e00b      	b.n	165d0 <NVIC_SetPriority+0x44>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   165b8:	9b00      	ldr	r3, [sp, #0]
   165ba:	b2db      	uxtb	r3, r3
   165bc:	4a07      	ldr	r2, [pc, #28]	; (165dc <NVIC_SetPriority+0x50>)
   165be:	f99d 1007 	ldrsb.w	r1, [sp, #7]
   165c2:	4608      	mov	r0, r1
   165c4:	015b      	lsls	r3, r3, #5
   165c6:	b2d9      	uxtb	r1, r3
   165c8:	1813      	adds	r3, r2, r0
   165ca:	460a      	mov	r2, r1
   165cc:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
   165d0:	bf00      	nop
   165d2:	b002      	add	sp, #8
   165d4:	4770      	bx	lr
   165d6:	bf00      	nop
   165d8:	e000ed00 	.word	0xe000ed00
   165dc:	e000e100 	.word	0xe000e100

000165e0 <InterruptLookupHandler>:
{
   165e0:	b500      	push	{lr}
   165e2:	b085      	sub	sp, #20
  uint8_t active_isr = (SCB->ICSR & 0xFF);
   165e4:	4b12      	ldr	r3, [pc, #72]	; (16630 <InterruptLookupHandler+0x50>)
   165e6:	685b      	ldr	r3, [r3, #4]
   165e8:	f88d 300f 	strb.w	r3, [sp, #15]
  IsrPointer isr     = dynamic_isr_vector_table[active_isr];
   165ec:	f89d 300f 	ldrb.w	r3, [sp, #15]
   165f0:	4a10      	ldr	r2, [pc, #64]	; (16634 <InterruptLookupHandler+0x54>)
   165f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   165f6:	9302      	str	r3, [sp, #8]
  SJ2_ASSERT_FATAL(isr != InterruptLookupHandler,
   165f8:	9b02      	ldr	r3, [sp, #8]
   165fa:	4a0f      	ldr	r2, [pc, #60]	; (16638 <InterruptLookupHandler+0x58>)
   165fc:	4293      	cmp	r3, r2
   165fe:	d110      	bne.n	16622 <InterruptLookupHandler+0x42>
   16600:	f89d 300f 	ldrb.w	r3, [sp, #15]
   16604:	9300      	str	r3, [sp, #0]
   16606:	23dd      	movs	r3, #221	; 0xdd
   16608:	4a0c      	ldr	r2, [pc, #48]	; (1663c <InterruptLookupHandler+0x5c>)
   1660a:	490d      	ldr	r1, [pc, #52]	; (16640 <InterruptLookupHandler+0x60>)
   1660c:	480d      	ldr	r0, [pc, #52]	; (16644 <InterruptLookupHandler+0x64>)
   1660e:	f002 f8e7 	bl	187e0 <printf>
   16612:	480d      	ldr	r0, [pc, #52]	; (16648 <InterruptLookupHandler+0x68>)
   16614:	f000 f93e 	bl	16894 <puts>
   16618:	2100      	movs	r1, #0
   1661a:	2001      	movs	r0, #1
   1661c:	f7fa ff40 	bl	114a0 <debug::PrintBacktrace(bool, void*)>
   16620:	e7fe      	b.n	16620 <InterruptLookupHandler+0x40>
  isr();
   16622:	9b02      	ldr	r3, [sp, #8]
   16624:	4798      	blx	r3
}
   16626:	bf00      	nop
   16628:	b005      	add	sp, #20
   1662a:	f85d fb04 	ldr.w	pc, [sp], #4
   1662e:	bf00      	nop
   16630:	e000ed00 	.word	0xe000ed00
   16634:	10000564 	.word	0x10000564
   16638:	000165e1 	.word	0x000165e1
   1663c:	0001e37c 	.word	0x0001e37c
   16640:	0001e36c 	.word	0x0001e36c
   16644:	0001e210 	.word	0x0001e210
   16648:	0001e2bc 	.word	0x0001e2bc

0001664c <RegisterIsr(IRQn, void (*)(), bool, long)>:
{
   1664c:	b500      	push	{lr}
   1664e:	b085      	sub	sp, #20
   16650:	9102      	str	r1, [sp, #8]
   16652:	9301      	str	r3, [sp, #4]
   16654:	4603      	mov	r3, r0
   16656:	f88d 300f 	strb.w	r3, [sp, #15]
   1665a:	4613      	mov	r3, r2
   1665c:	f88d 300e 	strb.w	r3, [sp, #14]
  dynamic_isr_vector_table[irq + kIrqOffset] = isr;
   16660:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   16664:	3310      	adds	r3, #16
   16666:	490f      	ldr	r1, [pc, #60]	; (166a4 <RegisterIsr(IRQn, void (*)(), bool, long)+0x58>)
   16668:	9a02      	ldr	r2, [sp, #8]
   1666a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  if (enable_interrupt && irq >= 0)
   1666e:	f89d 300e 	ldrb.w	r3, [sp, #14]
   16672:	2b00      	cmp	r3, #0
   16674:	d008      	beq.n	16688 <RegisterIsr(IRQn, void (*)(), bool, long)+0x3c>
   16676:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   1667a:	2b00      	cmp	r3, #0
   1667c:	db04      	blt.n	16688 <RegisterIsr(IRQn, void (*)(), bool, long)+0x3c>
    NVIC_EnableIRQ(irq);
   1667e:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   16682:	4618      	mov	r0, r3
   16684:	f7ff ff6c 	bl	16560 <NVIC_EnableIRQ>
  if (priority > -1)
   16688:	9b01      	ldr	r3, [sp, #4]
   1668a:	2b00      	cmp	r3, #0
   1668c:	db06      	blt.n	1669c <RegisterIsr(IRQn, void (*)(), bool, long)+0x50>
    NVIC_SetPriority(irq, priority);
   1668e:	9a01      	ldr	r2, [sp, #4]
   16690:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   16694:	4611      	mov	r1, r2
   16696:	4618      	mov	r0, r3
   16698:	f7ff ff78 	bl	1658c <NVIC_SetPriority>
}
   1669c:	bf00      	nop
   1669e:	b005      	add	sp, #20
   166a0:	f85d fb04 	ldr.w	pc, [sp], #4
   166a4:	10000564 	.word	0x10000564

000166a8 <GetRegistersFromStack>:
{
   166a8:	b500      	push	{lr}
   166aa:	b08d      	sub	sp, #52	; 0x34
   166ac:	9003      	str	r0, [sp, #12]
  volatile uint32_t r0  = fault_stack_address[0];
   166ae:	9b03      	ldr	r3, [sp, #12]
   166b0:	681b      	ldr	r3, [r3, #0]
   166b2:	930b      	str	r3, [sp, #44]	; 0x2c
  volatile uint32_t r1  = fault_stack_address[1];
   166b4:	9b03      	ldr	r3, [sp, #12]
   166b6:	685b      	ldr	r3, [r3, #4]
   166b8:	930a      	str	r3, [sp, #40]	; 0x28
  volatile uint32_t r2  = fault_stack_address[2];
   166ba:	9b03      	ldr	r3, [sp, #12]
   166bc:	689b      	ldr	r3, [r3, #8]
   166be:	9309      	str	r3, [sp, #36]	; 0x24
  volatile uint32_t r3  = fault_stack_address[3];
   166c0:	9b03      	ldr	r3, [sp, #12]
   166c2:	68db      	ldr	r3, [r3, #12]
   166c4:	9308      	str	r3, [sp, #32]
  volatile uint32_t r12 = fault_stack_address[4];
   166c6:	9b03      	ldr	r3, [sp, #12]
   166c8:	691b      	ldr	r3, [r3, #16]
   166ca:	9307      	str	r3, [sp, #28]
  volatile uint32_t lr = fault_stack_address[5];
   166cc:	9b03      	ldr	r3, [sp, #12]
   166ce:	695b      	ldr	r3, [r3, #20]
   166d0:	9306      	str	r3, [sp, #24]
  volatile uint32_t pc = fault_stack_address[6];
   166d2:	9b03      	ldr	r3, [sp, #12]
   166d4:	699b      	ldr	r3, [r3, #24]
   166d6:	9305      	str	r3, [sp, #20]
  volatile uint32_t psr = fault_stack_address[7];
   166d8:	9b03      	ldr	r3, [sp, #12]
   166da:	69db      	ldr	r3, [r3, #28]
   166dc:	9304      	str	r3, [sp, #16]
  printf(SJ2_BACKGROUND_RED "Hard Fault Exception Occurred!\n" SJ2_COLOR_RESET);
   166de:	480d      	ldr	r0, [pc, #52]	; (16714 <GetRegistersFromStack+0x6c>)
   166e0:	f002 f87e 	bl	187e0 <printf>
  printf("r0: 0x%08" PRIX32 ", r1: 0x%08" PRIX32
   166e4:	990b      	ldr	r1, [sp, #44]	; 0x2c
   166e6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   166e8:	9809      	ldr	r0, [sp, #36]	; 0x24
   166ea:	9b08      	ldr	r3, [sp, #32]
   166ec:	9300      	str	r3, [sp, #0]
   166ee:	4603      	mov	r3, r0
   166f0:	4809      	ldr	r0, [pc, #36]	; (16718 <GetRegistersFromStack+0x70>)
   166f2:	f002 f875 	bl	187e0 <printf>
  printf("r12: 0x%08" PRIX32 ", lr: 0x%08" PRIX32
   166f6:	9907      	ldr	r1, [sp, #28]
   166f8:	9a06      	ldr	r2, [sp, #24]
   166fa:	9805      	ldr	r0, [sp, #20]
   166fc:	9b04      	ldr	r3, [sp, #16]
   166fe:	9300      	str	r3, [sp, #0]
   16700:	4603      	mov	r3, r0
   16702:	4806      	ldr	r0, [pc, #24]	; (1671c <GetRegistersFromStack+0x74>)
   16704:	f002 f86c 	bl	187e0 <printf>
  debug::PrintBacktrace(true, reinterpret_cast<void *>(pc));
   16708:	9b05      	ldr	r3, [sp, #20]
   1670a:	4619      	mov	r1, r3
   1670c:	2001      	movs	r0, #1
   1670e:	f7fa fec7 	bl	114a0 <debug::PrintBacktrace(bool, void*)>
   16712:	e7fe      	b.n	16712 <GetRegistersFromStack+0x6a>
   16714:	0001e2d4 	.word	0x0001e2d4
   16718:	0001e300 	.word	0x0001e300
   1671c:	0001e334 	.word	0x0001e334

00016720 <FirmwareStdOut(int)>:
}
Stdout out = HostWrite;
Stdin in   = HostRead;
#else
int FirmwareStdOut(int data)
{
   16720:	b530      	push	{r4, r5, lr}
   16722:	b083      	sub	sp, #12
   16724:	4675      	mov	r5, lr
   16726:	9001      	str	r0, [sp, #4]
   16728:	462b      	mov	r3, r5
   1672a:	4619      	mov	r1, r3
   1672c:	4809      	ldr	r0, [pc, #36]	; (16754 <FirmwareStdOut(int)+0x34>)
   1672e:	f000 f8e1 	bl	168f4 <__cyg_profile_func_enter>
  uart0.Send(static_cast<uint8_t>(data));
   16732:	9b01      	ldr	r3, [sp, #4]
   16734:	b2db      	uxtb	r3, r3
   16736:	4619      	mov	r1, r3
   16738:	4807      	ldr	r0, [pc, #28]	; (16758 <FirmwareStdOut(int)+0x38>)
   1673a:	f7ff f9a7 	bl	15a8c <Uart::Send(unsigned char)>
  return 1;
   1673e:	2401      	movs	r4, #1
   16740:	462b      	mov	r3, r5
   16742:	4619      	mov	r1, r3
   16744:	4803      	ldr	r0, [pc, #12]	; (16754 <FirmwareStdOut(int)+0x34>)
   16746:	f000 f8e9 	bl	1691c <__cyg_profile_func_exit>
   1674a:	4623      	mov	r3, r4
}
   1674c:	4618      	mov	r0, r3
   1674e:	b003      	add	sp, #12
   16750:	bd30      	pop	{r4, r5, pc}
   16752:	bf00      	nop
   16754:	00016721 	.word	0x00016721
   16758:	10000538 	.word	0x10000538

0001675c <_exit>:
  }
  // Dummy implementation of exit with return code placed into
  // Arm register r3
  // NOLINTNEXTLINE(readability-identifier-naming)
  void _exit([[maybe_unused]] int rc)
  {
   1675c:	b500      	push	{lr}
   1675e:	b083      	sub	sp, #12
   16760:	4673      	mov	r3, lr
   16762:	9001      	str	r0, [sp, #4]
   16764:	4619      	mov	r1, r3
   16766:	4802      	ldr	r0, [pc, #8]	; (16770 <_exit+0x14>)
   16768:	f000 f8c4 	bl	168f4 <__cyg_profile_func_enter>
    while (1)
    {
      continue;
   1676c:	bf00      	nop
    while (1)
   1676e:	e7fd      	b.n	1676c <_exit+0x10>
   16770:	0001675d 	.word	0x0001675d

00016774 <_getpid>:
    }
  }
  // Dummy implementation of getpid
  // NOLINTNEXTLINE(readability-identifier-naming)
  int _getpid()
  {
   16774:	b538      	push	{r3, r4, r5, lr}
   16776:	4675      	mov	r5, lr
   16778:	462b      	mov	r3, r5
   1677a:	4619      	mov	r1, r3
   1677c:	4805      	ldr	r0, [pc, #20]	; (16794 <_getpid+0x20>)
   1677e:	f000 f8b9 	bl	168f4 <__cyg_profile_func_enter>
    return 1;
   16782:	2401      	movs	r4, #1
   16784:	462b      	mov	r3, r5
   16786:	4619      	mov	r1, r3
   16788:	4802      	ldr	r0, [pc, #8]	; (16794 <_getpid+0x20>)
   1678a:	f000 f8c7 	bl	1691c <__cyg_profile_func_exit>
   1678e:	4623      	mov	r3, r4
  }
   16790:	4618      	mov	r0, r3
   16792:	bd38      	pop	{r3, r4, r5, pc}
   16794:	00016775 	.word	0x00016775

00016798 <_kill>:
  // Dummy implementation of kill
  // NOLINTNEXTLINE(readability-identifier-naming)
  int _kill(int, int)
  {
   16798:	b530      	push	{r4, r5, lr}
   1679a:	b083      	sub	sp, #12
   1679c:	4675      	mov	r5, lr
   1679e:	9001      	str	r0, [sp, #4]
   167a0:	9100      	str	r1, [sp, #0]
   167a2:	462b      	mov	r3, r5
   167a4:	4619      	mov	r1, r3
   167a6:	4807      	ldr	r0, [pc, #28]	; (167c4 <_kill+0x2c>)
   167a8:	f000 f8a4 	bl	168f4 <__cyg_profile_func_enter>
    return -1;
   167ac:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   167b0:	462b      	mov	r3, r5
   167b2:	4619      	mov	r1, r3
   167b4:	4803      	ldr	r0, [pc, #12]	; (167c4 <_kill+0x2c>)
   167b6:	f000 f8b1 	bl	1691c <__cyg_profile_func_exit>
   167ba:	4623      	mov	r3, r4
  }
   167bc:	4618      	mov	r0, r3
   167be:	b003      	add	sp, #12
   167c0:	bd30      	pop	{r4, r5, pc}
   167c2:	bf00      	nop
   167c4:	00016799 	.word	0x00016799

000167c8 <_sbrk>:
    return 0;
  }
  // Implementation of sbrk for allocating and deallocating space for malloc.
  // NOLINTNEXTLINE(readability-identifier-naming)
  void * _sbrk(int increment)
  {
   167c8:	b530      	push	{r4, r5, lr}
   167ca:	b085      	sub	sp, #20
   167cc:	4675      	mov	r5, lr
   167ce:	9001      	str	r0, [sp, #4]
   167d0:	462b      	mov	r3, r5
   167d2:	4619      	mov	r1, r3
   167d4:	480f      	ldr	r0, [pc, #60]	; (16814 <_sbrk+0x4c>)
   167d6:	f000 f88d 	bl	168f4 <__cyg_profile_func_enter>
    void * previous_heap_position  = static_cast<void *>(heap_position);
   167da:	4b0f      	ldr	r3, [pc, #60]	; (16818 <_sbrk+0x50>)
   167dc:	681b      	ldr	r3, [r3, #0]
   167de:	9303      	str	r3, [sp, #12]
    // Check that by allocating this space, we do not exceed the heap area.
    if ((heap_position + increment) > &heap_end)
   167e0:	4b0d      	ldr	r3, [pc, #52]	; (16818 <_sbrk+0x50>)
   167e2:	681a      	ldr	r2, [r3, #0]
   167e4:	9b01      	ldr	r3, [sp, #4]
   167e6:	4413      	add	r3, r2
   167e8:	4a0c      	ldr	r2, [pc, #48]	; (1681c <_sbrk+0x54>)
   167ea:	4293      	cmp	r3, r2
   167ec:	d901      	bls.n	167f2 <_sbrk+0x2a>
    {
      previous_heap_position = nullptr;
   167ee:	2300      	movs	r3, #0
   167f0:	9303      	str	r3, [sp, #12]
    }
    heap_position += increment;
   167f2:	4b09      	ldr	r3, [pc, #36]	; (16818 <_sbrk+0x50>)
   167f4:	681a      	ldr	r2, [r3, #0]
   167f6:	9b01      	ldr	r3, [sp, #4]
   167f8:	4413      	add	r3, r2
   167fa:	4a07      	ldr	r2, [pc, #28]	; (16818 <_sbrk+0x50>)
   167fc:	6013      	str	r3, [r2, #0]
    return previous_heap_position;
   167fe:	9c03      	ldr	r4, [sp, #12]
   16800:	462b      	mov	r3, r5
   16802:	4619      	mov	r1, r3
   16804:	4803      	ldr	r0, [pc, #12]	; (16814 <_sbrk+0x4c>)
   16806:	f000 f889 	bl	1691c <__cyg_profile_func_exit>
   1680a:	4623      	mov	r3, r4
  }
   1680c:	4618      	mov	r0, r3
   1680e:	b005      	add	sp, #20
   16810:	bd30      	pop	{r4, r5, pc}
   16812:	bf00      	nop
   16814:	000167c9 	.word	0x000167c9
   16818:	10000648 	.word	0x10000648
   1681c:	20008000 	.word	0x20008000

00016820 <_putchar>:
    }
    return length;
  }
  // Needed by third party printf library
  void _putchar(char character)  // NOLINT
  {
   16820:	b510      	push	{r4, lr}
   16822:	b082      	sub	sp, #8
   16824:	4674      	mov	r4, lr
   16826:	4603      	mov	r3, r0
   16828:	f88d 3007 	strb.w	r3, [sp, #7]
   1682c:	4623      	mov	r3, r4
   1682e:	4619      	mov	r1, r3
   16830:	4808      	ldr	r0, [pc, #32]	; (16854 <_putchar+0x34>)
   16832:	f000 f85f 	bl	168f4 <__cyg_profile_func_enter>
    out(character);
   16836:	4b08      	ldr	r3, [pc, #32]	; (16858 <_putchar+0x38>)
   16838:	681b      	ldr	r3, [r3, #0]
   1683a:	f89d 2007 	ldrb.w	r2, [sp, #7]
   1683e:	4610      	mov	r0, r2
   16840:	4798      	blx	r3
   16842:	4623      	mov	r3, r4
   16844:	4619      	mov	r1, r3
   16846:	4803      	ldr	r0, [pc, #12]	; (16854 <_putchar+0x34>)
   16848:	f000 f868 	bl	1691c <__cyg_profile_func_exit>
  }
   1684c:	bf00      	nop
   1684e:	b002      	add	sp, #8
   16850:	bd10      	pop	{r4, pc}
   16852:	bf00      	nop
   16854:	00016821 	.word	0x00016821
   16858:	1000064c 	.word	0x1000064c

0001685c <putchar>:

  // Overload default libnano putchar() with a more optimal version that does
  // not use dynamic memory
  int putchar(int character)  // NOLINT
  {
   1685c:	b530      	push	{r4, r5, lr}
   1685e:	b083      	sub	sp, #12
   16860:	4674      	mov	r4, lr
   16862:	9001      	str	r0, [sp, #4]
   16864:	4623      	mov	r3, r4
   16866:	4619      	mov	r1, r3
   16868:	4808      	ldr	r0, [pc, #32]	; (1688c <putchar+0x30>)
   1686a:	f000 f843 	bl	168f4 <__cyg_profile_func_enter>
    return out(character);
   1686e:	4b08      	ldr	r3, [pc, #32]	; (16890 <putchar+0x34>)
   16870:	681b      	ldr	r3, [r3, #0]
   16872:	9801      	ldr	r0, [sp, #4]
   16874:	4798      	blx	r3
   16876:	4605      	mov	r5, r0
   16878:	4623      	mov	r3, r4
   1687a:	4619      	mov	r1, r3
   1687c:	4803      	ldr	r0, [pc, #12]	; (1688c <putchar+0x30>)
   1687e:	f000 f84d 	bl	1691c <__cyg_profile_func_exit>
   16882:	462b      	mov	r3, r5
  }
   16884:	4618      	mov	r0, r3
   16886:	b003      	add	sp, #12
   16888:	bd30      	pop	{r4, r5, pc}
   1688a:	bf00      	nop
   1688c:	0001685d 	.word	0x0001685d
   16890:	1000064c 	.word	0x1000064c

00016894 <puts>:

  // Overload default libnano puts() with a more optimal version that does
  // not use dynamic memory
  int puts(const char * str)  // NOLINT
  {
   16894:	b530      	push	{r4, r5, lr}
   16896:	b085      	sub	sp, #20
   16898:	4675      	mov	r5, lr
   1689a:	9001      	str	r0, [sp, #4]
   1689c:	462b      	mov	r3, r5
   1689e:	4619      	mov	r1, r3
   168a0:	4812      	ldr	r0, [pc, #72]	; (168ec <puts+0x58>)
   168a2:	f000 f827 	bl	168f4 <__cyg_profile_func_enter>
    int i;
    for (i = 0; str[i] != '\0'; i++)
   168a6:	2300      	movs	r3, #0
   168a8:	9303      	str	r3, [sp, #12]
   168aa:	9b03      	ldr	r3, [sp, #12]
   168ac:	9a01      	ldr	r2, [sp, #4]
   168ae:	4413      	add	r3, r2
   168b0:	781b      	ldrb	r3, [r3, #0]
   168b2:	2b00      	cmp	r3, #0
   168b4:	d00b      	beq.n	168ce <puts+0x3a>
    {
      out(str[i]);
   168b6:	4b0e      	ldr	r3, [pc, #56]	; (168f0 <puts+0x5c>)
   168b8:	681b      	ldr	r3, [r3, #0]
   168ba:	9a03      	ldr	r2, [sp, #12]
   168bc:	9901      	ldr	r1, [sp, #4]
   168be:	440a      	add	r2, r1
   168c0:	7812      	ldrb	r2, [r2, #0]
   168c2:	4610      	mov	r0, r2
   168c4:	4798      	blx	r3
    for (i = 0; str[i] != '\0'; i++)
   168c6:	9b03      	ldr	r3, [sp, #12]
   168c8:	3301      	adds	r3, #1
   168ca:	9303      	str	r3, [sp, #12]
   168cc:	e7ed      	b.n	168aa <puts+0x16>
    }
    out('\n');
   168ce:	4b08      	ldr	r3, [pc, #32]	; (168f0 <puts+0x5c>)
   168d0:	681b      	ldr	r3, [r3, #0]
   168d2:	200a      	movs	r0, #10
   168d4:	4798      	blx	r3
    return i;
   168d6:	9c03      	ldr	r4, [sp, #12]
   168d8:	462b      	mov	r3, r5
   168da:	4619      	mov	r1, r3
   168dc:	4803      	ldr	r0, [pc, #12]	; (168ec <puts+0x58>)
   168de:	f000 f81d 	bl	1691c <__cyg_profile_func_exit>
   168e2:	4623      	mov	r3, r4
  }
   168e4:	4618      	mov	r0, r3
   168e6:	b005      	add	sp, #20
   168e8:	bd30      	pop	{r4, r5, pc}
   168ea:	bf00      	nop
   168ec:	00016895 	.word	0x00016895
   168f0:	1000064c 	.word	0x1000064c

000168f4 <__cyg_profile_func_enter>:
  // =============================
  void * stack_trace[config::kBacktraceDepth] = { nullptr };
  size_t stack_depth = 0;

  void __cyg_profile_func_enter(void *, void * call_site)  // NOLINT
  {
   168f4:	b082      	sub	sp, #8
   168f6:	9001      	str	r0, [sp, #4]
   168f8:	9100      	str	r1, [sp, #0]
    stack_trace[stack_depth++] = call_site;
   168fa:	9a00      	ldr	r2, [sp, #0]
   168fc:	4b05      	ldr	r3, [pc, #20]	; (16914 <__cyg_profile_func_enter+0x20>)
   168fe:	681b      	ldr	r3, [r3, #0]
   16900:	1c59      	adds	r1, r3, #1
   16902:	4804      	ldr	r0, [pc, #16]	; (16914 <__cyg_profile_func_enter+0x20>)
   16904:	6001      	str	r1, [r0, #0]
   16906:	4904      	ldr	r1, [pc, #16]	; (16918 <__cyg_profile_func_enter+0x24>)
   16908:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
   1690c:	bf00      	nop
   1690e:	b002      	add	sp, #8
   16910:	4770      	bx	lr
   16912:	bf00      	nop
   16914:	10003274 	.word	0x10003274
   16918:	10003174 	.word	0x10003174

0001691c <__cyg_profile_func_exit>:

  void __cyg_profile_func_exit(void *, void *)  // NOLINT
  {
   1691c:	b082      	sub	sp, #8
   1691e:	9001      	str	r0, [sp, #4]
   16920:	9100      	str	r1, [sp, #0]
    stack_depth--;
   16922:	4b04      	ldr	r3, [pc, #16]	; (16934 <__cyg_profile_func_exit+0x18>)
   16924:	681b      	ldr	r3, [r3, #0]
   16926:	3b01      	subs	r3, #1
   16928:	4a02      	ldr	r2, [pc, #8]	; (16934 <__cyg_profile_func_exit+0x18>)
   1692a:	6013      	str	r3, [r2, #0]
  }
   1692c:	bf00      	nop
   1692e:	b002      	add	sp, #8
   16930:	4770      	bx	lr
   16932:	bf00      	nop
   16934:	10003274 	.word	0x10003274

00016938 <GetStackTrace()>:
}

void ** GetStackTrace()
{
   16938:	b538      	push	{r3, r4, r5, lr}
   1693a:	4675      	mov	r5, lr
   1693c:	462b      	mov	r3, r5
   1693e:	4619      	mov	r1, r3
   16940:	4805      	ldr	r0, [pc, #20]	; (16958 <GetStackTrace()+0x20>)
   16942:	f7ff ffd7 	bl	168f4 <__cyg_profile_func_enter>
  return stack_trace;
   16946:	4c05      	ldr	r4, [pc, #20]	; (1695c <GetStackTrace()+0x24>)
   16948:	462b      	mov	r3, r5
   1694a:	4619      	mov	r1, r3
   1694c:	4802      	ldr	r0, [pc, #8]	; (16958 <GetStackTrace()+0x20>)
   1694e:	f7ff ffe5 	bl	1691c <__cyg_profile_func_exit>
   16952:	4623      	mov	r3, r4
}
   16954:	4618      	mov	r0, r3
   16956:	bd38      	pop	{r3, r4, r5, pc}
   16958:	00016939 	.word	0x00016939
   1695c:	10003174 	.word	0x10003174

00016960 <GetStackDepth()>:

size_t GetStackDepth()
{
   16960:	b538      	push	{r3, r4, r5, lr}
   16962:	4675      	mov	r5, lr
   16964:	462b      	mov	r3, r5
   16966:	4619      	mov	r1, r3
   16968:	4806      	ldr	r0, [pc, #24]	; (16984 <GetStackDepth()+0x24>)
   1696a:	f7ff ffc3 	bl	168f4 <__cyg_profile_func_enter>
  return stack_depth;
   1696e:	4b06      	ldr	r3, [pc, #24]	; (16988 <GetStackDepth()+0x28>)
   16970:	681c      	ldr	r4, [r3, #0]
   16972:	462b      	mov	r3, r5
   16974:	4619      	mov	r1, r3
   16976:	4803      	ldr	r0, [pc, #12]	; (16984 <GetStackDepth()+0x24>)
   16978:	f7ff ffd0 	bl	1691c <__cyg_profile_func_exit>
   1697c:	4623      	mov	r3, r4
}
   1697e:	4618      	mov	r0, r3
   16980:	bd38      	pop	{r3, r4, r5, pc}
   16982:	bf00      	nop
   16984:	00016961 	.word	0x00016961
   16988:	10003274 	.word	0x10003274

0001698c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
   1698c:	b082      	sub	sp, #8
   1698e:	9001      	str	r0, [sp, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   16990:	9b01      	ldr	r3, [sp, #4]
   16992:	f103 0208 	add.w	r2, r3, #8
   16996:	9b01      	ldr	r3, [sp, #4]
   16998:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   1699a:	9b01      	ldr	r3, [sp, #4]
   1699c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   169a0:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   169a2:	9b01      	ldr	r3, [sp, #4]
   169a4:	f103 0208 	add.w	r2, r3, #8
   169a8:	9b01      	ldr	r3, [sp, #4]
   169aa:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   169ac:	9b01      	ldr	r3, [sp, #4]
   169ae:	f103 0208 	add.w	r2, r3, #8
   169b2:	9b01      	ldr	r3, [sp, #4]
   169b4:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
   169b6:	9b01      	ldr	r3, [sp, #4]
   169b8:	2200      	movs	r2, #0
   169ba:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
   169bc:	bf00      	nop
   169be:	b002      	add	sp, #8
   169c0:	4770      	bx	lr

000169c2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
   169c2:	b082      	sub	sp, #8
   169c4:	9001      	str	r0, [sp, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
   169c6:	9b01      	ldr	r3, [sp, #4]
   169c8:	2200      	movs	r2, #0
   169ca:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
   169cc:	bf00      	nop
   169ce:	b002      	add	sp, #8
   169d0:	4770      	bx	lr

000169d2 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   169d2:	b084      	sub	sp, #16
   169d4:	9001      	str	r0, [sp, #4]
   169d6:	9100      	str	r1, [sp, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
   169d8:	9b01      	ldr	r3, [sp, #4]
   169da:	685b      	ldr	r3, [r3, #4]
   169dc:	9303      	str	r3, [sp, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
   169de:	9b00      	ldr	r3, [sp, #0]
   169e0:	9a03      	ldr	r2, [sp, #12]
   169e2:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
   169e4:	9b03      	ldr	r3, [sp, #12]
   169e6:	689a      	ldr	r2, [r3, #8]
   169e8:	9b00      	ldr	r3, [sp, #0]
   169ea:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
   169ec:	9b03      	ldr	r3, [sp, #12]
   169ee:	689b      	ldr	r3, [r3, #8]
   169f0:	9a00      	ldr	r2, [sp, #0]
   169f2:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
   169f4:	9b03      	ldr	r3, [sp, #12]
   169f6:	9a00      	ldr	r2, [sp, #0]
   169f8:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   169fa:	9b00      	ldr	r3, [sp, #0]
   169fc:	9a01      	ldr	r2, [sp, #4]
   169fe:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
   16a00:	9b01      	ldr	r3, [sp, #4]
   16a02:	681b      	ldr	r3, [r3, #0]
   16a04:	1c5a      	adds	r2, r3, #1
   16a06:	9b01      	ldr	r3, [sp, #4]
   16a08:	601a      	str	r2, [r3, #0]
}
   16a0a:	bf00      	nop
   16a0c:	b004      	add	sp, #16
   16a0e:	4770      	bx	lr

00016a10 <uxListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
   16a10:	b084      	sub	sp, #16
   16a12:	9001      	str	r0, [sp, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
   16a14:	9b01      	ldr	r3, [sp, #4]
   16a16:	691b      	ldr	r3, [r3, #16]
   16a18:	9303      	str	r3, [sp, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   16a1a:	9b01      	ldr	r3, [sp, #4]
   16a1c:	685b      	ldr	r3, [r3, #4]
   16a1e:	9a01      	ldr	r2, [sp, #4]
   16a20:	6892      	ldr	r2, [r2, #8]
   16a22:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   16a24:	9b01      	ldr	r3, [sp, #4]
   16a26:	689b      	ldr	r3, [r3, #8]
   16a28:	9a01      	ldr	r2, [sp, #4]
   16a2a:	6852      	ldr	r2, [r2, #4]
   16a2c:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   16a2e:	9b03      	ldr	r3, [sp, #12]
   16a30:	685b      	ldr	r3, [r3, #4]
   16a32:	9a01      	ldr	r2, [sp, #4]
   16a34:	429a      	cmp	r2, r3
   16a36:	d103      	bne.n	16a40 <uxListRemove+0x30>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   16a38:	9b01      	ldr	r3, [sp, #4]
   16a3a:	689a      	ldr	r2, [r3, #8]
   16a3c:	9b03      	ldr	r3, [sp, #12]
   16a3e:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
   16a40:	9b01      	ldr	r3, [sp, #4]
   16a42:	2200      	movs	r2, #0
   16a44:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
   16a46:	9b03      	ldr	r3, [sp, #12]
   16a48:	681b      	ldr	r3, [r3, #0]
   16a4a:	1e5a      	subs	r2, r3, #1
   16a4c:	9b03      	ldr	r3, [sp, #12]
   16a4e:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
   16a50:	9b03      	ldr	r3, [sp, #12]
   16a52:	681b      	ldr	r3, [r3, #0]
}
   16a54:	4618      	mov	r0, r3
   16a56:	b004      	add	sp, #16
   16a58:	4770      	bx	lr

00016a5a <xTaskCreateStatic>:
									const uint32_t ulStackDepth,
									void * const pvParameters,
									UBaseType_t uxPriority,
									StackType_t * const puxStackBuffer,
									StaticTask_t * const pxTaskBuffer )
	{
   16a5a:	b500      	push	{lr}
   16a5c:	b08b      	sub	sp, #44	; 0x2c
   16a5e:	9007      	str	r0, [sp, #28]
   16a60:	9106      	str	r1, [sp, #24]
   16a62:	9205      	str	r2, [sp, #20]
   16a64:	9304      	str	r3, [sp, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
		}
		#endif /* configASSERT_DEFINED */


		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
   16a66:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   16a68:	2b00      	cmp	r3, #0
   16a6a:	d01d      	beq.n	16aa8 <xTaskCreateStatic+0x4e>
   16a6c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16a6e:	2b00      	cmp	r3, #0
   16a70:	d01a      	beq.n	16aa8 <xTaskCreateStatic+0x4e>
		{
			/* The memory used for the task's TCB and stack are passed into this
			function - use them. */
			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
   16a72:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   16a74:	9309      	str	r3, [sp, #36]	; 0x24
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
   16a76:	9b09      	ldr	r3, [sp, #36]	; 0x24
   16a78:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   16a7a:	631a      	str	r2, [r3, #48]	; 0x30

			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created statically in case the task is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
   16a7c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   16a7e:	2202      	movs	r2, #2
   16a80:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
			}
			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
   16a84:	2300      	movs	r3, #0
   16a86:	9303      	str	r3, [sp, #12]
   16a88:	9b09      	ldr	r3, [sp, #36]	; 0x24
   16a8a:	9302      	str	r3, [sp, #8]
   16a8c:	ab08      	add	r3, sp, #32
   16a8e:	9301      	str	r3, [sp, #4]
   16a90:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   16a92:	9300      	str	r3, [sp, #0]
   16a94:	9b04      	ldr	r3, [sp, #16]
   16a96:	9a05      	ldr	r2, [sp, #20]
   16a98:	9906      	ldr	r1, [sp, #24]
   16a9a:	9807      	ldr	r0, [sp, #28]
   16a9c:	f000 f852 	bl	16b44 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
   16aa0:	9809      	ldr	r0, [sp, #36]	; 0x24
   16aa2:	f000 f8c9 	bl	16c38 <prvAddNewTaskToReadyList>
   16aa6:	e001      	b.n	16aac <xTaskCreateStatic+0x52>
		}
		else
		{
			xReturn = NULL;
   16aa8:	2300      	movs	r3, #0
   16aaa:	9308      	str	r3, [sp, #32]
		}

		return xReturn;
   16aac:	9b08      	ldr	r3, [sp, #32]
	}
   16aae:	4618      	mov	r0, r3
   16ab0:	b00b      	add	sp, #44	; 0x2c
   16ab2:	f85d fb04 	ldr.w	pc, [sp], #4

00016ab6 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
   16ab6:	b500      	push	{lr}
   16ab8:	b08d      	sub	sp, #52	; 0x34
   16aba:	9007      	str	r0, [sp, #28]
   16abc:	9106      	str	r1, [sp, #24]
   16abe:	9304      	str	r3, [sp, #16]
   16ac0:	4613      	mov	r3, r2
   16ac2:	f8ad 3016 	strh.w	r3, [sp, #22]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   16ac6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   16aca:	009b      	lsls	r3, r3, #2
   16acc:	4618      	mov	r0, r3
   16ace:	f000 fce5 	bl	1749c <pvPortMalloc>
   16ad2:	9009      	str	r0, [sp, #36]	; 0x24

			if( pxStack != NULL )
   16ad4:	9b09      	ldr	r3, [sp, #36]	; 0x24
   16ad6:	2b00      	cmp	r3, #0
   16ad8:	d00e      	beq.n	16af8 <xTaskCreate+0x42>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
   16ada:	2060      	movs	r0, #96	; 0x60
   16adc:	f000 fcde 	bl	1749c <pvPortMalloc>
   16ae0:	900b      	str	r0, [sp, #44]	; 0x2c

				if( pxNewTCB != NULL )
   16ae2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16ae4:	2b00      	cmp	r3, #0
   16ae6:	d003      	beq.n	16af0 <xTaskCreate+0x3a>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
   16ae8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16aea:	9a09      	ldr	r2, [sp, #36]	; 0x24
   16aec:	631a      	str	r2, [r3, #48]	; 0x30
   16aee:	e005      	b.n	16afc <xTaskCreate+0x46>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
   16af0:	9809      	ldr	r0, [sp, #36]	; 0x24
   16af2:	f000 fce4 	bl	174be <vPortFree>
   16af6:	e001      	b.n	16afc <xTaskCreate+0x46>
				}
			}
			else
			{
				pxNewTCB = NULL;
   16af8:	2300      	movs	r3, #0
   16afa:	930b      	str	r3, [sp, #44]	; 0x2c
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
   16afc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16afe:	2b00      	cmp	r3, #0
   16b00:	d018      	beq.n	16b34 <xTaskCreate+0x7e>
		{
			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
   16b02:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16b04:	2200      	movs	r2, #0
   16b06:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
   16b0a:	f8bd 2016 	ldrh.w	r2, [sp, #22]
   16b0e:	2300      	movs	r3, #0
   16b10:	9303      	str	r3, [sp, #12]
   16b12:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16b14:	9302      	str	r3, [sp, #8]
   16b16:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   16b18:	9301      	str	r3, [sp, #4]
   16b1a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   16b1c:	9300      	str	r3, [sp, #0]
   16b1e:	9b04      	ldr	r3, [sp, #16]
   16b20:	9906      	ldr	r1, [sp, #24]
   16b22:	9807      	ldr	r0, [sp, #28]
   16b24:	f000 f80e 	bl	16b44 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
   16b28:	980b      	ldr	r0, [sp, #44]	; 0x2c
   16b2a:	f000 f885 	bl	16c38 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
   16b2e:	2301      	movs	r3, #1
   16b30:	930a      	str	r3, [sp, #40]	; 0x28
   16b32:	e002      	b.n	16b3a <xTaskCreate+0x84>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   16b34:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   16b38:	930a      	str	r3, [sp, #40]	; 0x28
		}

		return xReturn;
   16b3a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	}
   16b3c:	4618      	mov	r0, r3
   16b3e:	b00d      	add	sp, #52	; 0x34
   16b40:	f85d fb04 	ldr.w	pc, [sp], #4

00016b44 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
   16b44:	b500      	push	{lr}
   16b46:	b087      	sub	sp, #28
   16b48:	9003      	str	r0, [sp, #12]
   16b4a:	9102      	str	r1, [sp, #8]
   16b4c:	9201      	str	r2, [sp, #4]
   16b4e:	9300      	str	r3, [sp, #0]

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
   16b50:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16b52:	6b18      	ldr	r0, [r3, #48]	; 0x30
   16b54:	9b01      	ldr	r3, [sp, #4]
   16b56:	009b      	lsls	r3, r3, #2
   16b58:	461a      	mov	r2, r3
   16b5a:	21a5      	movs	r1, #165	; 0xa5
   16b5c:	f005 feec 	bl	1c938 <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
   16b60:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16b62:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   16b64:	9b01      	ldr	r3, [sp, #4]
   16b66:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   16b6a:	3b01      	subs	r3, #1
   16b6c:	009b      	lsls	r3, r3, #2
   16b6e:	4413      	add	r3, r2
   16b70:	9304      	str	r3, [sp, #16]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
   16b72:	9b04      	ldr	r3, [sp, #16]
   16b74:	f023 0307 	bic.w	r3, r3, #7
   16b78:	9304      	str	r3, [sp, #16]
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   16b7a:	2300      	movs	r3, #0
   16b7c:	9305      	str	r3, [sp, #20]
   16b7e:	e012      	b.n	16ba6 <prvInitialiseNewTask+0x62>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
   16b80:	9a02      	ldr	r2, [sp, #8]
   16b82:	9b05      	ldr	r3, [sp, #20]
   16b84:	4413      	add	r3, r2
   16b86:	7819      	ldrb	r1, [r3, #0]
   16b88:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   16b8a:	9b05      	ldr	r3, [sp, #20]
   16b8c:	4413      	add	r3, r2
   16b8e:	3334      	adds	r3, #52	; 0x34
   16b90:	460a      	mov	r2, r1
   16b92:	701a      	strb	r2, [r3, #0]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
   16b94:	9a02      	ldr	r2, [sp, #8]
   16b96:	9b05      	ldr	r3, [sp, #20]
   16b98:	4413      	add	r3, r2
   16b9a:	781b      	ldrb	r3, [r3, #0]
   16b9c:	2b00      	cmp	r3, #0
   16b9e:	d006      	beq.n	16bae <prvInitialiseNewTask+0x6a>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   16ba0:	9b05      	ldr	r3, [sp, #20]
   16ba2:	3301      	adds	r3, #1
   16ba4:	9305      	str	r3, [sp, #20]
   16ba6:	9b05      	ldr	r3, [sp, #20]
   16ba8:	2b0f      	cmp	r3, #15
   16baa:	d9e9      	bls.n	16b80 <prvInitialiseNewTask+0x3c>
   16bac:	e000      	b.n	16bb0 <prvInitialiseNewTask+0x6c>
		{
			break;
   16bae:	bf00      	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   16bb0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16bb2:	2200      	movs	r2, #0
   16bb4:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   16bb8:	9b08      	ldr	r3, [sp, #32]
   16bba:	2b04      	cmp	r3, #4
   16bbc:	d901      	bls.n	16bc2 <prvInitialiseNewTask+0x7e>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   16bbe:	2304      	movs	r3, #4
   16bc0:	9308      	str	r3, [sp, #32]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
   16bc2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16bc4:	9a08      	ldr	r2, [sp, #32]
   16bc6:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
   16bc8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16bca:	9a08      	ldr	r2, [sp, #32]
   16bcc:	64da      	str	r2, [r3, #76]	; 0x4c
		pxNewTCB->uxMutexesHeld = 0;
   16bce:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16bd0:	2200      	movs	r2, #0
   16bd2:	651a      	str	r2, [r3, #80]	; 0x50
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
   16bd4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16bd6:	3304      	adds	r3, #4
   16bd8:	4618      	mov	r0, r3
   16bda:	f7ff fef2 	bl	169c2 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
   16bde:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16be0:	3318      	adds	r3, #24
   16be2:	4618      	mov	r0, r3
   16be4:	f7ff feed 	bl	169c2 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
   16be8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16bea:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   16bec:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   16bee:	9b08      	ldr	r3, [sp, #32]
   16bf0:	f1c3 0205 	rsb	r2, r3, #5
   16bf4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16bf6:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
   16bf8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16bfa:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   16bfc:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif /* configUSE_APPLICATION_TASK_TAG */

	#if ( configGENERATE_RUN_TIME_STATS == 1 )
	{
		pxNewTCB->ulRunTimeCounter = 0UL;
   16bfe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16c00:	2200      	movs	r2, #0
   16c02:	655a      	str	r2, [r3, #84]	; 0x54
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
   16c04:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16c06:	2200      	movs	r2, #0
   16c08:	659a      	str	r2, [r3, #88]	; 0x58
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   16c0a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16c0c:	2200      	movs	r2, #0
   16c0e:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   16c12:	9a00      	ldr	r2, [sp, #0]
   16c14:	9903      	ldr	r1, [sp, #12]
   16c16:	9804      	ldr	r0, [sp, #16]
   16c18:	f000 fb1e 	bl	17258 <pxPortInitialiseStack>
   16c1c:	4602      	mov	r2, r0
   16c1e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16c20:	601a      	str	r2, [r3, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
   16c22:	9b09      	ldr	r3, [sp, #36]	; 0x24
   16c24:	2b00      	cmp	r3, #0
   16c26:	d002      	beq.n	16c2e <prvInitialiseNewTask+0xea>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   16c28:	9b09      	ldr	r3, [sp, #36]	; 0x24
   16c2a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   16c2c:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   16c2e:	bf00      	nop
   16c30:	b007      	add	sp, #28
   16c32:	f85d fb04 	ldr.w	pc, [sp], #4
   16c36:	Address 0x0000000000016c36 is out of bounds.


00016c38 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
   16c38:	b500      	push	{lr}
   16c3a:	b083      	sub	sp, #12
   16c3c:	9001      	str	r0, [sp, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
   16c3e:	f000 fba1 	bl	17384 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
   16c42:	4b2d      	ldr	r3, [pc, #180]	; (16cf8 <prvAddNewTaskToReadyList+0xc0>)
   16c44:	681b      	ldr	r3, [r3, #0]
   16c46:	3301      	adds	r3, #1
   16c48:	4a2b      	ldr	r2, [pc, #172]	; (16cf8 <prvAddNewTaskToReadyList+0xc0>)
   16c4a:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
   16c4c:	4b2b      	ldr	r3, [pc, #172]	; (16cfc <prvAddNewTaskToReadyList+0xc4>)
   16c4e:	681b      	ldr	r3, [r3, #0]
   16c50:	2b00      	cmp	r3, #0
   16c52:	d109      	bne.n	16c68 <prvAddNewTaskToReadyList+0x30>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
   16c54:	4a29      	ldr	r2, [pc, #164]	; (16cfc <prvAddNewTaskToReadyList+0xc4>)
   16c56:	9b01      	ldr	r3, [sp, #4]
   16c58:	6013      	str	r3, [r2, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   16c5a:	4b27      	ldr	r3, [pc, #156]	; (16cf8 <prvAddNewTaskToReadyList+0xc0>)
   16c5c:	681b      	ldr	r3, [r3, #0]
   16c5e:	2b01      	cmp	r3, #1
   16c60:	d110      	bne.n	16c84 <prvAddNewTaskToReadyList+0x4c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
   16c62:	f000 fa51 	bl	17108 <prvInitialiseTaskLists>
   16c66:	e00d      	b.n	16c84 <prvAddNewTaskToReadyList+0x4c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
   16c68:	4b25      	ldr	r3, [pc, #148]	; (16d00 <prvAddNewTaskToReadyList+0xc8>)
   16c6a:	681b      	ldr	r3, [r3, #0]
   16c6c:	2b00      	cmp	r3, #0
   16c6e:	d109      	bne.n	16c84 <prvAddNewTaskToReadyList+0x4c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
   16c70:	4b22      	ldr	r3, [pc, #136]	; (16cfc <prvAddNewTaskToReadyList+0xc4>)
   16c72:	681b      	ldr	r3, [r3, #0]
   16c74:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   16c76:	9b01      	ldr	r3, [sp, #4]
   16c78:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   16c7a:	429a      	cmp	r2, r3
   16c7c:	d802      	bhi.n	16c84 <prvAddNewTaskToReadyList+0x4c>
				{
					pxCurrentTCB = pxNewTCB;
   16c7e:	4a1f      	ldr	r2, [pc, #124]	; (16cfc <prvAddNewTaskToReadyList+0xc4>)
   16c80:	9b01      	ldr	r3, [sp, #4]
   16c82:	6013      	str	r3, [r2, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
   16c84:	4b1f      	ldr	r3, [pc, #124]	; (16d04 <prvAddNewTaskToReadyList+0xcc>)
   16c86:	681b      	ldr	r3, [r3, #0]
   16c88:	3301      	adds	r3, #1
   16c8a:	4a1e      	ldr	r2, [pc, #120]	; (16d04 <prvAddNewTaskToReadyList+0xcc>)
   16c8c:	6013      	str	r3, [r2, #0]

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
   16c8e:	4b1d      	ldr	r3, [pc, #116]	; (16d04 <prvAddNewTaskToReadyList+0xcc>)
   16c90:	681a      	ldr	r2, [r3, #0]
   16c92:	9b01      	ldr	r3, [sp, #4]
   16c94:	645a      	str	r2, [r3, #68]	; 0x44
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
   16c96:	9b01      	ldr	r3, [sp, #4]
   16c98:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   16c9a:	2201      	movs	r2, #1
   16c9c:	409a      	lsls	r2, r3
   16c9e:	4b1a      	ldr	r3, [pc, #104]	; (16d08 <prvAddNewTaskToReadyList+0xd0>)
   16ca0:	681b      	ldr	r3, [r3, #0]
   16ca2:	4313      	orrs	r3, r2
   16ca4:	4a18      	ldr	r2, [pc, #96]	; (16d08 <prvAddNewTaskToReadyList+0xd0>)
   16ca6:	6013      	str	r3, [r2, #0]
   16ca8:	9b01      	ldr	r3, [sp, #4]
   16caa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   16cac:	4613      	mov	r3, r2
   16cae:	009b      	lsls	r3, r3, #2
   16cb0:	4413      	add	r3, r2
   16cb2:	009b      	lsls	r3, r3, #2
   16cb4:	4a15      	ldr	r2, [pc, #84]	; (16d0c <prvAddNewTaskToReadyList+0xd4>)
   16cb6:	441a      	add	r2, r3
   16cb8:	9b01      	ldr	r3, [sp, #4]
   16cba:	3304      	adds	r3, #4
   16cbc:	4619      	mov	r1, r3
   16cbe:	4610      	mov	r0, r2
   16cc0:	f7ff fe87 	bl	169d2 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
   16cc4:	f000 fb72 	bl	173ac <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
   16cc8:	4b0d      	ldr	r3, [pc, #52]	; (16d00 <prvAddNewTaskToReadyList+0xc8>)
   16cca:	681b      	ldr	r3, [r3, #0]
   16ccc:	2b00      	cmp	r3, #0
   16cce:	d00e      	beq.n	16cee <prvAddNewTaskToReadyList+0xb6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
   16cd0:	4b0a      	ldr	r3, [pc, #40]	; (16cfc <prvAddNewTaskToReadyList+0xc4>)
   16cd2:	681b      	ldr	r3, [r3, #0]
   16cd4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   16cd6:	9b01      	ldr	r3, [sp, #4]
   16cd8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   16cda:	429a      	cmp	r2, r3
   16cdc:	d207      	bcs.n	16cee <prvAddNewTaskToReadyList+0xb6>
		{
			taskYIELD_IF_USING_PREEMPTION();
   16cde:	4b0c      	ldr	r3, [pc, #48]	; (16d10 <prvAddNewTaskToReadyList+0xd8>)
   16ce0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   16ce4:	601a      	str	r2, [r3, #0]
   16ce6:	f3bf 8f4f 	dsb	sy
   16cea:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   16cee:	bf00      	nop
   16cf0:	b003      	add	sp, #12
   16cf2:	f85d fb04 	ldr.w	pc, [sp], #4
   16cf6:	bf00      	nop
   16cf8:	10003350 	.word	0x10003350
   16cfc:	10003278 	.word	0x10003278
   16d00:	1000335c 	.word	0x1000335c
   16d04:	1000336c 	.word	0x1000336c
   16d08:	10003358 	.word	0x10003358
   16d0c:	1000327c 	.word	0x1000327c
   16d10:	e000ed04 	.word	0xe000ed04

00016d14 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
   16d14:	b500      	push	{lr}
   16d16:	b08b      	sub	sp, #44	; 0x2c
BaseType_t xReturn;

	/* Add the idle task at the lowest priority. */
	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
	{
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
   16d18:	2300      	movs	r3, #0
   16d1a:	9307      	str	r3, [sp, #28]
		StackType_t *pxIdleTaskStackBuffer = NULL;
   16d1c:	2300      	movs	r3, #0
   16d1e:	9306      	str	r3, [sp, #24]
		uint32_t ulIdleTaskStackSize;

		/* The Idle task is created using user provided RAM - obtain the
		address of the RAM then create the idle task. */
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
   16d20:	aa05      	add	r2, sp, #20
   16d22:	a906      	add	r1, sp, #24
   16d24:	ab07      	add	r3, sp, #28
   16d26:	4618      	mov	r0, r3
   16d28:	f7ff fa48 	bl	161bc <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
   16d2c:	9905      	ldr	r1, [sp, #20]
   16d2e:	9b06      	ldr	r3, [sp, #24]
   16d30:	9a07      	ldr	r2, [sp, #28]
   16d32:	9202      	str	r2, [sp, #8]
   16d34:	9301      	str	r3, [sp, #4]
   16d36:	2300      	movs	r3, #0
   16d38:	9300      	str	r3, [sp, #0]
   16d3a:	2300      	movs	r3, #0
   16d3c:	460a      	mov	r2, r1
   16d3e:	4916      	ldr	r1, [pc, #88]	; (16d98 <vTaskStartScheduler+0x84>)
   16d40:	4816      	ldr	r0, [pc, #88]	; (16d9c <vTaskStartScheduler+0x88>)
   16d42:	f7ff fe8a 	bl	16a5a <xTaskCreateStatic>
   16d46:	4602      	mov	r2, r0
   16d48:	4b15      	ldr	r3, [pc, #84]	; (16da0 <vTaskStartScheduler+0x8c>)
   16d4a:	601a      	str	r2, [r3, #0]
												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
												pxIdleTaskStackBuffer,
												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */

		if( xIdleTaskHandle != NULL )
   16d4c:	4b14      	ldr	r3, [pc, #80]	; (16da0 <vTaskStartScheduler+0x8c>)
   16d4e:	681b      	ldr	r3, [r3, #0]
   16d50:	2b00      	cmp	r3, #0
   16d52:	d002      	beq.n	16d5a <vTaskStartScheduler+0x46>
		{
			xReturn = pdPASS;
   16d54:	2301      	movs	r3, #1
   16d56:	9309      	str	r3, [sp, #36]	; 0x24
   16d58:	e001      	b.n	16d5e <vTaskStartScheduler+0x4a>
		}
		else
		{
			xReturn = pdFAIL;
   16d5a:	2300      	movs	r3, #0
   16d5c:	9309      	str	r3, [sp, #36]	; 0x24
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
   16d5e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   16d60:	2b01      	cmp	r3, #1
   16d62:	d114      	bne.n	16d8e <vTaskStartScheduler+0x7a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   16d64:	f04f 0328 	mov.w	r3, #40	; 0x28
   16d68:	f383 8811 	msr	BASEPRI, r3
   16d6c:	f3bf 8f6f 	isb	sy
   16d70:	f3bf 8f4f 	dsb	sy
   16d74:	9308      	str	r3, [sp, #32]
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
   16d76:	4b0b      	ldr	r3, [pc, #44]	; (16da4 <vTaskStartScheduler+0x90>)
   16d78:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16d7c:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
   16d7e:	4b0a      	ldr	r3, [pc, #40]	; (16da8 <vTaskStartScheduler+0x94>)
   16d80:	2201      	movs	r2, #1
   16d82:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
   16d84:	4b09      	ldr	r3, [pc, #36]	; (16dac <vTaskStartScheduler+0x98>)
   16d86:	2200      	movs	r2, #0
   16d88:	601a      	str	r2, [r3, #0]
		FreeRTOSConfig.h file. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
   16d8a:	f000 fad1 	bl	17330 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
   16d8e:	bf00      	nop
   16d90:	b00b      	add	sp, #44	; 0x2c
   16d92:	f85d fb04 	ldr.w	pc, [sp], #4
   16d96:	bf00      	nop
   16d98:	0001e39c 	.word	0x0001e39c
   16d9c:	000170fd 	.word	0x000170fd
   16da0:	10003374 	.word	0x10003374
   16da4:	10003370 	.word	0x10003370
   16da8:	1000335c 	.word	0x1000335c
   16dac:	10003354 	.word	0x10003354

00016db0 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
   16db0:	4b03      	ldr	r3, [pc, #12]	; (16dc0 <vTaskSuspendAll+0x10>)
   16db2:	681b      	ldr	r3, [r3, #0]
   16db4:	3301      	adds	r3, #1
   16db6:	4a02      	ldr	r2, [pc, #8]	; (16dc0 <vTaskSuspendAll+0x10>)
   16db8:	6013      	str	r3, [r2, #0]
}
   16dba:	bf00      	nop
   16dbc:	4770      	bx	lr
   16dbe:	bf00      	nop
   16dc0:	10003378 	.word	0x10003378

00016dc4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
   16dc4:	b500      	push	{lr}
   16dc6:	b085      	sub	sp, #20
TCB_t *pxTCB = NULL;
   16dc8:	2300      	movs	r3, #0
   16dca:	9303      	str	r3, [sp, #12]
BaseType_t xAlreadyYielded = pdFALSE;
   16dcc:	2300      	movs	r3, #0
   16dce:	9302      	str	r3, [sp, #8]
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
   16dd0:	f000 fad8 	bl	17384 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
   16dd4:	4b38      	ldr	r3, [pc, #224]	; (16eb8 <xTaskResumeAll+0xf4>)
   16dd6:	681b      	ldr	r3, [r3, #0]
   16dd8:	3b01      	subs	r3, #1
   16dda:	4a37      	ldr	r2, [pc, #220]	; (16eb8 <xTaskResumeAll+0xf4>)
   16ddc:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   16dde:	4b36      	ldr	r3, [pc, #216]	; (16eb8 <xTaskResumeAll+0xf4>)
   16de0:	681b      	ldr	r3, [r3, #0]
   16de2:	2b00      	cmp	r3, #0
   16de4:	d161      	bne.n	16eaa <xTaskResumeAll+0xe6>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   16de6:	4b35      	ldr	r3, [pc, #212]	; (16ebc <xTaskResumeAll+0xf8>)
   16de8:	681b      	ldr	r3, [r3, #0]
   16dea:	2b00      	cmp	r3, #0
   16dec:	d05d      	beq.n	16eaa <xTaskResumeAll+0xe6>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   16dee:	e02e      	b.n	16e4e <xTaskResumeAll+0x8a>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   16df0:	4b33      	ldr	r3, [pc, #204]	; (16ec0 <xTaskResumeAll+0xfc>)
   16df2:	68db      	ldr	r3, [r3, #12]
   16df4:	68db      	ldr	r3, [r3, #12]
   16df6:	9303      	str	r3, [sp, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   16df8:	9b03      	ldr	r3, [sp, #12]
   16dfa:	3318      	adds	r3, #24
   16dfc:	4618      	mov	r0, r3
   16dfe:	f7ff fe07 	bl	16a10 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   16e02:	9b03      	ldr	r3, [sp, #12]
   16e04:	3304      	adds	r3, #4
   16e06:	4618      	mov	r0, r3
   16e08:	f7ff fe02 	bl	16a10 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   16e0c:	9b03      	ldr	r3, [sp, #12]
   16e0e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   16e10:	2201      	movs	r2, #1
   16e12:	409a      	lsls	r2, r3
   16e14:	4b2b      	ldr	r3, [pc, #172]	; (16ec4 <xTaskResumeAll+0x100>)
   16e16:	681b      	ldr	r3, [r3, #0]
   16e18:	4313      	orrs	r3, r2
   16e1a:	4a2a      	ldr	r2, [pc, #168]	; (16ec4 <xTaskResumeAll+0x100>)
   16e1c:	6013      	str	r3, [r2, #0]
   16e1e:	9b03      	ldr	r3, [sp, #12]
   16e20:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   16e22:	4613      	mov	r3, r2
   16e24:	009b      	lsls	r3, r3, #2
   16e26:	4413      	add	r3, r2
   16e28:	009b      	lsls	r3, r3, #2
   16e2a:	4a27      	ldr	r2, [pc, #156]	; (16ec8 <xTaskResumeAll+0x104>)
   16e2c:	441a      	add	r2, r3
   16e2e:	9b03      	ldr	r3, [sp, #12]
   16e30:	3304      	adds	r3, #4
   16e32:	4619      	mov	r1, r3
   16e34:	4610      	mov	r0, r2
   16e36:	f7ff fdcc 	bl	169d2 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   16e3a:	9b03      	ldr	r3, [sp, #12]
   16e3c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   16e3e:	4b23      	ldr	r3, [pc, #140]	; (16ecc <xTaskResumeAll+0x108>)
   16e40:	681b      	ldr	r3, [r3, #0]
   16e42:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   16e44:	429a      	cmp	r2, r3
   16e46:	d302      	bcc.n	16e4e <xTaskResumeAll+0x8a>
					{
						xYieldPending = pdTRUE;
   16e48:	4b21      	ldr	r3, [pc, #132]	; (16ed0 <xTaskResumeAll+0x10c>)
   16e4a:	2201      	movs	r2, #1
   16e4c:	601a      	str	r2, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   16e4e:	4b1c      	ldr	r3, [pc, #112]	; (16ec0 <xTaskResumeAll+0xfc>)
   16e50:	681b      	ldr	r3, [r3, #0]
   16e52:	2b00      	cmp	r3, #0
   16e54:	d1cc      	bne.n	16df0 <xTaskResumeAll+0x2c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
   16e56:	9b03      	ldr	r3, [sp, #12]
   16e58:	2b00      	cmp	r3, #0
   16e5a:	d001      	beq.n	16e60 <xTaskResumeAll+0x9c>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
   16e5c:	f000 f9dc 	bl	17218 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   16e60:	4b1c      	ldr	r3, [pc, #112]	; (16ed4 <xTaskResumeAll+0x110>)
   16e62:	681b      	ldr	r3, [r3, #0]
   16e64:	9301      	str	r3, [sp, #4]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
   16e66:	9b01      	ldr	r3, [sp, #4]
   16e68:	2b00      	cmp	r3, #0
   16e6a:	d010      	beq.n	16e8e <xTaskResumeAll+0xca>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
   16e6c:	f000 f836 	bl	16edc <xTaskIncrementTick>
   16e70:	4603      	mov	r3, r0
   16e72:	2b00      	cmp	r3, #0
   16e74:	d002      	beq.n	16e7c <xTaskResumeAll+0xb8>
							{
								xYieldPending = pdTRUE;
   16e76:	4b16      	ldr	r3, [pc, #88]	; (16ed0 <xTaskResumeAll+0x10c>)
   16e78:	2201      	movs	r2, #1
   16e7a:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
   16e7c:	9b01      	ldr	r3, [sp, #4]
   16e7e:	3b01      	subs	r3, #1
   16e80:	9301      	str	r3, [sp, #4]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
   16e82:	9b01      	ldr	r3, [sp, #4]
   16e84:	2b00      	cmp	r3, #0
   16e86:	d1f1      	bne.n	16e6c <xTaskResumeAll+0xa8>

						uxPendedTicks = 0;
   16e88:	4b12      	ldr	r3, [pc, #72]	; (16ed4 <xTaskResumeAll+0x110>)
   16e8a:	2200      	movs	r2, #0
   16e8c:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
   16e8e:	4b10      	ldr	r3, [pc, #64]	; (16ed0 <xTaskResumeAll+0x10c>)
   16e90:	681b      	ldr	r3, [r3, #0]
   16e92:	2b00      	cmp	r3, #0
   16e94:	d009      	beq.n	16eaa <xTaskResumeAll+0xe6>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
   16e96:	2301      	movs	r3, #1
   16e98:	9302      	str	r3, [sp, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
   16e9a:	4b0f      	ldr	r3, [pc, #60]	; (16ed8 <xTaskResumeAll+0x114>)
   16e9c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   16ea0:	601a      	str	r2, [r3, #0]
   16ea2:	f3bf 8f4f 	dsb	sy
   16ea6:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   16eaa:	f000 fa7f 	bl	173ac <vPortExitCritical>

	return xAlreadyYielded;
   16eae:	9b02      	ldr	r3, [sp, #8]
}
   16eb0:	4618      	mov	r0, r3
   16eb2:	b005      	add	sp, #20
   16eb4:	f85d fb04 	ldr.w	pc, [sp], #4
   16eb8:	10003378 	.word	0x10003378
   16ebc:	10003350 	.word	0x10003350
   16ec0:	10003310 	.word	0x10003310
   16ec4:	10003358 	.word	0x10003358
   16ec8:	1000327c 	.word	0x1000327c
   16ecc:	10003278 	.word	0x10003278
   16ed0:	10003364 	.word	0x10003364
   16ed4:	10003360 	.word	0x10003360
   16ed8:	e000ed04 	.word	0xe000ed04

00016edc <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
   16edc:	b500      	push	{lr}
   16ede:	b087      	sub	sp, #28
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
   16ee0:	2300      	movs	r3, #0
   16ee2:	9305      	str	r3, [sp, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   16ee4:	4b48      	ldr	r3, [pc, #288]	; (17008 <xTaskIncrementTick+0x12c>)
   16ee6:	681b      	ldr	r3, [r3, #0]
   16ee8:	2b00      	cmp	r3, #0
   16eea:	d17c      	bne.n	16fe6 <xTaskIncrementTick+0x10a>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
   16eec:	4b47      	ldr	r3, [pc, #284]	; (1700c <xTaskIncrementTick+0x130>)
   16eee:	681b      	ldr	r3, [r3, #0]
   16ef0:	3301      	adds	r3, #1
   16ef2:	9304      	str	r3, [sp, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
   16ef4:	4a45      	ldr	r2, [pc, #276]	; (1700c <xTaskIncrementTick+0x130>)
   16ef6:	9b04      	ldr	r3, [sp, #16]
   16ef8:	6013      	str	r3, [r2, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
   16efa:	9b04      	ldr	r3, [sp, #16]
   16efc:	2b00      	cmp	r3, #0
   16efe:	d110      	bne.n	16f22 <xTaskIncrementTick+0x46>
		{
			taskSWITCH_DELAYED_LISTS();
   16f00:	4b43      	ldr	r3, [pc, #268]	; (17010 <xTaskIncrementTick+0x134>)
   16f02:	681b      	ldr	r3, [r3, #0]
   16f04:	9303      	str	r3, [sp, #12]
   16f06:	4b43      	ldr	r3, [pc, #268]	; (17014 <xTaskIncrementTick+0x138>)
   16f08:	681b      	ldr	r3, [r3, #0]
   16f0a:	4a41      	ldr	r2, [pc, #260]	; (17010 <xTaskIncrementTick+0x134>)
   16f0c:	6013      	str	r3, [r2, #0]
   16f0e:	4a41      	ldr	r2, [pc, #260]	; (17014 <xTaskIncrementTick+0x138>)
   16f10:	9b03      	ldr	r3, [sp, #12]
   16f12:	6013      	str	r3, [r2, #0]
   16f14:	4b40      	ldr	r3, [pc, #256]	; (17018 <xTaskIncrementTick+0x13c>)
   16f16:	681b      	ldr	r3, [r3, #0]
   16f18:	3301      	adds	r3, #1
   16f1a:	4a3f      	ldr	r2, [pc, #252]	; (17018 <xTaskIncrementTick+0x13c>)
   16f1c:	6013      	str	r3, [r2, #0]
   16f1e:	f000 f97b 	bl	17218 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
   16f22:	4b3e      	ldr	r3, [pc, #248]	; (1701c <xTaskIncrementTick+0x140>)
   16f24:	681b      	ldr	r3, [r3, #0]
   16f26:	9a04      	ldr	r2, [sp, #16]
   16f28:	429a      	cmp	r2, r3
   16f2a:	d34d      	bcc.n	16fc8 <xTaskIncrementTick+0xec>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   16f2c:	4b38      	ldr	r3, [pc, #224]	; (17010 <xTaskIncrementTick+0x134>)
   16f2e:	681b      	ldr	r3, [r3, #0]
   16f30:	681b      	ldr	r3, [r3, #0]
   16f32:	2b00      	cmp	r3, #0
   16f34:	d101      	bne.n	16f3a <xTaskIncrementTick+0x5e>
   16f36:	2301      	movs	r3, #1
   16f38:	e000      	b.n	16f3c <xTaskIncrementTick+0x60>
   16f3a:	2300      	movs	r3, #0
   16f3c:	2b00      	cmp	r3, #0
   16f3e:	d004      	beq.n	16f4a <xTaskIncrementTick+0x6e>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   16f40:	4b36      	ldr	r3, [pc, #216]	; (1701c <xTaskIncrementTick+0x140>)
   16f42:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16f46:	601a      	str	r2, [r3, #0]
					break;
   16f48:	e03e      	b.n	16fc8 <xTaskIncrementTick+0xec>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   16f4a:	4b31      	ldr	r3, [pc, #196]	; (17010 <xTaskIncrementTick+0x134>)
   16f4c:	681b      	ldr	r3, [r3, #0]
   16f4e:	68db      	ldr	r3, [r3, #12]
   16f50:	68db      	ldr	r3, [r3, #12]
   16f52:	9302      	str	r3, [sp, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   16f54:	9b02      	ldr	r3, [sp, #8]
   16f56:	685b      	ldr	r3, [r3, #4]
   16f58:	9301      	str	r3, [sp, #4]

					if( xConstTickCount < xItemValue )
   16f5a:	9a04      	ldr	r2, [sp, #16]
   16f5c:	9b01      	ldr	r3, [sp, #4]
   16f5e:	429a      	cmp	r2, r3
   16f60:	d203      	bcs.n	16f6a <xTaskIncrementTick+0x8e>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
   16f62:	4a2e      	ldr	r2, [pc, #184]	; (1701c <xTaskIncrementTick+0x140>)
   16f64:	9b01      	ldr	r3, [sp, #4]
   16f66:	6013      	str	r3, [r2, #0]
						break;
   16f68:	e02e      	b.n	16fc8 <xTaskIncrementTick+0xec>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   16f6a:	9b02      	ldr	r3, [sp, #8]
   16f6c:	3304      	adds	r3, #4
   16f6e:	4618      	mov	r0, r3
   16f70:	f7ff fd4e 	bl	16a10 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   16f74:	9b02      	ldr	r3, [sp, #8]
   16f76:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   16f78:	2b00      	cmp	r3, #0
   16f7a:	d004      	beq.n	16f86 <xTaskIncrementTick+0xaa>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   16f7c:	9b02      	ldr	r3, [sp, #8]
   16f7e:	3318      	adds	r3, #24
   16f80:	4618      	mov	r0, r3
   16f82:	f7ff fd45 	bl	16a10 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
   16f86:	9b02      	ldr	r3, [sp, #8]
   16f88:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   16f8a:	2201      	movs	r2, #1
   16f8c:	409a      	lsls	r2, r3
   16f8e:	4b24      	ldr	r3, [pc, #144]	; (17020 <xTaskIncrementTick+0x144>)
   16f90:	681b      	ldr	r3, [r3, #0]
   16f92:	4313      	orrs	r3, r2
   16f94:	4a22      	ldr	r2, [pc, #136]	; (17020 <xTaskIncrementTick+0x144>)
   16f96:	6013      	str	r3, [r2, #0]
   16f98:	9b02      	ldr	r3, [sp, #8]
   16f9a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   16f9c:	4613      	mov	r3, r2
   16f9e:	009b      	lsls	r3, r3, #2
   16fa0:	4413      	add	r3, r2
   16fa2:	009b      	lsls	r3, r3, #2
   16fa4:	4a1f      	ldr	r2, [pc, #124]	; (17024 <xTaskIncrementTick+0x148>)
   16fa6:	441a      	add	r2, r3
   16fa8:	9b02      	ldr	r3, [sp, #8]
   16faa:	3304      	adds	r3, #4
   16fac:	4619      	mov	r1, r3
   16fae:	4610      	mov	r0, r2
   16fb0:	f7ff fd0f 	bl	169d2 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   16fb4:	9b02      	ldr	r3, [sp, #8]
   16fb6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   16fb8:	4b1b      	ldr	r3, [pc, #108]	; (17028 <xTaskIncrementTick+0x14c>)
   16fba:	681b      	ldr	r3, [r3, #0]
   16fbc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   16fbe:	429a      	cmp	r2, r3
   16fc0:	d3b4      	bcc.n	16f2c <xTaskIncrementTick+0x50>
						{
							xSwitchRequired = pdTRUE;
   16fc2:	2301      	movs	r3, #1
   16fc4:	9305      	str	r3, [sp, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   16fc6:	e7b1      	b.n	16f2c <xTaskIncrementTick+0x50>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   16fc8:	4b17      	ldr	r3, [pc, #92]	; (17028 <xTaskIncrementTick+0x14c>)
   16fca:	681b      	ldr	r3, [r3, #0]
   16fcc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   16fce:	4915      	ldr	r1, [pc, #84]	; (17024 <xTaskIncrementTick+0x148>)
   16fd0:	4613      	mov	r3, r2
   16fd2:	009b      	lsls	r3, r3, #2
   16fd4:	4413      	add	r3, r2
   16fd6:	009b      	lsls	r3, r3, #2
   16fd8:	440b      	add	r3, r1
   16fda:	681b      	ldr	r3, [r3, #0]
   16fdc:	2b01      	cmp	r3, #1
   16fde:	d907      	bls.n	16ff0 <xTaskIncrementTick+0x114>
			{
				xSwitchRequired = pdTRUE;
   16fe0:	2301      	movs	r3, #1
   16fe2:	9305      	str	r3, [sp, #20]
   16fe4:	e004      	b.n	16ff0 <xTaskIncrementTick+0x114>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
   16fe6:	4b11      	ldr	r3, [pc, #68]	; (1702c <xTaskIncrementTick+0x150>)
   16fe8:	681b      	ldr	r3, [r3, #0]
   16fea:	3301      	adds	r3, #1
   16fec:	4a0f      	ldr	r2, [pc, #60]	; (1702c <xTaskIncrementTick+0x150>)
   16fee:	6013      	str	r3, [r2, #0]
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
   16ff0:	4b0f      	ldr	r3, [pc, #60]	; (17030 <xTaskIncrementTick+0x154>)
   16ff2:	681b      	ldr	r3, [r3, #0]
   16ff4:	2b00      	cmp	r3, #0
   16ff6:	d001      	beq.n	16ffc <xTaskIncrementTick+0x120>
		{
			xSwitchRequired = pdTRUE;
   16ff8:	2301      	movs	r3, #1
   16ffa:	9305      	str	r3, [sp, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
   16ffc:	9b05      	ldr	r3, [sp, #20]
}
   16ffe:	4618      	mov	r0, r3
   17000:	b007      	add	sp, #28
   17002:	f85d fb04 	ldr.w	pc, [sp], #4
   17006:	bf00      	nop
   17008:	10003378 	.word	0x10003378
   1700c:	10003354 	.word	0x10003354
   17010:	10003308 	.word	0x10003308
   17014:	1000330c 	.word	0x1000330c
   17018:	10003368 	.word	0x10003368
   1701c:	10003370 	.word	0x10003370
   17020:	10003358 	.word	0x10003358
   17024:	1000327c 	.word	0x1000327c
   17028:	10003278 	.word	0x10003278
   1702c:	10003360 	.word	0x10003360
   17030:	10003364 	.word	0x10003364

00017034 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
   17034:	b510      	push	{r4, lr}
   17036:	b084      	sub	sp, #16
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   17038:	4b29      	ldr	r3, [pc, #164]	; (170e0 <vTaskSwitchContext+0xac>)
   1703a:	681b      	ldr	r3, [r3, #0]
   1703c:	2b00      	cmp	r3, #0
   1703e:	d003      	beq.n	17048 <vTaskSwitchContext+0x14>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
   17040:	4b28      	ldr	r3, [pc, #160]	; (170e4 <vTaskSwitchContext+0xb0>)
   17042:	2201      	movs	r2, #1
   17044:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
   17046:	e047      	b.n	170d8 <vTaskSwitchContext+0xa4>
		xYieldPending = pdFALSE;
   17048:	4b26      	ldr	r3, [pc, #152]	; (170e4 <vTaskSwitchContext+0xb0>)
   1704a:	2200      	movs	r2, #0
   1704c:	601a      	str	r2, [r3, #0]
					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   1704e:	f7ff f87f 	bl	16150 <UptimeRTOS>
   17052:	4603      	mov	r3, r0
   17054:	460c      	mov	r4, r1
   17056:	461a      	mov	r2, r3
   17058:	4b23      	ldr	r3, [pc, #140]	; (170e8 <vTaskSwitchContext+0xb4>)
   1705a:	601a      	str	r2, [r3, #0]
				if( ulTotalRunTime > ulTaskSwitchedInTime )
   1705c:	4b22      	ldr	r3, [pc, #136]	; (170e8 <vTaskSwitchContext+0xb4>)
   1705e:	681a      	ldr	r2, [r3, #0]
   17060:	4b22      	ldr	r3, [pc, #136]	; (170ec <vTaskSwitchContext+0xb8>)
   17062:	681b      	ldr	r3, [r3, #0]
   17064:	429a      	cmp	r2, r3
   17066:	d909      	bls.n	1707c <vTaskSwitchContext+0x48>
					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   17068:	4b21      	ldr	r3, [pc, #132]	; (170f0 <vTaskSwitchContext+0xbc>)
   1706a:	681b      	ldr	r3, [r3, #0]
   1706c:	6d59      	ldr	r1, [r3, #84]	; 0x54
   1706e:	4a1e      	ldr	r2, [pc, #120]	; (170e8 <vTaskSwitchContext+0xb4>)
   17070:	6810      	ldr	r0, [r2, #0]
   17072:	4a1e      	ldr	r2, [pc, #120]	; (170ec <vTaskSwitchContext+0xb8>)
   17074:	6812      	ldr	r2, [r2, #0]
   17076:	1a82      	subs	r2, r0, r2
   17078:	440a      	add	r2, r1
   1707a:	655a      	str	r2, [r3, #84]	; 0x54
				ulTaskSwitchedInTime = ulTotalRunTime;
   1707c:	4b1a      	ldr	r3, [pc, #104]	; (170e8 <vTaskSwitchContext+0xb4>)
   1707e:	681b      	ldr	r3, [r3, #0]
   17080:	4a1a      	ldr	r2, [pc, #104]	; (170ec <vTaskSwitchContext+0xb8>)
   17082:	6013      	str	r3, [r2, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
   17084:	4b1b      	ldr	r3, [pc, #108]	; (170f4 <vTaskSwitchContext+0xc0>)
   17086:	681b      	ldr	r3, [r3, #0]
   17088:	9301      	str	r3, [sp, #4]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
   1708a:	9b01      	ldr	r3, [sp, #4]
   1708c:	fab3 f383 	clz	r3, r3
   17090:	f88d 3003 	strb.w	r3, [sp, #3]
		return ucReturn;
   17094:	f89d 3003 	ldrb.w	r3, [sp, #3]
   17098:	f1c3 031f 	rsb	r3, r3, #31
   1709c:	9303      	str	r3, [sp, #12]
   1709e:	9a03      	ldr	r2, [sp, #12]
   170a0:	4613      	mov	r3, r2
   170a2:	009b      	lsls	r3, r3, #2
   170a4:	4413      	add	r3, r2
   170a6:	009b      	lsls	r3, r3, #2
   170a8:	4a13      	ldr	r2, [pc, #76]	; (170f8 <vTaskSwitchContext+0xc4>)
   170aa:	4413      	add	r3, r2
   170ac:	9302      	str	r3, [sp, #8]
   170ae:	9b02      	ldr	r3, [sp, #8]
   170b0:	685b      	ldr	r3, [r3, #4]
   170b2:	685a      	ldr	r2, [r3, #4]
   170b4:	9b02      	ldr	r3, [sp, #8]
   170b6:	605a      	str	r2, [r3, #4]
   170b8:	9b02      	ldr	r3, [sp, #8]
   170ba:	685a      	ldr	r2, [r3, #4]
   170bc:	9b02      	ldr	r3, [sp, #8]
   170be:	3308      	adds	r3, #8
   170c0:	429a      	cmp	r2, r3
   170c2:	d104      	bne.n	170ce <vTaskSwitchContext+0x9a>
   170c4:	9b02      	ldr	r3, [sp, #8]
   170c6:	685b      	ldr	r3, [r3, #4]
   170c8:	685a      	ldr	r2, [r3, #4]
   170ca:	9b02      	ldr	r3, [sp, #8]
   170cc:	605a      	str	r2, [r3, #4]
   170ce:	9b02      	ldr	r3, [sp, #8]
   170d0:	685b      	ldr	r3, [r3, #4]
   170d2:	68db      	ldr	r3, [r3, #12]
   170d4:	4a06      	ldr	r2, [pc, #24]	; (170f0 <vTaskSwitchContext+0xbc>)
   170d6:	6013      	str	r3, [r2, #0]
}
   170d8:	bf00      	nop
   170da:	b004      	add	sp, #16
   170dc:	bd10      	pop	{r4, pc}
   170de:	bf00      	nop
   170e0:	10003378 	.word	0x10003378
   170e4:	10003364 	.word	0x10003364
   170e8:	10003380 	.word	0x10003380
   170ec:	1000337c 	.word	0x1000337c
   170f0:	10003278 	.word	0x10003278
   170f4:	10003358 	.word	0x10003358
   170f8:	1000327c 	.word	0x1000327c

000170fc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
   170fc:	b500      	push	{lr}
   170fe:	b083      	sub	sp, #12
   17100:	9001      	str	r0, [sp, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
   17102:	f000 f83f 	bl	17184 <prvCheckTasksWaitingTermination>
   17106:	e7fc      	b.n	17102 <prvIdleTask+0x6>

00017108 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
   17108:	b500      	push	{lr}
   1710a:	b083      	sub	sp, #12
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   1710c:	2300      	movs	r3, #0
   1710e:	9301      	str	r3, [sp, #4]
   17110:	e00c      	b.n	1712c <prvInitialiseTaskLists+0x24>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   17112:	9a01      	ldr	r2, [sp, #4]
   17114:	4613      	mov	r3, r2
   17116:	009b      	lsls	r3, r3, #2
   17118:	4413      	add	r3, r2
   1711a:	009b      	lsls	r3, r3, #2
   1711c:	4a11      	ldr	r2, [pc, #68]	; (17164 <prvInitialiseTaskLists+0x5c>)
   1711e:	4413      	add	r3, r2
   17120:	4618      	mov	r0, r3
   17122:	f7ff fc33 	bl	1698c <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   17126:	9b01      	ldr	r3, [sp, #4]
   17128:	3301      	adds	r3, #1
   1712a:	9301      	str	r3, [sp, #4]
   1712c:	9b01      	ldr	r3, [sp, #4]
   1712e:	2b04      	cmp	r3, #4
   17130:	d9ef      	bls.n	17112 <prvInitialiseTaskLists+0xa>
	}

	vListInitialise( &xDelayedTaskList1 );
   17132:	480d      	ldr	r0, [pc, #52]	; (17168 <prvInitialiseTaskLists+0x60>)
   17134:	f7ff fc2a 	bl	1698c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
   17138:	480c      	ldr	r0, [pc, #48]	; (1716c <prvInitialiseTaskLists+0x64>)
   1713a:	f7ff fc27 	bl	1698c <vListInitialise>
	vListInitialise( &xPendingReadyList );
   1713e:	480c      	ldr	r0, [pc, #48]	; (17170 <prvInitialiseTaskLists+0x68>)
   17140:	f7ff fc24 	bl	1698c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
   17144:	480b      	ldr	r0, [pc, #44]	; (17174 <prvInitialiseTaskLists+0x6c>)
   17146:	f7ff fc21 	bl	1698c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
   1714a:	480b      	ldr	r0, [pc, #44]	; (17178 <prvInitialiseTaskLists+0x70>)
   1714c:	f7ff fc1e 	bl	1698c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
   17150:	4b0a      	ldr	r3, [pc, #40]	; (1717c <prvInitialiseTaskLists+0x74>)
   17152:	4a05      	ldr	r2, [pc, #20]	; (17168 <prvInitialiseTaskLists+0x60>)
   17154:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   17156:	4b0a      	ldr	r3, [pc, #40]	; (17180 <prvInitialiseTaskLists+0x78>)
   17158:	4a04      	ldr	r2, [pc, #16]	; (1716c <prvInitialiseTaskLists+0x64>)
   1715a:	601a      	str	r2, [r3, #0]
}
   1715c:	bf00      	nop
   1715e:	b003      	add	sp, #12
   17160:	f85d fb04 	ldr.w	pc, [sp], #4
   17164:	1000327c 	.word	0x1000327c
   17168:	100032e0 	.word	0x100032e0
   1716c:	100032f4 	.word	0x100032f4
   17170:	10003310 	.word	0x10003310
   17174:	10003324 	.word	0x10003324
   17178:	1000333c 	.word	0x1000333c
   1717c:	10003308 	.word	0x10003308
   17180:	1000330c 	.word	0x1000330c

00017184 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
   17184:	b500      	push	{lr}
   17186:	b083      	sub	sp, #12
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent vTaskSuspendAll()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   17188:	e019      	b.n	171be <prvCheckTasksWaitingTermination+0x3a>
		{
			taskENTER_CRITICAL();
   1718a:	f000 f8fb 	bl	17384 <vPortEnterCritical>
			{
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   1718e:	4b10      	ldr	r3, [pc, #64]	; (171d0 <prvCheckTasksWaitingTermination+0x4c>)
   17190:	68db      	ldr	r3, [r3, #12]
   17192:	68db      	ldr	r3, [r3, #12]
   17194:	9301      	str	r3, [sp, #4]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   17196:	9b01      	ldr	r3, [sp, #4]
   17198:	3304      	adds	r3, #4
   1719a:	4618      	mov	r0, r3
   1719c:	f7ff fc38 	bl	16a10 <uxListRemove>
				--uxCurrentNumberOfTasks;
   171a0:	4b0c      	ldr	r3, [pc, #48]	; (171d4 <prvCheckTasksWaitingTermination+0x50>)
   171a2:	681b      	ldr	r3, [r3, #0]
   171a4:	3b01      	subs	r3, #1
   171a6:	4a0b      	ldr	r2, [pc, #44]	; (171d4 <prvCheckTasksWaitingTermination+0x50>)
   171a8:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
   171aa:	4b0b      	ldr	r3, [pc, #44]	; (171d8 <prvCheckTasksWaitingTermination+0x54>)
   171ac:	681b      	ldr	r3, [r3, #0]
   171ae:	3b01      	subs	r3, #1
   171b0:	4a09      	ldr	r2, [pc, #36]	; (171d8 <prvCheckTasksWaitingTermination+0x54>)
   171b2:	6013      	str	r3, [r2, #0]
			}
			taskEXIT_CRITICAL();
   171b4:	f000 f8fa 	bl	173ac <vPortExitCritical>

			prvDeleteTCB( pxTCB );
   171b8:	9801      	ldr	r0, [sp, #4]
   171ba:	f000 f80f 	bl	171dc <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   171be:	4b06      	ldr	r3, [pc, #24]	; (171d8 <prvCheckTasksWaitingTermination+0x54>)
   171c0:	681b      	ldr	r3, [r3, #0]
   171c2:	2b00      	cmp	r3, #0
   171c4:	d1e1      	bne.n	1718a <prvCheckTasksWaitingTermination+0x6>
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
   171c6:	bf00      	nop
   171c8:	b003      	add	sp, #12
   171ca:	f85d fb04 	ldr.w	pc, [sp], #4
   171ce:	bf00      	nop
   171d0:	10003324 	.word	0x10003324
   171d4:	10003350 	.word	0x10003350
   171d8:	10003338 	.word	0x10003338

000171dc <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
   171dc:	b500      	push	{lr}
   171de:	b083      	sub	sp, #12
   171e0:	9001      	str	r0, [sp, #4]
		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
		{
			/* The task could have been allocated statically or dynamically, so
			check what was statically allocated before trying to free the
			memory. */
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
   171e2:	9b01      	ldr	r3, [sp, #4]
   171e4:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
   171e8:	2b00      	cmp	r3, #0
   171ea:	d108      	bne.n	171fe <prvDeleteTCB+0x22>
			{
				/* Both the stack and TCB were allocated dynamically, so both
				must be freed. */
				vPortFree( pxTCB->pxStack );
   171ec:	9b01      	ldr	r3, [sp, #4]
   171ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   171f0:	4618      	mov	r0, r3
   171f2:	f000 f964 	bl	174be <vPortFree>
				vPortFree( pxTCB );
   171f6:	9801      	ldr	r0, [sp, #4]
   171f8:	f000 f961 	bl	174be <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
   171fc:	e007      	b.n	1720e <prvDeleteTCB+0x32>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
   171fe:	9b01      	ldr	r3, [sp, #4]
   17200:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
   17204:	2b01      	cmp	r3, #1
   17206:	d102      	bne.n	1720e <prvDeleteTCB+0x32>
				vPortFree( pxTCB );
   17208:	9801      	ldr	r0, [sp, #4]
   1720a:	f000 f958 	bl	174be <vPortFree>
	}
   1720e:	bf00      	nop
   17210:	b003      	add	sp, #12
   17212:	f85d fb04 	ldr.w	pc, [sp], #4
   17216:	Address 0x0000000000017216 is out of bounds.


00017218 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
   17218:	b082      	sub	sp, #8
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   1721a:	4b0d      	ldr	r3, [pc, #52]	; (17250 <prvResetNextTaskUnblockTime+0x38>)
   1721c:	681b      	ldr	r3, [r3, #0]
   1721e:	681b      	ldr	r3, [r3, #0]
   17220:	2b00      	cmp	r3, #0
   17222:	d101      	bne.n	17228 <prvResetNextTaskUnblockTime+0x10>
   17224:	2301      	movs	r3, #1
   17226:	e000      	b.n	1722a <prvResetNextTaskUnblockTime+0x12>
   17228:	2300      	movs	r3, #0
   1722a:	2b00      	cmp	r3, #0
   1722c:	d004      	beq.n	17238 <prvResetNextTaskUnblockTime+0x20>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   1722e:	4b09      	ldr	r3, [pc, #36]	; (17254 <prvResetNextTaskUnblockTime+0x3c>)
   17230:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17234:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
   17236:	e008      	b.n	1724a <prvResetNextTaskUnblockTime+0x32>
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   17238:	4b05      	ldr	r3, [pc, #20]	; (17250 <prvResetNextTaskUnblockTime+0x38>)
   1723a:	681b      	ldr	r3, [r3, #0]
   1723c:	68db      	ldr	r3, [r3, #12]
   1723e:	68db      	ldr	r3, [r3, #12]
   17240:	9301      	str	r3, [sp, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   17242:	9b01      	ldr	r3, [sp, #4]
   17244:	685b      	ldr	r3, [r3, #4]
   17246:	4a03      	ldr	r2, [pc, #12]	; (17254 <prvResetNextTaskUnblockTime+0x3c>)
   17248:	6013      	str	r3, [r2, #0]
}
   1724a:	bf00      	nop
   1724c:	b002      	add	sp, #8
   1724e:	4770      	bx	lr
   17250:	10003308 	.word	0x10003308
   17254:	10003370 	.word	0x10003370

00017258 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
   17258:	b084      	sub	sp, #16
   1725a:	9003      	str	r0, [sp, #12]
   1725c:	9102      	str	r1, [sp, #8]
   1725e:	9201      	str	r2, [sp, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
   17260:	9b03      	ldr	r3, [sp, #12]
   17262:	3b04      	subs	r3, #4
   17264:	9303      	str	r3, [sp, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   17266:	9b03      	ldr	r3, [sp, #12]
   17268:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   1726c:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   1726e:	9b03      	ldr	r3, [sp, #12]
   17270:	3b04      	subs	r3, #4
   17272:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
   17274:	9b02      	ldr	r3, [sp, #8]
   17276:	f023 0201 	bic.w	r2, r3, #1
   1727a:	9b03      	ldr	r3, [sp, #12]
   1727c:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   1727e:	9b03      	ldr	r3, [sp, #12]
   17280:	3b04      	subs	r3, #4
   17282:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
   17284:	4a0b      	ldr	r2, [pc, #44]	; (172b4 <pxPortInitialiseStack+0x5c>)
   17286:	9b03      	ldr	r3, [sp, #12]
   17288:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
   1728a:	9b03      	ldr	r3, [sp, #12]
   1728c:	3b14      	subs	r3, #20
   1728e:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   17290:	9a01      	ldr	r2, [sp, #4]
   17292:	9b03      	ldr	r3, [sp, #12]
   17294:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
   17296:	9b03      	ldr	r3, [sp, #12]
   17298:	3b04      	subs	r3, #4
   1729a:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
   1729c:	9b03      	ldr	r3, [sp, #12]
   1729e:	f06f 0202 	mvn.w	r2, #2
   172a2:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
   172a4:	9b03      	ldr	r3, [sp, #12]
   172a6:	3b20      	subs	r3, #32
   172a8:	9303      	str	r3, [sp, #12]

	return pxTopOfStack;
   172aa:	9b03      	ldr	r3, [sp, #12]
}
   172ac:	4618      	mov	r0, r3
   172ae:	b004      	add	sp, #16
   172b0:	4770      	bx	lr
   172b2:	bf00      	nop
   172b4:	000172b9 	.word	0x000172b9

000172b8 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
   172b8:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
   172ba:	2300      	movs	r3, #0
   172bc:	9300      	str	r3, [sp, #0]
	__asm volatile
   172be:	f04f 0328 	mov.w	r3, #40	; 0x28
   172c2:	f383 8811 	msr	BASEPRI, r3
   172c6:	f3bf 8f6f 	isb	sy
   172ca:	f3bf 8f4f 	dsb	sy
   172ce:	9301      	str	r3, [sp, #4]

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
   172d0:	bf00      	nop
   172d2:	9b00      	ldr	r3, [sp, #0]
   172d4:	2b00      	cmp	r3, #0
   172d6:	d0fc      	beq.n	172d2 <prvTaskExitError+0x1a>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
   172d8:	bf00      	nop
   172da:	b002      	add	sp, #8
   172dc:	4770      	bx	lr
   172de:	Address 0x00000000000172de is out of bounds.


000172e0 <vPortSVCHandler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
   172e0:	4b07      	ldr	r3, [pc, #28]	; (17300 <pxCurrentTCBConst2>)
   172e2:	6819      	ldr	r1, [r3, #0]
   172e4:	6808      	ldr	r0, [r1, #0]
   172e6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   172ea:	f380 8809 	msr	PSP, r0
   172ee:	f3bf 8f6f 	isb	sy
   172f2:	f04f 0000 	mov.w	r0, #0
   172f6:	f380 8811 	msr	BASEPRI, r0
   172fa:	4770      	bx	lr
   172fc:	f3af 8000 	nop.w

00017300 <pxCurrentTCBConst2>:
   17300:	10003278 	.word	0x10003278
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
   17304:	bf00      	nop
   17306:	bf00      	nop

00017308 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
   17308:	4808      	ldr	r0, [pc, #32]	; (1732c <prvPortStartFirstTask+0x24>)
   1730a:	6800      	ldr	r0, [r0, #0]
   1730c:	6800      	ldr	r0, [r0, #0]
   1730e:	f380 8808 	msr	MSP, r0
   17312:	f04f 0000 	mov.w	r0, #0
   17316:	f380 8814 	msr	CONTROL, r0
   1731a:	b662      	cpsie	i
   1731c:	b661      	cpsie	f
   1731e:	f3bf 8f4f 	dsb	sy
   17322:	f3bf 8f6f 	isb	sy
   17326:	df00      	svc	0
   17328:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
   1732a:	bf00      	nop
   1732c:	e000ed08 	.word	0xe000ed08

00017330 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
   17330:	b508      	push	{r3, lr}
		*pucFirstUserPriorityRegister = ulOriginalPriority;
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
   17332:	4b11      	ldr	r3, [pc, #68]	; (17378 <xPortStartScheduler+0x48>)
   17334:	681b      	ldr	r3, [r3, #0]
   17336:	4a10      	ldr	r2, [pc, #64]	; (17378 <xPortStartScheduler+0x48>)
   17338:	f443 0378 	orr.w	r3, r3, #16252928	; 0xf80000
   1733c:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
   1733e:	4b0e      	ldr	r3, [pc, #56]	; (17378 <xPortStartScheduler+0x48>)
   17340:	681b      	ldr	r3, [r3, #0]
   17342:	4a0d      	ldr	r2, [pc, #52]	; (17378 <xPortStartScheduler+0x48>)
   17344:	f043 4378 	orr.w	r3, r3, #4160749568	; 0xf8000000
   17348:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
   1734a:	f7fe ff51 	bl	161f0 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
   1734e:	4b0b      	ldr	r3, [pc, #44]	; (1737c <xPortStartScheduler+0x4c>)
   17350:	2200      	movs	r2, #0
   17352:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
   17354:	f000 f898 	bl	17488 <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
   17358:	4b09      	ldr	r3, [pc, #36]	; (17380 <xPortStartScheduler+0x50>)
   1735a:	681b      	ldr	r3, [r3, #0]
   1735c:	4a08      	ldr	r2, [pc, #32]	; (17380 <xPortStartScheduler+0x50>)
   1735e:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
   17362:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
   17364:	f7ff ffd0 	bl	17308 <prvPortStartFirstTask>
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
   17368:	f7ff fe64 	bl	17034 <vTaskSwitchContext>
	prvTaskExitError();
   1736c:	f7ff ffa4 	bl	172b8 <prvTaskExitError>

	/* Should not get here! */
	return 0;
   17370:	2300      	movs	r3, #0
}
   17372:	4618      	mov	r0, r3
   17374:	bd08      	pop	{r3, pc}
   17376:	bf00      	nop
   17378:	e000ed20 	.word	0xe000ed20
   1737c:	10000650 	.word	0x10000650
   17380:	e000ef34 	.word	0xe000ef34

00017384 <vPortEnterCritical>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
   17384:	b082      	sub	sp, #8
   17386:	f04f 0328 	mov.w	r3, #40	; 0x28
   1738a:	f383 8811 	msr	BASEPRI, r3
   1738e:	f3bf 8f6f 	isb	sy
   17392:	f3bf 8f4f 	dsb	sy
   17396:	9301      	str	r3, [sp, #4]
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
   17398:	4b03      	ldr	r3, [pc, #12]	; (173a8 <vPortEnterCritical+0x24>)
   1739a:	681b      	ldr	r3, [r3, #0]
   1739c:	3301      	adds	r3, #1
   1739e:	4a02      	ldr	r2, [pc, #8]	; (173a8 <vPortEnterCritical+0x24>)
   173a0:	6013      	str	r3, [r2, #0]
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
	}
}
   173a2:	bf00      	nop
   173a4:	b002      	add	sp, #8
   173a6:	4770      	bx	lr
   173a8:	10000650 	.word	0x10000650

000173ac <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
   173ac:	b082      	sub	sp, #8
	configASSERT( uxCriticalNesting );
	uxCriticalNesting--;
   173ae:	4b08      	ldr	r3, [pc, #32]	; (173d0 <vPortExitCritical+0x24>)
   173b0:	681b      	ldr	r3, [r3, #0]
   173b2:	3b01      	subs	r3, #1
   173b4:	4a06      	ldr	r2, [pc, #24]	; (173d0 <vPortExitCritical+0x24>)
   173b6:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
   173b8:	4b05      	ldr	r3, [pc, #20]	; (173d0 <vPortExitCritical+0x24>)
   173ba:	681b      	ldr	r3, [r3, #0]
   173bc:	2b00      	cmp	r3, #0
   173be:	d104      	bne.n	173ca <vPortExitCritical+0x1e>
   173c0:	2300      	movs	r3, #0
   173c2:	9301      	str	r3, [sp, #4]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   173c4:	9b01      	ldr	r3, [sp, #4]
   173c6:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
   173ca:	bf00      	nop
   173cc:	b002      	add	sp, #8
   173ce:	4770      	bx	lr
   173d0:	10000650 	.word	0x10000650
   173d4:	ffffffff 	.word	0xffffffff
   173d8:	ffffffff 	.word	0xffffffff
   173dc:	ffffffff 	.word	0xffffffff

000173e0 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
   173e0:	f3ef 8009 	mrs	r0, PSP
   173e4:	f3bf 8f6f 	isb	sy
   173e8:	4b15      	ldr	r3, [pc, #84]	; (17440 <pxCurrentTCBConst>)
   173ea:	681a      	ldr	r2, [r3, #0]
   173ec:	f01e 0f10 	tst.w	lr, #16
   173f0:	bf08      	it	eq
   173f2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
   173f6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   173fa:	6010      	str	r0, [r2, #0]
   173fc:	e92d 0009 	stmdb	sp!, {r0, r3}
   17400:	f04f 0028 	mov.w	r0, #40	; 0x28
   17404:	f380 8811 	msr	BASEPRI, r0
   17408:	f3bf 8f4f 	dsb	sy
   1740c:	f3bf 8f6f 	isb	sy
   17410:	f7ff fe10 	bl	17034 <vTaskSwitchContext>
   17414:	f04f 0000 	mov.w	r0, #0
   17418:	f380 8811 	msr	BASEPRI, r0
   1741c:	bc09      	pop	{r0, r3}
   1741e:	6819      	ldr	r1, [r3, #0]
   17420:	6808      	ldr	r0, [r1, #0]
   17422:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17426:	f01e 0f10 	tst.w	lr, #16
   1742a:	bf08      	it	eq
   1742c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
   17430:	f380 8809 	msr	PSP, r0
   17434:	f3bf 8f6f 	isb	sy
   17438:	4770      	bx	lr
   1743a:	bf00      	nop
   1743c:	f3af 8000 	nop.w

00017440 <pxCurrentTCBConst>:
   17440:	10003278 	.word	0x10003278
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
   17444:	bf00      	nop
   17446:	bf00      	nop

00017448 <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
   17448:	b500      	push	{lr}
   1744a:	b083      	sub	sp, #12
	__asm volatile
   1744c:	f04f 0328 	mov.w	r3, #40	; 0x28
   17450:	f383 8811 	msr	BASEPRI, r3
   17454:	f3bf 8f6f 	isb	sy
   17458:	f3bf 8f4f 	dsb	sy
   1745c:	9301      	str	r3, [sp, #4]
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
   1745e:	f7ff fd3d 	bl	16edc <xTaskIncrementTick>
   17462:	4603      	mov	r3, r0
   17464:	2b00      	cmp	r3, #0
   17466:	d003      	beq.n	17470 <xPortSysTickHandler+0x28>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   17468:	4b06      	ldr	r3, [pc, #24]	; (17484 <xPortSysTickHandler+0x3c>)
   1746a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1746e:	601a      	str	r2, [r3, #0]
   17470:	2300      	movs	r3, #0
   17472:	9300      	str	r3, [sp, #0]
	__asm volatile
   17474:	9b00      	ldr	r3, [sp, #0]
   17476:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
   1747a:	bf00      	nop
   1747c:	b003      	add	sp, #12
   1747e:	f85d fb04 	ldr.w	pc, [sp], #4
   17482:	bf00      	nop
   17484:	e000ed04 	.word	0xe000ed04

00017488 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
   17488:	f8df 000c 	ldr.w	r0, [pc, #12]	; 17498 <vPortEnableVFP+0x10>
   1748c:	6801      	ldr	r1, [r0, #0]
   1748e:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   17492:	6001      	str	r1, [r0, #0]
   17494:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
   17496:	bf00      	nop
   17498:	e000ed88 	.word	0xe000ed88

0001749c <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   1749c:	b500      	push	{lr}
   1749e:	b085      	sub	sp, #20
   174a0:	9001      	str	r0, [sp, #4]
void *pvReturn;

	vTaskSuspendAll();
   174a2:	f7ff fc85 	bl	16db0 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
   174a6:	9801      	ldr	r0, [sp, #4]
   174a8:	f005 fa36 	bl	1c918 <malloc>
   174ac:	4603      	mov	r3, r0
   174ae:	9303      	str	r3, [sp, #12]
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
   174b0:	f7ff fc88 	bl	16dc4 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
   174b4:	9b03      	ldr	r3, [sp, #12]
}
   174b6:	4618      	mov	r0, r3
   174b8:	b005      	add	sp, #20
   174ba:	f85d fb04 	ldr.w	pc, [sp], #4

000174be <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
   174be:	b500      	push	{lr}
   174c0:	b083      	sub	sp, #12
   174c2:	9001      	str	r0, [sp, #4]
	if( pv )
   174c4:	9b01      	ldr	r3, [sp, #4]
   174c6:	2b00      	cmp	r3, #0
   174c8:	d006      	beq.n	174d8 <vPortFree+0x1a>
	{
		vTaskSuspendAll();
   174ca:	f7ff fc71 	bl	16db0 <vTaskSuspendAll>
		{
			free( pv );
   174ce:	9801      	ldr	r0, [sp, #4]
   174d0:	f005 fa2a 	bl	1c928 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
   174d4:	f7ff fc76 	bl	16dc4 <xTaskResumeAll>
	}
}
   174d8:	bf00      	nop
   174da:	b003      	add	sp, #12
   174dc:	f85d fb04 	ldr.w	pc, [sp], #4

000174e0 <_out_buffer(char, void*, unsigned int, unsigned int)>:
} out_fct_wrap_type;


// internal buffer output
static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)
{
   174e0:	b510      	push	{r4, lr}
   174e2:	b084      	sub	sp, #16
   174e4:	4674      	mov	r4, lr
   174e6:	9102      	str	r1, [sp, #8]
   174e8:	9201      	str	r2, [sp, #4]
   174ea:	9300      	str	r3, [sp, #0]
   174ec:	4603      	mov	r3, r0
   174ee:	f88d 300f 	strb.w	r3, [sp, #15]
   174f2:	4623      	mov	r3, r4
   174f4:	4619      	mov	r1, r3
   174f6:	480a      	ldr	r0, [pc, #40]	; (17520 <_out_buffer(char, void*, unsigned int, unsigned int)+0x40>)
   174f8:	f7ff f9fc 	bl	168f4 <__cyg_profile_func_enter>
  if (idx < maxlen) {
   174fc:	9a01      	ldr	r2, [sp, #4]
   174fe:	9b00      	ldr	r3, [sp, #0]
   17500:	429a      	cmp	r2, r3
   17502:	d205      	bcs.n	17510 <_out_buffer(char, void*, unsigned int, unsigned int)+0x30>
    ((char*)buffer)[idx] = character;
   17504:	9a02      	ldr	r2, [sp, #8]
   17506:	9b01      	ldr	r3, [sp, #4]
   17508:	4413      	add	r3, r2
   1750a:	f89d 200f 	ldrb.w	r2, [sp, #15]
   1750e:	701a      	strb	r2, [r3, #0]
   17510:	4623      	mov	r3, r4
   17512:	4619      	mov	r1, r3
   17514:	4802      	ldr	r0, [pc, #8]	; (17520 <_out_buffer(char, void*, unsigned int, unsigned int)+0x40>)
   17516:	f7ff fa01 	bl	1691c <__cyg_profile_func_exit>
  }
}
   1751a:	bf00      	nop
   1751c:	b004      	add	sp, #16
   1751e:	bd10      	pop	{r4, pc}
   17520:	000174e1 	.word	0x000174e1

00017524 <_out_null(char, void*, unsigned int, unsigned int)>:


// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
   17524:	b510      	push	{r4, lr}
   17526:	b084      	sub	sp, #16
   17528:	4674      	mov	r4, lr
   1752a:	9102      	str	r1, [sp, #8]
   1752c:	9201      	str	r2, [sp, #4]
   1752e:	9300      	str	r3, [sp, #0]
   17530:	4603      	mov	r3, r0
   17532:	f88d 300f 	strb.w	r3, [sp, #15]
   17536:	4623      	mov	r3, r4
   17538:	4619      	mov	r1, r3
   1753a:	4805      	ldr	r0, [pc, #20]	; (17550 <_out_null(char, void*, unsigned int, unsigned int)+0x2c>)
   1753c:	f7ff f9da 	bl	168f4 <__cyg_profile_func_enter>
   17540:	4623      	mov	r3, r4
   17542:	4619      	mov	r1, r3
   17544:	4802      	ldr	r0, [pc, #8]	; (17550 <_out_null(char, void*, unsigned int, unsigned int)+0x2c>)
   17546:	f7ff f9e9 	bl	1691c <__cyg_profile_func_exit>
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}
   1754a:	bf00      	nop
   1754c:	b004      	add	sp, #16
   1754e:	bd10      	pop	{r4, pc}
   17550:	00017525 	.word	0x00017525

00017554 <_out_char(char, void*, unsigned int, unsigned int)>:


// internal _putchar wrapper
static inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)
{
   17554:	b510      	push	{r4, lr}
   17556:	b084      	sub	sp, #16
   17558:	4674      	mov	r4, lr
   1755a:	9102      	str	r1, [sp, #8]
   1755c:	9201      	str	r2, [sp, #4]
   1755e:	9300      	str	r3, [sp, #0]
   17560:	4603      	mov	r3, r0
   17562:	f88d 300f 	strb.w	r3, [sp, #15]
   17566:	4623      	mov	r3, r4
   17568:	4619      	mov	r1, r3
   1756a:	480a      	ldr	r0, [pc, #40]	; (17594 <_out_char(char, void*, unsigned int, unsigned int)+0x40>)
   1756c:	f7ff f9c2 	bl	168f4 <__cyg_profile_func_enter>
  (void)buffer; (void)idx; (void)maxlen;
  if (character) {
   17570:	f89d 300f 	ldrb.w	r3, [sp, #15]
   17574:	2b00      	cmp	r3, #0
   17576:	d004      	beq.n	17582 <_out_char(char, void*, unsigned int, unsigned int)+0x2e>
    _putchar(character);
   17578:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1757c:	4618      	mov	r0, r3
   1757e:	f7ff f94f 	bl	16820 <_putchar>
   17582:	4623      	mov	r3, r4
   17584:	4619      	mov	r1, r3
   17586:	4803      	ldr	r0, [pc, #12]	; (17594 <_out_char(char, void*, unsigned int, unsigned int)+0x40>)
   17588:	f7ff f9c8 	bl	1691c <__cyg_profile_func_exit>
  }
}
   1758c:	bf00      	nop
   1758e:	b004      	add	sp, #16
   17590:	bd10      	pop	{r4, pc}
   17592:	bf00      	nop
   17594:	00017555 	.word	0x00017555

00017598 <_strlen(char const*)>:


// internal strlen
// \return The length of the string (excluding the terminating 0)
static inline unsigned int _strlen(const char* str)
{
   17598:	b530      	push	{r4, r5, lr}
   1759a:	b085      	sub	sp, #20
   1759c:	4674      	mov	r4, lr
   1759e:	9001      	str	r0, [sp, #4]
   175a0:	4623      	mov	r3, r4
   175a2:	4619      	mov	r1, r3
   175a4:	480c      	ldr	r0, [pc, #48]	; (175d8 <_strlen(char const*)+0x40>)
   175a6:	f7ff f9a5 	bl	168f4 <__cyg_profile_func_enter>
  const char* s;
  for (s = str; *s; ++s);
   175aa:	9b01      	ldr	r3, [sp, #4]
   175ac:	9303      	str	r3, [sp, #12]
   175ae:	9b03      	ldr	r3, [sp, #12]
   175b0:	781b      	ldrb	r3, [r3, #0]
   175b2:	2b00      	cmp	r3, #0
   175b4:	d003      	beq.n	175be <_strlen(char const*)+0x26>
   175b6:	9b03      	ldr	r3, [sp, #12]
   175b8:	3301      	adds	r3, #1
   175ba:	9303      	str	r3, [sp, #12]
   175bc:	e7f7      	b.n	175ae <_strlen(char const*)+0x16>
  return (unsigned int)(s - str);
   175be:	9a03      	ldr	r2, [sp, #12]
   175c0:	9b01      	ldr	r3, [sp, #4]
   175c2:	1ad3      	subs	r3, r2, r3
   175c4:	461d      	mov	r5, r3
   175c6:	4623      	mov	r3, r4
   175c8:	4619      	mov	r1, r3
   175ca:	4803      	ldr	r0, [pc, #12]	; (175d8 <_strlen(char const*)+0x40>)
   175cc:	f7ff f9a6 	bl	1691c <__cyg_profile_func_exit>
   175d0:	462b      	mov	r3, r5
}
   175d2:	4618      	mov	r0, r3
   175d4:	b005      	add	sp, #20
   175d6:	bd30      	pop	{r4, r5, pc}
   175d8:	00017599 	.word	0x00017599

000175dc <_is_digit(char)>:


// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch)
{
   175dc:	b530      	push	{r4, r5, lr}
   175de:	b083      	sub	sp, #12
   175e0:	4675      	mov	r5, lr
   175e2:	4603      	mov	r3, r0
   175e4:	f88d 3007 	strb.w	r3, [sp, #7]
   175e8:	462b      	mov	r3, r5
   175ea:	4619      	mov	r1, r3
   175ec:	480b      	ldr	r0, [pc, #44]	; (1761c <_is_digit(char)+0x40>)
   175ee:	f7ff f981 	bl	168f4 <__cyg_profile_func_enter>
  return (ch >= '0') && (ch <= '9');
   175f2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   175f6:	2b2f      	cmp	r3, #47	; 0x2f
   175f8:	d905      	bls.n	17606 <_is_digit(char)+0x2a>
   175fa:	f89d 3007 	ldrb.w	r3, [sp, #7]
   175fe:	2b39      	cmp	r3, #57	; 0x39
   17600:	d801      	bhi.n	17606 <_is_digit(char)+0x2a>
   17602:	2401      	movs	r4, #1
   17604:	e000      	b.n	17608 <_is_digit(char)+0x2c>
   17606:	2400      	movs	r4, #0
   17608:	462b      	mov	r3, r5
   1760a:	4619      	mov	r1, r3
   1760c:	4803      	ldr	r0, [pc, #12]	; (1761c <_is_digit(char)+0x40>)
   1760e:	f7ff f985 	bl	1691c <__cyg_profile_func_exit>
   17612:	4623      	mov	r3, r4
}
   17614:	4618      	mov	r0, r3
   17616:	b003      	add	sp, #12
   17618:	bd30      	pop	{r4, r5, pc}
   1761a:	bf00      	nop
   1761c:	000175dd 	.word	0x000175dd

00017620 <_atoi(char const**)>:


// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char** str)
{
   17620:	b530      	push	{r4, r5, lr}
   17622:	b085      	sub	sp, #20
   17624:	4675      	mov	r5, lr
   17626:	9001      	str	r0, [sp, #4]
   17628:	462b      	mov	r3, r5
   1762a:	4619      	mov	r1, r3
   1762c:	4813      	ldr	r0, [pc, #76]	; (1767c <_atoi(char const**)+0x5c>)
   1762e:	f7ff f961 	bl	168f4 <__cyg_profile_func_enter>
  unsigned int i = 0U;
   17632:	2300      	movs	r3, #0
   17634:	9303      	str	r3, [sp, #12]
  while (_is_digit(**str)) {
   17636:	9b01      	ldr	r3, [sp, #4]
   17638:	681b      	ldr	r3, [r3, #0]
   1763a:	781b      	ldrb	r3, [r3, #0]
   1763c:	4618      	mov	r0, r3
   1763e:	f7ff ffcd 	bl	175dc <_is_digit(char)>
   17642:	4603      	mov	r3, r0
   17644:	2b00      	cmp	r3, #0
   17646:	d00f      	beq.n	17668 <_atoi(char const**)+0x48>
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
   17648:	9a03      	ldr	r2, [sp, #12]
   1764a:	4613      	mov	r3, r2
   1764c:	009b      	lsls	r3, r3, #2
   1764e:	4413      	add	r3, r2
   17650:	005b      	lsls	r3, r3, #1
   17652:	4618      	mov	r0, r3
   17654:	9b01      	ldr	r3, [sp, #4]
   17656:	681b      	ldr	r3, [r3, #0]
   17658:	1c59      	adds	r1, r3, #1
   1765a:	9a01      	ldr	r2, [sp, #4]
   1765c:	6011      	str	r1, [r2, #0]
   1765e:	781b      	ldrb	r3, [r3, #0]
   17660:	4403      	add	r3, r0
   17662:	3b30      	subs	r3, #48	; 0x30
   17664:	9303      	str	r3, [sp, #12]
  while (_is_digit(**str)) {
   17666:	e7e6      	b.n	17636 <_atoi(char const**)+0x16>
  }
  return i;
   17668:	9c03      	ldr	r4, [sp, #12]
   1766a:	462b      	mov	r3, r5
   1766c:	4619      	mov	r1, r3
   1766e:	4803      	ldr	r0, [pc, #12]	; (1767c <_atoi(char const**)+0x5c>)
   17670:	f7ff f954 	bl	1691c <__cyg_profile_func_exit>
   17674:	4623      	mov	r3, r4
}
   17676:	4618      	mov	r0, r3
   17678:	b005      	add	sp, #20
   1767a:	bd30      	pop	{r4, r5, pc}
   1767c:	00017621 	.word	0x00017621

00017680 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>:


// internal itoa format
static size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
{
   17680:	b530      	push	{r4, r5, lr}
   17682:	b089      	sub	sp, #36	; 0x24
   17684:	4675      	mov	r5, lr
   17686:	9003      	str	r0, [sp, #12]
   17688:	9102      	str	r1, [sp, #8]
   1768a:	9201      	str	r2, [sp, #4]
   1768c:	9300      	str	r3, [sp, #0]
   1768e:	462b      	mov	r3, r5
   17690:	4619      	mov	r1, r3
   17692:	4891      	ldr	r0, [pc, #580]	; (178d8 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x258>)
   17694:	f7ff f92e 	bl	168f4 <__cyg_profile_func_enter>
  const size_t start_idx = idx;
   17698:	9b01      	ldr	r3, [sp, #4]
   1769a:	9305      	str	r3, [sp, #20]

  // pad leading zeros
  while (!(flags & FLAGS_LEFT) && (len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   1769c:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1769e:	f003 0302 	and.w	r3, r3, #2
   176a2:	2b00      	cmp	r3, #0
   176a4:	d10e      	bne.n	176c4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
   176a6:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   176a8:	9b10      	ldr	r3, [sp, #64]	; 0x40
   176aa:	429a      	cmp	r2, r3
   176ac:	d20a      	bcs.n	176c4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
   176ae:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   176b0:	2b1f      	cmp	r3, #31
   176b2:	d807      	bhi.n	176c4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
    buf[len++] = '0';
   176b4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   176b6:	1c5a      	adds	r2, r3, #1
   176b8:	920d      	str	r2, [sp, #52]	; 0x34
   176ba:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   176bc:	4413      	add	r3, r2
   176be:	2230      	movs	r2, #48	; 0x30
   176c0:	701a      	strb	r2, [r3, #0]
  while (!(flags & FLAGS_LEFT) && (len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   176c2:	e7eb      	b.n	1769c <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1c>
  }
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   176c4:	9b12      	ldr	r3, [sp, #72]	; 0x48
   176c6:	f003 0302 	and.w	r3, r3, #2
   176ca:	2b00      	cmp	r3, #0
   176cc:	d113      	bne.n	176f6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
   176ce:	9b12      	ldr	r3, [sp, #72]	; 0x48
   176d0:	f003 0301 	and.w	r3, r3, #1
   176d4:	2b00      	cmp	r3, #0
   176d6:	d00e      	beq.n	176f6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
   176d8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   176da:	9b11      	ldr	r3, [sp, #68]	; 0x44
   176dc:	429a      	cmp	r2, r3
   176de:	d20a      	bcs.n	176f6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
   176e0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   176e2:	2b1f      	cmp	r3, #31
   176e4:	d807      	bhi.n	176f6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
    buf[len++] = '0';
   176e6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   176e8:	1c5a      	adds	r2, r3, #1
   176ea:	920d      	str	r2, [sp, #52]	; 0x34
   176ec:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   176ee:	4413      	add	r3, r2
   176f0:	2230      	movs	r2, #48	; 0x30
   176f2:	701a      	strb	r2, [r3, #0]
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   176f4:	e7e6      	b.n	176c4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
  }

  // handle hash
  if (flags & FLAGS_HASH) {
   176f6:	9b12      	ldr	r3, [sp, #72]	; 0x48
   176f8:	f003 0310 	and.w	r3, r3, #16
   176fc:	2b00      	cmp	r3, #0
   176fe:	d058      	beq.n	177b2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x132>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
   17700:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17702:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   17706:	2b00      	cmp	r3, #0
   17708:	d116      	bne.n	17738 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
   1770a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1770c:	2b00      	cmp	r3, #0
   1770e:	d013      	beq.n	17738 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
   17710:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   17712:	9b10      	ldr	r3, [sp, #64]	; 0x40
   17714:	429a      	cmp	r2, r3
   17716:	d003      	beq.n	17720 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xa0>
   17718:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1771a:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1771c:	429a      	cmp	r2, r3
   1771e:	d10b      	bne.n	17738 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
      len--;
   17720:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   17722:	3b01      	subs	r3, #1
   17724:	930d      	str	r3, [sp, #52]	; 0x34
      if (len && (base == 16U)) {
   17726:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   17728:	2b00      	cmp	r3, #0
   1772a:	d005      	beq.n	17738 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
   1772c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1772e:	2b10      	cmp	r3, #16
   17730:	d102      	bne.n	17738 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
        len--;
   17732:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   17734:	3b01      	subs	r3, #1
   17736:	930d      	str	r3, [sp, #52]	; 0x34
      }
    }
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   17738:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1773a:	2b10      	cmp	r3, #16
   1773c:	d10f      	bne.n	1775e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xde>
   1773e:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17740:	f003 0320 	and.w	r3, r3, #32
   17744:	2b00      	cmp	r3, #0
   17746:	d10a      	bne.n	1775e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xde>
   17748:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1774a:	2b1f      	cmp	r3, #31
   1774c:	d807      	bhi.n	1775e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xde>
      buf[len++] = 'x';
   1774e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   17750:	1c5a      	adds	r2, r3, #1
   17752:	920d      	str	r2, [sp, #52]	; 0x34
   17754:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   17756:	4413      	add	r3, r2
   17758:	2278      	movs	r2, #120	; 0x78
   1775a:	701a      	strb	r2, [r3, #0]
   1775c:	e01f      	b.n	1779e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
    }
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   1775e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   17760:	2b10      	cmp	r3, #16
   17762:	d10f      	bne.n	17784 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x104>
   17764:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17766:	f003 0320 	and.w	r3, r3, #32
   1776a:	2b00      	cmp	r3, #0
   1776c:	d00a      	beq.n	17784 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x104>
   1776e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   17770:	2b1f      	cmp	r3, #31
   17772:	d807      	bhi.n	17784 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x104>
      buf[len++] = 'X';
   17774:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   17776:	1c5a      	adds	r2, r3, #1
   17778:	920d      	str	r2, [sp, #52]	; 0x34
   1777a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1777c:	4413      	add	r3, r2
   1777e:	2258      	movs	r2, #88	; 0x58
   17780:	701a      	strb	r2, [r3, #0]
   17782:	e00c      	b.n	1779e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
    }
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   17784:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   17786:	2b02      	cmp	r3, #2
   17788:	d109      	bne.n	1779e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
   1778a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1778c:	2b1f      	cmp	r3, #31
   1778e:	d806      	bhi.n	1779e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
      buf[len++] = 'b';
   17790:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   17792:	1c5a      	adds	r2, r3, #1
   17794:	920d      	str	r2, [sp, #52]	; 0x34
   17796:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   17798:	4413      	add	r3, r2
   1779a:	2262      	movs	r2, #98	; 0x62
   1779c:	701a      	strb	r2, [r3, #0]
    }
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
   1779e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   177a0:	2b1f      	cmp	r3, #31
   177a2:	d806      	bhi.n	177b2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x132>
      buf[len++] = '0';
   177a4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   177a6:	1c5a      	adds	r2, r3, #1
   177a8:	920d      	str	r2, [sp, #52]	; 0x34
   177aa:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   177ac:	4413      	add	r3, r2
   177ae:	2230      	movs	r2, #48	; 0x30
   177b0:	701a      	strb	r2, [r3, #0]
    }
  }

  // handle sign
  if (len && (len == width) && (negative || (flags & FLAGS_PLUS) || (flags & FLAGS_SPACE))) {
   177b2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   177b4:	2b00      	cmp	r3, #0
   177b6:	d014      	beq.n	177e2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x162>
   177b8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   177ba:	9b11      	ldr	r3, [sp, #68]	; 0x44
   177bc:	429a      	cmp	r2, r3
   177be:	d110      	bne.n	177e2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x162>
   177c0:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
   177c4:	2b00      	cmp	r3, #0
   177c6:	d109      	bne.n	177dc <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x15c>
   177c8:	9b12      	ldr	r3, [sp, #72]	; 0x48
   177ca:	f003 0304 	and.w	r3, r3, #4
   177ce:	2b00      	cmp	r3, #0
   177d0:	d104      	bne.n	177dc <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x15c>
   177d2:	9b12      	ldr	r3, [sp, #72]	; 0x48
   177d4:	f003 0308 	and.w	r3, r3, #8
   177d8:	2b00      	cmp	r3, #0
   177da:	d002      	beq.n	177e2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x162>
    len--;
   177dc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   177de:	3b01      	subs	r3, #1
   177e0:	930d      	str	r3, [sp, #52]	; 0x34
  }
  if (len < PRINTF_NTOA_BUFFER_SIZE) {
   177e2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   177e4:	2b1f      	cmp	r3, #31
   177e6:	d824      	bhi.n	17832 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
    if (negative) {
   177e8:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
   177ec:	2b00      	cmp	r3, #0
   177ee:	d007      	beq.n	17800 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x180>
      buf[len++] = '-';
   177f0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   177f2:	1c5a      	adds	r2, r3, #1
   177f4:	920d      	str	r2, [sp, #52]	; 0x34
   177f6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   177f8:	4413      	add	r3, r2
   177fa:	222d      	movs	r2, #45	; 0x2d
   177fc:	701a      	strb	r2, [r3, #0]
   177fe:	e018      	b.n	17832 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
    }
    else if (flags & FLAGS_PLUS) {
   17800:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17802:	f003 0304 	and.w	r3, r3, #4
   17806:	2b00      	cmp	r3, #0
   17808:	d007      	beq.n	1781a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x19a>
      buf[len++] = '+';  // ignore the space if the '+' exists
   1780a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1780c:	1c5a      	adds	r2, r3, #1
   1780e:	920d      	str	r2, [sp, #52]	; 0x34
   17810:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   17812:	4413      	add	r3, r2
   17814:	222b      	movs	r2, #43	; 0x2b
   17816:	701a      	strb	r2, [r3, #0]
   17818:	e00b      	b.n	17832 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
    }
    else if (flags & FLAGS_SPACE) {
   1781a:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1781c:	f003 0308 	and.w	r3, r3, #8
   17820:	2b00      	cmp	r3, #0
   17822:	d006      	beq.n	17832 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
      buf[len++] = ' ';
   17824:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   17826:	1c5a      	adds	r2, r3, #1
   17828:	920d      	str	r2, [sp, #52]	; 0x34
   1782a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1782c:	4413      	add	r3, r2
   1782e:	2220      	movs	r2, #32
   17830:	701a      	strb	r2, [r3, #0]
    }
  }

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
   17832:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17834:	f003 0302 	and.w	r3, r3, #2
   17838:	2b00      	cmp	r3, #0
   1783a:	d116      	bne.n	1786a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ea>
   1783c:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1783e:	f003 0301 	and.w	r3, r3, #1
   17842:	2b00      	cmp	r3, #0
   17844:	d111      	bne.n	1786a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ea>
    for (size_t i = len; i < width; i++) {
   17846:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   17848:	9307      	str	r3, [sp, #28]
   1784a:	9a07      	ldr	r2, [sp, #28]
   1784c:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1784e:	429a      	cmp	r2, r3
   17850:	d20b      	bcs.n	1786a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ea>
      out(' ', buffer, idx++, maxlen);
   17852:	9a01      	ldr	r2, [sp, #4]
   17854:	1c53      	adds	r3, r2, #1
   17856:	9301      	str	r3, [sp, #4]
   17858:	9c03      	ldr	r4, [sp, #12]
   1785a:	9b00      	ldr	r3, [sp, #0]
   1785c:	9902      	ldr	r1, [sp, #8]
   1785e:	2020      	movs	r0, #32
   17860:	47a0      	blx	r4
    for (size_t i = len; i < width; i++) {
   17862:	9b07      	ldr	r3, [sp, #28]
   17864:	3301      	adds	r3, #1
   17866:	9307      	str	r3, [sp, #28]
   17868:	e7ef      	b.n	1784a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ca>
    }
  }

  // reverse string
  for (size_t i = 0U; i < len; i++) {
   1786a:	2300      	movs	r3, #0
   1786c:	9306      	str	r3, [sp, #24]
   1786e:	9a06      	ldr	r2, [sp, #24]
   17870:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   17872:	429a      	cmp	r2, r3
   17874:	d211      	bcs.n	1789a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x21a>
    out(buf[len - i - 1U], buffer, idx++, maxlen);
   17876:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   17878:	9b06      	ldr	r3, [sp, #24]
   1787a:	1ad3      	subs	r3, r2, r3
   1787c:	3b01      	subs	r3, #1
   1787e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   17880:	4413      	add	r3, r2
   17882:	7818      	ldrb	r0, [r3, #0]
   17884:	9a01      	ldr	r2, [sp, #4]
   17886:	1c53      	adds	r3, r2, #1
   17888:	9301      	str	r3, [sp, #4]
   1788a:	9c03      	ldr	r4, [sp, #12]
   1788c:	9b00      	ldr	r3, [sp, #0]
   1788e:	9902      	ldr	r1, [sp, #8]
   17890:	47a0      	blx	r4
  for (size_t i = 0U; i < len; i++) {
   17892:	9b06      	ldr	r3, [sp, #24]
   17894:	3301      	adds	r3, #1
   17896:	9306      	str	r3, [sp, #24]
   17898:	e7e9      	b.n	1786e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ee>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
   1789a:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1789c:	f003 0302 	and.w	r3, r3, #2
   178a0:	2b00      	cmp	r3, #0
   178a2:	d00e      	beq.n	178c2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x242>
    while (idx - start_idx < width) {
   178a4:	9a01      	ldr	r2, [sp, #4]
   178a6:	9b05      	ldr	r3, [sp, #20]
   178a8:	1ad3      	subs	r3, r2, r3
   178aa:	9a11      	ldr	r2, [sp, #68]	; 0x44
   178ac:	429a      	cmp	r2, r3
   178ae:	d908      	bls.n	178c2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x242>
      out(' ', buffer, idx++, maxlen);
   178b0:	9a01      	ldr	r2, [sp, #4]
   178b2:	1c53      	adds	r3, r2, #1
   178b4:	9301      	str	r3, [sp, #4]
   178b6:	9c03      	ldr	r4, [sp, #12]
   178b8:	9b00      	ldr	r3, [sp, #0]
   178ba:	9902      	ldr	r1, [sp, #8]
   178bc:	2020      	movs	r0, #32
   178be:	47a0      	blx	r4
    while (idx - start_idx < width) {
   178c0:	e7f0      	b.n	178a4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x224>
    }
  }

  return idx;
   178c2:	9c01      	ldr	r4, [sp, #4]
   178c4:	462b      	mov	r3, r5
   178c6:	4619      	mov	r1, r3
   178c8:	4803      	ldr	r0, [pc, #12]	; (178d8 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x258>)
   178ca:	f7ff f827 	bl	1691c <__cyg_profile_func_exit>
   178ce:	4623      	mov	r3, r4
}
   178d0:	4618      	mov	r0, r3
   178d2:	b009      	add	sp, #36	; 0x24
   178d4:	bd30      	pop	{r4, r5, pc}
   178d6:	bf00      	nop
   178d8:	00017681 	.word	0x00017681

000178dc <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>:


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
   178dc:	b530      	push	{r4, r5, lr}
   178de:	b097      	sub	sp, #92	; 0x5c
   178e0:	4674      	mov	r4, lr
   178e2:	900b      	str	r0, [sp, #44]	; 0x2c
   178e4:	910a      	str	r1, [sp, #40]	; 0x28
   178e6:	9209      	str	r2, [sp, #36]	; 0x24
   178e8:	9308      	str	r3, [sp, #32]
   178ea:	4623      	mov	r3, r4
   178ec:	4619      	mov	r1, r3
   178ee:	4833      	ldr	r0, [pc, #204]	; (179bc <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xe0>)
   178f0:	f7ff f800 	bl	168f4 <__cyg_profile_func_enter>
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;
   178f4:	2300      	movs	r3, #0
   178f6:	9315      	str	r3, [sp, #84]	; 0x54

  // no hash for 0 values
  if (!value) {
   178f8:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   178fa:	2b00      	cmp	r3, #0
   178fc:	d103      	bne.n	17906 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x2a>
    flags &= ~FLAGS_HASH;
   178fe:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17900:	f023 0310 	bic.w	r3, r3, #16
   17904:	931f      	str	r3, [sp, #124]	; 0x7c
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
   17906:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17908:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   1790c:	2b00      	cmp	r3, #0
   1790e:	d002      	beq.n	17916 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x3a>
   17910:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   17912:	2b00      	cmp	r3, #0
   17914:	d033      	beq.n	1797e <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xa2>
    do {
      const char digit = (char)(value % base);
   17916:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   17918:	9a1c      	ldr	r2, [sp, #112]	; 0x70
   1791a:	fbb3 f2f2 	udiv	r2, r3, r2
   1791e:	991c      	ldr	r1, [sp, #112]	; 0x70
   17920:	fb01 f202 	mul.w	r2, r1, r2
   17924:	1a9b      	subs	r3, r3, r2
   17926:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
   1792a:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   1792e:	2b09      	cmp	r3, #9
   17930:	d804      	bhi.n	1793c <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x60>
   17932:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   17936:	3330      	adds	r3, #48	; 0x30
   17938:	b2da      	uxtb	r2, r3
   1793a:	e00d      	b.n	17958 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x7c>
   1793c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1793e:	f003 0320 	and.w	r3, r3, #32
   17942:	2b00      	cmp	r3, #0
   17944:	d001      	beq.n	1794a <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x6e>
   17946:	2241      	movs	r2, #65	; 0x41
   17948:	e000      	b.n	1794c <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x70>
   1794a:	2261      	movs	r2, #97	; 0x61
   1794c:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   17950:	4413      	add	r3, r2
   17952:	b2db      	uxtb	r3, r3
   17954:	3b0a      	subs	r3, #10
   17956:	b2da      	uxtb	r2, r3
   17958:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1795a:	1c59      	adds	r1, r3, #1
   1795c:	9115      	str	r1, [sp, #84]	; 0x54
   1795e:	a916      	add	r1, sp, #88	; 0x58
   17960:	440b      	add	r3, r1
   17962:	f803 2c28 	strb.w	r2, [r3, #-40]
      value /= base;
   17966:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   17968:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   1796a:	fbb2 f3f3 	udiv	r3, r2, r3
   1796e:	931a      	str	r3, [sp, #104]	; 0x68
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
   17970:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   17972:	2b00      	cmp	r3, #0
   17974:	d003      	beq.n	1797e <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xa2>
   17976:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17978:	2b1f      	cmp	r3, #31
   1797a:	d800      	bhi.n	1797e <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xa2>
    do {
   1797c:	e7cb      	b.n	17916 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x3a>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
   1797e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17980:	9306      	str	r3, [sp, #24]
   17982:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   17984:	9305      	str	r3, [sp, #20]
   17986:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   17988:	9304      	str	r3, [sp, #16]
   1798a:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   1798c:	9303      	str	r3, [sp, #12]
   1798e:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
   17992:	9302      	str	r3, [sp, #8]
   17994:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17996:	9301      	str	r3, [sp, #4]
   17998:	ab0c      	add	r3, sp, #48	; 0x30
   1799a:	9300      	str	r3, [sp, #0]
   1799c:	9b08      	ldr	r3, [sp, #32]
   1799e:	9a09      	ldr	r2, [sp, #36]	; 0x24
   179a0:	990a      	ldr	r1, [sp, #40]	; 0x28
   179a2:	980b      	ldr	r0, [sp, #44]	; 0x2c
   179a4:	f7ff fe6c 	bl	17680 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>
   179a8:	4605      	mov	r5, r0
   179aa:	4623      	mov	r3, r4
   179ac:	4619      	mov	r1, r3
   179ae:	4803      	ldr	r0, [pc, #12]	; (179bc <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xe0>)
   179b0:	f7fe ffb4 	bl	1691c <__cyg_profile_func_exit>
   179b4:	462b      	mov	r3, r5
}
   179b6:	4618      	mov	r0, r3
   179b8:	b017      	add	sp, #92	; 0x5c
   179ba:	bd30      	pop	{r4, r5, pc}
   179bc:	000178dd 	.word	0x000178dd

000179c0 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>:


// internal itoa for 'long long' type
#if defined(PRINTF_SUPPORT_LONG_LONG)
static size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)
{
   179c0:	b530      	push	{r4, r5, lr}
   179c2:	b097      	sub	sp, #92	; 0x5c
   179c4:	4675      	mov	r5, lr
   179c6:	900b      	str	r0, [sp, #44]	; 0x2c
   179c8:	910a      	str	r1, [sp, #40]	; 0x28
   179ca:	9209      	str	r2, [sp, #36]	; 0x24
   179cc:	9308      	str	r3, [sp, #32]
   179ce:	462b      	mov	r3, r5
   179d0:	4619      	mov	r1, r3
   179d2:	4837      	ldr	r0, [pc, #220]	; (17ab0 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xf0>)
   179d4:	f7fe ff8e 	bl	168f4 <__cyg_profile_func_enter>
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;
   179d8:	2300      	movs	r3, #0
   179da:	9315      	str	r3, [sp, #84]	; 0x54

  // no hash for 0 values
  if (!value) {
   179dc:	e9dd 341a 	ldrd	r3, r4, [sp, #104]	; 0x68
   179e0:	4323      	orrs	r3, r4
   179e2:	d103      	bne.n	179ec <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x2c>
    flags &= ~FLAGS_HASH;
   179e4:	9b22      	ldr	r3, [sp, #136]	; 0x88
   179e6:	f023 0310 	bic.w	r3, r3, #16
   179ea:	9322      	str	r3, [sp, #136]	; 0x88
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
   179ec:	9b22      	ldr	r3, [sp, #136]	; 0x88
   179ee:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   179f2:	2b00      	cmp	r3, #0
   179f4:	d003      	beq.n	179fe <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x3e>
   179f6:	e9dd 341a 	ldrd	r3, r4, [sp, #104]	; 0x68
   179fa:	4323      	orrs	r3, r4
   179fc:	d039      	beq.n	17a72 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xb2>
    do {
      const char digit = (char)(value % base);
   179fe:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
   17a02:	e9dd 231e 	ldrd	r2, r3, [sp, #120]	; 0x78
   17a06:	f004 fddb 	bl	1c5c0 <__aeabi_uldivmod>
   17a0a:	461c      	mov	r4, r3
   17a0c:	4613      	mov	r3, r2
   17a0e:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
   17a12:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   17a16:	2b09      	cmp	r3, #9
   17a18:	d804      	bhi.n	17a24 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x64>
   17a1a:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   17a1e:	3330      	adds	r3, #48	; 0x30
   17a20:	b2da      	uxtb	r2, r3
   17a22:	e00d      	b.n	17a40 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x80>
   17a24:	9b22      	ldr	r3, [sp, #136]	; 0x88
   17a26:	f003 0320 	and.w	r3, r3, #32
   17a2a:	2b00      	cmp	r3, #0
   17a2c:	d001      	beq.n	17a32 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x72>
   17a2e:	2241      	movs	r2, #65	; 0x41
   17a30:	e000      	b.n	17a34 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x74>
   17a32:	2261      	movs	r2, #97	; 0x61
   17a34:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   17a38:	4413      	add	r3, r2
   17a3a:	b2db      	uxtb	r3, r3
   17a3c:	3b0a      	subs	r3, #10
   17a3e:	b2da      	uxtb	r2, r3
   17a40:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17a42:	1c59      	adds	r1, r3, #1
   17a44:	9115      	str	r1, [sp, #84]	; 0x54
   17a46:	a916      	add	r1, sp, #88	; 0x58
   17a48:	440b      	add	r3, r1
   17a4a:	f803 2c28 	strb.w	r2, [r3, #-40]
      value /= base;
   17a4e:	e9dd 231e 	ldrd	r2, r3, [sp, #120]	; 0x78
   17a52:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
   17a56:	f004 fdb3 	bl	1c5c0 <__aeabi_uldivmod>
   17a5a:	4603      	mov	r3, r0
   17a5c:	460c      	mov	r4, r1
   17a5e:	e9cd 341a 	strd	r3, r4, [sp, #104]	; 0x68
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
   17a62:	e9dd 341a 	ldrd	r3, r4, [sp, #104]	; 0x68
   17a66:	4323      	orrs	r3, r4
   17a68:	d003      	beq.n	17a72 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xb2>
   17a6a:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17a6c:	2b1f      	cmp	r3, #31
   17a6e:	d800      	bhi.n	17a72 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xb2>
    do {
   17a70:	e7c5      	b.n	179fe <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x3e>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
   17a72:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   17a74:	9a22      	ldr	r2, [sp, #136]	; 0x88
   17a76:	9206      	str	r2, [sp, #24]
   17a78:	9a21      	ldr	r2, [sp, #132]	; 0x84
   17a7a:	9205      	str	r2, [sp, #20]
   17a7c:	9a20      	ldr	r2, [sp, #128]	; 0x80
   17a7e:	9204      	str	r2, [sp, #16]
   17a80:	9303      	str	r3, [sp, #12]
   17a82:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
   17a86:	9302      	str	r3, [sp, #8]
   17a88:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17a8a:	9301      	str	r3, [sp, #4]
   17a8c:	ab0c      	add	r3, sp, #48	; 0x30
   17a8e:	9300      	str	r3, [sp, #0]
   17a90:	9b08      	ldr	r3, [sp, #32]
   17a92:	9a09      	ldr	r2, [sp, #36]	; 0x24
   17a94:	990a      	ldr	r1, [sp, #40]	; 0x28
   17a96:	980b      	ldr	r0, [sp, #44]	; 0x2c
   17a98:	f7ff fdf2 	bl	17680 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>
   17a9c:	4604      	mov	r4, r0
   17a9e:	462b      	mov	r3, r5
   17aa0:	4619      	mov	r1, r3
   17aa2:	4803      	ldr	r0, [pc, #12]	; (17ab0 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xf0>)
   17aa4:	f7fe ff3a 	bl	1691c <__cyg_profile_func_exit>
   17aa8:	4623      	mov	r3, r4
}
   17aaa:	4618      	mov	r0, r3
   17aac:	b017      	add	sp, #92	; 0x5c
   17aae:	bd30      	pop	{r4, r5, pc}
   17ab0:	000179c1 	.word	0x000179c1

00017ab4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)>:
#endif  // PRINTF_SUPPORT_LONG_LONG


#if defined(PRINTF_SUPPORT_FLOAT)
static size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value_param, unsigned int prec, unsigned int width, unsigned int flags)
{
   17ab4:	b530      	push	{r4, r5, lr}
   17ab6:	b09b      	sub	sp, #108	; 0x6c
   17ab8:	4675      	mov	r5, lr
   17aba:	9005      	str	r0, [sp, #20]
   17abc:	9104      	str	r1, [sp, #16]
   17abe:	9203      	str	r2, [sp, #12]
   17ac0:	9302      	str	r3, [sp, #8]
   17ac2:	ed8d 0b00 	vstr	d0, [sp]
   17ac6:	462b      	mov	r3, r5
   17ac8:	4619      	mov	r1, r3
   17aca:	48b7      	ldr	r0, [pc, #732]	; (17da8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2f4>)
   17acc:	f7fe ff12 	bl	168f4 <__cyg_profile_func_enter>
  const size_t start_idx = idx;
   17ad0:	9b03      	ldr	r3, [sp, #12]
   17ad2:	9311      	str	r3, [sp, #68]	; 0x44

  float value = static_cast<float>(value_param);
   17ad4:	e9dd 0100 	ldrd	r0, r1, [sp]
   17ad8:	f004 fd22 	bl	1c520 <__aeabi_d2f>
   17adc:	4603      	mov	r3, r0
   17ade:	9319      	str	r3, [sp, #100]	; 0x64

  char buf[PRINTF_FTOA_BUFFER_SIZE];
  size_t len  = 0U;
   17ae0:	2300      	movs	r3, #0
   17ae2:	9318      	str	r3, [sp, #96]	; 0x60
  float diff = 0.0;
   17ae4:	f04f 0300 	mov.w	r3, #0
   17ae8:	9310      	str	r3, [sp, #64]	; 0x40

  // if input is larger than thres_max, revert to exponential
  const float thres_max = (float)0x7FFFFFFF;
   17aea:	f04f 439e 	mov.w	r3, #1325400064	; 0x4f000000
   17aee:	930f      	str	r3, [sp, #60]	; 0x3c

  // powers of 10
  static const float pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };

  // test for negative
  bool negative = false;
   17af0:	2300      	movs	r3, #0
   17af2:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
  if (value < 0) {
   17af6:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   17afa:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   17afe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   17b02:	d50a      	bpl.n	17b1a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x66>
    negative = true;
   17b04:	2301      	movs	r3, #1
   17b06:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
    value = 0 - value;
   17b0a:	ed9f 7aa8 	vldr	s14, [pc, #672]	; 17dac <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2f8>
   17b0e:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   17b12:	ee77 7a67 	vsub.f32	s15, s14, s15
   17b16:	edcd 7a19 	vstr	s15, [sp, #100]	; 0x64
  }

  // set default precision to 6, if not set explicitly
  if (!(flags & FLAGS_PRECISION)) {
   17b1a:	9b20      	ldr	r3, [sp, #128]	; 0x80
   17b1c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   17b20:	2b00      	cmp	r3, #0
   17b22:	d101      	bne.n	17b28 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x74>
    prec = 6U;
   17b24:	2306      	movs	r3, #6
   17b26:	931e      	str	r3, [sp, #120]	; 0x78
  }
  // limit precision to 9, cause a prec >= 10 can lead to overflow errors
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
   17b28:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17b2a:	2b1f      	cmp	r3, #31
   17b2c:	d80e      	bhi.n	17b4c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x98>
   17b2e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   17b30:	2b09      	cmp	r3, #9
   17b32:	d90b      	bls.n	17b4c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x98>
    buf[len++] = '0';
   17b34:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17b36:	1c5a      	adds	r2, r3, #1
   17b38:	9218      	str	r2, [sp, #96]	; 0x60
   17b3a:	aa1a      	add	r2, sp, #104	; 0x68
   17b3c:	4413      	add	r3, r2
   17b3e:	2230      	movs	r2, #48	; 0x30
   17b40:	f803 2c50 	strb.w	r2, [r3, #-80]
    prec--;
   17b44:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   17b46:	3b01      	subs	r3, #1
   17b48:	931e      	str	r3, [sp, #120]	; 0x78
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
   17b4a:	e7ed      	b.n	17b28 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x74>
  }

  int whole = (int)value;
   17b4c:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   17b50:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   17b54:	ee17 3a90 	vmov	r3, s15
   17b58:	9316      	str	r3, [sp, #88]	; 0x58
  float tmp = (value - whole) * pow10[prec];
   17b5a:	9b16      	ldr	r3, [sp, #88]	; 0x58
   17b5c:	ee07 3a90 	vmov	s15, r3
   17b60:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   17b64:	ed9d 7a19 	vldr	s14, [sp, #100]	; 0x64
   17b68:	ee37 7a67 	vsub.f32	s14, s14, s15
   17b6c:	4a90      	ldr	r2, [pc, #576]	; (17db0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2fc>)
   17b6e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   17b70:	009b      	lsls	r3, r3, #2
   17b72:	4413      	add	r3, r2
   17b74:	edd3 7a00 	vldr	s15, [r3]
   17b78:	ee67 7a27 	vmul.f32	s15, s14, s15
   17b7c:	edcd 7a0e 	vstr	s15, [sp, #56]	; 0x38
  unsigned long frac = (unsigned long)tmp;
   17b80:	eddd 7a0e 	vldr	s15, [sp, #56]	; 0x38
   17b84:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   17b88:	ee17 3a90 	vmov	r3, s15
   17b8c:	9315      	str	r3, [sp, #84]	; 0x54
  diff = tmp - frac;
   17b8e:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17b90:	ee07 3a90 	vmov	s15, r3
   17b94:	eef8 7a67 	vcvt.f32.u32	s15, s15
   17b98:	ed9d 7a0e 	vldr	s14, [sp, #56]	; 0x38
   17b9c:	ee77 7a67 	vsub.f32	s15, s14, s15
   17ba0:	edcd 7a10 	vstr	s15, [sp, #64]	; 0x40

  if (diff > 0.5) {
   17ba4:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   17ba8:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   17bac:	eef4 7ac7 	vcmpe.f32	s15, s14
   17bb0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   17bb4:	dd18      	ble.n	17be8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x134>
    ++frac;
   17bb6:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17bb8:	3301      	adds	r3, #1
   17bba:	9315      	str	r3, [sp, #84]	; 0x54
    // handle rollover, e.g. case 0.99 with prec 1 is 1.0
    if (frac >= pow10[prec]) {
   17bbc:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17bbe:	ee07 3a90 	vmov	s15, r3
   17bc2:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   17bc6:	4a7a      	ldr	r2, [pc, #488]	; (17db0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2fc>)
   17bc8:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   17bca:	009b      	lsls	r3, r3, #2
   17bcc:	4413      	add	r3, r2
   17bce:	edd3 7a00 	vldr	s15, [r3]
   17bd2:	eeb4 7ae7 	vcmpe.f32	s14, s15
   17bd6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   17bda:	db19      	blt.n	17c10 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
      frac = 0;
   17bdc:	2300      	movs	r3, #0
   17bde:	9315      	str	r3, [sp, #84]	; 0x54
      ++whole;
   17be0:	9b16      	ldr	r3, [sp, #88]	; 0x58
   17be2:	3301      	adds	r3, #1
   17be4:	9316      	str	r3, [sp, #88]	; 0x58
   17be6:	e013      	b.n	17c10 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
    }
  }
  else if ((diff == 0.5) && ((frac == 0U) || (frac & 1U))) {
   17be8:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   17bec:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   17bf0:	eef4 7a47 	vcmp.f32	s15, s14
   17bf4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   17bf8:	d10a      	bne.n	17c10 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
   17bfa:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17bfc:	2b00      	cmp	r3, #0
   17bfe:	d004      	beq.n	17c0a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x156>
   17c00:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17c02:	f003 0301 	and.w	r3, r3, #1
   17c06:	2b00      	cmp	r3, #0
   17c08:	d002      	beq.n	17c10 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
    // if halfway, round up if odd, OR if last digit is 0
    ++frac;
   17c0a:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17c0c:	3301      	adds	r3, #1
   17c0e:	9315      	str	r3, [sp, #84]	; 0x54
  }

  // TBD: for very large numbers switch back to native sprintf for exponentials. Anyone want to write code to replace this?
  // Normal printf behavior is to print EVERY whole number digit which can be 100s of characters overflowing your buffers == bad
  if (value > thres_max) {
   17c10:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   17c14:	ed9f 7a67 	vldr	s14, [pc, #412]	; 17db4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x300>
   17c18:	eef4 7ac7 	vcmpe.f32	s15, s14
   17c1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   17c20:	dd01      	ble.n	17c26 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x172>
    return 0U;
   17c22:	2400      	movs	r4, #0
   17c24:	e156      	b.n	17ed4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x420>
  }

  if (prec == 0U) {
   17c26:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   17c28:	2b00      	cmp	r3, #0
   17c2a:	d129      	bne.n	17c80 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1cc>
    diff = value - (float)whole;
   17c2c:	9b16      	ldr	r3, [sp, #88]	; 0x58
   17c2e:	ee07 3a90 	vmov	s15, r3
   17c32:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   17c36:	ed9d 7a19 	vldr	s14, [sp, #100]	; 0x64
   17c3a:	ee77 7a67 	vsub.f32	s15, s14, s15
   17c3e:	edcd 7a10 	vstr	s15, [sp, #64]	; 0x40
    if (diff > 0.5) {
   17c42:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   17c46:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   17c4a:	eef4 7ac7 	vcmpe.f32	s15, s14
   17c4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   17c52:	dd03      	ble.n	17c5c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1a8>
      // greater than 0.5, round up, e.g. 1.6 -> 2
      ++whole;
   17c54:	9b16      	ldr	r3, [sp, #88]	; 0x58
   17c56:	3301      	adds	r3, #1
   17c58:	9316      	str	r3, [sp, #88]	; 0x58
   17c5a:	e05f      	b.n	17d1c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
    }
    else if ((diff == 0.5) && (whole & 1)) {
   17c5c:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   17c60:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   17c64:	eef4 7a47 	vcmp.f32	s15, s14
   17c68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   17c6c:	d156      	bne.n	17d1c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
   17c6e:	9b16      	ldr	r3, [sp, #88]	; 0x58
   17c70:	f003 0301 	and.w	r3, r3, #1
   17c74:	2b00      	cmp	r3, #0
   17c76:	d051      	beq.n	17d1c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      // exactly 0.5 and ODD, then round up
      // 1.5 -> 2, but 2.5 -> 2
      ++whole;
   17c78:	9b16      	ldr	r3, [sp, #88]	; 0x58
   17c7a:	3301      	adds	r3, #1
   17c7c:	9316      	str	r3, [sp, #88]	; 0x58
   17c7e:	e04d      	b.n	17d1c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
    }
  }
  else {
    unsigned int count = prec;
   17c80:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   17c82:	9314      	str	r3, [sp, #80]	; 0x50
    // now do fractional part, as an unsigned number
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
   17c84:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17c86:	2b1f      	cmp	r3, #31
   17c88:	d827      	bhi.n	17cda <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x226>
      --count;
   17c8a:	9b14      	ldr	r3, [sp, #80]	; 0x50
   17c8c:	3b01      	subs	r3, #1
   17c8e:	9314      	str	r3, [sp, #80]	; 0x50
      buf[len++] = (char)(48U + (frac % 10U));
   17c90:	9915      	ldr	r1, [sp, #84]	; 0x54
   17c92:	4b49      	ldr	r3, [pc, #292]	; (17db8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x304>)
   17c94:	fba3 2301 	umull	r2, r3, r3, r1
   17c98:	08da      	lsrs	r2, r3, #3
   17c9a:	4613      	mov	r3, r2
   17c9c:	009b      	lsls	r3, r3, #2
   17c9e:	4413      	add	r3, r2
   17ca0:	005b      	lsls	r3, r3, #1
   17ca2:	1aca      	subs	r2, r1, r3
   17ca4:	b2d3      	uxtb	r3, r2
   17ca6:	3330      	adds	r3, #48	; 0x30
   17ca8:	b2d9      	uxtb	r1, r3
   17caa:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17cac:	1c5a      	adds	r2, r3, #1
   17cae:	9218      	str	r2, [sp, #96]	; 0x60
   17cb0:	aa1a      	add	r2, sp, #104	; 0x68
   17cb2:	4413      	add	r3, r2
   17cb4:	460a      	mov	r2, r1
   17cb6:	f803 2c50 	strb.w	r2, [r3, #-80]
      if (!(frac /= 10U)) {
   17cba:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17cbc:	4a3e      	ldr	r2, [pc, #248]	; (17db8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x304>)
   17cbe:	fba2 2303 	umull	r2, r3, r2, r3
   17cc2:	08db      	lsrs	r3, r3, #3
   17cc4:	9315      	str	r3, [sp, #84]	; 0x54
   17cc6:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17cc8:	2b00      	cmp	r3, #0
   17cca:	bf0c      	ite	eq
   17ccc:	2301      	moveq	r3, #1
   17cce:	2300      	movne	r3, #0
   17cd0:	b2db      	uxtb	r3, r3
   17cd2:	2b00      	cmp	r3, #0
   17cd4:	d100      	bne.n	17cd8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x224>
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
   17cd6:	e7d5      	b.n	17c84 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1d0>
        break;
   17cd8:	bf00      	nop
      }
    }
    // add extra 0s
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
   17cda:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17cdc:	2b1f      	cmp	r3, #31
   17cde:	d806      	bhi.n	17cee <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x23a>
   17ce0:	9b14      	ldr	r3, [sp, #80]	; 0x50
   17ce2:	1e5a      	subs	r2, r3, #1
   17ce4:	9214      	str	r2, [sp, #80]	; 0x50
   17ce6:	2b00      	cmp	r3, #0
   17ce8:	d001      	beq.n	17cee <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x23a>
   17cea:	2301      	movs	r3, #1
   17cec:	e000      	b.n	17cf0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x23c>
   17cee:	2300      	movs	r3, #0
   17cf0:	2b00      	cmp	r3, #0
   17cf2:	d008      	beq.n	17d06 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x252>
      buf[len++] = '0';
   17cf4:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17cf6:	1c5a      	adds	r2, r3, #1
   17cf8:	9218      	str	r2, [sp, #96]	; 0x60
   17cfa:	aa1a      	add	r2, sp, #104	; 0x68
   17cfc:	4413      	add	r3, r2
   17cfe:	2230      	movs	r2, #48	; 0x30
   17d00:	f803 2c50 	strb.w	r2, [r3, #-80]
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
   17d04:	e7e9      	b.n	17cda <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x226>
    }
    if (len < PRINTF_FTOA_BUFFER_SIZE) {
   17d06:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17d08:	2b1f      	cmp	r3, #31
   17d0a:	d807      	bhi.n	17d1c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      // add decimal
      buf[len++] = '.';
   17d0c:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17d0e:	1c5a      	adds	r2, r3, #1
   17d10:	9218      	str	r2, [sp, #96]	; 0x60
   17d12:	aa1a      	add	r2, sp, #104	; 0x68
   17d14:	4413      	add	r3, r2
   17d16:	222e      	movs	r2, #46	; 0x2e
   17d18:	f803 2c50 	strb.w	r2, [r3, #-80]
    }
  }

  // do whole part, number is reversed
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
   17d1c:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17d1e:	2b1f      	cmp	r3, #31
   17d20:	d828      	bhi.n	17d74 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2c0>
    buf[len++] = (char)(48 + (whole % 10));
   17d22:	9a16      	ldr	r2, [sp, #88]	; 0x58
   17d24:	4b25      	ldr	r3, [pc, #148]	; (17dbc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x308>)
   17d26:	fb83 1302 	smull	r1, r3, r3, r2
   17d2a:	1099      	asrs	r1, r3, #2
   17d2c:	17d3      	asrs	r3, r2, #31
   17d2e:	1ac9      	subs	r1, r1, r3
   17d30:	460b      	mov	r3, r1
   17d32:	009b      	lsls	r3, r3, #2
   17d34:	440b      	add	r3, r1
   17d36:	005b      	lsls	r3, r3, #1
   17d38:	1ad1      	subs	r1, r2, r3
   17d3a:	b2cb      	uxtb	r3, r1
   17d3c:	3330      	adds	r3, #48	; 0x30
   17d3e:	b2d9      	uxtb	r1, r3
   17d40:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17d42:	1c5a      	adds	r2, r3, #1
   17d44:	9218      	str	r2, [sp, #96]	; 0x60
   17d46:	aa1a      	add	r2, sp, #104	; 0x68
   17d48:	4413      	add	r3, r2
   17d4a:	460a      	mov	r2, r1
   17d4c:	f803 2c50 	strb.w	r2, [r3, #-80]
    if (!(whole /= 10)) {
   17d50:	9b16      	ldr	r3, [sp, #88]	; 0x58
   17d52:	4a1a      	ldr	r2, [pc, #104]	; (17dbc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x308>)
   17d54:	fb82 1203 	smull	r1, r2, r2, r3
   17d58:	1092      	asrs	r2, r2, #2
   17d5a:	17db      	asrs	r3, r3, #31
   17d5c:	1ad3      	subs	r3, r2, r3
   17d5e:	9316      	str	r3, [sp, #88]	; 0x58
   17d60:	9b16      	ldr	r3, [sp, #88]	; 0x58
   17d62:	2b00      	cmp	r3, #0
   17d64:	bf0c      	ite	eq
   17d66:	2301      	moveq	r3, #1
   17d68:	2300      	movne	r3, #0
   17d6a:	b2db      	uxtb	r3, r3
   17d6c:	2b00      	cmp	r3, #0
   17d6e:	d100      	bne.n	17d72 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2be>
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
   17d70:	e7d4      	b.n	17d1c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      break;
   17d72:	bf00      	nop
    }
  }

  // pad leading zeros
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
   17d74:	9b20      	ldr	r3, [sp, #128]	; 0x80
   17d76:	f003 0302 	and.w	r3, r3, #2
   17d7a:	2b00      	cmp	r3, #0
   17d7c:	d120      	bne.n	17dc0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
   17d7e:	9b20      	ldr	r3, [sp, #128]	; 0x80
   17d80:	f003 0301 	and.w	r3, r3, #1
   17d84:	2b00      	cmp	r3, #0
   17d86:	d01b      	beq.n	17dc0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
   17d88:	9a18      	ldr	r2, [sp, #96]	; 0x60
   17d8a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17d8c:	429a      	cmp	r2, r3
   17d8e:	d217      	bcs.n	17dc0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
   17d90:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17d92:	2b1f      	cmp	r3, #31
   17d94:	d814      	bhi.n	17dc0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
    buf[len++] = '0';
   17d96:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17d98:	1c5a      	adds	r2, r3, #1
   17d9a:	9218      	str	r2, [sp, #96]	; 0x60
   17d9c:	aa1a      	add	r2, sp, #104	; 0x68
   17d9e:	4413      	add	r3, r2
   17da0:	2230      	movs	r2, #48	; 0x30
   17da2:	f803 2c50 	strb.w	r2, [r3, #-80]
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
   17da6:	e7e5      	b.n	17d74 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2c0>
   17da8:	00017ab5 	.word	0x00017ab5
   17dac:	00000000 	.word	0x00000000
   17db0:	0001e3cc 	.word	0x0001e3cc
   17db4:	4f000000 	.word	0x4f000000
   17db8:	cccccccd 	.word	0xcccccccd
   17dbc:	66666667 	.word	0x66666667
  }

  // handle sign
  if ((len == width) && (negative || (flags & FLAGS_PLUS) || (flags & FLAGS_SPACE))) {
   17dc0:	9a18      	ldr	r2, [sp, #96]	; 0x60
   17dc2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17dc4:	429a      	cmp	r2, r3
   17dc6:	d110      	bne.n	17dea <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x336>
   17dc8:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   17dcc:	2b00      	cmp	r3, #0
   17dce:	d109      	bne.n	17de4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x330>
   17dd0:	9b20      	ldr	r3, [sp, #128]	; 0x80
   17dd2:	f003 0304 	and.w	r3, r3, #4
   17dd6:	2b00      	cmp	r3, #0
   17dd8:	d104      	bne.n	17de4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x330>
   17dda:	9b20      	ldr	r3, [sp, #128]	; 0x80
   17ddc:	f003 0308 	and.w	r3, r3, #8
   17de0:	2b00      	cmp	r3, #0
   17de2:	d002      	beq.n	17dea <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x336>
    len--;
   17de4:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17de6:	3b01      	subs	r3, #1
   17de8:	9318      	str	r3, [sp, #96]	; 0x60
  }
  if (len < PRINTF_FTOA_BUFFER_SIZE) {
   17dea:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17dec:	2b1f      	cmp	r3, #31
   17dee:	d827      	bhi.n	17e40 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
    if (negative) {
   17df0:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   17df4:	2b00      	cmp	r3, #0
   17df6:	d008      	beq.n	17e0a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x356>
      buf[len++] = '-';
   17df8:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17dfa:	1c5a      	adds	r2, r3, #1
   17dfc:	9218      	str	r2, [sp, #96]	; 0x60
   17dfe:	aa1a      	add	r2, sp, #104	; 0x68
   17e00:	4413      	add	r3, r2
   17e02:	222d      	movs	r2, #45	; 0x2d
   17e04:	f803 2c50 	strb.w	r2, [r3, #-80]
   17e08:	e01a      	b.n	17e40 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
    }
    else if (flags & FLAGS_PLUS) {
   17e0a:	9b20      	ldr	r3, [sp, #128]	; 0x80
   17e0c:	f003 0304 	and.w	r3, r3, #4
   17e10:	2b00      	cmp	r3, #0
   17e12:	d008      	beq.n	17e26 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x372>
      buf[len++] = '+';  // ignore the space if the '+' exists
   17e14:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17e16:	1c5a      	adds	r2, r3, #1
   17e18:	9218      	str	r2, [sp, #96]	; 0x60
   17e1a:	aa1a      	add	r2, sp, #104	; 0x68
   17e1c:	4413      	add	r3, r2
   17e1e:	222b      	movs	r2, #43	; 0x2b
   17e20:	f803 2c50 	strb.w	r2, [r3, #-80]
   17e24:	e00c      	b.n	17e40 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
    }
    else if (flags & FLAGS_SPACE) {
   17e26:	9b20      	ldr	r3, [sp, #128]	; 0x80
   17e28:	f003 0308 	and.w	r3, r3, #8
   17e2c:	2b00      	cmp	r3, #0
   17e2e:	d007      	beq.n	17e40 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
      buf[len++] = ' ';
   17e30:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17e32:	1c5a      	adds	r2, r3, #1
   17e34:	9218      	str	r2, [sp, #96]	; 0x60
   17e36:	aa1a      	add	r2, sp, #104	; 0x68
   17e38:	4413      	add	r3, r2
   17e3a:	2220      	movs	r2, #32
   17e3c:	f803 2c50 	strb.w	r2, [r3, #-80]
    }
  }

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
   17e40:	9b20      	ldr	r3, [sp, #128]	; 0x80
   17e42:	f003 0302 	and.w	r3, r3, #2
   17e46:	2b00      	cmp	r3, #0
   17e48:	d116      	bne.n	17e78 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c4>
   17e4a:	9b20      	ldr	r3, [sp, #128]	; 0x80
   17e4c:	f003 0301 	and.w	r3, r3, #1
   17e50:	2b00      	cmp	r3, #0
   17e52:	d111      	bne.n	17e78 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c4>
    for (size_t i = len; i < width; i++) {
   17e54:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17e56:	9313      	str	r3, [sp, #76]	; 0x4c
   17e58:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   17e5a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17e5c:	429a      	cmp	r2, r3
   17e5e:	d20b      	bcs.n	17e78 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c4>
      out(' ', buffer, idx++, maxlen);
   17e60:	9a03      	ldr	r2, [sp, #12]
   17e62:	1c53      	adds	r3, r2, #1
   17e64:	9303      	str	r3, [sp, #12]
   17e66:	9c05      	ldr	r4, [sp, #20]
   17e68:	9b02      	ldr	r3, [sp, #8]
   17e6a:	9904      	ldr	r1, [sp, #16]
   17e6c:	2020      	movs	r0, #32
   17e6e:	47a0      	blx	r4
    for (size_t i = len; i < width; i++) {
   17e70:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   17e72:	3301      	adds	r3, #1
   17e74:	9313      	str	r3, [sp, #76]	; 0x4c
   17e76:	e7ef      	b.n	17e58 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3a4>
    }
  }

  // reverse string
  for (size_t i = 0U; i < len; i++) {
   17e78:	2300      	movs	r3, #0
   17e7a:	9312      	str	r3, [sp, #72]	; 0x48
   17e7c:	9a12      	ldr	r2, [sp, #72]	; 0x48
   17e7e:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17e80:	429a      	cmp	r2, r3
   17e82:	d212      	bcs.n	17eaa <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3f6>
    out(buf[len - i - 1U], buffer, idx++, maxlen);
   17e84:	9a18      	ldr	r2, [sp, #96]	; 0x60
   17e86:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17e88:	1ad3      	subs	r3, r2, r3
   17e8a:	3b01      	subs	r3, #1
   17e8c:	aa1a      	add	r2, sp, #104	; 0x68
   17e8e:	4413      	add	r3, r2
   17e90:	f813 0c50 	ldrb.w	r0, [r3, #-80]
   17e94:	9a03      	ldr	r2, [sp, #12]
   17e96:	1c53      	adds	r3, r2, #1
   17e98:	9303      	str	r3, [sp, #12]
   17e9a:	9c05      	ldr	r4, [sp, #20]
   17e9c:	9b02      	ldr	r3, [sp, #8]
   17e9e:	9904      	ldr	r1, [sp, #16]
   17ea0:	47a0      	blx	r4
  for (size_t i = 0U; i < len; i++) {
   17ea2:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17ea4:	3301      	adds	r3, #1
   17ea6:	9312      	str	r3, [sp, #72]	; 0x48
   17ea8:	e7e8      	b.n	17e7c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c8>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
   17eaa:	9b20      	ldr	r3, [sp, #128]	; 0x80
   17eac:	f003 0302 	and.w	r3, r3, #2
   17eb0:	2b00      	cmp	r3, #0
   17eb2:	d00e      	beq.n	17ed2 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x41e>
    while (idx - start_idx < width) {
   17eb4:	9a03      	ldr	r2, [sp, #12]
   17eb6:	9b11      	ldr	r3, [sp, #68]	; 0x44
   17eb8:	1ad3      	subs	r3, r2, r3
   17eba:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   17ebc:	429a      	cmp	r2, r3
   17ebe:	d908      	bls.n	17ed2 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x41e>
      out(' ', buffer, idx++, maxlen);
   17ec0:	9a03      	ldr	r2, [sp, #12]
   17ec2:	1c53      	adds	r3, r2, #1
   17ec4:	9303      	str	r3, [sp, #12]
   17ec6:	9c05      	ldr	r4, [sp, #20]
   17ec8:	9b02      	ldr	r3, [sp, #8]
   17eca:	9904      	ldr	r1, [sp, #16]
   17ecc:	2020      	movs	r0, #32
   17ece:	47a0      	blx	r4
    while (idx - start_idx < width) {
   17ed0:	e7f0      	b.n	17eb4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x400>
    }
  }

  return idx;
   17ed2:	9c03      	ldr	r4, [sp, #12]
   17ed4:	462b      	mov	r3, r5
   17ed6:	4619      	mov	r1, r3
   17ed8:	4803      	ldr	r0, [pc, #12]	; (17ee8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x434>)
   17eda:	f7fe fd1f 	bl	1691c <__cyg_profile_func_exit>
   17ede:	4623      	mov	r3, r4
}
   17ee0:	4618      	mov	r0, r3
   17ee2:	b01b      	add	sp, #108	; 0x6c
   17ee4:	bd30      	pop	{r4, r5, pc}
   17ee6:	bf00      	nop
   17ee8:	00017ab5 	.word	0x00017ab5

00017eec <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)>:
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
   17eec:	b570      	push	{r4, r5, r6, lr}
   17eee:	b0a0      	sub	sp, #128	; 0x80
   17ef0:	4676      	mov	r6, lr
   17ef2:	900d      	str	r0, [sp, #52]	; 0x34
   17ef4:	910c      	str	r1, [sp, #48]	; 0x30
   17ef6:	920b      	str	r2, [sp, #44]	; 0x2c
   17ef8:	930a      	str	r3, [sp, #40]	; 0x28
   17efa:	4633      	mov	r3, r6
   17efc:	4619      	mov	r1, r3
   17efe:	48a7      	ldr	r0, [pc, #668]	; (1819c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b0>)
   17f00:	f7fe fcf8 	bl	168f4 <__cyg_profile_func_enter>
  unsigned int flags, width, precision, n;
  size_t idx = 0U;
   17f04:	2300      	movs	r3, #0
   17f06:	931b      	str	r3, [sp, #108]	; 0x6c

  if (!buffer) {
   17f08:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   17f0a:	2b00      	cmp	r3, #0
   17f0c:	d101      	bne.n	17f12 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x26>
    // use null output function
    out = _out_null;
   17f0e:	4ba4      	ldr	r3, [pc, #656]	; (181a0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b4>)
   17f10:	930d      	str	r3, [sp, #52]	; 0x34
  }

  while (*format)
   17f12:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17f14:	781b      	ldrb	r3, [r3, #0]
   17f16:	2b00      	cmp	r3, #0
   17f18:	f000 8448 	beq.w	187ac <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8c0>
  {
    // format specifier?  %[flags][width][.precision][length]
    if (*format != '%') {
   17f1c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17f1e:	781b      	ldrb	r3, [r3, #0]
   17f20:	2b25      	cmp	r3, #37	; 0x25
   17f22:	d00d      	beq.n	17f40 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x54>
      // no
      out(*format, buffer, idx++, maxlen);
   17f24:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17f26:	7818      	ldrb	r0, [r3, #0]
   17f28:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17f2a:	1c53      	adds	r3, r2, #1
   17f2c:	931b      	str	r3, [sp, #108]	; 0x6c
   17f2e:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   17f30:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17f32:	990c      	ldr	r1, [sp, #48]	; 0x30
   17f34:	47a0      	blx	r4
      format++;
   17f36:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17f38:	3301      	adds	r3, #1
   17f3a:	930a      	str	r3, [sp, #40]	; 0x28
      continue;
   17f3c:	f000 bc34 	b.w	187a8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
    }
    else {
      // yes, evaluate it
      format++;
   17f40:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17f42:	3301      	adds	r3, #1
   17f44:	930a      	str	r3, [sp, #40]	; 0x28
    }

    // evaluate flags
    flags = 0U;
   17f46:	2300      	movs	r3, #0
   17f48:	931f      	str	r3, [sp, #124]	; 0x7c
    do {
      switch (*format) {
   17f4a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17f4c:	781b      	ldrb	r3, [r3, #0]
   17f4e:	3b20      	subs	r3, #32
   17f50:	2b10      	cmp	r3, #16
   17f52:	d857      	bhi.n	18004 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x118>
   17f54:	a201      	add	r2, pc, #4	; (adr r2, 17f5c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x70>)
   17f56:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   17f5a:	bf00      	nop
   17f5c:	00017fdd 	.word	0x00017fdd
   17f60:	00018005 	.word	0x00018005
   17f64:	00018005 	.word	0x00018005
   17f68:	00017ff1 	.word	0x00017ff1
   17f6c:	00018005 	.word	0x00018005
   17f70:	00018005 	.word	0x00018005
   17f74:	00018005 	.word	0x00018005
   17f78:	00018005 	.word	0x00018005
   17f7c:	00018005 	.word	0x00018005
   17f80:	00018005 	.word	0x00018005
   17f84:	00018005 	.word	0x00018005
   17f88:	00017fc9 	.word	0x00017fc9
   17f8c:	00018005 	.word	0x00018005
   17f90:	00017fb5 	.word	0x00017fb5
   17f94:	00018005 	.word	0x00018005
   17f98:	00018005 	.word	0x00018005
   17f9c:	00017fa1 	.word	0x00017fa1
        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
   17fa0:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17fa2:	f043 0301 	orr.w	r3, r3, #1
   17fa6:	931f      	str	r3, [sp, #124]	; 0x7c
   17fa8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17faa:	3301      	adds	r3, #1
   17fac:	930a      	str	r3, [sp, #40]	; 0x28
   17fae:	2301      	movs	r3, #1
   17fb0:	931c      	str	r3, [sp, #112]	; 0x70
   17fb2:	e02a      	b.n	1800a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
   17fb4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17fb6:	f043 0302 	orr.w	r3, r3, #2
   17fba:	931f      	str	r3, [sp, #124]	; 0x7c
   17fbc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17fbe:	3301      	adds	r3, #1
   17fc0:	930a      	str	r3, [sp, #40]	; 0x28
   17fc2:	2301      	movs	r3, #1
   17fc4:	931c      	str	r3, [sp, #112]	; 0x70
   17fc6:	e020      	b.n	1800a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
   17fc8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17fca:	f043 0304 	orr.w	r3, r3, #4
   17fce:	931f      	str	r3, [sp, #124]	; 0x7c
   17fd0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17fd2:	3301      	adds	r3, #1
   17fd4:	930a      	str	r3, [sp, #40]	; 0x28
   17fd6:	2301      	movs	r3, #1
   17fd8:	931c      	str	r3, [sp, #112]	; 0x70
   17fda:	e016      	b.n	1800a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
   17fdc:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17fde:	f043 0308 	orr.w	r3, r3, #8
   17fe2:	931f      	str	r3, [sp, #124]	; 0x7c
   17fe4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17fe6:	3301      	adds	r3, #1
   17fe8:	930a      	str	r3, [sp, #40]	; 0x28
   17fea:	2301      	movs	r3, #1
   17fec:	931c      	str	r3, [sp, #112]	; 0x70
   17fee:	e00c      	b.n	1800a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
   17ff0:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17ff2:	f043 0310 	orr.w	r3, r3, #16
   17ff6:	931f      	str	r3, [sp, #124]	; 0x7c
   17ff8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17ffa:	3301      	adds	r3, #1
   17ffc:	930a      	str	r3, [sp, #40]	; 0x28
   17ffe:	2301      	movs	r3, #1
   18000:	931c      	str	r3, [sp, #112]	; 0x70
   18002:	e002      	b.n	1800a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        default :                                   n = 0U; break;
   18004:	2300      	movs	r3, #0
   18006:	931c      	str	r3, [sp, #112]	; 0x70
   18008:	bf00      	nop
      }
    } while (n);
   1800a:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   1800c:	2b00      	cmp	r3, #0
   1800e:	d000      	beq.n	18012 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x126>
    do {
   18010:	e79b      	b.n	17f4a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x5e>

    // evaluate width field
    width = 0U;
   18012:	2300      	movs	r3, #0
   18014:	931e      	str	r3, [sp, #120]	; 0x78
    if (_is_digit(*format)) {
   18016:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18018:	781b      	ldrb	r3, [r3, #0]
   1801a:	4618      	mov	r0, r3
   1801c:	f7ff fade 	bl	175dc <_is_digit(char)>
   18020:	4603      	mov	r3, r0
   18022:	2b00      	cmp	r3, #0
   18024:	d005      	beq.n	18032 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x146>
      width = _atoi(&format);
   18026:	ab0a      	add	r3, sp, #40	; 0x28
   18028:	4618      	mov	r0, r3
   1802a:	f7ff faf9 	bl	17620 <_atoi(char const**)>
   1802e:	901e      	str	r0, [sp, #120]	; 0x78
   18030:	e018      	b.n	18064 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x178>
    }
    else if (*format == '*') {
   18032:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18034:	781b      	ldrb	r3, [r3, #0]
   18036:	2b2a      	cmp	r3, #42	; 0x2a
   18038:	d114      	bne.n	18064 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x178>
      const int w = va_arg(va, int);
   1803a:	9b24      	ldr	r3, [sp, #144]	; 0x90
   1803c:	1d1a      	adds	r2, r3, #4
   1803e:	9224      	str	r2, [sp, #144]	; 0x90
   18040:	681b      	ldr	r3, [r3, #0]
   18042:	9316      	str	r3, [sp, #88]	; 0x58
      if (w < 0) {
   18044:	9b16      	ldr	r3, [sp, #88]	; 0x58
   18046:	2b00      	cmp	r3, #0
   18048:	da07      	bge.n	1805a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x16e>
        flags |= FLAGS_LEFT;    // reverse padding
   1804a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1804c:	f043 0302 	orr.w	r3, r3, #2
   18050:	931f      	str	r3, [sp, #124]	; 0x7c
        width = (unsigned int)-w;
   18052:	9b16      	ldr	r3, [sp, #88]	; 0x58
   18054:	425b      	negs	r3, r3
   18056:	931e      	str	r3, [sp, #120]	; 0x78
   18058:	e001      	b.n	1805e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x172>
      }
      else {
        width = (unsigned int)w;
   1805a:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1805c:	931e      	str	r3, [sp, #120]	; 0x78
      }
      format++;
   1805e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18060:	3301      	adds	r3, #1
   18062:	930a      	str	r3, [sp, #40]	; 0x28
    }

    // evaluate precision field
    precision = 0U;
   18064:	2300      	movs	r3, #0
   18066:	931d      	str	r3, [sp, #116]	; 0x74
    if (*format == '.') {
   18068:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1806a:	781b      	ldrb	r3, [r3, #0]
   1806c:	2b2e      	cmp	r3, #46	; 0x2e
   1806e:	d124      	bne.n	180ba <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ce>
      flags |= FLAGS_PRECISION;
   18070:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18072:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   18076:	931f      	str	r3, [sp, #124]	; 0x7c
      format++;
   18078:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1807a:	3301      	adds	r3, #1
   1807c:	930a      	str	r3, [sp, #40]	; 0x28
      if (_is_digit(*format)) {
   1807e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18080:	781b      	ldrb	r3, [r3, #0]
   18082:	4618      	mov	r0, r3
   18084:	f7ff faaa 	bl	175dc <_is_digit(char)>
   18088:	4603      	mov	r3, r0
   1808a:	2b00      	cmp	r3, #0
   1808c:	d005      	beq.n	1809a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ae>
        precision = _atoi(&format);
   1808e:	ab0a      	add	r3, sp, #40	; 0x28
   18090:	4618      	mov	r0, r3
   18092:	f7ff fac5 	bl	17620 <_atoi(char const**)>
   18096:	901d      	str	r0, [sp, #116]	; 0x74
   18098:	e00f      	b.n	180ba <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ce>
      }
      else if (*format == '*') {
   1809a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1809c:	781b      	ldrb	r3, [r3, #0]
   1809e:	2b2a      	cmp	r3, #42	; 0x2a
   180a0:	d10b      	bne.n	180ba <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ce>
        const int prec = (int)va_arg(va, int);
   180a2:	9b24      	ldr	r3, [sp, #144]	; 0x90
   180a4:	1d1a      	adds	r2, r3, #4
   180a6:	9224      	str	r2, [sp, #144]	; 0x90
   180a8:	681b      	ldr	r3, [r3, #0]
   180aa:	9315      	str	r3, [sp, #84]	; 0x54
        precision = prec > 0 ? (unsigned int)prec : 0U;
   180ac:	9b15      	ldr	r3, [sp, #84]	; 0x54
   180ae:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   180b2:	931d      	str	r3, [sp, #116]	; 0x74
        format++;
   180b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   180b6:	3301      	adds	r3, #1
   180b8:	930a      	str	r3, [sp, #40]	; 0x28
      }
    }

    // evaluate length field
    switch (*format) {
   180ba:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   180bc:	781b      	ldrb	r3, [r3, #0]
   180be:	3b68      	subs	r3, #104	; 0x68
   180c0:	2b12      	cmp	r3, #18
   180c2:	d867      	bhi.n	18194 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2a8>
   180c4:	a201      	add	r2, pc, #4	; (adr r2, 180cc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1e0>)
   180c6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   180ca:	bf00      	nop
   180cc:	0001813f 	.word	0x0001813f
   180d0:	00018195 	.word	0x00018195
   180d4:	00018175 	.word	0x00018175
   180d8:	00018195 	.word	0x00018195
   180dc:	00018119 	.word	0x00018119
   180e0:	00018195 	.word	0x00018195
   180e4:	00018195 	.word	0x00018195
   180e8:	00018195 	.word	0x00018195
   180ec:	00018195 	.word	0x00018195
   180f0:	00018195 	.word	0x00018195
   180f4:	00018195 	.word	0x00018195
   180f8:	00018195 	.word	0x00018195
   180fc:	00018165 	.word	0x00018165
   18100:	00018195 	.word	0x00018195
   18104:	00018195 	.word	0x00018195
   18108:	00018195 	.word	0x00018195
   1810c:	00018195 	.word	0x00018195
   18110:	00018195 	.word	0x00018195
   18114:	00018185 	.word	0x00018185
      case 'l' :
        flags |= FLAGS_LONG;
   18118:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1811a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   1811e:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   18120:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18122:	3301      	adds	r3, #1
   18124:	930a      	str	r3, [sp, #40]	; 0x28
        if (*format == 'l') {
   18126:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18128:	781b      	ldrb	r3, [r3, #0]
   1812a:	2b6c      	cmp	r3, #108	; 0x6c
   1812c:	d134      	bne.n	18198 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ac>
          flags |= FLAGS_LONG_LONG;
   1812e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18130:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   18134:	931f      	str	r3, [sp, #124]	; 0x7c
          format++;
   18136:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18138:	3301      	adds	r3, #1
   1813a:	930a      	str	r3, [sp, #40]	; 0x28
        }
        break;
   1813c:	e02c      	b.n	18198 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ac>
      case 'h' :
        flags |= FLAGS_SHORT;
   1813e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18140:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   18144:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   18146:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18148:	3301      	adds	r3, #1
   1814a:	930a      	str	r3, [sp, #40]	; 0x28
        if (*format == 'h') {
   1814c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1814e:	781b      	ldrb	r3, [r3, #0]
   18150:	2b68      	cmp	r3, #104	; 0x68
   18152:	d127      	bne.n	181a4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b8>
          flags |= FLAGS_CHAR;
   18154:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18156:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1815a:	931f      	str	r3, [sp, #124]	; 0x7c
          format++;
   1815c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1815e:	3301      	adds	r3, #1
   18160:	930a      	str	r3, [sp, #40]	; 0x28
        }
        break;
   18162:	e01f      	b.n	181a4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b8>
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
      case 't' :
        flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   18164:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18166:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   1816a:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   1816c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1816e:	3301      	adds	r3, #1
   18170:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   18172:	e018      	b.n	181a6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
#endif
      case 'j' :
        flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   18174:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18176:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   1817a:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   1817c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1817e:	3301      	adds	r3, #1
   18180:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   18182:	e010      	b.n	181a6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
      case 'z' :
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   18184:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18186:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   1818a:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   1818c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1818e:	3301      	adds	r3, #1
   18190:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   18192:	e008      	b.n	181a6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
      default :
        break;
   18194:	bf00      	nop
   18196:	e006      	b.n	181a6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
        break;
   18198:	bf00      	nop
   1819a:	e004      	b.n	181a6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
   1819c:	00017eed 	.word	0x00017eed
   181a0:	00017525 	.word	0x00017525
        break;
   181a4:	bf00      	nop
    }

    // evaluate specifier
    switch (*format) {
   181a6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   181a8:	781b      	ldrb	r3, [r3, #0]
   181aa:	3b25      	subs	r3, #37	; 0x25
   181ac:	2b53      	cmp	r3, #83	; 0x53
   181ae:	f200 82ee 	bhi.w	1878e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8a2>
   181b2:	a201      	add	r2, pc, #4	; (adr r2, 181b8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2cc>)
   181b4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   181b8:	00018777 	.word	0x00018777
   181bc:	0001878f 	.word	0x0001878f
   181c0:	0001878f 	.word	0x0001878f
   181c4:	0001878f 	.word	0x0001878f
   181c8:	0001878f 	.word	0x0001878f
   181cc:	0001878f 	.word	0x0001878f
   181d0:	0001878f 	.word	0x0001878f
   181d4:	0001878f 	.word	0x0001878f
   181d8:	0001878f 	.word	0x0001878f
   181dc:	0001878f 	.word	0x0001878f
   181e0:	0001878f 	.word	0x0001878f
   181e4:	0001878f 	.word	0x0001878f
   181e8:	0001878f 	.word	0x0001878f
   181ec:	0001878f 	.word	0x0001878f
   181f0:	0001878f 	.word	0x0001878f
   181f4:	0001878f 	.word	0x0001878f
   181f8:	0001878f 	.word	0x0001878f
   181fc:	0001878f 	.word	0x0001878f
   18200:	0001878f 	.word	0x0001878f
   18204:	0001878f 	.word	0x0001878f
   18208:	0001878f 	.word	0x0001878f
   1820c:	0001878f 	.word	0x0001878f
   18210:	0001878f 	.word	0x0001878f
   18214:	0001878f 	.word	0x0001878f
   18218:	0001878f 	.word	0x0001878f
   1821c:	0001878f 	.word	0x0001878f
   18220:	0001878f 	.word	0x0001878f
   18224:	0001878f 	.word	0x0001878f
   18228:	0001878f 	.word	0x0001878f
   1822c:	0001878f 	.word	0x0001878f
   18230:	0001878f 	.word	0x0001878f
   18234:	0001878f 	.word	0x0001878f
   18238:	0001878f 	.word	0x0001878f
   1823c:	00018595 	.word	0x00018595
   18240:	0001878f 	.word	0x0001878f
   18244:	0001878f 	.word	0x0001878f
   18248:	0001878f 	.word	0x0001878f
   1824c:	0001878f 	.word	0x0001878f
   18250:	0001878f 	.word	0x0001878f
   18254:	0001878f 	.word	0x0001878f
   18258:	0001878f 	.word	0x0001878f
   1825c:	0001878f 	.word	0x0001878f
   18260:	0001878f 	.word	0x0001878f
   18264:	0001878f 	.word	0x0001878f
   18268:	0001878f 	.word	0x0001878f
   1826c:	0001878f 	.word	0x0001878f
   18270:	0001878f 	.word	0x0001878f
   18274:	0001878f 	.word	0x0001878f
   18278:	0001878f 	.word	0x0001878f
   1827c:	0001878f 	.word	0x0001878f
   18280:	0001878f 	.word	0x0001878f
   18284:	00018309 	.word	0x00018309
   18288:	0001878f 	.word	0x0001878f
   1828c:	0001878f 	.word	0x0001878f
   18290:	0001878f 	.word	0x0001878f
   18294:	0001878f 	.word	0x0001878f
   18298:	0001878f 	.word	0x0001878f
   1829c:	0001878f 	.word	0x0001878f
   182a0:	0001878f 	.word	0x0001878f
   182a4:	0001878f 	.word	0x0001878f
   182a8:	0001878f 	.word	0x0001878f
   182ac:	00018309 	.word	0x00018309
   182b0:	000185d1 	.word	0x000185d1
   182b4:	00018309 	.word	0x00018309
   182b8:	0001878f 	.word	0x0001878f
   182bc:	00018595 	.word	0x00018595
   182c0:	0001878f 	.word	0x0001878f
   182c4:	0001878f 	.word	0x0001878f
   182c8:	00018309 	.word	0x00018309
   182cc:	0001878f 	.word	0x0001878f
   182d0:	0001878f 	.word	0x0001878f
   182d4:	0001878f 	.word	0x0001878f
   182d8:	0001878f 	.word	0x0001878f
   182dc:	0001878f 	.word	0x0001878f
   182e0:	00018309 	.word	0x00018309
   182e4:	0001872f 	.word	0x0001872f
   182e8:	0001878f 	.word	0x0001878f
   182ec:	0001878f 	.word	0x0001878f
   182f0:	00018659 	.word	0x00018659
   182f4:	0001878f 	.word	0x0001878f
   182f8:	00018309 	.word	0x00018309
   182fc:	0001878f 	.word	0x0001878f
   18300:	0001878f 	.word	0x0001878f
   18304:	00018309 	.word	0x00018309
      case 'X' :
      case 'o' :
      case 'b' : {
        // set the base
        unsigned int base;
        if (*format == 'x' || *format == 'X') {
   18308:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1830a:	781b      	ldrb	r3, [r3, #0]
   1830c:	2b78      	cmp	r3, #120	; 0x78
   1830e:	d003      	beq.n	18318 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x42c>
   18310:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18312:	781b      	ldrb	r3, [r3, #0]
   18314:	2b58      	cmp	r3, #88	; 0x58
   18316:	d102      	bne.n	1831e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x432>
          base = 16U;
   18318:	2310      	movs	r3, #16
   1831a:	931a      	str	r3, [sp, #104]	; 0x68
   1831c:	e013      	b.n	18346 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x45a>
        }
        else if (*format == 'o') {
   1831e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18320:	781b      	ldrb	r3, [r3, #0]
   18322:	2b6f      	cmp	r3, #111	; 0x6f
   18324:	d102      	bne.n	1832c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x440>
          base =  8U;
   18326:	2308      	movs	r3, #8
   18328:	931a      	str	r3, [sp, #104]	; 0x68
   1832a:	e00c      	b.n	18346 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x45a>
        }
        else if (*format == 'b') {
   1832c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1832e:	781b      	ldrb	r3, [r3, #0]
   18330:	2b62      	cmp	r3, #98	; 0x62
   18332:	d102      	bne.n	1833a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x44e>
          base =  2U;
   18334:	2302      	movs	r3, #2
   18336:	931a      	str	r3, [sp, #104]	; 0x68
   18338:	e005      	b.n	18346 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x45a>
        }
        else {
          base = 10U;
   1833a:	230a      	movs	r3, #10
   1833c:	931a      	str	r3, [sp, #104]	; 0x68
          flags &= ~FLAGS_HASH;   // no hash for dec format
   1833e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18340:	f023 0310 	bic.w	r3, r3, #16
   18344:	931f      	str	r3, [sp, #124]	; 0x7c
        }
        // uppercase
        if (*format == 'X') {
   18346:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18348:	781b      	ldrb	r3, [r3, #0]
   1834a:	2b58      	cmp	r3, #88	; 0x58
   1834c:	d103      	bne.n	18356 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x46a>
          flags |= FLAGS_UPPERCASE;
   1834e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18350:	f043 0320 	orr.w	r3, r3, #32
   18354:	931f      	str	r3, [sp, #124]	; 0x7c
        }

        // no plus or space flag for u, x, X, o, b
        if ((*format != 'i') && (*format != 'd')) {
   18356:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18358:	781b      	ldrb	r3, [r3, #0]
   1835a:	2b69      	cmp	r3, #105	; 0x69
   1835c:	d007      	beq.n	1836e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x482>
   1835e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18360:	781b      	ldrb	r3, [r3, #0]
   18362:	2b64      	cmp	r3, #100	; 0x64
   18364:	d003      	beq.n	1836e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x482>
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
   18366:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18368:	f023 030c 	bic.w	r3, r3, #12
   1836c:	931f      	str	r3, [sp, #124]	; 0x7c
        }

        // ignore '0' flag when precision is given
        if (flags & FLAGS_PRECISION) {
   1836e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18370:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   18374:	2b00      	cmp	r3, #0
   18376:	d003      	beq.n	18380 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x494>
          flags &= ~FLAGS_ZEROPAD;
   18378:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1837a:	f023 0301 	bic.w	r3, r3, #1
   1837e:	931f      	str	r3, [sp, #124]	; 0x7c
        }

        // convert the integer
        if ((*format == 'i') || (*format == 'd')) {
   18380:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18382:	781b      	ldrb	r3, [r3, #0]
   18384:	2b69      	cmp	r3, #105	; 0x69
   18386:	d004      	beq.n	18392 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x4a6>
   18388:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1838a:	781b      	ldrb	r3, [r3, #0]
   1838c:	2b64      	cmp	r3, #100	; 0x64
   1838e:	f040 808d 	bne.w	184ac <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x5c0>
          // signed
          if (flags & FLAGS_LONG_LONG) {
   18392:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18394:	f403 7300 	and.w	r3, r3, #512	; 0x200
   18398:	2b00      	cmp	r3, #0
   1839a:	d02e      	beq.n	183fa <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x50e>
#if defined(PRINTF_SUPPORT_LONG_LONG)
            const long long value = va_arg(va, long long);
   1839c:	9b24      	ldr	r3, [sp, #144]	; 0x90
   1839e:	3307      	adds	r3, #7
   183a0:	f023 0307 	bic.w	r3, r3, #7
   183a4:	f103 0208 	add.w	r2, r3, #8
   183a8:	9224      	str	r2, [sp, #144]	; 0x90
   183aa:	e9d3 3400 	ldrd	r3, r4, [r3]
   183ae:	e9cd 340e 	strd	r3, r4, [sp, #56]	; 0x38
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   183b2:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
   183b6:	2b00      	cmp	r3, #0
   183b8:	f174 0200 	sbcs.w	r2, r4, #0
   183bc:	da02      	bge.n	183c4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x4d8>
   183be:	425b      	negs	r3, r3
   183c0:	eb64 0444 	sbc.w	r4, r4, r4, lsl #1
   183c4:	4619      	mov	r1, r3
   183c6:	4622      	mov	r2, r4
   183c8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   183ca:	0fdb      	lsrs	r3, r3, #31
   183cc:	b2d8      	uxtb	r0, r3
   183ce:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   183d0:	f04f 0400 	mov.w	r4, #0
   183d4:	9d1f      	ldr	r5, [sp, #124]	; 0x7c
   183d6:	9508      	str	r5, [sp, #32]
   183d8:	9d1e      	ldr	r5, [sp, #120]	; 0x78
   183da:	9507      	str	r5, [sp, #28]
   183dc:	9d1d      	ldr	r5, [sp, #116]	; 0x74
   183de:	9506      	str	r5, [sp, #24]
   183e0:	e9cd 3404 	strd	r3, r4, [sp, #16]
   183e4:	9002      	str	r0, [sp, #8]
   183e6:	e9cd 1200 	strd	r1, r2, [sp]
   183ea:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   183ec:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   183ee:	990c      	ldr	r1, [sp, #48]	; 0x30
   183f0:	980d      	ldr	r0, [sp, #52]	; 0x34
   183f2:	f7ff fae5 	bl	179c0 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>
   183f6:	901b      	str	r0, [sp, #108]	; 0x6c
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
          }
          else {
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
          }
   183f8:	e0c8      	b.n	1858c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
          else if (flags & FLAGS_LONG) {
   183fa:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   183fc:	f403 7380 	and.w	r3, r3, #256	; 0x100
   18400:	2b00      	cmp	r3, #0
   18402:	d01e      	beq.n	18442 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x556>
            const long value = va_arg(va, long);
   18404:	9b24      	ldr	r3, [sp, #144]	; 0x90
   18406:	1d1a      	adds	r2, r3, #4
   18408:	9224      	str	r2, [sp, #144]	; 0x90
   1840a:	681b      	ldr	r3, [r3, #0]
   1840c:	9311      	str	r3, [sp, #68]	; 0x44
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   1840e:	9b11      	ldr	r3, [sp, #68]	; 0x44
   18410:	2b00      	cmp	r3, #0
   18412:	bfb8      	it	lt
   18414:	425b      	neglt	r3, r3
   18416:	4619      	mov	r1, r3
   18418:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1841a:	0fdb      	lsrs	r3, r3, #31
   1841c:	b2db      	uxtb	r3, r3
   1841e:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   18420:	9205      	str	r2, [sp, #20]
   18422:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   18424:	9204      	str	r2, [sp, #16]
   18426:	9a1d      	ldr	r2, [sp, #116]	; 0x74
   18428:	9203      	str	r2, [sp, #12]
   1842a:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   1842c:	9202      	str	r2, [sp, #8]
   1842e:	9301      	str	r3, [sp, #4]
   18430:	9100      	str	r1, [sp, #0]
   18432:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   18434:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   18436:	990c      	ldr	r1, [sp, #48]	; 0x30
   18438:	980d      	ldr	r0, [sp, #52]	; 0x34
   1843a:	f7ff fa4f 	bl	178dc <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   1843e:	901b      	str	r0, [sp, #108]	; 0x6c
          }
   18440:	e0a4      	b.n	1858c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
   18442:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18444:	f003 0340 	and.w	r3, r3, #64	; 0x40
   18448:	2b00      	cmp	r3, #0
   1844a:	d005      	beq.n	18458 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x56c>
   1844c:	9b24      	ldr	r3, [sp, #144]	; 0x90
   1844e:	1d1a      	adds	r2, r3, #4
   18450:	9224      	str	r2, [sp, #144]	; 0x90
   18452:	681b      	ldr	r3, [r3, #0]
   18454:	b2db      	uxtb	r3, r3
   18456:	e00e      	b.n	18476 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x58a>
   18458:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1845a:	f003 0380 	and.w	r3, r3, #128	; 0x80
   1845e:	2b00      	cmp	r3, #0
   18460:	d005      	beq.n	1846e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x582>
   18462:	9b24      	ldr	r3, [sp, #144]	; 0x90
   18464:	1d1a      	adds	r2, r3, #4
   18466:	9224      	str	r2, [sp, #144]	; 0x90
   18468:	681b      	ldr	r3, [r3, #0]
   1846a:	b21b      	sxth	r3, r3
   1846c:	e003      	b.n	18476 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x58a>
   1846e:	9b24      	ldr	r3, [sp, #144]	; 0x90
   18470:	1d1a      	adds	r2, r3, #4
   18472:	9224      	str	r2, [sp, #144]	; 0x90
   18474:	681b      	ldr	r3, [r3, #0]
   18476:	9312      	str	r3, [sp, #72]	; 0x48
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   18478:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1847a:	2b00      	cmp	r3, #0
   1847c:	bfb8      	it	lt
   1847e:	425b      	neglt	r3, r3
   18480:	4619      	mov	r1, r3
   18482:	9b12      	ldr	r3, [sp, #72]	; 0x48
   18484:	0fdb      	lsrs	r3, r3, #31
   18486:	b2db      	uxtb	r3, r3
   18488:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   1848a:	9205      	str	r2, [sp, #20]
   1848c:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   1848e:	9204      	str	r2, [sp, #16]
   18490:	9a1d      	ldr	r2, [sp, #116]	; 0x74
   18492:	9203      	str	r2, [sp, #12]
   18494:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   18496:	9202      	str	r2, [sp, #8]
   18498:	9301      	str	r3, [sp, #4]
   1849a:	9100      	str	r1, [sp, #0]
   1849c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1849e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   184a0:	990c      	ldr	r1, [sp, #48]	; 0x30
   184a2:	980d      	ldr	r0, [sp, #52]	; 0x34
   184a4:	f7ff fa1a 	bl	178dc <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   184a8:	901b      	str	r0, [sp, #108]	; 0x6c
          }
   184aa:	e06f      	b.n	1858c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
        }
        else {
          // unsigned
          if (flags & FLAGS_LONG_LONG) {
   184ac:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   184ae:	f403 7300 	and.w	r3, r3, #512	; 0x200
   184b2:	2b00      	cmp	r3, #0
   184b4:	d020      	beq.n	184f8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x60c>
#if defined(PRINTF_SUPPORT_LONG_LONG)
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
   184b6:	9b24      	ldr	r3, [sp, #144]	; 0x90
   184b8:	3307      	adds	r3, #7
   184ba:	f023 0307 	bic.w	r3, r3, #7
   184be:	f103 0208 	add.w	r2, r3, #8
   184c2:	9224      	str	r2, [sp, #144]	; 0x90
   184c4:	e9d3 3400 	ldrd	r3, r4, [r3]
   184c8:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   184ca:	4611      	mov	r1, r2
   184cc:	f04f 0200 	mov.w	r2, #0
   184d0:	981f      	ldr	r0, [sp, #124]	; 0x7c
   184d2:	9008      	str	r0, [sp, #32]
   184d4:	981e      	ldr	r0, [sp, #120]	; 0x78
   184d6:	9007      	str	r0, [sp, #28]
   184d8:	981d      	ldr	r0, [sp, #116]	; 0x74
   184da:	9006      	str	r0, [sp, #24]
   184dc:	e9cd 1204 	strd	r1, r2, [sp, #16]
   184e0:	2200      	movs	r2, #0
   184e2:	9202      	str	r2, [sp, #8]
   184e4:	e9cd 3400 	strd	r3, r4, [sp]
   184e8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   184ea:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   184ec:	990c      	ldr	r1, [sp, #48]	; 0x30
   184ee:	980d      	ldr	r0, [sp, #52]	; 0x34
   184f0:	f7ff fa66 	bl	179c0 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>
   184f4:	901b      	str	r0, [sp, #108]	; 0x6c
   184f6:	e049      	b.n	1858c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
#endif
          }
          else if (flags & FLAGS_LONG) {
   184f8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   184fa:	f403 7380 	and.w	r3, r3, #256	; 0x100
   184fe:	2b00      	cmp	r3, #0
   18500:	d016      	beq.n	18530 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x644>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
   18502:	9b24      	ldr	r3, [sp, #144]	; 0x90
   18504:	1d1a      	adds	r2, r3, #4
   18506:	9224      	str	r2, [sp, #144]	; 0x90
   18508:	681b      	ldr	r3, [r3, #0]
   1850a:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   1850c:	9205      	str	r2, [sp, #20]
   1850e:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   18510:	9204      	str	r2, [sp, #16]
   18512:	9a1d      	ldr	r2, [sp, #116]	; 0x74
   18514:	9203      	str	r2, [sp, #12]
   18516:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   18518:	9202      	str	r2, [sp, #8]
   1851a:	2200      	movs	r2, #0
   1851c:	9201      	str	r2, [sp, #4]
   1851e:	9300      	str	r3, [sp, #0]
   18520:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   18522:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   18524:	990c      	ldr	r1, [sp, #48]	; 0x30
   18526:	980d      	ldr	r0, [sp, #52]	; 0x34
   18528:	f7ff f9d8 	bl	178dc <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   1852c:	901b      	str	r0, [sp, #108]	; 0x6c
   1852e:	e02d      	b.n	1858c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
          }
          else {
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
   18530:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18532:	f003 0340 	and.w	r3, r3, #64	; 0x40
   18536:	2b00      	cmp	r3, #0
   18538:	d005      	beq.n	18546 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x65a>
   1853a:	9b24      	ldr	r3, [sp, #144]	; 0x90
   1853c:	1d1a      	adds	r2, r3, #4
   1853e:	9224      	str	r2, [sp, #144]	; 0x90
   18540:	681b      	ldr	r3, [r3, #0]
   18542:	b2db      	uxtb	r3, r3
   18544:	e00e      	b.n	18564 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x678>
   18546:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18548:	f003 0380 	and.w	r3, r3, #128	; 0x80
   1854c:	2b00      	cmp	r3, #0
   1854e:	d005      	beq.n	1855c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x670>
   18550:	9b24      	ldr	r3, [sp, #144]	; 0x90
   18552:	1d1a      	adds	r2, r3, #4
   18554:	9224      	str	r2, [sp, #144]	; 0x90
   18556:	681b      	ldr	r3, [r3, #0]
   18558:	b29b      	uxth	r3, r3
   1855a:	e003      	b.n	18564 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x678>
   1855c:	9b24      	ldr	r3, [sp, #144]	; 0x90
   1855e:	1d1a      	adds	r2, r3, #4
   18560:	9224      	str	r2, [sp, #144]	; 0x90
   18562:	681b      	ldr	r3, [r3, #0]
   18564:	9313      	str	r3, [sp, #76]	; 0x4c
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
   18566:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18568:	9305      	str	r3, [sp, #20]
   1856a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   1856c:	9304      	str	r3, [sp, #16]
   1856e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   18570:	9303      	str	r3, [sp, #12]
   18572:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   18574:	9302      	str	r3, [sp, #8]
   18576:	2300      	movs	r3, #0
   18578:	9301      	str	r3, [sp, #4]
   1857a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1857c:	9300      	str	r3, [sp, #0]
   1857e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   18580:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   18582:	990c      	ldr	r1, [sp, #48]	; 0x30
   18584:	980d      	ldr	r0, [sp, #52]	; 0x34
   18586:	f7ff f9a9 	bl	178dc <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   1858a:	901b      	str	r0, [sp, #108]	; 0x6c
          }
        }
        format++;
   1858c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1858e:	3301      	adds	r3, #1
   18590:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   18592:	e109      	b.n	187a8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }
#if defined(PRINTF_SUPPORT_FLOAT)
      case 'f' :
      case 'F' :
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
   18594:	9b24      	ldr	r3, [sp, #144]	; 0x90
   18596:	3307      	adds	r3, #7
   18598:	f023 0307 	bic.w	r3, r3, #7
   1859c:	f103 0208 	add.w	r2, r3, #8
   185a0:	9224      	str	r2, [sp, #144]	; 0x90
   185a2:	ed93 7b00 	vldr	d7, [r3]
   185a6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   185a8:	9302      	str	r3, [sp, #8]
   185aa:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   185ac:	9301      	str	r3, [sp, #4]
   185ae:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   185b0:	9300      	str	r3, [sp, #0]
   185b2:	eeb0 0a47 	vmov.f32	s0, s14
   185b6:	eef0 0a67 	vmov.f32	s1, s15
   185ba:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   185bc:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   185be:	990c      	ldr	r1, [sp, #48]	; 0x30
   185c0:	980d      	ldr	r0, [sp, #52]	; 0x34
   185c2:	f7ff fa77 	bl	17ab4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)>
   185c6:	901b      	str	r0, [sp, #108]	; 0x6c
        format++;
   185c8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   185ca:	3301      	adds	r3, #1
   185cc:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   185ce:	e0eb      	b.n	187a8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
#endif  // PRINTF_SUPPORT_FLOAT
      case 'c' : {
        unsigned int l = 1U;
   185d0:	2301      	movs	r3, #1
   185d2:	9319      	str	r3, [sp, #100]	; 0x64
        // pre padding
        if (!(flags & FLAGS_LEFT)) {
   185d4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   185d6:	f003 0302 	and.w	r3, r3, #2
   185da:	2b00      	cmp	r3, #0
   185dc:	d113      	bne.n	18606 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x71a>
          while (l++ < width) {
   185de:	9b19      	ldr	r3, [sp, #100]	; 0x64
   185e0:	1c5a      	adds	r2, r3, #1
   185e2:	9219      	str	r2, [sp, #100]	; 0x64
   185e4:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   185e6:	429a      	cmp	r2, r3
   185e8:	bf8c      	ite	hi
   185ea:	2301      	movhi	r3, #1
   185ec:	2300      	movls	r3, #0
   185ee:	b2db      	uxtb	r3, r3
   185f0:	2b00      	cmp	r3, #0
   185f2:	d008      	beq.n	18606 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x71a>
            out(' ', buffer, idx++, maxlen);
   185f4:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   185f6:	1c53      	adds	r3, r2, #1
   185f8:	931b      	str	r3, [sp, #108]	; 0x6c
   185fa:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   185fc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   185fe:	990c      	ldr	r1, [sp, #48]	; 0x30
   18600:	2020      	movs	r0, #32
   18602:	47a0      	blx	r4
          while (l++ < width) {
   18604:	e7eb      	b.n	185de <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6f2>
          }
        }
        // char output
        out((char)va_arg(va, int), buffer, idx++, maxlen);
   18606:	9b24      	ldr	r3, [sp, #144]	; 0x90
   18608:	1d1a      	adds	r2, r3, #4
   1860a:	9224      	str	r2, [sp, #144]	; 0x90
   1860c:	681b      	ldr	r3, [r3, #0]
   1860e:	b2d8      	uxtb	r0, r3
   18610:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   18612:	1c53      	adds	r3, r2, #1
   18614:	931b      	str	r3, [sp, #108]	; 0x6c
   18616:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   18618:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1861a:	990c      	ldr	r1, [sp, #48]	; 0x30
   1861c:	47a0      	blx	r4
        // post padding
        if (flags & FLAGS_LEFT) {
   1861e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18620:	f003 0302 	and.w	r3, r3, #2
   18624:	2b00      	cmp	r3, #0
   18626:	d013      	beq.n	18650 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x764>
          while (l++ < width) {
   18628:	9b19      	ldr	r3, [sp, #100]	; 0x64
   1862a:	1c5a      	adds	r2, r3, #1
   1862c:	9219      	str	r2, [sp, #100]	; 0x64
   1862e:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   18630:	429a      	cmp	r2, r3
   18632:	bf8c      	ite	hi
   18634:	2301      	movhi	r3, #1
   18636:	2300      	movls	r3, #0
   18638:	b2db      	uxtb	r3, r3
   1863a:	2b00      	cmp	r3, #0
   1863c:	d008      	beq.n	18650 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x764>
            out(' ', buffer, idx++, maxlen);
   1863e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   18640:	1c53      	adds	r3, r2, #1
   18642:	931b      	str	r3, [sp, #108]	; 0x6c
   18644:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   18646:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   18648:	990c      	ldr	r1, [sp, #48]	; 0x30
   1864a:	2020      	movs	r0, #32
   1864c:	47a0      	blx	r4
          while (l++ < width) {
   1864e:	e7eb      	b.n	18628 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x73c>
          }
        }
        format++;
   18650:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18652:	3301      	adds	r3, #1
   18654:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   18656:	e0a7      	b.n	187a8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }

      case 's' : {
        char* p = va_arg(va, char*);
   18658:	9b24      	ldr	r3, [sp, #144]	; 0x90
   1865a:	1d1a      	adds	r2, r3, #4
   1865c:	9224      	str	r2, [sp, #144]	; 0x90
   1865e:	681b      	ldr	r3, [r3, #0]
   18660:	9318      	str	r3, [sp, #96]	; 0x60
        unsigned int l = _strlen(p);
   18662:	9818      	ldr	r0, [sp, #96]	; 0x60
   18664:	f7fe ff98 	bl	17598 <_strlen(char const*)>
   18668:	9017      	str	r0, [sp, #92]	; 0x5c
        // pre padding
        if (flags & FLAGS_PRECISION) {
   1866a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1866c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   18670:	2b00      	cmp	r3, #0
   18672:	d007      	beq.n	18684 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x798>
          l = (l < precision ? l : precision);
   18674:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   18676:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   18678:	429a      	cmp	r2, r3
   1867a:	d201      	bcs.n	18680 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x794>
   1867c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1867e:	e000      	b.n	18682 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x796>
   18680:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   18682:	9317      	str	r3, [sp, #92]	; 0x5c
        }
        if (!(flags & FLAGS_LEFT)) {
   18684:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18686:	f003 0302 	and.w	r3, r3, #2
   1868a:	2b00      	cmp	r3, #0
   1868c:	d113      	bne.n	186b6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ca>
          while (l++ < width) {
   1868e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   18690:	1c5a      	adds	r2, r3, #1
   18692:	9217      	str	r2, [sp, #92]	; 0x5c
   18694:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   18696:	429a      	cmp	r2, r3
   18698:	bf8c      	ite	hi
   1869a:	2301      	movhi	r3, #1
   1869c:	2300      	movls	r3, #0
   1869e:	b2db      	uxtb	r3, r3
   186a0:	2b00      	cmp	r3, #0
   186a2:	d008      	beq.n	186b6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ca>
            out(' ', buffer, idx++, maxlen);
   186a4:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   186a6:	1c53      	adds	r3, r2, #1
   186a8:	931b      	str	r3, [sp, #108]	; 0x6c
   186aa:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   186ac:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   186ae:	990c      	ldr	r1, [sp, #48]	; 0x30
   186b0:	2020      	movs	r0, #32
   186b2:	47a0      	blx	r4
          while (l++ < width) {
   186b4:	e7eb      	b.n	1868e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7a2>
          }
        }
        // string output
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
   186b6:	9b18      	ldr	r3, [sp, #96]	; 0x60
   186b8:	781b      	ldrb	r3, [r3, #0]
   186ba:	2b00      	cmp	r3, #0
   186bc:	d00b      	beq.n	186d6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ea>
   186be:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   186c0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   186c4:	2b00      	cmp	r3, #0
   186c6:	d004      	beq.n	186d2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7e6>
   186c8:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   186ca:	1e5a      	subs	r2, r3, #1
   186cc:	921d      	str	r2, [sp, #116]	; 0x74
   186ce:	2b00      	cmp	r3, #0
   186d0:	d001      	beq.n	186d6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ea>
   186d2:	2301      	movs	r3, #1
   186d4:	e000      	b.n	186d8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ec>
   186d6:	2300      	movs	r3, #0
   186d8:	2b00      	cmp	r3, #0
   186da:	d00b      	beq.n	186f4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x808>
          out(*(p++), buffer, idx++, maxlen);
   186dc:	9b18      	ldr	r3, [sp, #96]	; 0x60
   186de:	1c5a      	adds	r2, r3, #1
   186e0:	9218      	str	r2, [sp, #96]	; 0x60
   186e2:	7818      	ldrb	r0, [r3, #0]
   186e4:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   186e6:	1c53      	adds	r3, r2, #1
   186e8:	931b      	str	r3, [sp, #108]	; 0x6c
   186ea:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   186ec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   186ee:	990c      	ldr	r1, [sp, #48]	; 0x30
   186f0:	47a0      	blx	r4
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
   186f2:	e7e0      	b.n	186b6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ca>
        }
        // post padding
        if (flags & FLAGS_LEFT) {
   186f4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   186f6:	f003 0302 	and.w	r3, r3, #2
   186fa:	2b00      	cmp	r3, #0
   186fc:	d013      	beq.n	18726 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x83a>
          while (l++ < width) {
   186fe:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   18700:	1c5a      	adds	r2, r3, #1
   18702:	9217      	str	r2, [sp, #92]	; 0x5c
   18704:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   18706:	429a      	cmp	r2, r3
   18708:	bf8c      	ite	hi
   1870a:	2301      	movhi	r3, #1
   1870c:	2300      	movls	r3, #0
   1870e:	b2db      	uxtb	r3, r3
   18710:	2b00      	cmp	r3, #0
   18712:	d008      	beq.n	18726 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x83a>
            out(' ', buffer, idx++, maxlen);
   18714:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   18716:	1c53      	adds	r3, r2, #1
   18718:	931b      	str	r3, [sp, #108]	; 0x6c
   1871a:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   1871c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1871e:	990c      	ldr	r1, [sp, #48]	; 0x30
   18720:	2020      	movs	r0, #32
   18722:	47a0      	blx	r4
          while (l++ < width) {
   18724:	e7eb      	b.n	186fe <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x812>
          }
        }
        format++;
   18726:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18728:	3301      	adds	r3, #1
   1872a:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   1872c:	e03c      	b.n	187a8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }

      case 'p' : {
        width = sizeof(void*) * 2U;
   1872e:	2308      	movs	r3, #8
   18730:	931e      	str	r3, [sp, #120]	; 0x78
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
   18732:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   18734:	f043 0321 	orr.w	r3, r3, #33	; 0x21
   18738:	931f      	str	r3, [sp, #124]	; 0x7c
#if defined(PRINTF_SUPPORT_LONG_LONG)
        const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
   1873a:	2300      	movs	r3, #0
   1873c:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
        if (is_ll) {
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
        }
        else {
#endif
          idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
   18740:	9b24      	ldr	r3, [sp, #144]	; 0x90
   18742:	1d1a      	adds	r2, r3, #4
   18744:	9224      	str	r2, [sp, #144]	; 0x90
   18746:	681b      	ldr	r3, [r3, #0]
   18748:	461a      	mov	r2, r3
   1874a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1874c:	9305      	str	r3, [sp, #20]
   1874e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   18750:	9304      	str	r3, [sp, #16]
   18752:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   18754:	9303      	str	r3, [sp, #12]
   18756:	2310      	movs	r3, #16
   18758:	9302      	str	r3, [sp, #8]
   1875a:	2300      	movs	r3, #0
   1875c:	9301      	str	r3, [sp, #4]
   1875e:	9200      	str	r2, [sp, #0]
   18760:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   18762:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   18764:	990c      	ldr	r1, [sp, #48]	; 0x30
   18766:	980d      	ldr	r0, [sp, #52]	; 0x34
   18768:	f7ff f8b8 	bl	178dc <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   1876c:	901b      	str	r0, [sp, #108]	; 0x6c
#if defined(PRINTF_SUPPORT_LONG_LONG)
        }
#endif
        format++;
   1876e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18770:	3301      	adds	r3, #1
   18772:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   18774:	e018      	b.n	187a8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }

      case '%' :
        out('%', buffer, idx++, maxlen);
   18776:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   18778:	1c53      	adds	r3, r2, #1
   1877a:	931b      	str	r3, [sp, #108]	; 0x6c
   1877c:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   1877e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   18780:	990c      	ldr	r1, [sp, #48]	; 0x30
   18782:	2025      	movs	r0, #37	; 0x25
   18784:	47a0      	blx	r4
        format++;
   18786:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18788:	3301      	adds	r3, #1
   1878a:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   1878c:	e00c      	b.n	187a8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>

      default :
        out(*format, buffer, idx++, maxlen);
   1878e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18790:	7818      	ldrb	r0, [r3, #0]
   18792:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   18794:	1c53      	adds	r3, r2, #1
   18796:	931b      	str	r3, [sp, #108]	; 0x6c
   18798:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   1879a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1879c:	990c      	ldr	r1, [sp, #48]	; 0x30
   1879e:	47a0      	blx	r4
        format++;
   187a0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   187a2:	3301      	adds	r3, #1
   187a4:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   187a6:	bf00      	nop
  while (*format)
   187a8:	f7ff bbb3 	b.w	17f12 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x26>
    }
  }

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
   187ac:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   187ae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   187b0:	429a      	cmp	r2, r3
   187b2:	d302      	bcc.n	187ba <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ce>
   187b4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   187b6:	1e5a      	subs	r2, r3, #1
   187b8:	e000      	b.n	187bc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8d0>
   187ba:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   187bc:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   187be:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   187c0:	990c      	ldr	r1, [sp, #48]	; 0x30
   187c2:	2000      	movs	r0, #0
   187c4:	47a0      	blx	r4

  // return written chars without terminating \0
  return (int)idx;
   187c6:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
   187c8:	4633      	mov	r3, r6
   187ca:	4619      	mov	r1, r3
   187cc:	4803      	ldr	r0, [pc, #12]	; (187dc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8f0>)
   187ce:	f7fe f8a5 	bl	1691c <__cyg_profile_func_exit>
   187d2:	4623      	mov	r3, r4
}
   187d4:	4618      	mov	r0, r3
   187d6:	b020      	add	sp, #128	; 0x80
   187d8:	bd70      	pop	{r4, r5, r6, pc}
   187da:	bf00      	nop
   187dc:	00017eed 	.word	0x00017eed

000187e0 <printf>:

///////////////////////////////////////////////////////////////////////////////


int printf(const char* format, ...)
{
   187e0:	b40f      	push	{r0, r1, r2, r3}
   187e2:	b530      	push	{r4, r5, lr}
   187e4:	b087      	sub	sp, #28
   187e6:	4675      	mov	r5, lr
   187e8:	462b      	mov	r3, r5
   187ea:	4619      	mov	r1, r3
   187ec:	480d      	ldr	r0, [pc, #52]	; (18824 <printf+0x44>)
   187ee:	f7fe f881 	bl	168f4 <__cyg_profile_func_enter>
  va_list va;
  va_start(va, format);
   187f2:	ab0b      	add	r3, sp, #44	; 0x2c
   187f4:	9304      	str	r3, [sp, #16]
  char buffer[1];
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
   187f6:	a903      	add	r1, sp, #12
   187f8:	9b04      	ldr	r3, [sp, #16]
   187fa:	9300      	str	r3, [sp, #0]
   187fc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   187fe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   18802:	4809      	ldr	r0, [pc, #36]	; (18828 <printf+0x48>)
   18804:	f7ff fb72 	bl	17eec <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)>
   18808:	9005      	str	r0, [sp, #20]
  va_end(va);
  return ret;
   1880a:	9c05      	ldr	r4, [sp, #20]
   1880c:	462b      	mov	r3, r5
   1880e:	4619      	mov	r1, r3
   18810:	4804      	ldr	r0, [pc, #16]	; (18824 <printf+0x44>)
   18812:	f7fe f883 	bl	1691c <__cyg_profile_func_exit>
   18816:	4623      	mov	r3, r4
}
   18818:	4618      	mov	r0, r3
   1881a:	b007      	add	sp, #28
   1881c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   18820:	b004      	add	sp, #16
   18822:	4770      	bx	lr
   18824:	000187e1 	.word	0x000187e1
   18828:	00017555 	.word	0x00017555

0001882c <sprintf>:


int sprintf(char* buffer, const char* format, ...)
{
   1882c:	b40e      	push	{r1, r2, r3}
   1882e:	b530      	push	{r4, r5, lr}
   18830:	b086      	sub	sp, #24
   18832:	4675      	mov	r5, lr
   18834:	9003      	str	r0, [sp, #12]
   18836:	462b      	mov	r3, r5
   18838:	4619      	mov	r1, r3
   1883a:	480e      	ldr	r0, [pc, #56]	; (18874 <sprintf+0x48>)
   1883c:	f7fe f85a 	bl	168f4 <__cyg_profile_func_enter>
  va_list va;
  va_start(va, format);
   18840:	ab0a      	add	r3, sp, #40	; 0x28
   18842:	9304      	str	r3, [sp, #16]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
   18844:	9b04      	ldr	r3, [sp, #16]
   18846:	9300      	str	r3, [sp, #0]
   18848:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1884a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1884e:	9903      	ldr	r1, [sp, #12]
   18850:	4809      	ldr	r0, [pc, #36]	; (18878 <sprintf+0x4c>)
   18852:	f7ff fb4b 	bl	17eec <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)>
   18856:	9005      	str	r0, [sp, #20]
  va_end(va);
  return ret;
   18858:	9c05      	ldr	r4, [sp, #20]
   1885a:	462b      	mov	r3, r5
   1885c:	4619      	mov	r1, r3
   1885e:	4805      	ldr	r0, [pc, #20]	; (18874 <sprintf+0x48>)
   18860:	f7fe f85c 	bl	1691c <__cyg_profile_func_exit>
   18864:	4623      	mov	r3, r4
}
   18866:	4618      	mov	r0, r3
   18868:	b006      	add	sp, #24
   1886a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   1886e:	b003      	add	sp, #12
   18870:	4770      	bx	lr
   18872:	bf00      	nop
   18874:	0001882d 	.word	0x0001882d
   18878:	000174e1 	.word	0x000174e1

0001887c <vsnprintf>:
  return ret;
}


int vsnprintf(char* buffer, size_t count, const char* format, va_list va)
{
   1887c:	b530      	push	{r4, r5, lr}
   1887e:	b087      	sub	sp, #28
   18880:	4674      	mov	r4, lr
   18882:	9005      	str	r0, [sp, #20]
   18884:	9104      	str	r1, [sp, #16]
   18886:	9203      	str	r2, [sp, #12]
   18888:	9302      	str	r3, [sp, #8]
   1888a:	4623      	mov	r3, r4
   1888c:	4619      	mov	r1, r3
   1888e:	480a      	ldr	r0, [pc, #40]	; (188b8 <vsnprintf+0x3c>)
   18890:	f7fe f830 	bl	168f4 <__cyg_profile_func_enter>
  return _vsnprintf(_out_buffer, buffer, count, format, va);
   18894:	9b02      	ldr	r3, [sp, #8]
   18896:	9300      	str	r3, [sp, #0]
   18898:	9b03      	ldr	r3, [sp, #12]
   1889a:	9a04      	ldr	r2, [sp, #16]
   1889c:	9905      	ldr	r1, [sp, #20]
   1889e:	4807      	ldr	r0, [pc, #28]	; (188bc <vsnprintf+0x40>)
   188a0:	f7ff fb24 	bl	17eec <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)>
   188a4:	4605      	mov	r5, r0
   188a6:	4623      	mov	r3, r4
   188a8:	4619      	mov	r1, r3
   188aa:	4803      	ldr	r0, [pc, #12]	; (188b8 <vsnprintf+0x3c>)
   188ac:	f7fe f836 	bl	1691c <__cyg_profile_func_exit>
   188b0:	462b      	mov	r3, r5
}
   188b2:	4618      	mov	r0, r3
   188b4:	b007      	add	sp, #28
   188b6:	bd30      	pop	{r4, r5, pc}
   188b8:	0001887d 	.word	0x0001887d
   188bc:	000174e1 	.word	0x000174e1

000188c0 <SdInterface::SdInterface()>:
// NOLINTNEXTLINE(readability-identifier-naming)
// Relevant Datasheet:
// https://www.sdcard.org/downloads/pls/pdf/index.php?p=Part1_Physical_Layer_Simplified_Specification_Ver6.00.jpg&f=Part1_Physical_Layer_Simplified_Specification_Ver6.00.pdf&e=EN_SS1
// TODO(#348):  Write a class to represent a single Sd Card Block to make use
//              of block-related functions easier.
class SdInterface
   188c0:	b530      	push	{r4, r5, lr}
   188c2:	b083      	sub	sp, #12
   188c4:	4675      	mov	r5, lr
   188c6:	9001      	str	r0, [sp, #4]
   188c8:	462b      	mov	r3, r5
   188ca:	4619      	mov	r1, r3
   188cc:	4807      	ldr	r0, [pc, #28]	; (188ec <SdInterface::SdInterface()+0x2c>)
   188ce:	f7fe f811 	bl	168f4 <__cyg_profile_func_enter>
   188d2:	4a07      	ldr	r2, [pc, #28]	; (188f0 <SdInterface::SdInterface()+0x30>)
   188d4:	9b01      	ldr	r3, [sp, #4]
   188d6:	601a      	str	r2, [r3, #0]
   188d8:	9c01      	ldr	r4, [sp, #4]
   188da:	462b      	mov	r3, r5
   188dc:	4619      	mov	r1, r3
   188de:	4803      	ldr	r0, [pc, #12]	; (188ec <SdInterface::SdInterface()+0x2c>)
   188e0:	f7fe f81c 	bl	1691c <__cyg_profile_func_exit>
   188e4:	4623      	mov	r3, r4
   188e6:	4618      	mov	r0, r3
   188e8:	b003      	add	sp, #12
   188ea:	bd30      	pop	{r4, r5, pc}
   188ec:	000188c1 	.word	0x000188c1
   188f0:	0001f3ec 	.word	0x0001f3ec

000188f4 <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)>:
  /// port that is broken out through the board's GPIO, allowing you to probe
  /// the chip select manually. To use this version instead of the main version,
  /// instantiate an Sd card instance like so:
  ///
  ///   Sd sdcard(Sd::DebugSdCard_t{});
  constexpr Sd(DebugSdCard_t, uint8_t port = 1, uint8_t pin = 8,
   188f4:	b530      	push	{r4, r5, lr}
   188f6:	b083      	sub	sp, #12
   188f8:	4675      	mov	r5, lr
   188fa:	9001      	str	r0, [sp, #4]
   188fc:	f88d 1000 	strb.w	r1, [sp]
   18900:	4611      	mov	r1, r2
   18902:	461a      	mov	r2, r3
   18904:	460b      	mov	r3, r1
   18906:	f88d 3003 	strb.w	r3, [sp, #3]
   1890a:	4613      	mov	r3, r2
   1890c:	f88d 3002 	strb.w	r3, [sp, #2]
   18910:	462b      	mov	r3, r5
   18912:	4619      	mov	r1, r3
   18914:	481d      	ldr	r0, [pc, #116]	; (1898c <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)+0x98>)
   18916:	f7fd ffed 	bl	168f4 <__cyg_profile_func_enter>
      : ssp_interface_(&ssp_),
        ssp_(Ssp::Peripheral::kSsp2),
        chip_select_(&chip_select_pin_),
        chip_select_external_(&chip_select_external_pin_),
        chip_select_pin_(port, pin),
        chip_select_external_pin_(extport, extpin)
   1891a:	9b01      	ldr	r3, [sp, #4]
   1891c:	4618      	mov	r0, r3
   1891e:	f7ff ffcf 	bl	188c0 <SdInterface::SdInterface()>
   18922:	4a1b      	ldr	r2, [pc, #108]	; (18990 <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)+0x9c>)
   18924:	9b01      	ldr	r3, [sp, #4]
   18926:	601a      	str	r2, [r3, #0]
   18928:	9b01      	ldr	r3, [sp, #4]
   1892a:	f103 0208 	add.w	r2, r3, #8
   1892e:	9b01      	ldr	r3, [sp, #4]
   18930:	605a      	str	r2, [r3, #4]
   18932:	9b01      	ldr	r3, [sp, #4]
   18934:	3308      	adds	r3, #8
   18936:	2102      	movs	r1, #2
   18938:	4618      	mov	r0, r3
   1893a:	f7fa fbfb 	bl	13134 <Ssp::Ssp(Ssp::Peripheral)>
   1893e:	9b01      	ldr	r3, [sp, #4]
   18940:	f103 0240 	add.w	r2, r3, #64	; 0x40
   18944:	9b01      	ldr	r3, [sp, #4]
   18946:	639a      	str	r2, [r3, #56]	; 0x38
   18948:	9b01      	ldr	r3, [sp, #4]
   1894a:	f103 0254 	add.w	r2, r3, #84	; 0x54
   1894e:	9b01      	ldr	r3, [sp, #4]
   18950:	63da      	str	r2, [r3, #60]	; 0x3c
   18952:	9b01      	ldr	r3, [sp, #4]
   18954:	3340      	adds	r3, #64	; 0x40
   18956:	f89d 2002 	ldrb.w	r2, [sp, #2]
   1895a:	f89d 1003 	ldrb.w	r1, [sp, #3]
   1895e:	4618      	mov	r0, r3
   18960:	f7f9 fdb8 	bl	124d4 <Gpio::Gpio(unsigned char, unsigned char)>
   18964:	9b01      	ldr	r3, [sp, #4]
   18966:	3354      	adds	r3, #84	; 0x54
   18968:	f89d 201c 	ldrb.w	r2, [sp, #28]
   1896c:	f89d 1018 	ldrb.w	r1, [sp, #24]
   18970:	4618      	mov	r0, r3
   18972:	f7f9 fdaf 	bl	124d4 <Gpio::Gpio(unsigned char, unsigned char)>
  {
  }
   18976:	9c01      	ldr	r4, [sp, #4]
   18978:	462b      	mov	r3, r5
   1897a:	4619      	mov	r1, r3
   1897c:	4803      	ldr	r0, [pc, #12]	; (1898c <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)+0x98>)
   1897e:	f7fd ffcd 	bl	1691c <__cyg_profile_func_exit>
   18982:	4623      	mov	r3, r4
   18984:	4618      	mov	r0, r3
   18986:	b003      	add	sp, #12
   18988:	bd30      	pop	{r4, r5, pc}
   1898a:	bf00      	nop
   1898c:	000188f5 	.word	0x000188f5
   18990:	0001f3c0 	.word	0x0001f3c0

00018994 <Sd::Initialize()>:

  void Initialize() override
   18994:	b530      	push	{r4, r5, lr}
   18996:	b085      	sub	sp, #20
   18998:	4675      	mov	r5, lr
   1899a:	9003      	str	r0, [sp, #12]
   1899c:	462b      	mov	r3, r5
   1899e:	4619      	mov	r1, r3
   189a0:	4827      	ldr	r0, [pc, #156]	; (18a40 <Sd::Initialize()+0xac>)
   189a2:	f7fd ffa7 	bl	168f4 <__cyg_profile_func_enter>
  {
    LOG_DEBUG("Begin initialization:");
    LOG_DEBUG("Setting CS as output...");
    chip_select_->SetAsOutput();
   189a6:	9b03      	ldr	r3, [sp, #12]
   189a8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   189aa:	9b03      	ldr	r3, [sp, #12]
   189ac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   189ae:	681b      	ldr	r3, [r3, #0]
   189b0:	3304      	adds	r3, #4
   189b2:	681b      	ldr	r3, [r3, #0]
   189b4:	4610      	mov	r0, r2
   189b6:	4798      	blx	r3
    chip_select_->SetHigh();
   189b8:	9b03      	ldr	r3, [sp, #12]
   189ba:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   189bc:	9b03      	ldr	r3, [sp, #12]
   189be:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   189c0:	681b      	ldr	r3, [r3, #0]
   189c2:	330c      	adds	r3, #12
   189c4:	681b      	ldr	r3, [r3, #0]
   189c6:	4610      	mov	r0, r2
   189c8:	4798      	blx	r3
    chip_select_external_->SetAsOutput();
   189ca:	9b03      	ldr	r3, [sp, #12]
   189cc:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   189ce:	9b03      	ldr	r3, [sp, #12]
   189d0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   189d2:	681b      	ldr	r3, [r3, #0]
   189d4:	3304      	adds	r3, #4
   189d6:	681b      	ldr	r3, [r3, #0]
   189d8:	4610      	mov	r0, r2
   189da:	4798      	blx	r3
    chip_select_external_->SetHigh();
   189dc:	9b03      	ldr	r3, [sp, #12]
   189de:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   189e0:	9b03      	ldr	r3, [sp, #12]
   189e2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   189e4:	681b      	ldr	r3, [r3, #0]
   189e6:	330c      	adds	r3, #12
   189e8:	681b      	ldr	r3, [r3, #0]
   189ea:	4610      	mov	r0, r2
   189ec:	4798      	blx	r3

    LOG_DEBUG("Setting SSP Clock Speed...");
    ssp_interface_->SetClock(false, false, 14, 2);  // 400kHz
   189ee:	9b03      	ldr	r3, [sp, #12]
   189f0:	6858      	ldr	r0, [r3, #4]
   189f2:	9b03      	ldr	r3, [sp, #12]
   189f4:	685b      	ldr	r3, [r3, #4]
   189f6:	681b      	ldr	r3, [r3, #0]
   189f8:	3318      	adds	r3, #24
   189fa:	681c      	ldr	r4, [r3, #0]
   189fc:	2302      	movs	r3, #2
   189fe:	9300      	str	r3, [sp, #0]
   18a00:	230e      	movs	r3, #14
   18a02:	2200      	movs	r2, #0
   18a04:	2100      	movs	r1, #0
   18a06:	47a0      	blx	r4

    LOG_DEBUG("Setting Peripheral Mode...");
    ssp_interface_->SetPeripheralMode(Ssp::MasterSlaveMode::kMaster,
   18a08:	9b03      	ldr	r3, [sp, #12]
   18a0a:	6858      	ldr	r0, [r3, #4]
   18a0c:	9b03      	ldr	r3, [sp, #12]
   18a0e:	685b      	ldr	r3, [r3, #4]
                                      Ssp::FrameMode::kSpi,
                                      Ssp::DataSize::kEight);
   18a10:	681b      	ldr	r3, [r3, #0]
   18a12:	3310      	adds	r3, #16
   18a14:	681c      	ldr	r4, [r3, #0]
    ssp_interface_->SetPeripheralMode(Ssp::MasterSlaveMode::kMaster,
   18a16:	2307      	movs	r3, #7
   18a18:	2200      	movs	r2, #0
   18a1a:	2100      	movs	r1, #0
   18a1c:	47a0      	blx	r4

    LOG_DEBUG("Starting SSP Peripheral...");
    ssp_interface_->Initialize();
   18a1e:	9b03      	ldr	r3, [sp, #12]
   18a20:	685a      	ldr	r2, [r3, #4]
   18a22:	9b03      	ldr	r3, [sp, #12]
   18a24:	685b      	ldr	r3, [r3, #4]
   18a26:	681b      	ldr	r3, [r3, #0]
   18a28:	681b      	ldr	r3, [r3, #0]
   18a2a:	4610      	mov	r0, r2
   18a2c:	4798      	blx	r3
   18a2e:	462b      	mov	r3, r5
   18a30:	4619      	mov	r1, r3
   18a32:	4803      	ldr	r0, [pc, #12]	; (18a40 <Sd::Initialize()+0xac>)
   18a34:	f7fd ff72 	bl	1691c <__cyg_profile_func_exit>
  }
   18a38:	bf00      	nop
   18a3a:	b005      	add	sp, #20
   18a3c:	bd30      	pop	{r4, r5, pc}
   18a3e:	bf00      	nop
   18a40:	00018995 	.word	0x00018995

00018a44 <Sd::Mount(SdInterface::CardInfo_t*)>:

  // Initialize SD Card
  // TODO(#349): Split method into smaller piece with single jobs
  bool Mount(CardInfo_t * sd) override
   18a44:	b530      	push	{r4, r5, lr}
   18a46:	b08b      	sub	sp, #44	; 0x2c
   18a48:	4675      	mov	r5, lr
   18a4a:	9003      	str	r0, [sp, #12]
   18a4c:	9102      	str	r1, [sp, #8]
   18a4e:	462b      	mov	r3, r5
   18a50:	4619      	mov	r1, r3
   18a52:	48a7      	ldr	r0, [pc, #668]	; (18cf0 <Sd::Mount(SdInterface::CardInfo_t*)+0x2ac>)
   18a54:	f7fd ff4e 	bl	168f4 <__cyg_profile_func_enter>
  {
    uint8_t tries     = 0;
   18a58:	2300      	movs	r3, #0
   18a5a:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    bool card_is_idle = false;
   18a5e:	2300      	movs	r3, #0
   18a60:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26

    // Reset the card and force it to go to idle state at <400kHz with a
    // CMD0 + (active-low) CS
    LOG_DEBUG("Sending SD Card to Idle State...");
    sd->response.length = SendCmd(Command::kReset, 0x00000000,
                                  sd->response.data.byte, 100, KeepAlive::kYes);
   18a64:	9b03      	ldr	r3, [sp, #12]
   18a66:	681b      	ldr	r3, [r3, #0]
   18a68:	681c      	ldr	r4, [r3, #0]
    sd->response.length = SendCmd(Command::kReset, 0x00000000,
   18a6a:	9b02      	ldr	r3, [sp, #8]
   18a6c:	f103 0208 	add.w	r2, r3, #8
   18a70:	2301      	movs	r3, #1
   18a72:	9301      	str	r3, [sp, #4]
   18a74:	2364      	movs	r3, #100	; 0x64
   18a76:	9300      	str	r3, [sp, #0]
   18a78:	4613      	mov	r3, r2
   18a7a:	2200      	movs	r2, #0
   18a7c:	2140      	movs	r1, #64	; 0x40
   18a7e:	9803      	ldr	r0, [sp, #12]
   18a80:	47a0      	blx	r4
   18a82:	4602      	mov	r2, r0
   18a84:	9b02      	ldr	r3, [sp, #8]
   18a86:	611a      	str	r2, [r3, #16]

    // Reset the card again to trigger SPI mode
    LOG_DEBUG("Initializing SPI mode...");
    do
    {
      tries++;
   18a88:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   18a8c:	3301      	adds	r3, #1
   18a8e:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
      sd->response.length = SendCmd(
          Command::kReset, 0x00, sd->response.data.byte, 100, KeepAlive::kYes);
   18a92:	9b03      	ldr	r3, [sp, #12]
   18a94:	681b      	ldr	r3, [r3, #0]
   18a96:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(
   18a98:	9b02      	ldr	r3, [sp, #8]
   18a9a:	f103 0208 	add.w	r2, r3, #8
   18a9e:	2301      	movs	r3, #1
   18aa0:	9301      	str	r3, [sp, #4]
   18aa2:	2364      	movs	r3, #100	; 0x64
   18aa4:	9300      	str	r3, [sp, #0]
   18aa6:	4613      	mov	r3, r2
   18aa8:	2200      	movs	r2, #0
   18aaa:	2140      	movs	r1, #64	; 0x40
   18aac:	9803      	ldr	r0, [sp, #12]
   18aae:	47a0      	blx	r4
   18ab0:	4602      	mov	r2, r0
   18ab2:	9b02      	ldr	r3, [sp, #8]
   18ab4:	611a      	str	r2, [r3, #16]

      // Check if R1 response frame's bit 1 is set (to ensure that
      // card is in idle state)
      if (sd->response.data.byte[0] != 0xFF &&
   18ab6:	9b02      	ldr	r3, [sp, #8]
   18ab8:	7a1b      	ldrb	r3, [r3, #8]
   18aba:	2bff      	cmp	r3, #255	; 0xff
   18abc:	d008      	beq.n	18ad0 <Sd::Mount(SdInterface::CardInfo_t*)+0x8c>
          (sd->response.data.byte[0] & 0x01) == 0x01)
   18abe:	9b02      	ldr	r3, [sp, #8]
   18ac0:	7a1b      	ldrb	r3, [r3, #8]
   18ac2:	f003 0301 	and.w	r3, r3, #1
      if (sd->response.data.byte[0] != 0xFF &&
   18ac6:	2b00      	cmp	r3, #0
   18ac8:	d002      	beq.n	18ad0 <Sd::Mount(SdInterface::CardInfo_t*)+0x8c>
      {
        // If it is, we can move on; otherwise, keep trying for a set
        // amount of tries
        card_is_idle = true;
   18aca:	2301      	movs	r3, #1
   18acc:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
      }
      Delay(10);
   18ad0:	f04f 000a 	mov.w	r0, #10
   18ad4:	f04f 0100 	mov.w	r1, #0
   18ad8:	f7f7 fd72 	bl	105c0 <Delay(unsigned long long)>
    } while (tries < kBusTimeout && !card_is_idle);
   18adc:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   18ae0:	2bf9      	cmp	r3, #249	; 0xf9
   18ae2:	d804      	bhi.n	18aee <Sd::Mount(SdInterface::CardInfo_t*)+0xaa>
   18ae4:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
   18ae8:	2b00      	cmp	r3, #0
   18aea:	d100      	bne.n	18aee <Sd::Mount(SdInterface::CardInfo_t*)+0xaa>
    do
   18aec:	e7cc      	b.n	18a88 <Sd::Mount(SdInterface::CardInfo_t*)+0x44>
    LOG_DEBUG("%d tries", tries);
    if (tries >= kBusTimeout)
   18aee:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   18af2:	2bf9      	cmp	r3, #249	; 0xf9
   18af4:	d91b      	bls.n	18b2e <Sd::Mount(SdInterface::CardInfo_t*)+0xea>
    {
      LOG_ERROR("Failed to initiate SPI mode within timeout. Aborting!");
   18af6:	f240 13ff 	movw	r3, #511	; 0x1ff
   18afa:	4a7e      	ldr	r2, [pc, #504]	; (18cf4 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   18afc:	497e      	ldr	r1, [pc, #504]	; (18cf8 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b4>)
   18afe:	487f      	ldr	r0, [pc, #508]	; (18cfc <Sd::Mount(SdInterface::CardInfo_t*)+0x2b8>)
   18b00:	f7ff fe6e 	bl	187e0 <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   18b04:	9b03      	ldr	r3, [sp, #12]
   18b06:	681b      	ldr	r3, [r3, #0]
   18b08:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   18b0a:	9b02      	ldr	r3, [sp, #8]
   18b0c:	f103 0208 	add.w	r2, r3, #8
   18b10:	2300      	movs	r3, #0
   18b12:	9301      	str	r3, [sp, #4]
   18b14:	2300      	movs	r3, #0
   18b16:	9300      	str	r3, [sp, #0]
   18b18:	4613      	mov	r3, r2
   18b1a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   18b1e:	21ff      	movs	r1, #255	; 0xff
   18b20:	9803      	ldr	r0, [sp, #12]
   18b22:	47a0      	blx	r4
   18b24:	4602      	mov	r2, r0
   18b26:	9b02      	ldr	r3, [sp, #8]
   18b28:	611a      	str	r2, [r3, #16]
      return false;
   18b2a:	2400      	movs	r4, #0
   18b2c:	e10c      	b.n	18d48 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    }

    // Send the host's supported voltage (3.3V) and ask if the card
    // supports it
    LOG_DEBUG("Checking Current SD Card Voltage Level...");
    constexpr uint8_t kCheckPattern = 0xAB;
   18b2e:	23ab      	movs	r3, #171	; 0xab
   18b30:	f88d 301f 	strb.w	r3, [sp, #31]
    uint64_t supported_voltage      = 0x00000001;
   18b34:	f04f 0301 	mov.w	r3, #1
   18b38:	f04f 0400 	mov.w	r4, #0
   18b3c:	e9cd 3404 	strd	r3, r4, [sp, #16]
    sd->response.length =
        SendCmd(Command::kGetOp,
                static_cast<uint32_t>((supported_voltage << 8) | kCheckPattern),
                sd->response.data.byte, 100, KeepAlive::kYes);
   18b40:	9b03      	ldr	r3, [sp, #12]
   18b42:	681b      	ldr	r3, [r3, #0]
   18b44:	681c      	ldr	r4, [r3, #0]
                static_cast<uint32_t>((supported_voltage << 8) | kCheckPattern),
   18b46:	9b04      	ldr	r3, [sp, #16]
   18b48:	021b      	lsls	r3, r3, #8
        SendCmd(Command::kGetOp,
   18b4a:	f043 02ab 	orr.w	r2, r3, #171	; 0xab
   18b4e:	9b02      	ldr	r3, [sp, #8]
   18b50:	f103 0108 	add.w	r1, r3, #8
   18b54:	2301      	movs	r3, #1
   18b56:	9301      	str	r3, [sp, #4]
   18b58:	2364      	movs	r3, #100	; 0x64
   18b5a:	9300      	str	r3, [sp, #0]
   18b5c:	460b      	mov	r3, r1
   18b5e:	2148      	movs	r1, #72	; 0x48
   18b60:	9803      	ldr	r0, [sp, #12]
   18b62:	47a0      	blx	r4
   18b64:	4602      	mov	r2, r0
    sd->response.length =
   18b66:	9b02      	ldr	r3, [sp, #8]
   18b68:	611a      	str	r2, [r3, #16]
    if (sd->response.data.byte[4] != kCheckPattern)
   18b6a:	9b02      	ldr	r3, [sp, #8]
   18b6c:	7b1b      	ldrb	r3, [r3, #12]
   18b6e:	2bab      	cmp	r3, #171	; 0xab
   18b70:	d01b      	beq.n	18baa <Sd::Mount(SdInterface::CardInfo_t*)+0x166>
    {
      // If the last byte is not an exact echo of the LSB of the kGetOp
      // command's argument, this response is invalid
      LOG_ERROR("Response integrity check failed. Aborting!");
   18b72:	f240 2312 	movw	r3, #530	; 0x212
   18b76:	4a5f      	ldr	r2, [pc, #380]	; (18cf4 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   18b78:	4961      	ldr	r1, [pc, #388]	; (18d00 <Sd::Mount(SdInterface::CardInfo_t*)+0x2bc>)
   18b7a:	4862      	ldr	r0, [pc, #392]	; (18d04 <Sd::Mount(SdInterface::CardInfo_t*)+0x2c0>)
   18b7c:	f7ff fe30 	bl	187e0 <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   18b80:	9b03      	ldr	r3, [sp, #12]
   18b82:	681b      	ldr	r3, [r3, #0]
   18b84:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   18b86:	9b02      	ldr	r3, [sp, #8]
   18b88:	f103 0208 	add.w	r2, r3, #8
   18b8c:	2300      	movs	r3, #0
   18b8e:	9301      	str	r3, [sp, #4]
   18b90:	2300      	movs	r3, #0
   18b92:	9300      	str	r3, [sp, #0]
   18b94:	4613      	mov	r3, r2
   18b96:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   18b9a:	21ff      	movs	r1, #255	; 0xff
   18b9c:	9803      	ldr	r0, [sp, #12]
   18b9e:	47a0      	blx	r4
   18ba0:	4602      	mov	r2, r0
   18ba2:	9b02      	ldr	r3, [sp, #8]
   18ba4:	611a      	str	r2, [r3, #16]
      return false;
   18ba6:	2400      	movs	r4, #0
   18ba8:	e0ce      	b.n	18d48 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    }
    else if (sd->response.data.byte[3] &
   18baa:	9b02      	ldr	r3, [sp, #8]
   18bac:	7adb      	ldrb	r3, [r3, #11]
   18bae:	4619      	mov	r1, r3
             (supported_voltage == static_cast<uint64_t>(0x00)))
   18bb0:	9a04      	ldr	r2, [sp, #16]
   18bb2:	9b05      	ldr	r3, [sp, #20]
   18bb4:	4313      	orrs	r3, r2
   18bb6:	2b00      	cmp	r3, #0
   18bb8:	bf0c      	ite	eq
   18bba:	2301      	moveq	r3, #1
   18bbc:	2300      	movne	r3, #0
   18bbe:	b2db      	uxtb	r3, r3
    else if (sd->response.data.byte[3] &
   18bc0:	400b      	ands	r3, r1
   18bc2:	2b00      	cmp	r3, #0
   18bc4:	d01b      	beq.n	18bfe <Sd::Mount(SdInterface::CardInfo_t*)+0x1ba>
    {
      // If the 2nd-to-last byte of the reponse AND'ed with our host
      // device's supported voltage range is 0x00, the SD card doesn't
      // support our device's operating voltage
      LOG_ERROR("Unsupported voltage in use. Aborting!");
   18bc6:	f240 231d 	movw	r3, #541	; 0x21d
   18bca:	4a4a      	ldr	r2, [pc, #296]	; (18cf4 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   18bcc:	494e      	ldr	r1, [pc, #312]	; (18d08 <Sd::Mount(SdInterface::CardInfo_t*)+0x2c4>)
   18bce:	484f      	ldr	r0, [pc, #316]	; (18d0c <Sd::Mount(SdInterface::CardInfo_t*)+0x2c8>)
   18bd0:	f7ff fe06 	bl	187e0 <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   18bd4:	9b03      	ldr	r3, [sp, #12]
   18bd6:	681b      	ldr	r3, [r3, #0]
   18bd8:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   18bda:	9b02      	ldr	r3, [sp, #8]
   18bdc:	f103 0208 	add.w	r2, r3, #8
   18be0:	2300      	movs	r3, #0
   18be2:	9301      	str	r3, [sp, #4]
   18be4:	2300      	movs	r3, #0
   18be6:	9300      	str	r3, [sp, #0]
   18be8:	4613      	mov	r3, r2
   18bea:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   18bee:	21ff      	movs	r1, #255	; 0xff
   18bf0:	9803      	ldr	r0, [sp, #12]
   18bf2:	47a0      	blx	r4
   18bf4:	4602      	mov	r2, r0
   18bf6:	9b02      	ldr	r3, [sp, #8]
   18bf8:	611a      	str	r2, [r3, #16]
      return false;
   18bfa:	2400      	movs	r4, #0
   18bfc:	e0a4      	b.n	18d48 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    }

    // Indicate that the host supports SDHC/SDXC and wait for card to
    // shift out of idle state
    LOG_DEBUG("Expressing High-Capacity SD Card Support...");
    tries = 0;
   18bfe:	2300      	movs	r3, #0
   18c00:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    do
    {
      // Send host's operating conditions
      sd->response.length =
          SendCmd(Command::kInit, 0x40000000, sd->response.data.byte, 100,
                  KeepAlive::kYes);
   18c04:	9b03      	ldr	r3, [sp, #12]
   18c06:	681b      	ldr	r3, [r3, #0]
   18c08:	681c      	ldr	r4, [r3, #0]
          SendCmd(Command::kInit, 0x40000000, sd->response.data.byte, 100,
   18c0a:	9b02      	ldr	r3, [sp, #8]
   18c0c:	f103 0208 	add.w	r2, r3, #8
   18c10:	2301      	movs	r3, #1
   18c12:	9301      	str	r3, [sp, #4]
   18c14:	2364      	movs	r3, #100	; 0x64
   18c16:	9300      	str	r3, [sp, #0]
   18c18:	4613      	mov	r3, r2
   18c1a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   18c1e:	2141      	movs	r1, #65	; 0x41
   18c20:	9803      	ldr	r0, [sp, #12]
   18c22:	47a0      	blx	r4
   18c24:	4602      	mov	r2, r0
      sd->response.length =
   18c26:	9b02      	ldr	r3, [sp, #8]
   18c28:	611a      	str	r2, [r3, #16]
      tries++;
   18c2a:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   18c2e:	3301      	adds	r3, #1
   18c30:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    } while (tries < kBusTimeout && sd->response.data.byte[0] & 0x01);
   18c34:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   18c38:	2bf9      	cmp	r3, #249	; 0xf9
   18c3a:	d806      	bhi.n	18c4a <Sd::Mount(SdInterface::CardInfo_t*)+0x206>
   18c3c:	9b02      	ldr	r3, [sp, #8]
   18c3e:	7a1b      	ldrb	r3, [r3, #8]
   18c40:	f003 0301 	and.w	r3, r3, #1
   18c44:	2b00      	cmp	r3, #0
   18c46:	d000      	beq.n	18c4a <Sd::Mount(SdInterface::CardInfo_t*)+0x206>
    do
   18c48:	e7dc      	b.n	18c04 <Sd::Mount(SdInterface::CardInfo_t*)+0x1c0>
    if (tries == kBusTimeout)
   18c4a:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   18c4e:	2bfa      	cmp	r3, #250	; 0xfa
   18c50:	d11b      	bne.n	18c8a <Sd::Mount(SdInterface::CardInfo_t*)+0x246>
    {
      LOG_ERROR("SD Card timed out. Aborting!");
   18c52:	f240 2331 	movw	r3, #561	; 0x231
   18c56:	4a27      	ldr	r2, [pc, #156]	; (18cf4 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   18c58:	492d      	ldr	r1, [pc, #180]	; (18d10 <Sd::Mount(SdInterface::CardInfo_t*)+0x2cc>)
   18c5a:	482e      	ldr	r0, [pc, #184]	; (18d14 <Sd::Mount(SdInterface::CardInfo_t*)+0x2d0>)
   18c5c:	f7ff fdc0 	bl	187e0 <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   18c60:	9b03      	ldr	r3, [sp, #12]
   18c62:	681b      	ldr	r3, [r3, #0]
   18c64:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   18c66:	9b02      	ldr	r3, [sp, #8]
   18c68:	f103 0208 	add.w	r2, r3, #8
   18c6c:	2300      	movs	r3, #0
   18c6e:	9301      	str	r3, [sp, #4]
   18c70:	2300      	movs	r3, #0
   18c72:	9300      	str	r3, [sp, #0]
   18c74:	4613      	mov	r3, r2
   18c76:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   18c7a:	21ff      	movs	r1, #255	; 0xff
   18c7c:	9803      	ldr	r0, [sp, #12]
   18c7e:	47a0      	blx	r4
   18c80:	4602      	mov	r2, r0
   18c82:	9b02      	ldr	r3, [sp, #8]
   18c84:	611a      	str	r2, [r3, #16]
      return false;
   18c86:	2400      	movs	r4, #0
   18c88:	e05e      	b.n	18d48 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    // After card is ready, acquire card capacity info using kGetOcr a
    // second time
    LOG_DEBUG("Reading Card Capacity Information...");
    // Read CCS
    sd->response.length = SendCmd(Command::kGetOcr, 0x00,
                                  sd->response.data.byte, 100, KeepAlive::kYes);
   18c8a:	9b03      	ldr	r3, [sp, #12]
   18c8c:	681b      	ldr	r3, [r3, #0]
   18c8e:	681c      	ldr	r4, [r3, #0]
    sd->response.length = SendCmd(Command::kGetOcr, 0x00,
   18c90:	9b02      	ldr	r3, [sp, #8]
   18c92:	f103 0208 	add.w	r2, r3, #8
   18c96:	2301      	movs	r3, #1
   18c98:	9301      	str	r3, [sp, #4]
   18c9a:	2364      	movs	r3, #100	; 0x64
   18c9c:	9300      	str	r3, [sp, #0]
   18c9e:	4613      	mov	r3, r2
   18ca0:	2200      	movs	r2, #0
   18ca2:	217a      	movs	r1, #122	; 0x7a
   18ca4:	9803      	ldr	r0, [sp, #12]
   18ca6:	47a0      	blx	r4
   18ca8:	4602      	mov	r2, r0
   18caa:	9b02      	ldr	r3, [sp, #8]
   18cac:	611a      	str	r2, [r3, #16]
    if (sd->response.data.byte[1] & 0x40)
   18cae:	9b02      	ldr	r3, [sp, #8]
   18cb0:	7a5b      	ldrb	r3, [r3, #9]
   18cb2:	f003 0340 	and.w	r3, r3, #64	; 0x40
   18cb6:	2b00      	cmp	r3, #0
   18cb8:	d003      	beq.n	18cc2 <Sd::Mount(SdInterface::CardInfo_t*)+0x27e>
    {
      // The card is either high or extended capacity
      LOG_DEBUG("SD Card is HC/XC");
      sd->type = Type::kSDHC;
   18cba:	9b02      	ldr	r3, [sp, #8]
   18cbc:	2201      	movs	r2, #1
   18cbe:	605a      	str	r2, [r3, #4]
   18cc0:	e002      	b.n	18cc8 <Sd::Mount(SdInterface::CardInfo_t*)+0x284>
    }
    else
    {
      // The card is standard capacity
      LOG_DEBUG("SD Card is SC");
      sd->type = Type::kSDSC;
   18cc2:	9b02      	ldr	r3, [sp, #8]
   18cc4:	2200      	movs	r2, #0
   18cc6:	605a      	str	r2, [r3, #4]
    }

    // Store OCR information
    for (int i = 0; i < 4; i++)
   18cc8:	2300      	movs	r3, #0
   18cca:	9308      	str	r3, [sp, #32]
   18ccc:	9b08      	ldr	r3, [sp, #32]
   18cce:	2b03      	cmp	r3, #3
   18cd0:	dc22      	bgt.n	18d18 <Sd::Mount(SdInterface::CardInfo_t*)+0x2d4>
    {
      // ensure OCR doesn't capture the R1 section of the response
      sd->ocr.byte[i] = sd->response.data.byte[i + 1];
   18cd2:	9b08      	ldr	r3, [sp, #32]
   18cd4:	3301      	adds	r3, #1
   18cd6:	9a02      	ldr	r2, [sp, #8]
   18cd8:	4413      	add	r3, r2
   18cda:	7a19      	ldrb	r1, [r3, #8]
   18cdc:	9a02      	ldr	r2, [sp, #8]
   18cde:	9b08      	ldr	r3, [sp, #32]
   18ce0:	4413      	add	r3, r2
   18ce2:	460a      	mov	r2, r1
   18ce4:	701a      	strb	r2, [r3, #0]
    for (int i = 0; i < 4; i++)
   18ce6:	9b08      	ldr	r3, [sp, #32]
   18ce8:	3301      	adds	r3, #1
   18cea:	9308      	str	r3, [sp, #32]
   18cec:	e7ee      	b.n	18ccc <Sd::Mount(SdInterface::CardInfo_t*)+0x288>
   18cee:	bf00      	nop
   18cf0:	00018a45 	.word	0x00018a45
   18cf4:	0001f410 	.word	0x0001f410
   18cf8:	0001f320 	.word	0x0001f320
   18cfc:	0001e9b4 	.word	0x0001e9b4
   18d00:	0001f328 	.word	0x0001f328
   18d04:	0001ea24 	.word	0x0001ea24
   18d08:	0001f330 	.word	0x0001f330
   18d0c:	0001ea88 	.word	0x0001ea88
   18d10:	0001f338 	.word	0x0001f338
   18d14:	0001eae8 	.word	0x0001eae8
    }

    // If card is SDSC, manually set its block size
    if (sd->type == Type::kSDSC)
   18d18:	9b02      	ldr	r3, [sp, #8]
   18d1a:	685b      	ldr	r3, [r3, #4]
   18d1c:	2b00      	cmp	r3, #0
   18d1e:	d112      	bne.n	18d46 <Sd::Mount(SdInterface::CardInfo_t*)+0x302>
    {
      // Send requested byte size
      sd->response.length =
          SendCmd(Command::kChgBlkLen, static_cast<uint32_t>(kBlockSize),
                  sd->response.data.byte, 0, KeepAlive::kYes);
   18d20:	9b03      	ldr	r3, [sp, #12]
   18d22:	681b      	ldr	r3, [r3, #0]
   18d24:	681c      	ldr	r4, [r3, #0]
          SendCmd(Command::kChgBlkLen, static_cast<uint32_t>(kBlockSize),
   18d26:	9b02      	ldr	r3, [sp, #8]
   18d28:	f103 0208 	add.w	r2, r3, #8
   18d2c:	2301      	movs	r3, #1
   18d2e:	9301      	str	r3, [sp, #4]
   18d30:	2300      	movs	r3, #0
   18d32:	9300      	str	r3, [sp, #0]
   18d34:	4613      	mov	r3, r2
   18d36:	f44f 7200 	mov.w	r2, #512	; 0x200
   18d3a:	2150      	movs	r1, #80	; 0x50
   18d3c:	9803      	ldr	r0, [sp, #12]
   18d3e:	47a0      	blx	r4
   18d40:	4602      	mov	r2, r0
      sd->response.length =
   18d42:	9b02      	ldr	r3, [sp, #8]
   18d44:	611a      	str	r2, [r3, #16]
    }

    return true;
   18d46:	2401      	movs	r4, #1
   18d48:	462b      	mov	r3, r5
   18d4a:	4619      	mov	r1, r3
   18d4c:	4803      	ldr	r0, [pc, #12]	; (18d5c <Sd::Mount(SdInterface::CardInfo_t*)+0x318>)
   18d4e:	f7fd fde5 	bl	1691c <__cyg_profile_func_exit>
   18d52:	4623      	mov	r3, r4
  }
   18d54:	4618      	mov	r0, r3
   18d56:	b00b      	add	sp, #44	; 0x2c
   18d58:	bd30      	pop	{r4, r5, pc}
   18d5a:	bf00      	nop
   18d5c:	00018a45 	.word	0x00018a45

00018d60 <Sd::ToBool(bool)>:

  // Returns string to represent a boolean value
  const char * ToBool(bool condition)
   18d60:	b530      	push	{r4, r5, lr}
   18d62:	b083      	sub	sp, #12
   18d64:	4675      	mov	r5, lr
   18d66:	9001      	str	r0, [sp, #4]
   18d68:	460b      	mov	r3, r1
   18d6a:	f88d 3003 	strb.w	r3, [sp, #3]
   18d6e:	462b      	mov	r3, r5
   18d70:	4619      	mov	r1, r3
   18d72:	4809      	ldr	r0, [pc, #36]	; (18d98 <Sd::ToBool(bool)+0x38>)
   18d74:	f7fd fdbe 	bl	168f4 <__cyg_profile_func_enter>
  {
    return (condition) ? "true" : "false";
   18d78:	f89d 3003 	ldrb.w	r3, [sp, #3]
   18d7c:	2b00      	cmp	r3, #0
   18d7e:	d001      	beq.n	18d84 <Sd::ToBool(bool)+0x24>
   18d80:	4c06      	ldr	r4, [pc, #24]	; (18d9c <Sd::ToBool(bool)+0x3c>)
   18d82:	e000      	b.n	18d86 <Sd::ToBool(bool)+0x26>
   18d84:	4c06      	ldr	r4, [pc, #24]	; (18da0 <Sd::ToBool(bool)+0x40>)
   18d86:	462b      	mov	r3, r5
   18d88:	4619      	mov	r1, r3
   18d8a:	4803      	ldr	r0, [pc, #12]	; (18d98 <Sd::ToBool(bool)+0x38>)
   18d8c:	f7fd fdc6 	bl	1691c <__cyg_profile_func_exit>
   18d90:	4623      	mov	r3, r4
  }
   18d92:	4618      	mov	r0, r3
   18d94:	b003      	add	sp, #12
   18d96:	bd30      	pop	{r4, r5, pc}
   18d98:	00018d61 	.word	0x00018d61
   18d9c:	0001eb40 	.word	0x0001eb40
   18da0:	0001eb48 	.word	0x0001eb48

00018da4 <Sd::WaitToReadBlock()>:

  // Waits for the card to respond after a single or multi block read cmd is
  // sent.
  void WaitToReadBlock()
   18da4:	b510      	push	{r4, lr}
   18da6:	b084      	sub	sp, #16
   18da8:	4674      	mov	r4, lr
   18daa:	9001      	str	r0, [sp, #4]
   18dac:	4623      	mov	r3, r4
   18dae:	4619      	mov	r1, r3
   18db0:	4814      	ldr	r0, [pc, #80]	; (18e04 <Sd::WaitToReadBlock()+0x60>)
   18db2:	f7fd fd9f 	bl	168f4 <__cyg_profile_func_enter>
    // Bit 4 -->  If set, card is locked
    // Bit 3 -->  If set, address is out or range
    // Bit 2 -->  If set, card ECC failed
    // Bit 1 -->  If set, CC error occurred
    // Bit 0 -->  If set, a generic error occurred
    uint8_t wait_byte = 0x00;
   18db6:	2300      	movs	r3, #0
   18db8:	f88d 300f 	strb.w	r3, [sp, #15]
    do
    {
      wait_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   18dbc:	9b01      	ldr	r3, [sp, #4]
   18dbe:	685a      	ldr	r2, [r3, #4]
   18dc0:	9b01      	ldr	r3, [sp, #4]
   18dc2:	685b      	ldr	r3, [r3, #4]
   18dc4:	681b      	ldr	r3, [r3, #0]
   18dc6:	3308      	adds	r3, #8
   18dc8:	681b      	ldr	r3, [r3, #0]
   18dca:	21ff      	movs	r1, #255	; 0xff
   18dcc:	4610      	mov	r0, r2
   18dce:	4798      	blx	r3
   18dd0:	4603      	mov	r3, r0
   18dd2:	f88d 300f 	strb.w	r3, [sp, #15]
    } while (wait_byte != 0xFE && (wait_byte & 0xE0) != 0x00);
   18dd6:	f89d 300f 	ldrb.w	r3, [sp, #15]
   18dda:	2bfe      	cmp	r3, #254	; 0xfe
   18ddc:	d006      	beq.n	18dec <Sd::WaitToReadBlock()+0x48>
   18dde:	f89d 300f 	ldrb.w	r3, [sp, #15]
   18de2:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
   18de6:	2b00      	cmp	r3, #0
   18de8:	d000      	beq.n	18dec <Sd::WaitToReadBlock()+0x48>
    do
   18dea:	e7e7      	b.n	18dbc <Sd::WaitToReadBlock()+0x18>

    // DEBUG: Check the value of the wait byte
    if (wait_byte == 0xFE)
   18dec:	f89d 300f 	ldrb.w	r3, [sp, #15]
   18df0:	2bfe      	cmp	r3, #254	; 0xfe
   18df2:	4623      	mov	r3, r4
   18df4:	4619      	mov	r1, r3
   18df6:	4803      	ldr	r0, [pc, #12]	; (18e04 <Sd::WaitToReadBlock()+0x60>)
   18df8:	f7fd fd90 	bl	1691c <__cyg_profile_func_exit>
      LOG_DEBUG("Addr Out of Range?: %s", ToBool(wait_byte & 0x08));
      LOG_DEBUG("Card ECC Failed?: %s", ToBool(wait_byte & 0x04));
      LOG_DEBUG("CC Error?: %s", ToBool(wait_byte & 0x02));
      LOG_DEBUG("Error?: %s", ToBool(wait_byte & 0x01));
    }
  }
   18dfc:	bf00      	nop
   18dfe:	b004      	add	sp, #16
   18e00:	bd10      	pop	{r4, pc}
   18e02:	bf00      	nop
   18e04:	00018da5 	.word	0x00018da5

00018e08 <Sd::WaitWhileBusy()>:

  // Waits for the card to be ready to receive a new block after one has
  // been written or erased
  void WaitWhileBusy()
   18e08:	b510      	push	{r4, lr}
   18e0a:	b084      	sub	sp, #16
   18e0c:	4674      	mov	r4, lr
   18e0e:	9001      	str	r0, [sp, #4]
   18e10:	4623      	mov	r3, r4
   18e12:	4619      	mov	r1, r3
   18e14:	480f      	ldr	r0, [pc, #60]	; (18e54 <Sd::WaitWhileBusy()+0x4c>)
   18e16:	f7fd fd6d 	bl	168f4 <__cyg_profile_func_enter>
  {
    // Wait for the card to finish programming (i.e. when the
    // bytes return to 0xFF)
    uint8_t busy_byte = 0x00;
   18e1a:	2300      	movs	r3, #0
   18e1c:	f88d 300f 	strb.w	r3, [sp, #15]
    LOG_DEBUG("Card is busy. Waiting for it to finish...");
    do
    {
      busy_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   18e20:	9b01      	ldr	r3, [sp, #4]
   18e22:	685a      	ldr	r2, [r3, #4]
   18e24:	9b01      	ldr	r3, [sp, #4]
   18e26:	685b      	ldr	r3, [r3, #4]
   18e28:	681b      	ldr	r3, [r3, #0]
   18e2a:	3308      	adds	r3, #8
   18e2c:	681b      	ldr	r3, [r3, #0]
   18e2e:	21ff      	movs	r1, #255	; 0xff
   18e30:	4610      	mov	r0, r2
   18e32:	4798      	blx	r3
   18e34:	4603      	mov	r3, r0
   18e36:	f88d 300f 	strb.w	r3, [sp, #15]
    } while (busy_byte != 0xFF);
   18e3a:	f89d 300f 	ldrb.w	r3, [sp, #15]
   18e3e:	2bff      	cmp	r3, #255	; 0xff
   18e40:	d000      	beq.n	18e44 <Sd::WaitWhileBusy()+0x3c>
    do
   18e42:	e7ed      	b.n	18e20 <Sd::WaitWhileBusy()+0x18>
   18e44:	4623      	mov	r3, r4
   18e46:	4619      	mov	r1, r3
   18e48:	4802      	ldr	r0, [pc, #8]	; (18e54 <Sd::WaitWhileBusy()+0x4c>)
   18e4a:	f7fd fd67 	bl	1691c <__cyg_profile_func_exit>
    LOG_DEBUG("Card finished!");
  }
   18e4e:	bf00      	nop
   18e50:	b004      	add	sp, #16
   18e52:	bd10      	pop	{r4, pc}
   18e54:	00018e09 	.word	0x00018e09

00018e58 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)>:

  // Read any number of blocks from the SD card
  uint8_t ReadBlock(uint32_t address, uint8_t * array,
   18e58:	b530      	push	{r4, r5, lr}
   18e5a:	f5ad 7d13 	sub.w	sp, sp, #588	; 0x24c
   18e5e:	4675      	mov	r5, lr
   18e60:	ac05      	add	r4, sp, #20
   18e62:	6020      	str	r0, [r4, #0]
   18e64:	a804      	add	r0, sp, #16
   18e66:	6001      	str	r1, [r0, #0]
   18e68:	a903      	add	r1, sp, #12
   18e6a:	600a      	str	r2, [r1, #0]
   18e6c:	aa02      	add	r2, sp, #8
   18e6e:	6013      	str	r3, [r2, #0]
   18e70:	462b      	mov	r3, r5
   18e72:	4619      	mov	r1, r3
   18e74:	487d      	ldr	r0, [pc, #500]	; (1906c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x214>)
   18e76:	f7fd fd3d 	bl	168f4 <__cyg_profile_func_enter>
                    uint32_t blocks = 1) override
  {
    LOG_DEBUG("Block %" PRId32 " :: 0x%" PRIX32 " for %" PRId32 " blocks",
              address, address, blocks);
    // Wait for a previous command to finish
    WaitWhileBusy();
   18e7a:	ab05      	add	r3, sp, #20
   18e7c:	6818      	ldr	r0, [r3, #0]
   18e7e:	f7ff ffc3 	bl	18e08 <Sd::WaitWhileBusy()>

    // Create a temporary storage location to store sd command responses
    Sd::CardInfo_t sd;
    bool payload_had_bad_crc = false;
   18e82:	2300      	movs	r3, #0
   18e84:	f88d 3247 	strb.w	r3, [sp, #583]	; 0x247

    // Create a temporary place to store blocks of 512 bytes (this is now
    // possible because the constructor enforces block size cross-
    // compatibility)
    uint8_t block_store[512] = { 0 };
   18e88:	ab06      	add	r3, sp, #24
   18e8a:	4618      	mov	r0, r3
   18e8c:	f44f 7300 	mov.w	r3, #512	; 0x200
   18e90:	461a      	mov	r2, r3
   18e92:	2100      	movs	r1, #0
   18e94:	f003 fd50 	bl	1c938 <memset>

    // Determine appropriate command to send
    Command read_cmd;
    if (blocks > 1)
   18e98:	ab02      	add	r3, sp, #8
   18e9a:	681b      	ldr	r3, [r3, #0]
   18e9c:	2b01      	cmp	r3, #1
   18e9e:	d902      	bls.n	18ea6 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x4e>
    {
      read_cmd = Command::kReadMulti;
   18ea0:	2352      	movs	r3, #82	; 0x52
   18ea2:	9390      	str	r3, [sp, #576]	; 0x240
   18ea4:	e001      	b.n	18eaa <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x52>
    }
    else
    {
      read_cmd = Command::kReadSingle;
   18ea6:	2351      	movs	r3, #81	; 0x51
   18ea8:	9390      	str	r3, [sp, #576]	; 0x240
    }

    // Send initial read command
    sd.response.length =
        SendCmd(read_cmd, address, sd.response.data.byte, 4, KeepAlive::kYes);
   18eaa:	ab05      	add	r3, sp, #20
   18eac:	681b      	ldr	r3, [r3, #0]
   18eae:	681b      	ldr	r3, [r3, #0]
   18eb0:	681c      	ldr	r4, [r3, #0]
   18eb2:	ab86      	add	r3, sp, #536	; 0x218
   18eb4:	f103 0108 	add.w	r1, r3, #8
   18eb8:	aa04      	add	r2, sp, #16
   18eba:	a805      	add	r0, sp, #20
   18ebc:	2301      	movs	r3, #1
   18ebe:	9301      	str	r3, [sp, #4]
   18ec0:	2304      	movs	r3, #4
   18ec2:	9300      	str	r3, [sp, #0]
   18ec4:	460b      	mov	r3, r1
   18ec6:	6812      	ldr	r2, [r2, #0]
   18ec8:	9990      	ldr	r1, [sp, #576]	; 0x240
   18eca:	6800      	ldr	r0, [r0, #0]
   18ecc:	47a0      	blx	r4
   18ece:	4603      	mov	r3, r0
    sd.response.length =
   18ed0:	938a      	str	r3, [sp, #552]	; 0x228
    LOG_DEBUG("Sent Read Cmd");
    LOG_DEBUG("[R1 Response:0x%02X]", sd.response.data.byte[0]);

    // Check if the command was acknowledged properly
    if (sd.response.data.byte[0] == 0x00)
   18ed2:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   18ed6:	2b00      	cmp	r3, #0
   18ed8:	f040 80d8 	bne.w	1908c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x234>
    {
      // For every block requested
      uint16_t block_count;
      for (block_count = 0; block_count < blocks; block_count++)
   18edc:	2300      	movs	r3, #0
   18ede:	f8ad 323e 	strh.w	r3, [sp, #574]	; 0x23e
   18ee2:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   18ee6:	aa02      	add	r2, sp, #8
   18ee8:	6812      	ldr	r2, [r2, #0]
   18eea:	429a      	cmp	r2, r3
   18eec:	f240 8099 	bls.w	19022 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x1ca>
      {
        // Wait for the card to respond with a ready signal
        WaitToReadBlock();
   18ef0:	ab05      	add	r3, sp, #20
   18ef2:	6818      	ldr	r0, [r3, #0]
   18ef4:	f7ff ff56 	bl	18da4 <Sd::WaitToReadBlock()>

        // Calculate the block address offset
        uint16_t block_addr_offset =
   18ef8:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   18efc:	025b      	lsls	r3, r3, #9
   18efe:	f8ad 323a 	strh.w	r3, [sp, #570]	; 0x23a
            static_cast<uint16_t>(block_count * kBlockSize);

        // Read all the bytes of a single block
        for (uint16_t byte_count = 0; byte_count < kBlockSize; byte_count++)
   18f02:	2300      	movs	r3, #0
   18f04:	f8ad 323c 	strh.w	r3, [sp, #572]	; 0x23c
   18f08:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   18f0c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   18f10:	d22b      	bcs.n	18f6a <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x112>
        {
          // Calculate the current storage index
          uint16_t storage_index =
   18f12:	f8bd 223a 	ldrh.w	r2, [sp, #570]	; 0x23a
   18f16:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   18f1a:	4413      	add	r3, r2
   18f1c:	f8ad 3238 	strh.w	r3, [sp, #568]	; 0x238
              static_cast<uint16_t>(block_addr_offset + byte_count);

          // Transfer a byte to read a block from the SD card
          array[storage_index] =
              static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   18f20:	ab05      	add	r3, sp, #20
   18f22:	681b      	ldr	r3, [r3, #0]
   18f24:	685a      	ldr	r2, [r3, #4]
   18f26:	ab05      	add	r3, sp, #20
   18f28:	681b      	ldr	r3, [r3, #0]
   18f2a:	685b      	ldr	r3, [r3, #4]
   18f2c:	681b      	ldr	r3, [r3, #0]
   18f2e:	3308      	adds	r3, #8
   18f30:	681b      	ldr	r3, [r3, #0]
   18f32:	21ff      	movs	r1, #255	; 0xff
   18f34:	4610      	mov	r0, r2
   18f36:	4798      	blx	r3
   18f38:	4603      	mov	r3, r0
   18f3a:	4619      	mov	r1, r3
          array[storage_index] =
   18f3c:	f8bd 3238 	ldrh.w	r3, [sp, #568]	; 0x238
   18f40:	aa03      	add	r2, sp, #12
   18f42:	6812      	ldr	r2, [r2, #0]
   18f44:	4413      	add	r3, r2
   18f46:	b2ca      	uxtb	r2, r1
   18f48:	701a      	strb	r2, [r3, #0]

          // Copy that byte into our temporary block store
          block_store[byte_count] = array[storage_index];
   18f4a:	f8bd 3238 	ldrh.w	r3, [sp, #568]	; 0x238
   18f4e:	aa03      	add	r2, sp, #12
   18f50:	6812      	ldr	r2, [r2, #0]
   18f52:	441a      	add	r2, r3
   18f54:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   18f58:	7811      	ldrb	r1, [r2, #0]
   18f5a:	aa06      	add	r2, sp, #24
   18f5c:	54d1      	strb	r1, [r2, r3]
        for (uint16_t byte_count = 0; byte_count < kBlockSize; byte_count++)
   18f5e:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   18f62:	3301      	adds	r3, #1
   18f64:	f8ad 323c 	strh.w	r3, [sp, #572]	; 0x23c
   18f68:	e7ce      	b.n	18f08 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0xb0>
        }

        // Then read the block's 16-bit CRC (i.e. read two bytes)
        uint16_t block_crc =
            static_cast<uint16_t>((ssp_interface_->Transfer(0xFF) << 8) |
   18f6a:	ab05      	add	r3, sp, #20
   18f6c:	681b      	ldr	r3, [r3, #0]
   18f6e:	685a      	ldr	r2, [r3, #4]
   18f70:	ab05      	add	r3, sp, #20
   18f72:	681b      	ldr	r3, [r3, #0]
   18f74:	685b      	ldr	r3, [r3, #4]
   18f76:	681b      	ldr	r3, [r3, #0]
   18f78:	3308      	adds	r3, #8
   18f7a:	681b      	ldr	r3, [r3, #0]
   18f7c:	21ff      	movs	r1, #255	; 0xff
   18f7e:	4610      	mov	r0, r2
   18f80:	4798      	blx	r3
   18f82:	4603      	mov	r3, r0
   18f84:	021b      	lsls	r3, r3, #8
   18f86:	b21c      	sxth	r4, r3
                                  ssp_interface_->Transfer(0xFF));
   18f88:	ab05      	add	r3, sp, #20
   18f8a:	681b      	ldr	r3, [r3, #0]
   18f8c:	685a      	ldr	r2, [r3, #4]
   18f8e:	ab05      	add	r3, sp, #20
   18f90:	681b      	ldr	r3, [r3, #0]
   18f92:	685b      	ldr	r3, [r3, #4]
   18f94:	681b      	ldr	r3, [r3, #0]
   18f96:	3308      	adds	r3, #8
   18f98:	681b      	ldr	r3, [r3, #0]
   18f9a:	21ff      	movs	r1, #255	; 0xff
   18f9c:	4610      	mov	r0, r2
   18f9e:	4798      	blx	r3
   18fa0:	4603      	mov	r3, r0
   18fa2:	b21b      	sxth	r3, r3
            static_cast<uint16_t>((ssp_interface_->Transfer(0xFF) << 8) |
   18fa4:	4323      	orrs	r3, r4
   18fa6:	b21b      	sxth	r3, r3
                                  ssp_interface_->Transfer(0xFF));
   18fa8:	f8ad 3236 	strh.w	r3, [sp, #566]	; 0x236

        // Run a CRC-16 calculation on the message to determine if the
        // received CRCs match (i.e. checks if the block data is
        // valid).
        uint16_t expected_block_crc = GetCrc16(block_store, 512);
   18fac:	ab05      	add	r3, sp, #20
   18fae:	681b      	ldr	r3, [r3, #0]
   18fb0:	681b      	ldr	r3, [r3, #0]
   18fb2:	3320      	adds	r3, #32
   18fb4:	681b      	ldr	r3, [r3, #0]
   18fb6:	a906      	add	r1, sp, #24
   18fb8:	a805      	add	r0, sp, #20
   18fba:	f44f 7200 	mov.w	r2, #512	; 0x200
   18fbe:	6800      	ldr	r0, [r0, #0]
   18fc0:	4798      	blx	r3
   18fc2:	4603      	mov	r3, r0
   18fc4:	f8ad 3234 	strh.w	r3, [sp, #564]	; 0x234

        LOG_DEBUG("Block #%d @ 0x%" PRIX32 " acquired", block_count, address);
        LOG_DEBUG("Expecting block crc16 '0x%04X'", expected_block_crc);
        LOG_DEBUG("Got '0x%04X'", block_crc);
        if (expected_block_crc != block_crc)
   18fc8:	f8bd 2234 	ldrh.w	r2, [sp, #564]	; 0x234
   18fcc:	f8bd 3236 	ldrh.w	r3, [sp, #566]	; 0x236
   18fd0:	429a      	cmp	r2, r3
   18fd2:	d020      	beq.n	19016 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x1be>
        {
          // If they do not match, set the bad crc status
          payload_had_bad_crc = true;
   18fd4:	2301      	movs	r3, #1
   18fd6:	f88d 3247 	strb.w	r3, [sp, #583]	; 0x247
          LOG_ERROR("While Reading Block #%d CRC16:", block_count);
   18fda:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   18fde:	9300      	str	r3, [sp, #0]
   18fe0:	f240 23ed 	movw	r3, #749	; 0x2ed
   18fe4:	4a22      	ldr	r2, [pc, #136]	; (19070 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x218>)
   18fe6:	4923      	ldr	r1, [pc, #140]	; (19074 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x21c>)
   18fe8:	4823      	ldr	r0, [pc, #140]	; (19078 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x220>)
   18fea:	f7ff fbf9 	bl	187e0 <printf>
          LOG_ERROR("Expected '0x%04X'", expected_block_crc);
   18fee:	f8bd 3234 	ldrh.w	r3, [sp, #564]	; 0x234
   18ff2:	9300      	str	r3, [sp, #0]
   18ff4:	f240 23ee 	movw	r3, #750	; 0x2ee
   18ff8:	4a1d      	ldr	r2, [pc, #116]	; (19070 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x218>)
   18ffa:	4920      	ldr	r1, [pc, #128]	; (1907c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x224>)
   18ffc:	4820      	ldr	r0, [pc, #128]	; (19080 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x228>)
   18ffe:	f7ff fbef 	bl	187e0 <printf>
          LOG_ERROR("Got '0x%04X'", block_crc);
   19002:	f8bd 3236 	ldrh.w	r3, [sp, #566]	; 0x236
   19006:	9300      	str	r3, [sp, #0]
   19008:	f240 23ef 	movw	r3, #751	; 0x2ef
   1900c:	4a18      	ldr	r2, [pc, #96]	; (19070 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x218>)
   1900e:	491d      	ldr	r1, [pc, #116]	; (19084 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x22c>)
   19010:	481d      	ldr	r0, [pc, #116]	; (19088 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x230>)
   19012:	f7ff fbe5 	bl	187e0 <printf>
      for (block_count = 0; block_count < blocks; block_count++)
   19016:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   1901a:	3301      	adds	r3, #1
   1901c:	f8ad 323e 	strh.w	r3, [sp, #574]	; 0x23e
   19020:	e75f      	b.n	18ee2 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x8a>
        }
      }

      // After reading multiple blocks, send the stop command to terminate the
      // transaction (i.e. no keep-alive)
      if (blocks > 1)
   19022:	ab02      	add	r3, sp, #8
   19024:	681b      	ldr	r3, [r3, #0]
   19026:	2b01      	cmp	r3, #1
   19028:	d913      	bls.n	19052 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x1fa>
      {
        sd.response.length =
            SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte, 4,
                    KeepAlive::kNo);
   1902a:	ab05      	add	r3, sp, #20
   1902c:	681b      	ldr	r3, [r3, #0]
   1902e:	681b      	ldr	r3, [r3, #0]
   19030:	681c      	ldr	r4, [r3, #0]
            SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte, 4,
   19032:	ab86      	add	r3, sp, #536	; 0x218
   19034:	f103 0208 	add.w	r2, r3, #8
   19038:	a805      	add	r0, sp, #20
   1903a:	2300      	movs	r3, #0
   1903c:	9301      	str	r3, [sp, #4]
   1903e:	2304      	movs	r3, #4
   19040:	9300      	str	r3, [sp, #0]
   19042:	4613      	mov	r3, r2
   19044:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   19048:	214c      	movs	r1, #76	; 0x4c
   1904a:	6800      	ldr	r0, [r0, #0]
   1904c:	47a0      	blx	r4
   1904e:	4603      	mov	r3, r0
        sd.response.length =
   19050:	938a      	str	r3, [sp, #552]	; 0x228
      LOG_DEBUG("Response Byte");
      LOG_DEBUG("0x%02X", sd.response.data.byte[0]);

      // If there was a bad crc from the payload, manually set the
      // CRC error flag in the command response byte
      if (payload_had_bad_crc)
   19052:	f89d 3247 	ldrb.w	r3, [sp, #583]	; 0x247
   19056:	2b00      	cmp	r3, #0
   19058:	f000 80c0 	beq.w	191dc <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x384>
      {
        sd.response.data.byte[0] |= 0x08;
   1905c:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   19060:	f043 0308 	orr.w	r3, r3, #8
   19064:	b2db      	uxtb	r3, r3
   19066:	f88d 3220 	strb.w	r3, [sp, #544]	; 0x220
   1906a:	e0b7      	b.n	191dc <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x384>
   1906c:	00018e59 	.word	0x00018e59
   19070:	0001f444 	.word	0x0001f444
   19074:	0001f340 	.word	0x0001f340
   19078:	0001eb50 	.word	0x0001eb50
   1907c:	0001f348 	.word	0x0001f348
   19080:	0001eba8 	.word	0x0001eba8
   19084:	0001f350 	.word	0x0001f350
   19088:	0001ebf4 	.word	0x0001ebf4
      }
    }
    else
    {
      LOG_ERROR("Read Cmd was not acknowledged properly!");
   1908c:	f240 3309 	movw	r3, #777	; 0x309
   19090:	4a65      	ldr	r2, [pc, #404]	; (19228 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   19092:	4966      	ldr	r1, [pc, #408]	; (1922c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d4>)
   19094:	4866      	ldr	r0, [pc, #408]	; (19230 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d8>)
   19096:	f7ff fba3 	bl	187e0 <printf>
      LOG_ERROR("Parameter Err: %s", ToBool(sd.response.data.byte[0] & 0x40));
   1909a:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   1909e:	f003 0340 	and.w	r3, r3, #64	; 0x40
   190a2:	2b00      	cmp	r3, #0
   190a4:	bf14      	ite	ne
   190a6:	2301      	movne	r3, #1
   190a8:	2300      	moveq	r3, #0
   190aa:	b2da      	uxtb	r2, r3
   190ac:	ab05      	add	r3, sp, #20
   190ae:	4611      	mov	r1, r2
   190b0:	6818      	ldr	r0, [r3, #0]
   190b2:	f7ff fe55 	bl	18d60 <Sd::ToBool(bool)>
   190b6:	4603      	mov	r3, r0
   190b8:	9300      	str	r3, [sp, #0]
   190ba:	f240 330a 	movw	r3, #778	; 0x30a
   190be:	4a5a      	ldr	r2, [pc, #360]	; (19228 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   190c0:	495c      	ldr	r1, [pc, #368]	; (19234 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3dc>)
   190c2:	485d      	ldr	r0, [pc, #372]	; (19238 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3e0>)
   190c4:	f7ff fb8c 	bl	187e0 <printf>
      LOG_ERROR("Addr Err: %s", ToBool(sd.response.data.byte[0] & 0x20));
   190c8:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   190cc:	f003 0320 	and.w	r3, r3, #32
   190d0:	2b00      	cmp	r3, #0
   190d2:	bf14      	ite	ne
   190d4:	2301      	movne	r3, #1
   190d6:	2300      	moveq	r3, #0
   190d8:	b2da      	uxtb	r2, r3
   190da:	ab05      	add	r3, sp, #20
   190dc:	4611      	mov	r1, r2
   190de:	6818      	ldr	r0, [r3, #0]
   190e0:	f7ff fe3e 	bl	18d60 <Sd::ToBool(bool)>
   190e4:	4603      	mov	r3, r0
   190e6:	9300      	str	r3, [sp, #0]
   190e8:	f240 330b 	movw	r3, #779	; 0x30b
   190ec:	4a4e      	ldr	r2, [pc, #312]	; (19228 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   190ee:	4953      	ldr	r1, [pc, #332]	; (1923c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3e4>)
   190f0:	4853      	ldr	r0, [pc, #332]	; (19240 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3e8>)
   190f2:	f7ff fb75 	bl	187e0 <printf>
      LOG_ERROR("Erase Seq Err: %s", ToBool(sd.response.data.byte[0] & 0x10));
   190f6:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   190fa:	f003 0310 	and.w	r3, r3, #16
   190fe:	2b00      	cmp	r3, #0
   19100:	bf14      	ite	ne
   19102:	2301      	movne	r3, #1
   19104:	2300      	moveq	r3, #0
   19106:	b2da      	uxtb	r2, r3
   19108:	ab05      	add	r3, sp, #20
   1910a:	4611      	mov	r1, r2
   1910c:	6818      	ldr	r0, [r3, #0]
   1910e:	f7ff fe27 	bl	18d60 <Sd::ToBool(bool)>
   19112:	4603      	mov	r3, r0
   19114:	9300      	str	r3, [sp, #0]
   19116:	f44f 7343 	mov.w	r3, #780	; 0x30c
   1911a:	4a43      	ldr	r2, [pc, #268]	; (19228 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   1911c:	4949      	ldr	r1, [pc, #292]	; (19244 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3ec>)
   1911e:	484a      	ldr	r0, [pc, #296]	; (19248 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3f0>)
   19120:	f7ff fb5e 	bl	187e0 <printf>
      LOG_ERROR("Com CRC Err: %s", ToBool(sd.response.data.byte[0] & 0x08));
   19124:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   19128:	f003 0308 	and.w	r3, r3, #8
   1912c:	2b00      	cmp	r3, #0
   1912e:	bf14      	ite	ne
   19130:	2301      	movne	r3, #1
   19132:	2300      	moveq	r3, #0
   19134:	b2da      	uxtb	r2, r3
   19136:	ab05      	add	r3, sp, #20
   19138:	4611      	mov	r1, r2
   1913a:	6818      	ldr	r0, [r3, #0]
   1913c:	f7ff fe10 	bl	18d60 <Sd::ToBool(bool)>
   19140:	4603      	mov	r3, r0
   19142:	9300      	str	r3, [sp, #0]
   19144:	f240 330d 	movw	r3, #781	; 0x30d
   19148:	4a37      	ldr	r2, [pc, #220]	; (19228 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   1914a:	4940      	ldr	r1, [pc, #256]	; (1924c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3f4>)
   1914c:	4840      	ldr	r0, [pc, #256]	; (19250 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3f8>)
   1914e:	f7ff fb47 	bl	187e0 <printf>
      LOG_ERROR("Illegal Cmd Err: %s", ToBool(sd.response.data.byte[0] & 0x04));
   19152:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   19156:	f003 0304 	and.w	r3, r3, #4
   1915a:	2b00      	cmp	r3, #0
   1915c:	bf14      	ite	ne
   1915e:	2301      	movne	r3, #1
   19160:	2300      	moveq	r3, #0
   19162:	b2da      	uxtb	r2, r3
   19164:	ab05      	add	r3, sp, #20
   19166:	4611      	mov	r1, r2
   19168:	6818      	ldr	r0, [r3, #0]
   1916a:	f7ff fdf9 	bl	18d60 <Sd::ToBool(bool)>
   1916e:	4603      	mov	r3, r0
   19170:	9300      	str	r3, [sp, #0]
   19172:	f240 330e 	movw	r3, #782	; 0x30e
   19176:	4a2c      	ldr	r2, [pc, #176]	; (19228 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   19178:	4936      	ldr	r1, [pc, #216]	; (19254 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3fc>)
   1917a:	4837      	ldr	r0, [pc, #220]	; (19258 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x400>)
   1917c:	f7ff fb30 	bl	187e0 <printf>
      LOG_ERROR("Erase Reset: %s", ToBool(sd.response.data.byte[0] & 0x02));
   19180:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   19184:	f003 0302 	and.w	r3, r3, #2
   19188:	2b00      	cmp	r3, #0
   1918a:	bf14      	ite	ne
   1918c:	2301      	movne	r3, #1
   1918e:	2300      	moveq	r3, #0
   19190:	b2da      	uxtb	r2, r3
   19192:	ab05      	add	r3, sp, #20
   19194:	4611      	mov	r1, r2
   19196:	6818      	ldr	r0, [r3, #0]
   19198:	f7ff fde2 	bl	18d60 <Sd::ToBool(bool)>
   1919c:	4603      	mov	r3, r0
   1919e:	9300      	str	r3, [sp, #0]
   191a0:	f240 330f 	movw	r3, #783	; 0x30f
   191a4:	4a20      	ldr	r2, [pc, #128]	; (19228 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   191a6:	492d      	ldr	r1, [pc, #180]	; (1925c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x404>)
   191a8:	482d      	ldr	r0, [pc, #180]	; (19260 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x408>)
   191aa:	f7ff fb19 	bl	187e0 <printf>
      LOG_ERROR("In Idle: %s", ToBool(sd.response.data.byte[0] & 0x01));
   191ae:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   191b2:	f003 0301 	and.w	r3, r3, #1
   191b6:	2b00      	cmp	r3, #0
   191b8:	bf14      	ite	ne
   191ba:	2301      	movne	r3, #1
   191bc:	2300      	moveq	r3, #0
   191be:	b2da      	uxtb	r2, r3
   191c0:	ab05      	add	r3, sp, #20
   191c2:	4611      	mov	r1, r2
   191c4:	6818      	ldr	r0, [r3, #0]
   191c6:	f7ff fdcb 	bl	18d60 <Sd::ToBool(bool)>
   191ca:	4603      	mov	r3, r0
   191cc:	9300      	str	r3, [sp, #0]
   191ce:	f44f 7344 	mov.w	r3, #784	; 0x310
   191d2:	4a15      	ldr	r2, [pc, #84]	; (19228 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   191d4:	4923      	ldr	r1, [pc, #140]	; (19264 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x40c>)
   191d6:	4824      	ldr	r0, [pc, #144]	; (19268 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x410>)
   191d8:	f7ff fb02 	bl	187e0 <printf>
    LOG_DEBUG("Now waiting for SD Card to exit Idle Mode...");
    do
    {
      // Query the status register
      sd.response.length = SendCmd(Command::kGetStatus, 32,
                                   sd.response.data.byte, 0, KeepAlive::kNo);
   191dc:	ab05      	add	r3, sp, #20
   191de:	681b      	ldr	r3, [r3, #0]
   191e0:	681b      	ldr	r3, [r3, #0]
   191e2:	681c      	ldr	r4, [r3, #0]
      sd.response.length = SendCmd(Command::kGetStatus, 32,
   191e4:	ab86      	add	r3, sp, #536	; 0x218
   191e6:	f103 0208 	add.w	r2, r3, #8
   191ea:	a805      	add	r0, sp, #20
   191ec:	2300      	movs	r3, #0
   191ee:	9301      	str	r3, [sp, #4]
   191f0:	2300      	movs	r3, #0
   191f2:	9300      	str	r3, [sp, #0]
   191f4:	4613      	mov	r3, r2
   191f6:	2220      	movs	r2, #32
   191f8:	210d      	movs	r1, #13
   191fa:	6800      	ldr	r0, [r0, #0]
   191fc:	47a0      	blx	r4
   191fe:	4603      	mov	r3, r0
   19200:	938a      	str	r3, [sp, #552]	; 0x228
    } while (sd.response.data.byte[0] & 0x01);
   19202:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   19206:	f003 0301 	and.w	r3, r3, #1
   1920a:	2b00      	cmp	r3, #0
   1920c:	d000      	beq.n	19210 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3b8>
    do
   1920e:	e7e5      	b.n	191dc <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x384>
    LOG_DEBUG("SD Card is out of Idle Mode!");

    // Return the status
    LOG_DEBUG("Read Complete! [R1 Response: 0x%02X]", sd.response.data.byte[0]);
    return sd.response.data.byte[0];
   19210:	f89d 4220 	ldrb.w	r4, [sp, #544]	; 0x220
   19214:	462b      	mov	r3, r5
   19216:	4619      	mov	r1, r3
   19218:	4814      	ldr	r0, [pc, #80]	; (1926c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x414>)
   1921a:	f7fd fb7f 	bl	1691c <__cyg_profile_func_exit>
   1921e:	4623      	mov	r3, r4
  }
   19220:	4618      	mov	r0, r3
   19222:	f50d 7d13 	add.w	sp, sp, #588	; 0x24c
   19226:	bd30      	pop	{r4, r5, pc}
   19228:	0001f444 	.word	0x0001f444
   1922c:	0001f358 	.word	0x0001f358
   19230:	0001ec3c 	.word	0x0001ec3c
   19234:	0001f360 	.word	0x0001f360
   19238:	0001eca0 	.word	0x0001eca0
   1923c:	0001f368 	.word	0x0001f368
   19240:	0001ecec 	.word	0x0001ecec
   19244:	0001f370 	.word	0x0001f370
   19248:	0001ed34 	.word	0x0001ed34
   1924c:	0001f378 	.word	0x0001f378
   19250:	0001ed80 	.word	0x0001ed80
   19254:	0001f380 	.word	0x0001f380
   19258:	0001edcc 	.word	0x0001edcc
   1925c:	0001f388 	.word	0x0001f388
   19260:	0001ee1c 	.word	0x0001ee1c
   19264:	0001f390 	.word	0x0001f390
   19268:	0001ee68 	.word	0x0001ee68
   1926c:	00018e59 	.word	0x00018e59

00019270 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)>:

  // Writes any number of 512-byte blocks to the SD Card
  uint8_t WriteBlock(uint32_t address, const uint8_t * array,
   19270:	b530      	push	{r4, r5, lr}
   19272:	b095      	sub	sp, #84	; 0x54
   19274:	4675      	mov	r5, lr
   19276:	9005      	str	r0, [sp, #20]
   19278:	9104      	str	r1, [sp, #16]
   1927a:	9203      	str	r2, [sp, #12]
   1927c:	9302      	str	r3, [sp, #8]
   1927e:	462b      	mov	r3, r5
   19280:	4619      	mov	r1, r3
   19282:	4865      	ldr	r0, [pc, #404]	; (19418 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x1a8>)
   19284:	f7fd fb36 	bl	168f4 <__cyg_profile_func_enter>
                     uint32_t blocks = 1) override
  {
    // Wait for a previous command to finish
    WaitWhileBusy();
   19288:	9805      	ldr	r0, [sp, #20]
   1928a:	f7ff fdbd 	bl	18e08 <Sd::WaitWhileBusy()>
    Sd::CardInfo_t sd;

    // Determine appropriate command and start token to send
    Command write_cmd;
    uint8_t write_start_tkn;
    if (blocks > 1)
   1928e:	9b02      	ldr	r3, [sp, #8]
   19290:	2b01      	cmp	r3, #1
   19292:	d905      	bls.n	192a0 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x30>
    {
      write_cmd       = Command::kWriteMulti;
   19294:	2359      	movs	r3, #89	; 0x59
   19296:	9313      	str	r3, [sp, #76]	; 0x4c
      write_start_tkn = 0xFC;
   19298:	23fc      	movs	r3, #252	; 0xfc
   1929a:	f88d 304b 	strb.w	r3, [sp, #75]	; 0x4b
   1929e:	e004      	b.n	192aa <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x3a>
    }
    else
    {
      write_cmd       = Command::kWriteSingle;
   192a0:	2358      	movs	r3, #88	; 0x58
   192a2:	9313      	str	r3, [sp, #76]	; 0x4c
      write_start_tkn = 0xFE;
   192a4:	23fe      	movs	r3, #254	; 0xfe
   192a6:	f88d 304b 	strb.w	r3, [sp, #75]	; 0x4b
    }

    // Send initial write command
    sd.response.length = SendCmd(write_cmd, address, sd.response.data.byte, 100,
                                 KeepAlive::kYes);
   192aa:	9b05      	ldr	r3, [sp, #20]
   192ac:	681b      	ldr	r3, [r3, #0]
   192ae:	681c      	ldr	r4, [r3, #0]
    sd.response.length = SendCmd(write_cmd, address, sd.response.data.byte, 100,
   192b0:	ab06      	add	r3, sp, #24
   192b2:	f103 0208 	add.w	r2, r3, #8
   192b6:	2301      	movs	r3, #1
   192b8:	9301      	str	r3, [sp, #4]
   192ba:	2364      	movs	r3, #100	; 0x64
   192bc:	9300      	str	r3, [sp, #0]
   192be:	4613      	mov	r3, r2
   192c0:	9a04      	ldr	r2, [sp, #16]
   192c2:	9913      	ldr	r1, [sp, #76]	; 0x4c
   192c4:	9805      	ldr	r0, [sp, #20]
   192c6:	47a0      	blx	r4
   192c8:	4603      	mov	r3, r0
   192ca:	930a      	str	r3, [sp, #40]	; 0x28
    LOG_DEBUG("Sent Write Cmd");
    LOG_DEBUG("[R1 Response:0x%02X]", sd.response.data.byte[0]);

    // Check if the response was acknowledged properly
    if (sd.response.data.byte[0] == 0x00)
   192cc:	f89d 3020 	ldrb.w	r3, [sp, #32]
   192d0:	2b00      	cmp	r3, #0
   192d2:	f040 8096 	bne.w	19402 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x192>
    {
      // If no errors, proceed write given block(s) to SD Card
      // For each given block
      for (uint16_t current_block_num = 0; current_block_num < blocks;
   192d6:	2300      	movs	r3, #0
   192d8:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
   192dc:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   192e0:	9a02      	ldr	r2, [sp, #8]
   192e2:	429a      	cmp	r2, r3
   192e4:	d97a      	bls.n	193dc <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x16c>
           current_block_num++)
      {
        // Calculate array offset
        uint64_t arr_offset = current_block_num * kBlockSize;
   192e6:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   192ea:	025b      	lsls	r3, r3, #9
   192ec:	ea4f 74e3 	mov.w	r4, r3, asr #31
   192f0:	e9cd 340e 	strd	r3, r4, [sp, #56]	; 0x38

        // Send the start token for the current block
        ssp_interface_->Transfer(write_start_tkn);
   192f4:	9b05      	ldr	r3, [sp, #20]
   192f6:	685a      	ldr	r2, [r3, #4]
   192f8:	9b05      	ldr	r3, [sp, #20]
   192fa:	685b      	ldr	r3, [r3, #4]
   192fc:	681b      	ldr	r3, [r3, #0]
   192fe:	3308      	adds	r3, #8
   19300:	681b      	ldr	r3, [r3, #0]
   19302:	f89d 104b 	ldrb.w	r1, [sp, #75]	; 0x4b
   19306:	b289      	uxth	r1, r1
   19308:	4610      	mov	r0, r2
   1930a:	4798      	blx	r3

        // Write all 512-bytes of the given block
        LOG_DEBUG("Writing block #%d", current_block_num);
        for (uint16_t current_byte = 0; current_byte < kBlockSize;
   1930c:	2300      	movs	r3, #0
   1930e:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
   19312:	f8bd 3046 	ldrh.w	r3, [sp, #70]	; 0x46
   19316:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   1931a:	d216      	bcs.n	1934a <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0xda>
             current_byte++)
        {
          ssp_interface_->Transfer(array[arr_offset + current_byte]);
   1931c:	9b05      	ldr	r3, [sp, #20]
   1931e:	6858      	ldr	r0, [r3, #4]
   19320:	9b05      	ldr	r3, [sp, #20]
   19322:	685b      	ldr	r3, [r3, #4]
   19324:	681b      	ldr	r3, [r3, #0]
   19326:	3308      	adds	r3, #8
   19328:	681b      	ldr	r3, [r3, #0]
   1932a:	990e      	ldr	r1, [sp, #56]	; 0x38
   1932c:	f8bd 2046 	ldrh.w	r2, [sp, #70]	; 0x46
   19330:	440a      	add	r2, r1
   19332:	9903      	ldr	r1, [sp, #12]
   19334:	440a      	add	r2, r1
   19336:	7812      	ldrb	r2, [r2, #0]
   19338:	b292      	uxth	r2, r2
   1933a:	4611      	mov	r1, r2
   1933c:	4798      	blx	r3
        for (uint16_t current_byte = 0; current_byte < kBlockSize;
   1933e:	f8bd 3046 	ldrh.w	r3, [sp, #70]	; 0x46
   19342:	3301      	adds	r3, #1
   19344:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
   19348:	e7e3      	b.n	19312 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0xa2>
        }

        // Read the data response token after writing the block
        uint8_t data_response_tkn =
            static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   1934a:	9b05      	ldr	r3, [sp, #20]
   1934c:	685a      	ldr	r2, [r3, #4]
   1934e:	9b05      	ldr	r3, [sp, #20]
   19350:	685b      	ldr	r3, [r3, #4]
   19352:	681b      	ldr	r3, [r3, #0]
   19354:	3308      	adds	r3, #8
   19356:	681b      	ldr	r3, [r3, #0]
   19358:	21ff      	movs	r1, #255	; 0xff
   1935a:	4610      	mov	r0, r2
   1935c:	4798      	blx	r3
   1935e:	4603      	mov	r3, r0
   19360:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
                  ToBool(data_response_tkn & 0x0B));
        LOG_DEBUG("Data Rejected (write err)?: %s",
                  ToBool(data_response_tkn & 0x0D));

        // If writing multiple blocks and the previous block was rejected
        if (blocks > 1 && !(data_response_tkn & 0x05))
   19364:	9b02      	ldr	r3, [sp, #8]
   19366:	2b01      	cmp	r3, #1
   19368:	d92f      	bls.n	193ca <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x15a>
   1936a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   1936e:	f003 0305 	and.w	r3, r3, #5
   19372:	2b00      	cmp	r3, #0
   19374:	d129      	bne.n	193ca <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x15a>
        {
          // Send an immediate stop (CMD12)
          sd.response.length =
              SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte,
                      100, KeepAlive::kYes);
   19376:	9b05      	ldr	r3, [sp, #20]
   19378:	681b      	ldr	r3, [r3, #0]
   1937a:	681c      	ldr	r4, [r3, #0]
              SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte,
   1937c:	ab06      	add	r3, sp, #24
   1937e:	f103 0208 	add.w	r2, r3, #8
   19382:	2301      	movs	r3, #1
   19384:	9301      	str	r3, [sp, #4]
   19386:	2364      	movs	r3, #100	; 0x64
   19388:	9300      	str	r3, [sp, #0]
   1938a:	4613      	mov	r3, r2
   1938c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   19390:	214c      	movs	r1, #76	; 0x4c
   19392:	9805      	ldr	r0, [sp, #20]
   19394:	47a0      	blx	r4
   19396:	4603      	mov	r3, r0
          sd.response.length =
   19398:	930a      	str	r3, [sp, #40]	; 0x28
          LOG_DEBUG("Stopped Transmission due to rejection...");
          LOG_DEBUG("[R1 Response: 0x%02X]", sd.response.data.byte[0]);

          // In the case of a write error, ask for the reason why
          if (data_response_tkn & 0x0D)
   1939a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   1939e:	f003 030d 	and.w	r3, r3, #13
   193a2:	2b00      	cmp	r3, #0
   193a4:	d011      	beq.n	193ca <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x15a>
          {
            sd.response.length =
                SendCmd(Command::kGetStatus, 0xFFFFFFFF, sd.response.data.byte,
                        100, KeepAlive::kYes);
   193a6:	9b05      	ldr	r3, [sp, #20]
   193a8:	681b      	ldr	r3, [r3, #0]
   193aa:	681c      	ldr	r4, [r3, #0]
                SendCmd(Command::kGetStatus, 0xFFFFFFFF, sd.response.data.byte,
   193ac:	ab06      	add	r3, sp, #24
   193ae:	f103 0208 	add.w	r2, r3, #8
   193b2:	2301      	movs	r3, #1
   193b4:	9301      	str	r3, [sp, #4]
   193b6:	2364      	movs	r3, #100	; 0x64
   193b8:	9300      	str	r3, [sp, #0]
   193ba:	4613      	mov	r3, r2
   193bc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   193c0:	210d      	movs	r1, #13
   193c2:	9805      	ldr	r0, [sp, #20]
   193c4:	47a0      	blx	r4
   193c6:	4603      	mov	r3, r0
            sd.response.length =
   193c8:	930a      	str	r3, [sp, #40]	; 0x28
                "Checking Status Register to see cause of Write Error...");
            LOG_DEBUG("[R2 Response: 0x%04" PRIX32 "]",
                      sd.response.data.dWord.lo);
          }
        }
        WaitWhileBusy();
   193ca:	9805      	ldr	r0, [sp, #20]
   193cc:	f7ff fd1c 	bl	18e08 <Sd::WaitWhileBusy()>
      for (uint16_t current_block_num = 0; current_block_num < blocks;
   193d0:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   193d4:	3301      	adds	r3, #1
   193d6:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
   193da:	e77f      	b.n	192dc <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x6c>
      }

      if (blocks > 1)
   193dc:	9b02      	ldr	r3, [sp, #8]
   193de:	2b01      	cmp	r3, #1
   193e0:	d90f      	bls.n	19402 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x192>
      {
        constexpr uint8_t kStopToken = 0xFD;
   193e2:	23fd      	movs	r3, #253	; 0xfd
   193e4:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
        ssp_interface_->Transfer(kStopToken);
   193e8:	9b05      	ldr	r3, [sp, #20]
   193ea:	685a      	ldr	r2, [r3, #4]
   193ec:	9b05      	ldr	r3, [sp, #20]
   193ee:	685b      	ldr	r3, [r3, #4]
   193f0:	681b      	ldr	r3, [r3, #0]
   193f2:	3308      	adds	r3, #8
   193f4:	681b      	ldr	r3, [r3, #0]
   193f6:	21fd      	movs	r1, #253	; 0xfd
   193f8:	4610      	mov	r0, r2
   193fa:	4798      	blx	r3

        // Wait for the card's programming to complete before
        // reselecting it (i.e. to prevent corruption)
        WaitWhileBusy();
   193fc:	9805      	ldr	r0, [sp, #20]
   193fe:	f7ff fd03 	bl	18e08 <Sd::WaitWhileBusy()>
      LOG_DEBUG("Illegal Cmd Err: %s", ToBool(sd.response.data.byte[0] & 0x04));
      LOG_DEBUG("Erase Reset: %s", ToBool(sd.response.data.byte[0] & 0x02));
      LOG_DEBUG("In Idle: %s", ToBool(sd.response.data.byte[0] & 0x01));
    }

    return sd.response.data.byte[0];
   19402:	f89d 4020 	ldrb.w	r4, [sp, #32]
   19406:	462b      	mov	r3, r5
   19408:	4619      	mov	r1, r3
   1940a:	4803      	ldr	r0, [pc, #12]	; (19418 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x1a8>)
   1940c:	f7fd fa86 	bl	1691c <__cyg_profile_func_exit>
   19410:	4623      	mov	r3, r4
  }
   19412:	4618      	mov	r0, r3
   19414:	b015      	add	sp, #84	; 0x54
   19416:	bd30      	pop	{r4, r5, pc}
   19418:	00019271 	.word	0x00019271

0001941c <Sd::DeleteBlock(unsigned long, unsigned long)>:

  // Deletes any number of blocks (inclusively) within a range of address.
  uint8_t DeleteBlock(uint32_t start, uint32_t end) override
   1941c:	b530      	push	{r4, r5, lr}
   1941e:	b08f      	sub	sp, #60	; 0x3c
   19420:	4675      	mov	r5, lr
   19422:	9005      	str	r0, [sp, #20]
   19424:	9104      	str	r1, [sp, #16]
   19426:	9203      	str	r2, [sp, #12]
   19428:	462b      	mov	r3, r5
   1942a:	4619      	mov	r1, r3
   1942c:	483d      	ldr	r0, [pc, #244]	; (19524 <Sd::DeleteBlock(unsigned long, unsigned long)+0x108>)
   1942e:	f7fd fa61 	bl	168f4 <__cyg_profile_func_enter>
  {
    // Wait for a previous command to finish
    WaitWhileBusy();
   19432:	9805      	ldr	r0, [sp, #20]
   19434:	f7ff fce8 	bl	18e08 <Sd::WaitWhileBusy()>

    // Create a temporary storage location to store sd command responses
    Sd::CardInfo_t sd;
    bool delete_failed = false;
   19438:	2300      	movs	r3, #0
   1943a:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37

    // Set the delete start address
    LOG_DEBUG("Setting Delete Start Address...");
    sd.response.length = SendCmd(Command::kDelFrom, start,
                                 sd.response.data.byte, 100, KeepAlive::kYes);
   1943e:	9b05      	ldr	r3, [sp, #20]
   19440:	681b      	ldr	r3, [r3, #0]
   19442:	681c      	ldr	r4, [r3, #0]
    sd.response.length = SendCmd(Command::kDelFrom, start,
   19444:	ab06      	add	r3, sp, #24
   19446:	f103 0208 	add.w	r2, r3, #8
   1944a:	2301      	movs	r3, #1
   1944c:	9301      	str	r3, [sp, #4]
   1944e:	2364      	movs	r3, #100	; 0x64
   19450:	9300      	str	r3, [sp, #0]
   19452:	4613      	mov	r3, r2
   19454:	9a04      	ldr	r2, [sp, #16]
   19456:	2160      	movs	r1, #96	; 0x60
   19458:	9805      	ldr	r0, [sp, #20]
   1945a:	47a0      	blx	r4
   1945c:	4603      	mov	r3, r0
   1945e:	930a      	str	r3, [sp, #40]	; 0x28

    // Wait while the writing the start address
    WaitWhileBusy();
   19460:	9805      	ldr	r0, [sp, #20]
   19462:	f7ff fcd1 	bl	18e08 <Sd::WaitWhileBusy()>

    // Force return if an error occurred
    if (sd.response.data.byte[0] != 0x00)
   19466:	f89d 3020 	ldrb.w	r3, [sp, #32]
   1946a:	2b00      	cmp	r3, #0
   1946c:	d009      	beq.n	19482 <Sd::DeleteBlock(unsigned long, unsigned long)+0x66>
    {
      LOG_ERROR("Failed to set Start Address!");
   1946e:	f44f 736a 	mov.w	r3, #936	; 0x3a8
   19472:	4a2d      	ldr	r2, [pc, #180]	; (19528 <Sd::DeleteBlock(unsigned long, unsigned long)+0x10c>)
   19474:	492d      	ldr	r1, [pc, #180]	; (1952c <Sd::DeleteBlock(unsigned long, unsigned long)+0x110>)
   19476:	482e      	ldr	r0, [pc, #184]	; (19530 <Sd::DeleteBlock(unsigned long, unsigned long)+0x114>)
   19478:	f7ff f9b2 	bl	187e0 <printf>
      delete_failed = true;
   1947c:	2301      	movs	r3, #1
   1947e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    }

    // Set the delete end address
    if (!delete_failed)
   19482:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   19486:	f083 0301 	eor.w	r3, r3, #1
   1948a:	b2db      	uxtb	r3, r3
   1948c:	2b00      	cmp	r3, #0
   1948e:	d010      	beq.n	194b2 <Sd::DeleteBlock(unsigned long, unsigned long)+0x96>
    {
      LOG_DEBUG("Setting Delete End Address...");
      sd.response.length = SendCmd(Command::kDelTo, end, sd.response.data.byte,
                                   100, KeepAlive::kYes);
   19490:	9b05      	ldr	r3, [sp, #20]
   19492:	681b      	ldr	r3, [r3, #0]
   19494:	681c      	ldr	r4, [r3, #0]
      sd.response.length = SendCmd(Command::kDelTo, end, sd.response.data.byte,
   19496:	ab06      	add	r3, sp, #24
   19498:	f103 0208 	add.w	r2, r3, #8
   1949c:	2301      	movs	r3, #1
   1949e:	9301      	str	r3, [sp, #4]
   194a0:	2364      	movs	r3, #100	; 0x64
   194a2:	9300      	str	r3, [sp, #0]
   194a4:	4613      	mov	r3, r2
   194a6:	9a03      	ldr	r2, [sp, #12]
   194a8:	2161      	movs	r1, #97	; 0x61
   194aa:	9805      	ldr	r0, [sp, #20]
   194ac:	47a0      	blx	r4
   194ae:	4603      	mov	r3, r0
   194b0:	930a      	str	r3, [sp, #40]	; 0x28
    }

    // Wait while the writing the end address
    WaitWhileBusy();
   194b2:	9805      	ldr	r0, [sp, #20]
   194b4:	f7ff fca8 	bl	18e08 <Sd::WaitWhileBusy()>

    // Force return if an error occurred
    if (sd.response.data.byte[0] != 0x00)
   194b8:	f89d 3020 	ldrb.w	r3, [sp, #32]
   194bc:	2b00      	cmp	r3, #0
   194be:	d009      	beq.n	194d4 <Sd::DeleteBlock(unsigned long, unsigned long)+0xb8>
    {
      LOG_ERROR("Failed to set End Address!");
   194c0:	f240 33ba 	movw	r3, #954	; 0x3ba
   194c4:	4a18      	ldr	r2, [pc, #96]	; (19528 <Sd::DeleteBlock(unsigned long, unsigned long)+0x10c>)
   194c6:	491b      	ldr	r1, [pc, #108]	; (19534 <Sd::DeleteBlock(unsigned long, unsigned long)+0x118>)
   194c8:	481b      	ldr	r0, [pc, #108]	; (19538 <Sd::DeleteBlock(unsigned long, unsigned long)+0x11c>)
   194ca:	f7ff f989 	bl	187e0 <printf>
      delete_failed = true;
   194ce:	2301      	movs	r3, #1
   194d0:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    }

    // Finally, attempt a delete
    if (!delete_failed)
   194d4:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   194d8:	f083 0301 	eor.w	r3, r3, #1
   194dc:	b2db      	uxtb	r3, r3
   194de:	2b00      	cmp	r3, #0
   194e0:	d014      	beq.n	1950c <Sd::DeleteBlock(unsigned long, unsigned long)+0xf0>
    {
      // Issue the delete command to delete from our from:to range
      LOG_DEBUG("Issuing Delete Command...");
      sd.response.length = SendCmd(Command::kDel, 0xFFFFFFFF,
                                   sd.response.data.byte, 100, KeepAlive::kYes);
   194e2:	9b05      	ldr	r3, [sp, #20]
   194e4:	681b      	ldr	r3, [r3, #0]
   194e6:	681c      	ldr	r4, [r3, #0]
      sd.response.length = SendCmd(Command::kDel, 0xFFFFFFFF,
   194e8:	ab06      	add	r3, sp, #24
   194ea:	f103 0208 	add.w	r2, r3, #8
   194ee:	2301      	movs	r3, #1
   194f0:	9301      	str	r3, [sp, #4]
   194f2:	2364      	movs	r3, #100	; 0x64
   194f4:	9300      	str	r3, [sp, #0]
   194f6:	4613      	mov	r3, r2
   194f8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   194fc:	2166      	movs	r1, #102	; 0x66
   194fe:	9805      	ldr	r0, [sp, #20]
   19500:	47a0      	blx	r4
   19502:	4603      	mov	r3, r0
   19504:	930a      	str	r3, [sp, #40]	; 0x28

      // Wait while the deletion occurs
      WaitWhileBusy();
   19506:	9805      	ldr	r0, [sp, #20]
   19508:	f7ff fc7e 	bl	18e08 <Sd::WaitWhileBusy()>
      LOG_DEBUG("[R1 Response: 0x%02X]", sd.response.data.byte[0]);
      LOG_DEBUG("Deletion Complete...");
    }

    // Return status
    return sd.response.data.byte[0];
   1950c:	f89d 4020 	ldrb.w	r4, [sp, #32]
   19510:	462b      	mov	r3, r5
   19512:	4619      	mov	r1, r3
   19514:	4803      	ldr	r0, [pc, #12]	; (19524 <Sd::DeleteBlock(unsigned long, unsigned long)+0x108>)
   19516:	f7fd fa01 	bl	1691c <__cyg_profile_func_exit>
   1951a:	4623      	mov	r3, r4
  }
   1951c:	4618      	mov	r0, r3
   1951e:	b00f      	add	sp, #60	; 0x3c
   19520:	bd30      	pop	{r4, r5, pc}
   19522:	bf00      	nop
   19524:	0001941d 	.word	0x0001941d
   19528:	0001f480 	.word	0x0001f480
   1952c:	0001f398 	.word	0x0001f398
   19530:	0001eeb0 	.word	0x0001eeb0
   19534:	0001f3a0 	.word	0x0001f3a0
   19538:	0001ef08 	.word	0x0001ef08

0001953c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)>:

  // Send a command
  uint32_t SendCmd(Command sdc, uint32_t arg, uint8_t response_buffer[],
   1953c:	e92d 49f0 	stmdb	sp!, {r4, r5, r6, r7, r8, fp, lr}
   19540:	b08f      	sub	sp, #60	; 0x3c
   19542:	46f0      	mov	r8, lr
   19544:	9003      	str	r0, [sp, #12]
   19546:	9102      	str	r1, [sp, #8]
   19548:	9201      	str	r2, [sp, #4]
   1954a:	9300      	str	r3, [sp, #0]
   1954c:	4643      	mov	r3, r8
   1954e:	4619      	mov	r1, r3
   19550:	4840      	ldr	r0, [pc, #256]	; (19654 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x118>)
   19552:	f7fd f9cf 	bl	168f4 <__cyg_profile_func_enter>
                   uint32_t delay, KeepAlive keep_alive) override
  {
    ResponseType res_type;
    uint8_t res_len    = 0;
   19556:	2300      	movs	r3, #0
   19558:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    uint8_t crc        = 0;
   1955c:	2300      	movs	r3, #0
   1955e:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    uint8_t tries      = 0;
   19562:	2300      	movs	r3, #0
   19564:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    uint8_t bit_offset = 0;  // determines the distance of the response's
   19568:	2300      	movs	r3, #0
   1956a:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                             // 0 bit from the MSB place
    uint8_t temp_byte = 0;
   1956e:	2300      	movs	r3, #0
   19570:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f

    // Determine the response type of the set command
    switch (sdc)
   19574:	9b02      	ldr	r3, [sp, #8]
   19576:	2b58      	cmp	r3, #88	; 0x58
   19578:	d052      	beq.n	19620 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xe4>
   1957a:	2b58      	cmp	r3, #88	; 0x58
   1957c:	dc16      	bgt.n	195ac <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x70>
   1957e:	2b48      	cmp	r3, #72	; 0x48
   19580:	d033      	beq.n	195ea <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xae>
   19582:	2b48      	cmp	r3, #72	; 0x48
   19584:	dc06      	bgt.n	19594 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x58>
   19586:	2b40      	cmp	r3, #64	; 0x40
   19588:	d029      	beq.n	195de <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xa2>
   1958a:	2b41      	cmp	r3, #65	; 0x41
   1958c:	d02a      	beq.n	195e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xa8>
   1958e:	2b0d      	cmp	r3, #13
   19590:	d031      	beq.n	195f6 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xba>
   19592:	e054      	b.n	1963e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   19594:	2b50      	cmp	r3, #80	; 0x50
   19596:	d03a      	beq.n	1960e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xd2>
   19598:	2b50      	cmp	r3, #80	; 0x50
   1959a:	dc02      	bgt.n	195a2 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x66>
   1959c:	2b4c      	cmp	r3, #76	; 0x4c
   1959e:	d027      	beq.n	195f0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xb4>
   195a0:	e04d      	b.n	1963e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   195a2:	2b51      	cmp	r3, #81	; 0x51
   195a4:	d036      	beq.n	19614 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xd8>
   195a6:	2b52      	cmp	r3, #82	; 0x52
   195a8:	d037      	beq.n	1961a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xde>
   195aa:	e048      	b.n	1963e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   195ac:	2b66      	cmp	r3, #102	; 0x66
   195ae:	d043      	beq.n	19638 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xfc>
   195b0:	2b66      	cmp	r3, #102	; 0x66
   195b2:	dc06      	bgt.n	195c2 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x86>
   195b4:	2b60      	cmp	r3, #96	; 0x60
   195b6:	d039      	beq.n	1962c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xf0>
   195b8:	2b61      	cmp	r3, #97	; 0x61
   195ba:	d03a      	beq.n	19632 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xf6>
   195bc:	2b59      	cmp	r3, #89	; 0x59
   195be:	d032      	beq.n	19626 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xea>
   195c0:	e03d      	b.n	1963e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   195c2:	2b77      	cmp	r3, #119	; 0x77
   195c4:	d01a      	beq.n	195fc <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xc0>
   195c6:	2b77      	cmp	r3, #119	; 0x77
   195c8:	dc02      	bgt.n	195d0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x94>
   195ca:	2b69      	cmp	r3, #105	; 0x69
   195cc:	d019      	beq.n	19602 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xc6>
   195ce:	e036      	b.n	1963e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   195d0:	2b7a      	cmp	r3, #122	; 0x7a
   195d2:	d019      	beq.n	19608 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xcc>
   195d4:	2bff      	cmp	r3, #255	; 0xff
   195d6:	d132      	bne.n	1963e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
    {
      case Command::kGarbage: res_type = ResponseType::kR1; break;
   195d8:	2300      	movs	r3, #0
   195da:	930d      	str	r3, [sp, #52]	; 0x34
   195dc:	e042      	b.n	19664 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kReset: res_type = ResponseType::kR1; break;
   195de:	2300      	movs	r3, #0
   195e0:	930d      	str	r3, [sp, #52]	; 0x34
   195e2:	e03f      	b.n	19664 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kInit: res_type = ResponseType::kR1; break;
   195e4:	2300      	movs	r3, #0
   195e6:	930d      	str	r3, [sp, #52]	; 0x34
   195e8:	e03c      	b.n	19664 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kGetOp: res_type = ResponseType::kR7; break;
   195ea:	2307      	movs	r3, #7
   195ec:	930d      	str	r3, [sp, #52]	; 0x34
   195ee:	e039      	b.n	19664 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kStopTrans: res_type = ResponseType::kR1; break;
   195f0:	2300      	movs	r3, #0
   195f2:	930d      	str	r3, [sp, #52]	; 0x34
   195f4:	e036      	b.n	19664 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kGetStatus: res_type = ResponseType::kR2; break;
   195f6:	2302      	movs	r3, #2
   195f8:	930d      	str	r3, [sp, #52]	; 0x34
   195fa:	e033      	b.n	19664 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kAcBegin: res_type = ResponseType::kR1; break;
   195fc:	2300      	movs	r3, #0
   195fe:	930d      	str	r3, [sp, #52]	; 0x34
   19600:	e030      	b.n	19664 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kAcInit: res_type = ResponseType::kR1; break;
   19602:	2300      	movs	r3, #0
   19604:	930d      	str	r3, [sp, #52]	; 0x34
   19606:	e02d      	b.n	19664 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kGetOcr: res_type = ResponseType::kR3; break;
   19608:	2303      	movs	r3, #3
   1960a:	930d      	str	r3, [sp, #52]	; 0x34
   1960c:	e02a      	b.n	19664 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kChgBlkLen: res_type = ResponseType::kR1; break;
   1960e:	2300      	movs	r3, #0
   19610:	930d      	str	r3, [sp, #52]	; 0x34
   19612:	e027      	b.n	19664 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kReadSingle: res_type = ResponseType::kR1; break;
   19614:	2300      	movs	r3, #0
   19616:	930d      	str	r3, [sp, #52]	; 0x34
   19618:	e024      	b.n	19664 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kReadMulti: res_type = ResponseType::kR1; break;
   1961a:	2300      	movs	r3, #0
   1961c:	930d      	str	r3, [sp, #52]	; 0x34
   1961e:	e021      	b.n	19664 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kWriteSingle: res_type = ResponseType::kR1; break;
   19620:	2300      	movs	r3, #0
   19622:	930d      	str	r3, [sp, #52]	; 0x34
   19624:	e01e      	b.n	19664 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kWriteMulti: res_type = ResponseType::kR1; break;
   19626:	2300      	movs	r3, #0
   19628:	930d      	str	r3, [sp, #52]	; 0x34
   1962a:	e01b      	b.n	19664 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kDelFrom: res_type = ResponseType::kR1; break;
   1962c:	2300      	movs	r3, #0
   1962e:	930d      	str	r3, [sp, #52]	; 0x34
   19630:	e018      	b.n	19664 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kDelTo: res_type = ResponseType::kR1; break;
   19632:	2300      	movs	r3, #0
   19634:	930d      	str	r3, [sp, #52]	; 0x34
   19636:	e015      	b.n	19664 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kDel: res_type = ResponseType::kR1b; break;
   19638:	2301      	movs	r3, #1
   1963a:	930d      	str	r3, [sp, #52]	; 0x34
   1963c:	e012      	b.n	19664 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      default:
        LOG_ERROR("Unknown response type. Aborting!");
   1963e:	f240 33f3 	movw	r3, #1011	; 0x3f3
   19642:	4a05      	ldr	r2, [pc, #20]	; (19658 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x11c>)
   19644:	4905      	ldr	r1, [pc, #20]	; (1965c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x120>)
   19646:	4806      	ldr	r0, [pc, #24]	; (19660 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x124>)
   19648:	f7ff f8ca 	bl	187e0 <printf>
        return -1;
   1964c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   19650:	e1b1      	b.n	199b6 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x47a>
   19652:	bf00      	nop
   19654:	0001953d 	.word	0x0001953d
   19658:	0001f4b4 	.word	0x0001f4b4
   1965c:	0001f3a8 	.word	0x0001f3a8
   19660:	0001ef5c 	.word	0x0001ef5c
    // algorithm
    uint8_t msg[5] = { static_cast<uint8_t>(sdc),
                       static_cast<uint8_t>(arg >> 24),
                       static_cast<uint8_t>(arg >> 16),
                       static_cast<uint8_t>(arg >> 8),
                       static_cast<uint8_t>(arg >> 0) };
   19664:	9b02      	ldr	r3, [sp, #8]
   19666:	b2db      	uxtb	r3, r3
   19668:	f88d 3010 	strb.w	r3, [sp, #16]
                       static_cast<uint8_t>(arg >> 24),
   1966c:	9b01      	ldr	r3, [sp, #4]
   1966e:	0e1b      	lsrs	r3, r3, #24
                       static_cast<uint8_t>(arg >> 0) };
   19670:	b2db      	uxtb	r3, r3
   19672:	f88d 3011 	strb.w	r3, [sp, #17]
                       static_cast<uint8_t>(arg >> 16),
   19676:	9b01      	ldr	r3, [sp, #4]
   19678:	0c1b      	lsrs	r3, r3, #16
                       static_cast<uint8_t>(arg >> 0) };
   1967a:	b2db      	uxtb	r3, r3
   1967c:	f88d 3012 	strb.w	r3, [sp, #18]
                       static_cast<uint8_t>(arg >> 8),
   19680:	9b01      	ldr	r3, [sp, #4]
   19682:	0a1b      	lsrs	r3, r3, #8
                       static_cast<uint8_t>(arg >> 0) };
   19684:	b2db      	uxtb	r3, r3
   19686:	f88d 3013 	strb.w	r3, [sp, #19]
   1968a:	9b01      	ldr	r3, [sp, #4]
   1968c:	b2db      	uxtb	r3, r3
   1968e:	f88d 3014 	strb.w	r3, [sp, #20]

    crc = GetCrc7(msg, sizeof(msg));
   19692:	9b03      	ldr	r3, [sp, #12]
   19694:	681b      	ldr	r3, [r3, #0]
   19696:	331c      	adds	r3, #28
   19698:	681b      	ldr	r3, [r3, #0]
   1969a:	a904      	add	r1, sp, #16
   1969c:	2205      	movs	r2, #5
   1969e:	9803      	ldr	r0, [sp, #12]
   196a0:	4798      	blx	r3
   196a2:	4603      	mov	r3, r0
   196a4:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    if (sdc == Command::kGarbage)
   196a8:	9b02      	ldr	r3, [sp, #8]
   196aa:	2bff      	cmp	r3, #255	; 0xff
   196ac:	d102      	bne.n	196b4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x178>
    {
      crc = 0xFF;
   196ae:	23ff      	movs	r3, #255	; 0xff
   196b0:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    }

    // Select the SD Card
    chip_select_->SetLow();
   196b4:	9b03      	ldr	r3, [sp, #12]
   196b6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   196b8:	9b03      	ldr	r3, [sp, #12]
   196ba:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   196bc:	681b      	ldr	r3, [r3, #0]
   196be:	3310      	adds	r3, #16
   196c0:	681b      	ldr	r3, [r3, #0]
   196c2:	4610      	mov	r0, r2
   196c4:	4798      	blx	r3
    chip_select_external_->SetLow();
   196c6:	9b03      	ldr	r3, [sp, #12]
   196c8:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   196ca:	9b03      	ldr	r3, [sp, #12]
   196cc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   196ce:	681b      	ldr	r3, [r3, #0]
   196d0:	3310      	adds	r3, #16
   196d2:	681b      	ldr	r3, [r3, #0]
   196d4:	4610      	mov	r0, r2
   196d6:	4798      	blx	r3

    // If desired, wait a bit before talking
    if (delay > 0)
   196d8:	9b16      	ldr	r3, [sp, #88]	; 0x58
   196da:	2b00      	cmp	r3, #0
   196dc:	d007      	beq.n	196ee <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x1b2>
    {
      Delay(delay);
   196de:	9b16      	ldr	r3, [sp, #88]	; 0x58
   196e0:	461a      	mov	r2, r3
   196e2:	f04f 0300 	mov.w	r3, #0
   196e6:	4610      	mov	r0, r2
   196e8:	4619      	mov	r1, r3
   196ea:	f7f6 ff69 	bl	105c0 <Delay(unsigned long long)>
    }

    // Send the desired command frame to the SD card board
    // Begin by transfering the command byte
    ssp_interface_->Transfer(static_cast<uint16_t>(sdc));
   196ee:	9b03      	ldr	r3, [sp, #12]
   196f0:	685a      	ldr	r2, [r3, #4]
   196f2:	9b03      	ldr	r3, [sp, #12]
   196f4:	685b      	ldr	r3, [r3, #4]
   196f6:	681b      	ldr	r3, [r3, #0]
   196f8:	3308      	adds	r3, #8
   196fa:	681b      	ldr	r3, [r3, #0]
   196fc:	9902      	ldr	r1, [sp, #8]
   196fe:	b289      	uxth	r1, r1
   19700:	4610      	mov	r0, r2
   19702:	4798      	blx	r3
    // Send arg byte [31:24]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 24) & 0xFF);
   19704:	9b03      	ldr	r3, [sp, #12]
   19706:	6858      	ldr	r0, [r3, #4]
   19708:	9b03      	ldr	r3, [sp, #12]
   1970a:	685b      	ldr	r3, [r3, #4]
   1970c:	681b      	ldr	r3, [r3, #0]
   1970e:	3308      	adds	r3, #8
   19710:	681b      	ldr	r3, [r3, #0]
   19712:	9a01      	ldr	r2, [sp, #4]
   19714:	0e12      	lsrs	r2, r2, #24
   19716:	b292      	uxth	r2, r2
   19718:	b2d2      	uxtb	r2, r2
   1971a:	b292      	uxth	r2, r2
   1971c:	4611      	mov	r1, r2
   1971e:	4798      	blx	r3
    // Send arg byte [23:16]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 16) & 0xFF);
   19720:	9b03      	ldr	r3, [sp, #12]
   19722:	6858      	ldr	r0, [r3, #4]
   19724:	9b03      	ldr	r3, [sp, #12]
   19726:	685b      	ldr	r3, [r3, #4]
   19728:	681b      	ldr	r3, [r3, #0]
   1972a:	3308      	adds	r3, #8
   1972c:	681b      	ldr	r3, [r3, #0]
   1972e:	9a01      	ldr	r2, [sp, #4]
   19730:	0c12      	lsrs	r2, r2, #16
   19732:	b292      	uxth	r2, r2
   19734:	b2d2      	uxtb	r2, r2
   19736:	b292      	uxth	r2, r2
   19738:	4611      	mov	r1, r2
   1973a:	4798      	blx	r3
    // Send arg byte [15:8]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 8) & 0xFF);
   1973c:	9b03      	ldr	r3, [sp, #12]
   1973e:	6858      	ldr	r0, [r3, #4]
   19740:	9b03      	ldr	r3, [sp, #12]
   19742:	685b      	ldr	r3, [r3, #4]
   19744:	681b      	ldr	r3, [r3, #0]
   19746:	3308      	adds	r3, #8
   19748:	681b      	ldr	r3, [r3, #0]
   1974a:	9a01      	ldr	r2, [sp, #4]
   1974c:	0a12      	lsrs	r2, r2, #8
   1974e:	b292      	uxth	r2, r2
   19750:	b2d2      	uxtb	r2, r2
   19752:	b292      	uxth	r2, r2
   19754:	4611      	mov	r1, r2
   19756:	4798      	blx	r3
    // Send arg byte [7:0]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 0) & 0xFF);
   19758:	9b03      	ldr	r3, [sp, #12]
   1975a:	685a      	ldr	r2, [r3, #4]
   1975c:	9b03      	ldr	r3, [sp, #12]
   1975e:	685b      	ldr	r3, [r3, #4]
   19760:	681b      	ldr	r3, [r3, #0]
   19762:	3308      	adds	r3, #8
   19764:	681b      	ldr	r3, [r3, #0]
   19766:	9901      	ldr	r1, [sp, #4]
   19768:	b289      	uxth	r1, r1
   1976a:	b2c9      	uxtb	r1, r1
   1976c:	b289      	uxth	r1, r1
   1976e:	4610      	mov	r0, r2
   19770:	4798      	blx	r3
    // Send 7-bit CRC and LSB stop addr (as b1)
    ssp_interface_->Transfer(static_cast<uint16_t>(crc << 1) | 0x01);
   19772:	9b03      	ldr	r3, [sp, #12]
   19774:	6858      	ldr	r0, [r3, #4]
   19776:	9b03      	ldr	r3, [sp, #12]
   19778:	685b      	ldr	r3, [r3, #4]
   1977a:	681b      	ldr	r3, [r3, #0]
   1977c:	3308      	adds	r3, #8
   1977e:	681b      	ldr	r3, [r3, #0]
   19780:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
   19784:	b292      	uxth	r2, r2
   19786:	0052      	lsls	r2, r2, #1
   19788:	b292      	uxth	r2, r2
   1978a:	f042 0201 	orr.w	r2, r2, #1
   1978e:	b292      	uxth	r2, r2
   19790:	4611      	mov	r1, r2
   19792:	4798      	blx	r3

    // Write garbage while waiting for a response
    // Send at least 1 byte of garbage before checking for a response
    temp_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   19794:	9b03      	ldr	r3, [sp, #12]
   19796:	685a      	ldr	r2, [r3, #4]
   19798:	9b03      	ldr	r3, [sp, #12]
   1979a:	685b      	ldr	r3, [r3, #4]
   1979c:	681b      	ldr	r3, [r3, #0]
   1979e:	3308      	adds	r3, #8
   197a0:	681b      	ldr	r3, [r3, #0]
   197a2:	21ff      	movs	r1, #255	; 0xff
   197a4:	4610      	mov	r0, r2
   197a6:	4798      	blx	r3
   197a8:	4603      	mov	r3, r0
   197aa:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    while (tries++ < kBusTimeout)
   197ae:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   197b2:	1c5a      	adds	r2, r3, #1
   197b4:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
   197b8:	2bf9      	cmp	r3, #249	; 0xf9
   197ba:	bf94      	ite	ls
   197bc:	2301      	movls	r3, #1
   197be:	2300      	movhi	r3, #0
   197c0:	b2db      	uxtb	r3, r3
   197c2:	2b00      	cmp	r3, #0
   197c4:	d027      	beq.n	19816 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2da>
    {
      temp_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   197c6:	9b03      	ldr	r3, [sp, #12]
   197c8:	685a      	ldr	r2, [r3, #4]
   197ca:	9b03      	ldr	r3, [sp, #12]
   197cc:	685b      	ldr	r3, [r3, #4]
   197ce:	681b      	ldr	r3, [r3, #0]
   197d0:	3308      	adds	r3, #8
   197d2:	681b      	ldr	r3, [r3, #0]
   197d4:	21ff      	movs	r1, #255	; 0xff
   197d6:	4610      	mov	r0, r2
   197d8:	4798      	blx	r3
   197da:	4603      	mov	r3, r0
   197dc:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
      if (temp_byte != 0xFF)
   197e0:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
   197e4:	2bff      	cmp	r3, #255	; 0xff
   197e6:	d00f      	beq.n	19808 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2cc>
      {
        // Determine the offset, since the first byte of a
        // response will always be 0.
        while (temp_byte & (0x80 >> bit_offset))
   197e8:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
   197ec:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   197f0:	2180      	movs	r1, #128	; 0x80
   197f2:	fa41 f303 	asr.w	r3, r1, r3
   197f6:	4013      	ands	r3, r2
   197f8:	2b00      	cmp	r3, #0
   197fa:	d00b      	beq.n	19814 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2d8>
        {
          bit_offset++;
   197fc:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   19800:	3301      	adds	r3, #1
   19802:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
        while (temp_byte & (0x80 >> bit_offset))
   19806:	e7ef      	b.n	197e8 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2ac>
        }
        break;
      }
      tries++;
   19808:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   1980c:	3301      	adds	r3, #1
   1980e:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    while (tries++ < kBusTimeout)
   19812:	e7cc      	b.n	197ae <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x272>
        break;
   19814:	bf00      	nop
    }

    // Determine response length (in bytes) based on response type
    switch (res_type)
   19816:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   19818:	2b07      	cmp	r3, #7
   1981a:	d827      	bhi.n	1986c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x330>
   1981c:	a201      	add	r2, pc, #4	; (adr r2, 19824 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2e8>)
   1981e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   19822:	bf00      	nop
   19824:	00019845 	.word	0x00019845
   19828:	0001984d 	.word	0x0001984d
   1982c:	00019855 	.word	0x00019855
   19830:	0001985d 	.word	0x0001985d
   19834:	0001986d 	.word	0x0001986d
   19838:	0001986d 	.word	0x0001986d
   1983c:	0001986d 	.word	0x0001986d
   19840:	00019865 	.word	0x00019865
    {
      case ResponseType::kR1: res_len = 1; break;
   19844:	2301      	movs	r3, #1
   19846:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   1984a:	e019      	b.n	19880 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR1b: res_len = 1; break;
   1984c:	2301      	movs	r3, #1
   1984e:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   19852:	e015      	b.n	19880 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR2: res_len = 2; break;
   19854:	2302      	movs	r3, #2
   19856:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   1985a:	e011      	b.n	19880 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR3: res_len = 5; break;
   1985c:	2305      	movs	r3, #5
   1985e:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   19862:	e00d      	b.n	19880 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR7: res_len = 5; break;
   19864:	2305      	movs	r3, #5
   19866:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   1986a:	e009      	b.n	19880 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      default:
        LOG_ERROR("Response unsupported in SPI mode. Aborting!");
   1986c:	f240 433a 	movw	r3, #1082	; 0x43a
   19870:	4a56      	ldr	r2, [pc, #344]	; (199cc <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x490>)
   19872:	4957      	ldr	r1, [pc, #348]	; (199d0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x494>)
   19874:	4857      	ldr	r0, [pc, #348]	; (199d4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x498>)
   19876:	f7fe ffb3 	bl	187e0 <printf>
        return -1;
   1987a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1987e:	e09a      	b.n	199b6 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x47a>
        break;
    }

    // Acquire the response
    uint64_t temp_response = 0;
   19880:	f04f 0200 	mov.w	r2, #0
   19884:	f04f 0300 	mov.w	r3, #0
   19888:	e9cd 2308 	strd	r2, r3, [sp, #32]
    // Read an extra 8 bits since the response was offset
    uint8_t bytes_to_read =
   1988c:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   19890:	2b00      	cmp	r3, #0
   19892:	d004      	beq.n	1989e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x362>
   19894:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   19898:	3301      	adds	r3, #1
   1989a:	b2db      	uxtb	r3, r3
   1989c:	e001      	b.n	198a2 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x366>
   1989e:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   198a2:	f88d 301f 	strb.w	r3, [sp, #31]
        static_cast<uint8_t>((bit_offset > 0) ? res_len + 1 : res_len);
    while (bytes_to_read-- > 0)
   198a6:	f89d 301f 	ldrb.w	r3, [sp, #31]
   198aa:	1e5a      	subs	r2, r3, #1
   198ac:	f88d 201f 	strb.w	r2, [sp, #31]
   198b0:	2b00      	cmp	r3, #0
   198b2:	bf14      	ite	ne
   198b4:	2301      	movne	r3, #1
   198b6:	2300      	moveq	r3, #0
   198b8:	b2db      	uxtb	r3, r3
   198ba:	2b00      	cmp	r3, #0
   198bc:	d025      	beq.n	1990a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x3ce>
    {
      // Make space for the next byte
      temp_response = temp_response << 8;
   198be:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   198c2:	f04f 0200 	mov.w	r2, #0
   198c6:	f04f 0300 	mov.w	r3, #0
   198ca:	020b      	lsls	r3, r1, #8
   198cc:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
   198d0:	0202      	lsls	r2, r0, #8
   198d2:	e9cd 2308 	strd	r2, r3, [sp, #32]
      temp_response |= temp_byte;
   198d6:	f89d b02f 	ldrb.w	fp, [sp, #47]	; 0x2f
   198da:	f04f 0c00 	mov.w	ip, #0
   198de:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   198e2:	ea4b 0200 	orr.w	r2, fp, r0
   198e6:	ea4c 0301 	orr.w	r3, ip, r1
   198ea:	e9cd 2308 	strd	r2, r3, [sp, #32]
      temp_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   198ee:	9b03      	ldr	r3, [sp, #12]
   198f0:	685a      	ldr	r2, [r3, #4]
   198f2:	9b03      	ldr	r3, [sp, #12]
   198f4:	685b      	ldr	r3, [r3, #4]
   198f6:	681b      	ldr	r3, [r3, #0]
   198f8:	3308      	adds	r3, #8
   198fa:	681b      	ldr	r3, [r3, #0]
   198fc:	21ff      	movs	r1, #255	; 0xff
   198fe:	4610      	mov	r0, r2
   19900:	4798      	blx	r3
   19902:	4603      	mov	r3, r0
   19904:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    while (bytes_to_read-- > 0)
   19908:	e7cd      	b.n	198a6 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x36a>
    }
    // Compensate for the bit offset
    temp_response = temp_response >> bit_offset;
   1990a:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
   1990e:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   19912:	f1c1 0c20 	rsb	ip, r1, #32
   19916:	f1a1 0020 	sub.w	r0, r1, #32
   1991a:	fa22 f401 	lsr.w	r4, r2, r1
   1991e:	fa03 fc0c 	lsl.w	ip, r3, ip
   19922:	ea44 040c 	orr.w	r4, r4, ip
   19926:	fa23 f000 	lsr.w	r0, r3, r0
   1992a:	4304      	orrs	r4, r0
   1992c:	fa23 f501 	lsr.w	r5, r3, r1
   19930:	e9cd 4508 	strd	r4, r5, [sp, #32]

    // Only write to the response buffer if it is provided
    if (response_buffer != nullptr)
   19934:	9b00      	ldr	r3, [sp, #0]
   19936:	2b00      	cmp	r3, #0
   19938:	d025      	beq.n	19986 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x44a>
    {
      for (int i = 0; i < res_len; i++)
   1993a:	2300      	movs	r3, #0
   1993c:	9306      	str	r3, [sp, #24]
   1993e:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   19942:	9a06      	ldr	r2, [sp, #24]
   19944:	429a      	cmp	r2, r3
   19946:	da1e      	bge.n	19986 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x44a>
      {
        response_buffer[i] =
            static_cast<uint8_t>(temp_response >> 8 * (res_len - 1 - i));
   19948:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   1994c:	1e5a      	subs	r2, r3, #1
   1994e:	9b06      	ldr	r3, [sp, #24]
   19950:	1ad3      	subs	r3, r2, r3
   19952:	00da      	lsls	r2, r3, #3
   19954:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   19958:	f1c2 0020 	rsb	r0, r2, #32
   1995c:	f1a2 0120 	sub.w	r1, r2, #32
   19960:	fa23 f602 	lsr.w	r6, r3, r2
   19964:	fa04 f000 	lsl.w	r0, r4, r0
   19968:	4306      	orrs	r6, r0
   1996a:	fa24 f101 	lsr.w	r1, r4, r1
   1996e:	430e      	orrs	r6, r1
   19970:	fa24 f702 	lsr.w	r7, r4, r2
        response_buffer[i] =
   19974:	9b06      	ldr	r3, [sp, #24]
   19976:	9a00      	ldr	r2, [sp, #0]
   19978:	4413      	add	r3, r2
   1997a:	b2f2      	uxtb	r2, r6
   1997c:	701a      	strb	r2, [r3, #0]
      for (int i = 0; i < res_len; i++)
   1997e:	9b06      	ldr	r3, [sp, #24]
   19980:	3301      	adds	r3, #1
   19982:	9306      	str	r3, [sp, #24]
   19984:	e7db      	b.n	1993e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x402>
      }
    }

    // Only end the transaction if keep_alive isn't requested
    if (keep_alive == KeepAlive::kNo)
   19986:	f89d 305c 	ldrb.w	r3, [sp, #92]	; 0x5c
   1998a:	2b00      	cmp	r3, #0
   1998c:	d111      	bne.n	199b2 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x476>
    {
      // Deselect the SPI comm board
      chip_select_->SetHigh();
   1998e:	9b03      	ldr	r3, [sp, #12]
   19990:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   19992:	9b03      	ldr	r3, [sp, #12]
   19994:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   19996:	681b      	ldr	r3, [r3, #0]
   19998:	330c      	adds	r3, #12
   1999a:	681b      	ldr	r3, [r3, #0]
   1999c:	4610      	mov	r0, r2
   1999e:	4798      	blx	r3
      chip_select_external_->SetHigh();
   199a0:	9b03      	ldr	r3, [sp, #12]
   199a2:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   199a4:	9b03      	ldr	r3, [sp, #12]
   199a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   199a8:	681b      	ldr	r3, [r3, #0]
   199aa:	330c      	adds	r3, #12
   199ac:	681b      	ldr	r3, [r3, #0]
   199ae:	4610      	mov	r0, r2
   199b0:	4798      	blx	r3
    }
    return res_len;
   199b2:	f89d 4033 	ldrb.w	r4, [sp, #51]	; 0x33
   199b6:	4643      	mov	r3, r8
   199b8:	4619      	mov	r1, r3
   199ba:	4807      	ldr	r0, [pc, #28]	; (199d8 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x49c>)
   199bc:	f7fc ffae 	bl	1691c <__cyg_profile_func_exit>
   199c0:	4623      	mov	r3, r4
  }
   199c2:	4618      	mov	r0, r3
   199c4:	b00f      	add	sp, #60	; 0x3c
   199c6:	e8bd 89f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, fp, pc}
   199ca:	bf00      	nop
   199cc:	0001f4b4 	.word	0x0001f4b4
   199d0:	0001f3b0 	.word	0x0001f3b0
   199d4:	0001efb8 	.word	0x0001efb8
   199d8:	0001953d 	.word	0x0001953d

000199dc <Sd::Crc7Add(unsigned char, unsigned char)>:

  // Adds a message byte to the current CRC-7 to get a the new CRC-7
  uint8_t Crc7Add(uint8_t crc, uint8_t message_byte) override
   199dc:	b530      	push	{r4, r5, lr}
   199de:	b083      	sub	sp, #12
   199e0:	4675      	mov	r5, lr
   199e2:	9001      	str	r0, [sp, #4]
   199e4:	460b      	mov	r3, r1
   199e6:	f88d 3003 	strb.w	r3, [sp, #3]
   199ea:	4613      	mov	r3, r2
   199ec:	f88d 3002 	strb.w	r3, [sp, #2]
   199f0:	462b      	mov	r3, r5
   199f2:	4619      	mov	r1, r3
   199f4:	4809      	ldr	r0, [pc, #36]	; (19a1c <Sd::Crc7Add(unsigned char, unsigned char)+0x40>)
   199f6:	f7fc ff7d 	bl	168f4 <__cyg_profile_func_enter>
  {
    return kCrcTable8.crc_table[(crc << 1) ^ message_byte];
   199fa:	f89d 3003 	ldrb.w	r3, [sp, #3]
   199fe:	005a      	lsls	r2, r3, #1
   19a00:	f89d 3002 	ldrb.w	r3, [sp, #2]
   19a04:	4053      	eors	r3, r2
   19a06:	4a06      	ldr	r2, [pc, #24]	; (19a20 <Sd::Crc7Add(unsigned char, unsigned char)+0x44>)
   19a08:	5cd4      	ldrb	r4, [r2, r3]
   19a0a:	462b      	mov	r3, r5
   19a0c:	4619      	mov	r1, r3
   19a0e:	4803      	ldr	r0, [pc, #12]	; (19a1c <Sd::Crc7Add(unsigned char, unsigned char)+0x40>)
   19a10:	f7fc ff84 	bl	1691c <__cyg_profile_func_exit>
   19a14:	4623      	mov	r3, r4
  }
   19a16:	4618      	mov	r0, r3
   19a18:	b003      	add	sp, #12
   19a1a:	bd30      	pop	{r4, r5, pc}
   19a1c:	000199dd 	.word	0x000199dd
   19a20:	0001f020 	.word	0x0001f020

00019a24 <Sd::GetCrc7(unsigned char*, unsigned char)>:

  // Returns the CRC-7 for a message of "length" bytes
  uint8_t GetCrc7(uint8_t * message, uint8_t length) override
   19a24:	b530      	push	{r4, r5, lr}
   19a26:	b087      	sub	sp, #28
   19a28:	4675      	mov	r5, lr
   19a2a:	9003      	str	r0, [sp, #12]
   19a2c:	9102      	str	r1, [sp, #8]
   19a2e:	4613      	mov	r3, r2
   19a30:	f88d 3007 	strb.w	r3, [sp, #7]
   19a34:	462b      	mov	r3, r5
   19a36:	4619      	mov	r1, r3
   19a38:	4815      	ldr	r0, [pc, #84]	; (19a90 <Sd::GetCrc7(unsigned char*, unsigned char)+0x6c>)
   19a3a:	f7fc ff5b 	bl	168f4 <__cyg_profile_func_enter>
  {
    uint8_t crc = 0;
   19a3e:	2300      	movs	r3, #0
   19a40:	f88d 3017 	strb.w	r3, [sp, #23]
    for (int i = 0; i < length; i++)
   19a44:	2300      	movs	r3, #0
   19a46:	9304      	str	r3, [sp, #16]
   19a48:	f89d 3007 	ldrb.w	r3, [sp, #7]
   19a4c:	9a04      	ldr	r2, [sp, #16]
   19a4e:	429a      	cmp	r2, r3
   19a50:	da12      	bge.n	19a78 <Sd::GetCrc7(unsigned char*, unsigned char)+0x54>
    {
      crc = Crc7Add(crc, message[i]);
   19a52:	9b03      	ldr	r3, [sp, #12]
   19a54:	681b      	ldr	r3, [r3, #0]
   19a56:	3318      	adds	r3, #24
   19a58:	681b      	ldr	r3, [r3, #0]
   19a5a:	9a04      	ldr	r2, [sp, #16]
   19a5c:	9902      	ldr	r1, [sp, #8]
   19a5e:	440a      	add	r2, r1
   19a60:	7812      	ldrb	r2, [r2, #0]
   19a62:	f89d 1017 	ldrb.w	r1, [sp, #23]
   19a66:	9803      	ldr	r0, [sp, #12]
   19a68:	4798      	blx	r3
   19a6a:	4603      	mov	r3, r0
   19a6c:	f88d 3017 	strb.w	r3, [sp, #23]
    for (int i = 0; i < length; i++)
   19a70:	9b04      	ldr	r3, [sp, #16]
   19a72:	3301      	adds	r3, #1
   19a74:	9304      	str	r3, [sp, #16]
   19a76:	e7e7      	b.n	19a48 <Sd::GetCrc7(unsigned char*, unsigned char)+0x24>
    }
    return crc;
   19a78:	f89d 4017 	ldrb.w	r4, [sp, #23]
   19a7c:	462b      	mov	r3, r5
   19a7e:	4619      	mov	r1, r3
   19a80:	4803      	ldr	r0, [pc, #12]	; (19a90 <Sd::GetCrc7(unsigned char*, unsigned char)+0x6c>)
   19a82:	f7fc ff4b 	bl	1691c <__cyg_profile_func_exit>
   19a86:	4623      	mov	r3, r4
  }
   19a88:	4618      	mov	r0, r3
   19a8a:	b007      	add	sp, #28
   19a8c:	bd30      	pop	{r4, r5, pc}
   19a8e:	bf00      	nop
   19a90:	00019a25 	.word	0x00019a25

00019a94 <Sd::GetCrc16(unsigned char*, unsigned short)>:

  // Returns CCITT CRC-16 for a message of "length" bytes
  uint16_t GetCrc16(uint8_t * message, uint16_t length) override
   19a94:	e92d 48f0 	stmdb	sp!, {r4, r5, r6, r7, fp, lr}
   19a98:	b08c      	sub	sp, #48	; 0x30
   19a9a:	4677      	mov	r7, lr
   19a9c:	9003      	str	r0, [sp, #12]
   19a9e:	9102      	str	r1, [sp, #8]
   19aa0:	4613      	mov	r3, r2
   19aa2:	f8ad 3006 	strh.w	r3, [sp, #6]
   19aa6:	463b      	mov	r3, r7
   19aa8:	4619      	mov	r1, r3
   19aaa:	4837      	ldr	r0, [pc, #220]	; (19b88 <Sd::GetCrc16(unsigned char*, unsigned short)+0xf4>)
   19aac:	f7fc ff22 	bl	168f4 <__cyg_profile_func_enter>
  {
    uint64_t crc = 0x0000;
   19ab0:	f04f 0300 	mov.w	r3, #0
   19ab4:	f04f 0400 	mov.w	r4, #0
   19ab8:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
    uint64_t temp;
    uint64_t final_value = 0;
   19abc:	f04f 0300 	mov.w	r3, #0
   19ac0:	f04f 0400 	mov.w	r4, #0
   19ac4:	e9cd 3406 	strd	r3, r4, [sp, #24]

    for (uint64_t count = 0; count < length; ++count)
   19ac8:	f04f 0300 	mov.w	r3, #0
   19acc:	f04f 0400 	mov.w	r4, #0
   19ad0:	e9cd 3408 	strd	r3, r4, [sp, #32]
   19ad4:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   19ad8:	f04f 0400 	mov.w	r4, #0
   19adc:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
   19ae0:	42a2      	cmp	r2, r4
   19ae2:	bf08      	it	eq
   19ae4:	4299      	cmpeq	r1, r3
   19ae6:	d23f      	bcs.n	19b68 <Sd::GetCrc16(unsigned char*, unsigned short)+0xd4>
    {
      temp = (*message++ ^ (crc >> 8)) & 0xff;
   19ae8:	9b02      	ldr	r3, [sp, #8]
   19aea:	1c5a      	adds	r2, r3, #1
   19aec:	9202      	str	r2, [sp, #8]
   19aee:	781b      	ldrb	r3, [r3, #0]
   19af0:	b2dd      	uxtb	r5, r3
   19af2:	f04f 0600 	mov.w	r6, #0
   19af6:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
   19afa:	f04f 0300 	mov.w	r3, #0
   19afe:	f04f 0400 	mov.w	r4, #0
   19b02:	0a0b      	lsrs	r3, r1, #8
   19b04:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   19b08:	0a14      	lsrs	r4, r2, #8
   19b0a:	ea83 0b05 	eor.w	fp, r3, r5
   19b0e:	ea84 0c06 	eor.w	ip, r4, r6
   19b12:	f04f 01ff 	mov.w	r1, #255	; 0xff
   19b16:	f04f 0200 	mov.w	r2, #0
   19b1a:	ea0b 0301 	and.w	r3, fp, r1
   19b1e:	ea0c 0402 	and.w	r4, ip, r2
   19b22:	e9cd 3404 	strd	r3, r4, [sp, #16]
      crc  = kCrcTable16.crc_table[temp] ^ (crc << 8);
   19b26:	4a19      	ldr	r2, [pc, #100]	; (19b8c <Sd::GetCrc16(unsigned char*, unsigned short)+0xf8>)
   19b28:	9b04      	ldr	r3, [sp, #16]
   19b2a:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
   19b2e:	b29d      	uxth	r5, r3
   19b30:	f04f 0600 	mov.w	r6, #0
   19b34:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
   19b38:	f04f 0b00 	mov.w	fp, #0
   19b3c:	f04f 0c00 	mov.w	ip, #0
   19b40:	ea4f 2c02 	mov.w	ip, r2, lsl #8
   19b44:	ea4c 6c11 	orr.w	ip, ip, r1, lsr #24
   19b48:	ea4f 2b01 	mov.w	fp, r1, lsl #8
   19b4c:	ea8b 0305 	eor.w	r3, fp, r5
   19b50:	ea8c 0406 	eor.w	r4, ip, r6
   19b54:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
    for (uint64_t count = 0; count < length; ++count)
   19b58:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   19b5c:	1c59      	adds	r1, r3, #1
   19b5e:	f144 0200 	adc.w	r2, r4, #0
   19b62:	e9cd 1208 	strd	r1, r2, [sp, #32]
   19b66:	e7b5      	b.n	19ad4 <Sd::GetCrc16(unsigned char*, unsigned short)+0x40>
    }

    return static_cast<uint16_t>(crc ^ final_value);
   19b68:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
   19b6c:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   19b70:	4053      	eors	r3, r2
   19b72:	b29c      	uxth	r4, r3
   19b74:	463b      	mov	r3, r7
   19b76:	4619      	mov	r1, r3
   19b78:	4803      	ldr	r0, [pc, #12]	; (19b88 <Sd::GetCrc16(unsigned char*, unsigned short)+0xf4>)
   19b7a:	f7fc fecf 	bl	1691c <__cyg_profile_func_exit>
   19b7e:	4623      	mov	r3, r4
  }
   19b80:	4618      	mov	r0, r3
   19b82:	b00c      	add	sp, #48	; 0x30
   19b84:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
   19b88:	00019a95 	.word	0x00019a95
   19b8c:	0001f120 	.word	0x0001f120

00019b90 <disk_status>:
bool initialized = false;
}  // namespace

/// @param drive_number - Physical drive number to identify the drive
extern "C" DSTATUS disk_status([[maybe_unused]] BYTE drive_number)
{
   19b90:	b530      	push	{r4, r5, lr}
   19b92:	b089      	sub	sp, #36	; 0x24
   19b94:	4675      	mov	r5, lr
   19b96:	4603      	mov	r3, r0
   19b98:	f88d 3007 	strb.w	r3, [sp, #7]
   19b9c:	462b      	mov	r3, r5
   19b9e:	4619      	mov	r1, r3
   19ba0:	481c      	ldr	r0, [pc, #112]	; (19c14 <disk_status+0x84>)
   19ba2:	f7fc fea7 	bl	168f4 <__cyg_profile_func_enter>
  LOG_DEBUG("Getting Disk Status!");
  DSTATUS result = STA_NODISK;
   19ba6:	2302      	movs	r3, #2
   19ba8:	f88d 301f 	strb.w	r3, [sp, #31]
  Gpio card_detect(1, 9);
   19bac:	ab02      	add	r3, sp, #8
   19bae:	2209      	movs	r2, #9
   19bb0:	2101      	movs	r1, #1
   19bb2:	4618      	mov	r0, r3
   19bb4:	f7f8 fc8e 	bl	124d4 <Gpio::Gpio(unsigned char, unsigned char)>
  card_detect.SetAsInput();
   19bb8:	ab02      	add	r3, sp, #8
   19bba:	4618      	mov	r0, r3
   19bbc:	f7f8 fcc8 	bl	12550 <Gpio::SetAsInput()>
  card_detect.GetPin().SetMode(Pin::Mode::kPullUp);
   19bc0:	ab02      	add	r3, sp, #8
   19bc2:	4618      	mov	r0, r3
   19bc4:	f7f8 fe0c 	bl	127e0 <Gpio::GetPin()>
   19bc8:	4602      	mov	r2, r0
   19bca:	6813      	ldr	r3, [r2, #0]
   19bcc:	3304      	adds	r3, #4
   19bce:	681b      	ldr	r3, [r3, #0]
   19bd0:	2102      	movs	r1, #2
   19bd2:	4610      	mov	r0, r2
   19bd4:	4798      	blx	r3
  // Card detect is active low
  if (!card_detect.Read())
   19bd6:	ab02      	add	r3, sp, #8
   19bd8:	4618      	mov	r0, r3
   19bda:	f7f8 fdc9 	bl	12770 <Gpio::Read()>
   19bde:	4603      	mov	r3, r0
   19be0:	f083 0301 	eor.w	r3, r3, #1
   19be4:	b2db      	uxtb	r3, r3
   19be6:	2b00      	cmp	r3, #0
   19be8:	d008      	beq.n	19bfc <disk_status+0x6c>
  {
    LOG_DEBUG("Card IS present!");
    result = (initialized) ? 0 : STA_NOINIT;
   19bea:	4b0b      	ldr	r3, [pc, #44]	; (19c18 <disk_status+0x88>)
   19bec:	781b      	ldrb	r3, [r3, #0]
   19bee:	2b00      	cmp	r3, #0
   19bf0:	d001      	beq.n	19bf6 <disk_status+0x66>
   19bf2:	2300      	movs	r3, #0
   19bf4:	e000      	b.n	19bf8 <disk_status+0x68>
   19bf6:	2301      	movs	r3, #1
   19bf8:	f88d 301f 	strb.w	r3, [sp, #31]
  }
  else
  {
    LOG_DEBUG("Card is NOT present!");
  }
  return result;
   19bfc:	f89d 401f 	ldrb.w	r4, [sp, #31]
   19c00:	462b      	mov	r3, r5
   19c02:	4619      	mov	r1, r3
   19c04:	4803      	ldr	r0, [pc, #12]	; (19c14 <disk_status+0x84>)
   19c06:	f7fc fe89 	bl	1691c <__cyg_profile_func_exit>
   19c0a:	4623      	mov	r3, r4
}
   19c0c:	4618      	mov	r0, r3
   19c0e:	b009      	add	sp, #36	; 0x24
   19c10:	bd30      	pop	{r4, r5, pc}
   19c12:	bf00      	nop
   19c14:	00019b91 	.word	0x00019b91
   19c18:	100033ec 	.word	0x100033ec

00019c1c <disk_initialize>:

extern "C" DSTATUS disk_initialize([[maybe_unused]] BYTE drive_number)
{
   19c1c:	b530      	push	{r4, r5, lr}
   19c1e:	b08b      	sub	sp, #44	; 0x2c
   19c20:	4675      	mov	r5, lr
   19c22:	4603      	mov	r3, r0
   19c24:	f88d 3007 	strb.w	r3, [sp, #7]
   19c28:	462b      	mov	r3, r5
   19c2a:	4619      	mov	r1, r3
   19c2c:	4812      	ldr	r0, [pc, #72]	; (19c78 <disk_initialize+0x5c>)
   19c2e:	f7fc fe61 	bl	168f4 <__cyg_profile_func_enter>
  LOG_DEBUG("DISK INIT!");
  sd_card.Initialize();
   19c32:	4812      	ldr	r0, [pc, #72]	; (19c7c <disk_initialize+0x60>)
   19c34:	f7fe feae 	bl	18994 <Sd::Initialize()>
  Sd::CardInfo_t card_info;
  DSTATUS status = sd_card.Mount(&card_info) ? 0 : STA_NOINIT;
   19c38:	ab02      	add	r3, sp, #8
   19c3a:	4619      	mov	r1, r3
   19c3c:	480f      	ldr	r0, [pc, #60]	; (19c7c <disk_initialize+0x60>)
   19c3e:	f7fe ff01 	bl	18a44 <Sd::Mount(SdInterface::CardInfo_t*)>
   19c42:	4603      	mov	r3, r0
   19c44:	2b00      	cmp	r3, #0
   19c46:	d001      	beq.n	19c4c <disk_initialize+0x30>
   19c48:	2300      	movs	r3, #0
   19c4a:	e000      	b.n	19c4e <disk_initialize+0x32>
   19c4c:	2301      	movs	r3, #1
   19c4e:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
  if (status == 0)
   19c52:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   19c56:	2b00      	cmp	r3, #0
   19c58:	d102      	bne.n	19c60 <disk_initialize+0x44>
  {
    initialized = true;
   19c5a:	4b09      	ldr	r3, [pc, #36]	; (19c80 <disk_initialize+0x64>)
   19c5c:	2201      	movs	r2, #1
   19c5e:	701a      	strb	r2, [r3, #0]
  }
  return status;
   19c60:	f89d 4027 	ldrb.w	r4, [sp, #39]	; 0x27
   19c64:	462b      	mov	r3, r5
   19c66:	4619      	mov	r1, r3
   19c68:	4803      	ldr	r0, [pc, #12]	; (19c78 <disk_initialize+0x5c>)
   19c6a:	f7fc fe57 	bl	1691c <__cyg_profile_func_exit>
   19c6e:	4623      	mov	r3, r4
}
   19c70:	4618      	mov	r0, r3
   19c72:	b00b      	add	sp, #44	; 0x2c
   19c74:	bd30      	pop	{r4, r5, pc}
   19c76:	bf00      	nop
   19c78:	00019c1d 	.word	0x00019c1d
   19c7c:	10003384 	.word	0x10003384
   19c80:	100033ec 	.word	0x100033ec

00019c84 <disk_read>:

extern "C" DRESULT disk_read([[maybe_unused]] BYTE drive_number, BYTE * buffer,
                             DWORD sector, UINT count)
{
   19c84:	b530      	push	{r4, r5, lr}
   19c86:	b085      	sub	sp, #20
   19c88:	4675      	mov	r5, lr
   19c8a:	9102      	str	r1, [sp, #8]
   19c8c:	9201      	str	r2, [sp, #4]
   19c8e:	9300      	str	r3, [sp, #0]
   19c90:	4603      	mov	r3, r0
   19c92:	f88d 300f 	strb.w	r3, [sp, #15]
   19c96:	462b      	mov	r3, r5
   19c98:	4619      	mov	r1, r3
   19c9a:	4809      	ldr	r0, [pc, #36]	; (19cc0 <disk_read+0x3c>)
   19c9c:	f7fc fe2a 	bl	168f4 <__cyg_profile_func_enter>
  LOG_DEBUG("drive_number: %u :: sector: %ld :: count: %u", drive_number,
            sector, count);

  sd_card.ReadBlock(sector, buffer, static_cast<uint32_t>(count));
   19ca0:	9b00      	ldr	r3, [sp, #0]
   19ca2:	9a02      	ldr	r2, [sp, #8]
   19ca4:	9901      	ldr	r1, [sp, #4]
   19ca6:	4807      	ldr	r0, [pc, #28]	; (19cc4 <disk_read+0x40>)
   19ca8:	f7ff f8d6 	bl	18e58 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)>
  return RES_OK;
   19cac:	2400      	movs	r4, #0
   19cae:	462b      	mov	r3, r5
   19cb0:	4619      	mov	r1, r3
   19cb2:	4803      	ldr	r0, [pc, #12]	; (19cc0 <disk_read+0x3c>)
   19cb4:	f7fc fe32 	bl	1691c <__cyg_profile_func_exit>
   19cb8:	4623      	mov	r3, r4
}
   19cba:	4618      	mov	r0, r3
   19cbc:	b005      	add	sp, #20
   19cbe:	bd30      	pop	{r4, r5, pc}
   19cc0:	00019c85 	.word	0x00019c85
   19cc4:	10003384 	.word	0x10003384

00019cc8 <disk_write>:

#if FF_FS_READONLY == 0

extern "C" DRESULT disk_write([[maybe_unused]] BYTE drive_number,
                              const BYTE * buffer, DWORD sector, UINT count)
{
   19cc8:	b530      	push	{r4, r5, lr}
   19cca:	b085      	sub	sp, #20
   19ccc:	4675      	mov	r5, lr
   19cce:	9102      	str	r1, [sp, #8]
   19cd0:	9201      	str	r2, [sp, #4]
   19cd2:	9300      	str	r3, [sp, #0]
   19cd4:	4603      	mov	r3, r0
   19cd6:	f88d 300f 	strb.w	r3, [sp, #15]
   19cda:	462b      	mov	r3, r5
   19cdc:	4619      	mov	r1, r3
   19cde:	4809      	ldr	r0, [pc, #36]	; (19d04 <disk_write+0x3c>)
   19ce0:	f7fc fe08 	bl	168f4 <__cyg_profile_func_enter>
  LOG_DEBUG("drive_number: %u :: sector: %ld :: count: %u", drive_number,
            sector, count);
  sd_card.WriteBlock(sector, buffer, static_cast<uint32_t>(count));
   19ce4:	9b00      	ldr	r3, [sp, #0]
   19ce6:	9a02      	ldr	r2, [sp, #8]
   19ce8:	9901      	ldr	r1, [sp, #4]
   19cea:	4807      	ldr	r0, [pc, #28]	; (19d08 <disk_write+0x40>)
   19cec:	f7ff fac0 	bl	19270 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)>
  return RES_OK;
   19cf0:	2400      	movs	r4, #0
   19cf2:	462b      	mov	r3, r5
   19cf4:	4619      	mov	r1, r3
   19cf6:	4803      	ldr	r0, [pc, #12]	; (19d04 <disk_write+0x3c>)
   19cf8:	f7fc fe10 	bl	1691c <__cyg_profile_func_exit>
   19cfc:	4623      	mov	r3, r4
}
   19cfe:	4618      	mov	r0, r3
   19d00:	b005      	add	sp, #20
   19d02:	bd30      	pop	{r4, r5, pc}
   19d04:	00019cc9 	.word	0x00019cc9
   19d08:	10003384 	.word	0x10003384

00019d0c <disk_ioctl>:
#endif

extern "C" DRESULT disk_ioctl([[maybe_unused]] BYTE drive_number,
                              [[maybe_unused]] BYTE command,
                              [[maybe_unused]] void * buffer)
{
   19d0c:	b530      	push	{r4, r5, lr}
   19d0e:	b083      	sub	sp, #12
   19d10:	4675      	mov	r5, lr
   19d12:	4603      	mov	r3, r0
   19d14:	9200      	str	r2, [sp, #0]
   19d16:	f88d 3007 	strb.w	r3, [sp, #7]
   19d1a:	460b      	mov	r3, r1
   19d1c:	f88d 3006 	strb.w	r3, [sp, #6]
   19d20:	462b      	mov	r3, r5
   19d22:	4619      	mov	r1, r3
   19d24:	4806      	ldr	r0, [pc, #24]	; (19d40 <disk_ioctl+0x34>)
   19d26:	f7fc fde5 	bl	168f4 <__cyg_profile_func_enter>
  return RES_PARERR;
   19d2a:	2404      	movs	r4, #4
   19d2c:	462b      	mov	r3, r5
   19d2e:	4619      	mov	r1, r3
   19d30:	4803      	ldr	r0, [pc, #12]	; (19d40 <disk_ioctl+0x34>)
   19d32:	f7fc fdf3 	bl	1691c <__cyg_profile_func_exit>
   19d36:	4623      	mov	r3, r4
}
   19d38:	4618      	mov	r0, r3
   19d3a:	b003      	add	sp, #12
   19d3c:	bd30      	pop	{r4, r5, pc}
   19d3e:	bf00      	nop
   19d40:	00019d0d 	.word	0x00019d0d

00019d44 <__static_initialization_and_destruction_0(int, int)>:
   19d44:	b530      	push	{r4, r5, lr}
   19d46:	b085      	sub	sp, #20
   19d48:	4674      	mov	r4, lr
   19d4a:	9003      	str	r0, [sp, #12]
   19d4c:	9102      	str	r1, [sp, #8]
   19d4e:	4623      	mov	r3, r4
   19d50:	4619      	mov	r1, r3
   19d52:	480e      	ldr	r0, [pc, #56]	; (19d8c <__static_initialization_and_destruction_0(int, int)+0x48>)
   19d54:	f7fc fdce 	bl	168f4 <__cyg_profile_func_enter>
   19d58:	9b03      	ldr	r3, [sp, #12]
   19d5a:	2b01      	cmp	r3, #1
   19d5c:	d10e      	bne.n	19d7c <__static_initialization_and_destruction_0(int, int)+0x38>
   19d5e:	9b02      	ldr	r3, [sp, #8]
   19d60:	f64f 72ff 	movw	r2, #65535	; 0xffff
   19d64:	4293      	cmp	r3, r2
   19d66:	d109      	bne.n	19d7c <__static_initialization_and_destruction_0(int, int)+0x38>
Sd sd_card(Sd::DebugSdCard_t{});
   19d68:	2306      	movs	r3, #6
   19d6a:	9301      	str	r3, [sp, #4]
   19d6c:	2300      	movs	r3, #0
   19d6e:	9300      	str	r3, [sp, #0]
   19d70:	2308      	movs	r3, #8
   19d72:	2201      	movs	r2, #1
   19d74:	4629      	mov	r1, r5
   19d76:	4806      	ldr	r0, [pc, #24]	; (19d90 <__static_initialization_and_destruction_0(int, int)+0x4c>)
   19d78:	f7fe fdbc 	bl	188f4 <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)>
   19d7c:	4623      	mov	r3, r4
   19d7e:	4619      	mov	r1, r3
   19d80:	4802      	ldr	r0, [pc, #8]	; (19d8c <__static_initialization_and_destruction_0(int, int)+0x48>)
   19d82:	f7fc fdcb 	bl	1691c <__cyg_profile_func_exit>
}
   19d86:	bf00      	nop
   19d88:	b005      	add	sp, #20
   19d8a:	bd30      	pop	{r4, r5, pc}
   19d8c:	00019d45 	.word	0x00019d45
   19d90:	10003384 	.word	0x10003384

00019d94 <_GLOBAL__sub_I_disk_status>:
   19d94:	b510      	push	{r4, lr}
   19d96:	4674      	mov	r4, lr
   19d98:	4623      	mov	r3, r4
   19d9a:	4619      	mov	r1, r3
   19d9c:	4806      	ldr	r0, [pc, #24]	; (19db8 <_GLOBAL__sub_I_disk_status+0x24>)
   19d9e:	f7fc fda9 	bl	168f4 <__cyg_profile_func_enter>
   19da2:	f64f 71ff 	movw	r1, #65535	; 0xffff
   19da6:	2001      	movs	r0, #1
   19da8:	f7ff ffcc 	bl	19d44 <__static_initialization_and_destruction_0(int, int)>
   19dac:	4623      	mov	r3, r4
   19dae:	4619      	mov	r1, r3
   19db0:	4801      	ldr	r0, [pc, #4]	; (19db8 <_GLOBAL__sub_I_disk_status+0x24>)
   19db2:	f7fc fdb3 	bl	1691c <__cyg_profile_func_exit>
   19db6:	bd10      	pop	{r4, pc}
   19db8:	00019d95 	.word	0x00019d95

00019dbc <ld_word>:
/*-----------------------------------------------------------------------*/

static WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
{
	WORD rv;

   19dbc:	b530      	push	{r4, r5, lr}
   19dbe:	b085      	sub	sp, #20
   19dc0:	4675      	mov	r5, lr
   19dc2:	9001      	str	r0, [sp, #4]
   19dc4:	462b      	mov	r3, r5
   19dc6:	4619      	mov	r1, r3
   19dc8:	480e      	ldr	r0, [pc, #56]	; (19e04 <ld_word+0x48>)
   19dca:	f7fc fd93 	bl	168f4 <__cyg_profile_func_enter>
	rv = ptr[1];
	rv = rv << 8 | ptr[0];
	return rv;
   19dce:	9b01      	ldr	r3, [sp, #4]
   19dd0:	3301      	adds	r3, #1
   19dd2:	781b      	ldrb	r3, [r3, #0]
   19dd4:	f8ad 300e 	strh.w	r3, [sp, #14]
}
   19dd8:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   19ddc:	021b      	lsls	r3, r3, #8
   19dde:	b21a      	sxth	r2, r3
   19de0:	9b01      	ldr	r3, [sp, #4]
   19de2:	781b      	ldrb	r3, [r3, #0]
   19de4:	b21b      	sxth	r3, r3
   19de6:	4313      	orrs	r3, r2
   19de8:	b21b      	sxth	r3, r3
   19dea:	f8ad 300e 	strh.w	r3, [sp, #14]

   19dee:	f8bd 400e 	ldrh.w	r4, [sp, #14]
   19df2:	462b      	mov	r3, r5
   19df4:	4619      	mov	r1, r3
   19df6:	4803      	ldr	r0, [pc, #12]	; (19e04 <ld_word+0x48>)
   19df8:	f7fc fd90 	bl	1691c <__cyg_profile_func_exit>
   19dfc:	4623      	mov	r3, r4
static DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
   19dfe:	4618      	mov	r0, r3
   19e00:	b005      	add	sp, #20
   19e02:	bd30      	pop	{r4, r5, pc}
   19e04:	00019dbd 	.word	0x00019dbd

00019e08 <ld_dword>:
{
	DWORD rv;

   19e08:	b530      	push	{r4, r5, lr}
   19e0a:	b085      	sub	sp, #20
   19e0c:	4675      	mov	r5, lr
   19e0e:	9001      	str	r0, [sp, #4]
   19e10:	462b      	mov	r3, r5
   19e12:	4619      	mov	r1, r3
   19e14:	4812      	ldr	r0, [pc, #72]	; (19e60 <ld_dword+0x58>)
   19e16:	f7fc fd6d 	bl	168f4 <__cyg_profile_func_enter>
	rv = ptr[3];
	rv = rv << 8 | ptr[2];
	rv = rv << 8 | ptr[1];
   19e1a:	9b01      	ldr	r3, [sp, #4]
   19e1c:	3303      	adds	r3, #3
   19e1e:	781b      	ldrb	r3, [r3, #0]
   19e20:	9303      	str	r3, [sp, #12]
	rv = rv << 8 | ptr[0];
   19e22:	9b03      	ldr	r3, [sp, #12]
   19e24:	021b      	lsls	r3, r3, #8
   19e26:	9a01      	ldr	r2, [sp, #4]
   19e28:	3202      	adds	r2, #2
   19e2a:	7812      	ldrb	r2, [r2, #0]
   19e2c:	4313      	orrs	r3, r2
   19e2e:	9303      	str	r3, [sp, #12]
	return rv;
   19e30:	9b03      	ldr	r3, [sp, #12]
   19e32:	021b      	lsls	r3, r3, #8
   19e34:	9a01      	ldr	r2, [sp, #4]
   19e36:	3201      	adds	r2, #1
   19e38:	7812      	ldrb	r2, [r2, #0]
   19e3a:	4313      	orrs	r3, r2
   19e3c:	9303      	str	r3, [sp, #12]
}
   19e3e:	9b03      	ldr	r3, [sp, #12]
   19e40:	021b      	lsls	r3, r3, #8
   19e42:	9a01      	ldr	r2, [sp, #4]
   19e44:	7812      	ldrb	r2, [r2, #0]
   19e46:	4313      	orrs	r3, r2
   19e48:	9303      	str	r3, [sp, #12]

   19e4a:	9c03      	ldr	r4, [sp, #12]
   19e4c:	462b      	mov	r3, r5
   19e4e:	4619      	mov	r1, r3
   19e50:	4803      	ldr	r0, [pc, #12]	; (19e60 <ld_dword+0x58>)
   19e52:	f7fc fd63 	bl	1691c <__cyg_profile_func_exit>
   19e56:	4623      	mov	r3, r4
#if FF_FS_EXFAT
   19e58:	4618      	mov	r0, r3
   19e5a:	b005      	add	sp, #20
   19e5c:	bd30      	pop	{r4, r5, pc}
   19e5e:	bf00      	nop
   19e60:	00019e09 	.word	0x00019e09

00019e64 <st_word>:

#if !FF_FS_READONLY
static void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
{
	*ptr++ = (BYTE)val; val >>= 8;
	*ptr++ = (BYTE)val;
   19e64:	b510      	push	{r4, lr}
   19e66:	b082      	sub	sp, #8
   19e68:	4674      	mov	r4, lr
   19e6a:	9001      	str	r0, [sp, #4]
   19e6c:	460b      	mov	r3, r1
   19e6e:	f8ad 3002 	strh.w	r3, [sp, #2]
   19e72:	4623      	mov	r3, r4
   19e74:	4619      	mov	r1, r3
   19e76:	480f      	ldr	r0, [pc, #60]	; (19eb4 <st_word+0x50>)
   19e78:	f7fc fd3c 	bl	168f4 <__cyg_profile_func_enter>
}
   19e7c:	9b01      	ldr	r3, [sp, #4]
   19e7e:	1c5a      	adds	r2, r3, #1
   19e80:	9201      	str	r2, [sp, #4]
   19e82:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   19e86:	b2d2      	uxtb	r2, r2
   19e88:	701a      	strb	r2, [r3, #0]
   19e8a:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   19e8e:	0a1b      	lsrs	r3, r3, #8
   19e90:	f8ad 3002 	strh.w	r3, [sp, #2]

   19e94:	9b01      	ldr	r3, [sp, #4]
   19e96:	1c5a      	adds	r2, r3, #1
   19e98:	9201      	str	r2, [sp, #4]
   19e9a:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   19e9e:	b2d2      	uxtb	r2, r2
   19ea0:	701a      	strb	r2, [r3, #0]
   19ea2:	4623      	mov	r3, r4
   19ea4:	4619      	mov	r1, r3
   19ea6:	4803      	ldr	r0, [pc, #12]	; (19eb4 <st_word+0x50>)
   19ea8:	f7fc fd38 	bl	1691c <__cyg_profile_func_exit>
static void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
   19eac:	bf00      	nop
   19eae:	b002      	add	sp, #8
   19eb0:	bd10      	pop	{r4, pc}
   19eb2:	bf00      	nop
   19eb4:	00019e65 	.word	0x00019e65

00019eb8 <st_dword>:
{
	*ptr++ = (BYTE)val; val >>= 8;
	*ptr++ = (BYTE)val; val >>= 8;
   19eb8:	b510      	push	{r4, lr}
   19eba:	b082      	sub	sp, #8
   19ebc:	4674      	mov	r4, lr
   19ebe:	9001      	str	r0, [sp, #4]
   19ec0:	9100      	str	r1, [sp, #0]
   19ec2:	4623      	mov	r3, r4
   19ec4:	4619      	mov	r1, r3
   19ec6:	4816      	ldr	r0, [pc, #88]	; (19f20 <st_dword+0x68>)
   19ec8:	f7fc fd14 	bl	168f4 <__cyg_profile_func_enter>
	*ptr++ = (BYTE)val; val >>= 8;
   19ecc:	9b01      	ldr	r3, [sp, #4]
   19ece:	1c5a      	adds	r2, r3, #1
   19ed0:	9201      	str	r2, [sp, #4]
   19ed2:	9a00      	ldr	r2, [sp, #0]
   19ed4:	b2d2      	uxtb	r2, r2
   19ed6:	701a      	strb	r2, [r3, #0]
   19ed8:	9b00      	ldr	r3, [sp, #0]
   19eda:	0a1b      	lsrs	r3, r3, #8
   19edc:	9300      	str	r3, [sp, #0]
	*ptr++ = (BYTE)val;
   19ede:	9b01      	ldr	r3, [sp, #4]
   19ee0:	1c5a      	adds	r2, r3, #1
   19ee2:	9201      	str	r2, [sp, #4]
   19ee4:	9a00      	ldr	r2, [sp, #0]
   19ee6:	b2d2      	uxtb	r2, r2
   19ee8:	701a      	strb	r2, [r3, #0]
   19eea:	9b00      	ldr	r3, [sp, #0]
   19eec:	0a1b      	lsrs	r3, r3, #8
   19eee:	9300      	str	r3, [sp, #0]
}
   19ef0:	9b01      	ldr	r3, [sp, #4]
   19ef2:	1c5a      	adds	r2, r3, #1
   19ef4:	9201      	str	r2, [sp, #4]
   19ef6:	9a00      	ldr	r2, [sp, #0]
   19ef8:	b2d2      	uxtb	r2, r2
   19efa:	701a      	strb	r2, [r3, #0]
   19efc:	9b00      	ldr	r3, [sp, #0]
   19efe:	0a1b      	lsrs	r3, r3, #8
   19f00:	9300      	str	r3, [sp, #0]

   19f02:	9b01      	ldr	r3, [sp, #4]
   19f04:	1c5a      	adds	r2, r3, #1
   19f06:	9201      	str	r2, [sp, #4]
   19f08:	9a00      	ldr	r2, [sp, #0]
   19f0a:	b2d2      	uxtb	r2, r2
   19f0c:	701a      	strb	r2, [r3, #0]
   19f0e:	4623      	mov	r3, r4
   19f10:	4619      	mov	r1, r3
   19f12:	4803      	ldr	r0, [pc, #12]	; (19f20 <st_dword+0x68>)
   19f14:	f7fc fd02 	bl	1691c <__cyg_profile_func_exit>
#if FF_FS_EXFAT
   19f18:	bf00      	nop
   19f1a:	b002      	add	sp, #8
   19f1c:	bd10      	pop	{r4, pc}
   19f1e:	bf00      	nop
   19f20:	00019eb9 	.word	0x00019eb9

00019f24 <mem_cpy>:

/* Copy memory to memory */
static void mem_cpy (void* dst, const void* src, UINT cnt)
{
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;
   19f24:	b510      	push	{r4, lr}
   19f26:	b086      	sub	sp, #24
   19f28:	4674      	mov	r4, lr
   19f2a:	9003      	str	r0, [sp, #12]
   19f2c:	9102      	str	r1, [sp, #8]
   19f2e:	9201      	str	r2, [sp, #4]
   19f30:	4623      	mov	r3, r4
   19f32:	4619      	mov	r1, r3
   19f34:	480f      	ldr	r0, [pc, #60]	; (19f74 <mem_cpy+0x50>)
   19f36:	f7fc fcdd 	bl	168f4 <__cyg_profile_func_enter>

   19f3a:	9b03      	ldr	r3, [sp, #12]
   19f3c:	9305      	str	r3, [sp, #20]
	if (cnt != 0) {
   19f3e:	9b02      	ldr	r3, [sp, #8]
   19f40:	9304      	str	r3, [sp, #16]
		do {
			*d++ = *s++;
   19f42:	9b01      	ldr	r3, [sp, #4]
   19f44:	2b00      	cmp	r3, #0
   19f46:	d00d      	beq.n	19f64 <mem_cpy+0x40>
		} while (--cnt);
	}
   19f48:	9a04      	ldr	r2, [sp, #16]
   19f4a:	1c53      	adds	r3, r2, #1
   19f4c:	9304      	str	r3, [sp, #16]
   19f4e:	9b05      	ldr	r3, [sp, #20]
   19f50:	1c59      	adds	r1, r3, #1
   19f52:	9105      	str	r1, [sp, #20]
   19f54:	7812      	ldrb	r2, [r2, #0]
   19f56:	701a      	strb	r2, [r3, #0]
}
   19f58:	9b01      	ldr	r3, [sp, #4]
   19f5a:	3b01      	subs	r3, #1
   19f5c:	9301      	str	r3, [sp, #4]
   19f5e:	9b01      	ldr	r3, [sp, #4]
   19f60:	2b00      	cmp	r3, #0
   19f62:	d1f1      	bne.n	19f48 <mem_cpy+0x24>
   19f64:	4623      	mov	r3, r4
   19f66:	4619      	mov	r1, r3
   19f68:	4802      	ldr	r0, [pc, #8]	; (19f74 <mem_cpy+0x50>)
   19f6a:	f7fc fcd7 	bl	1691c <__cyg_profile_func_exit>


   19f6e:	bf00      	nop
   19f70:	b006      	add	sp, #24
   19f72:	bd10      	pop	{r4, pc}
   19f74:	00019f25 	.word	0x00019f25

00019f78 <mem_set>:
/* Fill memory block */
static void mem_set (void* dst, int val, UINT cnt)
{
	BYTE *d = (BYTE*)dst;

   19f78:	b510      	push	{r4, lr}
   19f7a:	b086      	sub	sp, #24
   19f7c:	4674      	mov	r4, lr
   19f7e:	9003      	str	r0, [sp, #12]
   19f80:	9102      	str	r1, [sp, #8]
   19f82:	9201      	str	r2, [sp, #4]
   19f84:	4623      	mov	r3, r4
   19f86:	4619      	mov	r1, r3
   19f88:	480c      	ldr	r0, [pc, #48]	; (19fbc <mem_set+0x44>)
   19f8a:	f7fc fcb3 	bl	168f4 <__cyg_profile_func_enter>
	do {
   19f8e:	9b03      	ldr	r3, [sp, #12]
   19f90:	9305      	str	r3, [sp, #20]
		*d++ = (BYTE)val;
	} while (--cnt);
}
   19f92:	9b05      	ldr	r3, [sp, #20]
   19f94:	1c5a      	adds	r2, r3, #1
   19f96:	9205      	str	r2, [sp, #20]
   19f98:	9a02      	ldr	r2, [sp, #8]
   19f9a:	b2d2      	uxtb	r2, r2
   19f9c:	701a      	strb	r2, [r3, #0]

   19f9e:	9b01      	ldr	r3, [sp, #4]
   19fa0:	3b01      	subs	r3, #1
   19fa2:	9301      	str	r3, [sp, #4]
   19fa4:	9b01      	ldr	r3, [sp, #4]
   19fa6:	2b00      	cmp	r3, #0
   19fa8:	d1f3      	bne.n	19f92 <mem_set+0x1a>
   19faa:	4623      	mov	r3, r4
   19fac:	4619      	mov	r1, r3
   19fae:	4803      	ldr	r0, [pc, #12]	; (19fbc <mem_set+0x44>)
   19fb0:	f7fc fcb4 	bl	1691c <__cyg_profile_func_exit>

   19fb4:	bf00      	nop
   19fb6:	b006      	add	sp, #24
   19fb8:	bd10      	pop	{r4, pc}
   19fba:	bf00      	nop
   19fbc:	00019f79 	.word	0x00019f79

00019fc0 <mem_cmp>:
/* Compare memory block */
static int mem_cmp (const void* dst, const void* src, UINT cnt)	/* ZR:same, NZ:different */
{
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;
   19fc0:	b530      	push	{r4, r5, lr}
   19fc2:	b089      	sub	sp, #36	; 0x24
   19fc4:	4675      	mov	r5, lr
   19fc6:	9003      	str	r0, [sp, #12]
   19fc8:	9102      	str	r1, [sp, #8]
   19fca:	9201      	str	r2, [sp, #4]
   19fcc:	462b      	mov	r3, r5
   19fce:	4619      	mov	r1, r3
   19fd0:	4813      	ldr	r0, [pc, #76]	; (1a020 <mem_cmp+0x60>)
   19fd2:	f7fc fc8f 	bl	168f4 <__cyg_profile_func_enter>

   19fd6:	9b03      	ldr	r3, [sp, #12]
   19fd8:	9307      	str	r3, [sp, #28]
   19fda:	9b02      	ldr	r3, [sp, #8]
   19fdc:	9306      	str	r3, [sp, #24]
	do {
   19fde:	2300      	movs	r3, #0
   19fe0:	9305      	str	r3, [sp, #20]
		r = *d++ - *s++;
	} while (--cnt && r == 0);

   19fe2:	9b07      	ldr	r3, [sp, #28]
   19fe4:	1c5a      	adds	r2, r3, #1
   19fe6:	9207      	str	r2, [sp, #28]
   19fe8:	781b      	ldrb	r3, [r3, #0]
   19fea:	4619      	mov	r1, r3
   19fec:	9b06      	ldr	r3, [sp, #24]
   19fee:	1c5a      	adds	r2, r3, #1
   19ff0:	9206      	str	r2, [sp, #24]
   19ff2:	781b      	ldrb	r3, [r3, #0]
   19ff4:	1acb      	subs	r3, r1, r3
   19ff6:	9305      	str	r3, [sp, #20]
	return r;
   19ff8:	9b01      	ldr	r3, [sp, #4]
   19ffa:	3b01      	subs	r3, #1
   19ffc:	9301      	str	r3, [sp, #4]
   19ffe:	9b01      	ldr	r3, [sp, #4]
   1a000:	2b00      	cmp	r3, #0
   1a002:	d002      	beq.n	1a00a <mem_cmp+0x4a>
   1a004:	9b05      	ldr	r3, [sp, #20]
   1a006:	2b00      	cmp	r3, #0
   1a008:	d0eb      	beq.n	19fe2 <mem_cmp+0x22>
}

   1a00a:	9c05      	ldr	r4, [sp, #20]
   1a00c:	462b      	mov	r3, r5
   1a00e:	4619      	mov	r1, r3
   1a010:	4803      	ldr	r0, [pc, #12]	; (1a020 <mem_cmp+0x60>)
   1a012:	f7fc fc83 	bl	1691c <__cyg_profile_func_exit>
   1a016:	4623      	mov	r3, r4

   1a018:	4618      	mov	r0, r3
   1a01a:	b009      	add	sp, #36	; 0x24
   1a01c:	bd30      	pop	{r4, r5, pc}
   1a01e:	bf00      	nop
   1a020:	00019fc1 	.word	0x00019fc1

0001a024 <chk_chr>:
/* Check if chr is contained in the string */
static int chk_chr (const char* str, int chr)	/* NZ:contained, ZR:not contained */
{
	while (*str && *str != chr) str++;
	return *str;
   1a024:	b530      	push	{r4, r5, lr}
   1a026:	b083      	sub	sp, #12
   1a028:	4674      	mov	r4, lr
   1a02a:	9001      	str	r0, [sp, #4]
   1a02c:	9100      	str	r1, [sp, #0]
   1a02e:	4623      	mov	r3, r4
   1a030:	4619      	mov	r1, r3
   1a032:	480e      	ldr	r0, [pc, #56]	; (1a06c <chk_chr+0x48>)
   1a034:	f7fc fc5e 	bl	168f4 <__cyg_profile_func_enter>
}
   1a038:	e002      	b.n	1a040 <chk_chr+0x1c>
   1a03a:	9b01      	ldr	r3, [sp, #4]
   1a03c:	3301      	adds	r3, #1
   1a03e:	9301      	str	r3, [sp, #4]
   1a040:	9b01      	ldr	r3, [sp, #4]
   1a042:	781b      	ldrb	r3, [r3, #0]
   1a044:	2b00      	cmp	r3, #0
   1a046:	d005      	beq.n	1a054 <chk_chr+0x30>
   1a048:	9b01      	ldr	r3, [sp, #4]
   1a04a:	781b      	ldrb	r3, [r3, #0]
   1a04c:	461a      	mov	r2, r3
   1a04e:	9b00      	ldr	r3, [sp, #0]
   1a050:	4293      	cmp	r3, r2
   1a052:	d1f2      	bne.n	1a03a <chk_chr+0x16>

   1a054:	9b01      	ldr	r3, [sp, #4]
   1a056:	781b      	ldrb	r3, [r3, #0]
   1a058:	461d      	mov	r5, r3
   1a05a:	4623      	mov	r3, r4
   1a05c:	4619      	mov	r1, r3
   1a05e:	4803      	ldr	r0, [pc, #12]	; (1a06c <chk_chr+0x48>)
   1a060:	f7fc fc5c 	bl	1691c <__cyg_profile_func_exit>
   1a064:	462b      	mov	r3, r5

   1a066:	4618      	mov	r0, r3
   1a068:	b003      	add	sp, #12
   1a06a:	bd30      	pop	{r4, r5, pc}
   1a06c:	0001a025 	.word	0x0001a025

0001a070 <dbc_1st>:
/* Test if the character is DBC 1st byte */
static int dbc_1st (BYTE c)
{
#if FF_CODE_PAGE == 0		/* Variable code page */
	if (DbcTbl && c >= DbcTbl[0]) {
   1a070:	b530      	push	{r4, r5, lr}
   1a072:	b083      	sub	sp, #12
   1a074:	4675      	mov	r5, lr
   1a076:	4603      	mov	r3, r0
   1a078:	f88d 3007 	strb.w	r3, [sp, #7]
   1a07c:	462b      	mov	r3, r5
   1a07e:	4619      	mov	r1, r3
   1a080:	4812      	ldr	r0, [pc, #72]	; (1a0cc <dbc_1st+0x5c>)
   1a082:	f7fc fc37 	bl	168f4 <__cyg_profile_func_enter>
		if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;	/* 1st byte range 2 */
	}
#elif FF_CODE_PAGE >= 900	/* DBCS fixed code page */
	if (c >= DbcTbl[0]) {
		if (c <= DbcTbl[1]) return 1;
		if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;
   1a086:	2281      	movs	r2, #129	; 0x81
   1a088:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1a08c:	4293      	cmp	r3, r2
   1a08e:	d312      	bcc.n	1a0b6 <dbc_1st+0x46>
	}
   1a090:	229f      	movs	r2, #159	; 0x9f
   1a092:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1a096:	4293      	cmp	r3, r2
   1a098:	d801      	bhi.n	1a09e <dbc_1st+0x2e>
   1a09a:	2401      	movs	r4, #1
   1a09c:	e00c      	b.n	1a0b8 <dbc_1st+0x48>
#else						/* SBCS fixed code page */
   1a09e:	22e0      	movs	r2, #224	; 0xe0
   1a0a0:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1a0a4:	4293      	cmp	r3, r2
   1a0a6:	d306      	bcc.n	1a0b6 <dbc_1st+0x46>
   1a0a8:	22fc      	movs	r2, #252	; 0xfc
   1a0aa:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1a0ae:	4293      	cmp	r3, r2
   1a0b0:	d801      	bhi.n	1a0b6 <dbc_1st+0x46>
   1a0b2:	2401      	movs	r4, #1
   1a0b4:	e000      	b.n	1a0b8 <dbc_1st+0x48>
	if (c != 0) return 0;	/* Always false */
#endif
	return 0;
}

   1a0b6:	2400      	movs	r4, #0
   1a0b8:	462b      	mov	r3, r5
   1a0ba:	4619      	mov	r1, r3
   1a0bc:	4803      	ldr	r0, [pc, #12]	; (1a0cc <dbc_1st+0x5c>)
   1a0be:	f7fc fc2d 	bl	1691c <__cyg_profile_func_exit>
   1a0c2:	4623      	mov	r3, r4

   1a0c4:	4618      	mov	r0, r3
   1a0c6:	b003      	add	sp, #12
   1a0c8:	bd30      	pop	{r4, r5, pc}
   1a0ca:	bf00      	nop
   1a0cc:	0001a071 	.word	0x0001a071

0001a0d0 <dbc_2nd>:
/* Test if the character is DBC 2nd byte */
static int dbc_2nd (BYTE c)
{
#if FF_CODE_PAGE == 0		/* Variable code page */
	if (DbcTbl && c >= DbcTbl[4]) {
   1a0d0:	b530      	push	{r4, r5, lr}
   1a0d2:	b083      	sub	sp, #12
   1a0d4:	4675      	mov	r5, lr
   1a0d6:	4603      	mov	r3, r0
   1a0d8:	f88d 3007 	strb.w	r3, [sp, #7]
   1a0dc:	462b      	mov	r3, r5
   1a0de:	4619      	mov	r1, r3
   1a0e0:	4818      	ldr	r0, [pc, #96]	; (1a144 <dbc_2nd+0x74>)
   1a0e2:	f7fc fc07 	bl	168f4 <__cyg_profile_func_enter>
		if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;	/* 2nd byte range 3 */
	}
#elif FF_CODE_PAGE >= 900	/* DBCS fixed code page */
	if (c >= DbcTbl[4]) {
		if (c <= DbcTbl[5]) return 1;
		if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;
   1a0e6:	2240      	movs	r2, #64	; 0x40
   1a0e8:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1a0ec:	4293      	cmp	r3, r2
   1a0ee:	d31e      	bcc.n	1a12e <dbc_2nd+0x5e>
		if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;
   1a0f0:	227e      	movs	r2, #126	; 0x7e
   1a0f2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1a0f6:	4293      	cmp	r3, r2
   1a0f8:	d801      	bhi.n	1a0fe <dbc_2nd+0x2e>
   1a0fa:	2401      	movs	r4, #1
   1a0fc:	e018      	b.n	1a130 <dbc_2nd+0x60>
	}
   1a0fe:	2280      	movs	r2, #128	; 0x80
   1a100:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1a104:	4293      	cmp	r3, r2
   1a106:	d306      	bcc.n	1a116 <dbc_2nd+0x46>
   1a108:	22fc      	movs	r2, #252	; 0xfc
   1a10a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1a10e:	4293      	cmp	r3, r2
   1a110:	d801      	bhi.n	1a116 <dbc_2nd+0x46>
   1a112:	2401      	movs	r4, #1
   1a114:	e00c      	b.n	1a130 <dbc_2nd+0x60>
#else						/* SBCS fixed code page */
   1a116:	2200      	movs	r2, #0
   1a118:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1a11c:	4293      	cmp	r3, r2
   1a11e:	d306      	bcc.n	1a12e <dbc_2nd+0x5e>
   1a120:	2200      	movs	r2, #0
   1a122:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1a126:	4293      	cmp	r3, r2
   1a128:	d801      	bhi.n	1a12e <dbc_2nd+0x5e>
   1a12a:	2401      	movs	r4, #1
   1a12c:	e000      	b.n	1a130 <dbc_2nd+0x60>
	if (c != 0) return 0;	/* Always false */
#endif
	return 0;
}

   1a12e:	2400      	movs	r4, #0
   1a130:	462b      	mov	r3, r5
   1a132:	4619      	mov	r1, r3
   1a134:	4803      	ldr	r0, [pc, #12]	; (1a144 <dbc_2nd+0x74>)
   1a136:	f7fc fbf1 	bl	1691c <__cyg_profile_func_exit>
   1a13a:	4623      	mov	r3, r4

   1a13c:	4618      	mov	r0, r3
   1a13e:	b003      	add	sp, #12
   1a140:	bd30      	pop	{r4, r5, pc}
   1a142:	bf00      	nop
   1a144:	0001a0d1 	.word	0x0001a0d1

0001a148 <sync_window>:
static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
	FATFS* fs			/* Filesystem object */
)
{
	FRESULT res = FR_OK;

   1a148:	b530      	push	{r4, r5, lr}
   1a14a:	b085      	sub	sp, #20
   1a14c:	4675      	mov	r5, lr
   1a14e:	9001      	str	r0, [sp, #4]
   1a150:	462b      	mov	r3, r5
   1a152:	4619      	mov	r1, r3
   1a154:	4821      	ldr	r0, [pc, #132]	; (1a1dc <sync_window+0x94>)
   1a156:	f7fc fbcd 	bl	168f4 <__cyg_profile_func_enter>

   1a15a:	2300      	movs	r3, #0
   1a15c:	f88d 300f 	strb.w	r3, [sp, #15]
	if (fs->wflag) {	/* Is the disk access window dirty */
		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write back the window */
			fs->wflag = 0;	/* Clear window dirty flag */
   1a160:	9b01      	ldr	r3, [sp, #4]
   1a162:	78db      	ldrb	r3, [r3, #3]
   1a164:	2b00      	cmp	r3, #0
   1a166:	d02d      	beq.n	1a1c4 <sync_window+0x7c>
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
   1a168:	9b01      	ldr	r3, [sp, #4]
   1a16a:	7858      	ldrb	r0, [r3, #1]
   1a16c:	9b01      	ldr	r3, [sp, #4]
   1a16e:	f103 0130 	add.w	r1, r3, #48	; 0x30
   1a172:	9b01      	ldr	r3, [sp, #4]
   1a174:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1a176:	2301      	movs	r3, #1
   1a178:	f7ff fda6 	bl	19cc8 <disk_write>
   1a17c:	4603      	mov	r3, r0
   1a17e:	2b00      	cmp	r3, #0
   1a180:	d11d      	bne.n	1a1be <sync_window+0x76>
				if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
   1a182:	9b01      	ldr	r3, [sp, #4]
   1a184:	2200      	movs	r2, #0
   1a186:	70da      	strb	r2, [r3, #3]
			}
   1a188:	9b01      	ldr	r3, [sp, #4]
   1a18a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1a18c:	9b01      	ldr	r3, [sp, #4]
   1a18e:	6a1b      	ldr	r3, [r3, #32]
   1a190:	1ad2      	subs	r2, r2, r3
   1a192:	9b01      	ldr	r3, [sp, #4]
   1a194:	699b      	ldr	r3, [r3, #24]
   1a196:	429a      	cmp	r2, r3
   1a198:	d214      	bcs.n	1a1c4 <sync_window+0x7c>
		} else {
   1a19a:	9b01      	ldr	r3, [sp, #4]
   1a19c:	789b      	ldrb	r3, [r3, #2]
   1a19e:	2b02      	cmp	r3, #2
   1a1a0:	d110      	bne.n	1a1c4 <sync_window+0x7c>
   1a1a2:	9b01      	ldr	r3, [sp, #4]
   1a1a4:	7858      	ldrb	r0, [r3, #1]
   1a1a6:	9b01      	ldr	r3, [sp, #4]
   1a1a8:	f103 0130 	add.w	r1, r3, #48	; 0x30
   1a1ac:	9b01      	ldr	r3, [sp, #4]
   1a1ae:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1a1b0:	9b01      	ldr	r3, [sp, #4]
   1a1b2:	699b      	ldr	r3, [r3, #24]
   1a1b4:	441a      	add	r2, r3
   1a1b6:	2301      	movs	r3, #1
   1a1b8:	f7ff fd86 	bl	19cc8 <disk_write>
   1a1bc:	e002      	b.n	1a1c4 <sync_window+0x7c>
			res = FR_DISK_ERR;
		}
	}
   1a1be:	2301      	movs	r3, #1
   1a1c0:	f88d 300f 	strb.w	r3, [sp, #15]
	return res;
}
#endif
   1a1c4:	f89d 400f 	ldrb.w	r4, [sp, #15]
   1a1c8:	462b      	mov	r3, r5
   1a1ca:	4619      	mov	r1, r3
   1a1cc:	4803      	ldr	r0, [pc, #12]	; (1a1dc <sync_window+0x94>)
   1a1ce:	f7fc fba5 	bl	1691c <__cyg_profile_func_exit>
   1a1d2:	4623      	mov	r3, r4

   1a1d4:	4618      	mov	r0, r3
   1a1d6:	b005      	add	sp, #20
   1a1d8:	bd30      	pop	{r4, r5, pc}
   1a1da:	bf00      	nop
   1a1dc:	0001a149 	.word	0x0001a149

0001a1e0 <move_window>:
	FATFS* fs,			/* Filesystem object */
	DWORD sector		/* Sector number to make appearance in the fs->win[] */
)
{
	FRESULT res = FR_OK;

   1a1e0:	b530      	push	{r4, r5, lr}
   1a1e2:	b085      	sub	sp, #20
   1a1e4:	4675      	mov	r5, lr
   1a1e6:	9001      	str	r0, [sp, #4]
   1a1e8:	9100      	str	r1, [sp, #0]
   1a1ea:	462b      	mov	r3, r5
   1a1ec:	4619      	mov	r1, r3
   1a1ee:	481a      	ldr	r0, [pc, #104]	; (1a258 <move_window+0x78>)
   1a1f0:	f7fc fb80 	bl	168f4 <__cyg_profile_func_enter>

   1a1f4:	2300      	movs	r3, #0
   1a1f6:	f88d 300f 	strb.w	r3, [sp, #15]
	if (sector != fs->winsect) {	/* Window offset changed? */
#if !FF_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
   1a1fa:	9b01      	ldr	r3, [sp, #4]
   1a1fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1a1fe:	9a00      	ldr	r2, [sp, #0]
   1a200:	429a      	cmp	r2, r3
   1a202:	d01e      	beq.n	1a242 <move_window+0x62>
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
   1a204:	9801      	ldr	r0, [sp, #4]
   1a206:	f7ff ff9f 	bl	1a148 <sync_window>
   1a20a:	4603      	mov	r3, r0
   1a20c:	f88d 300f 	strb.w	r3, [sp, #15]
			if (disk_read(fs->pdrv, fs->win, sector, 1) != RES_OK) {
				sector = 0xFFFFFFFF;	/* Invalidate window if read data is not valid */
   1a210:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1a214:	2b00      	cmp	r3, #0
   1a216:	d114      	bne.n	1a242 <move_window+0x62>
				res = FR_DISK_ERR;
   1a218:	9b01      	ldr	r3, [sp, #4]
   1a21a:	7858      	ldrb	r0, [r3, #1]
   1a21c:	9b01      	ldr	r3, [sp, #4]
   1a21e:	f103 0130 	add.w	r1, r3, #48	; 0x30
   1a222:	2301      	movs	r3, #1
   1a224:	9a00      	ldr	r2, [sp, #0]
   1a226:	f7ff fd2d 	bl	19c84 <disk_read>
   1a22a:	4603      	mov	r3, r0
   1a22c:	2b00      	cmp	r3, #0
   1a22e:	d005      	beq.n	1a23c <move_window+0x5c>
			}
   1a230:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1a234:	9300      	str	r3, [sp, #0]
			fs->winsect = sector;
   1a236:	2301      	movs	r3, #1
   1a238:	f88d 300f 	strb.w	r3, [sp, #15]
		}
	}
   1a23c:	9b01      	ldr	r3, [sp, #4]
   1a23e:	9a00      	ldr	r2, [sp, #0]
   1a240:	62da      	str	r2, [r3, #44]	; 0x2c
	return res;
}

   1a242:	f89d 400f 	ldrb.w	r4, [sp, #15]
   1a246:	462b      	mov	r3, r5
   1a248:	4619      	mov	r1, r3
   1a24a:	4803      	ldr	r0, [pc, #12]	; (1a258 <move_window+0x78>)
   1a24c:	f7fc fb66 	bl	1691c <__cyg_profile_func_exit>
   1a250:	4623      	mov	r3, r4

   1a252:	4618      	mov	r0, r3
   1a254:	b005      	add	sp, #20
   1a256:	bd30      	pop	{r4, r5, pc}
   1a258:	0001a1e1 	.word	0x0001a1e1

0001a25c <sync_fs>:
static FRESULT sync_fs (	/* Returns FR_OK or FR_DISK_ERR */
	FATFS* fs		/* Filesystem object */
)
{
	FRESULT res;

   1a25c:	b530      	push	{r4, r5, lr}
   1a25e:	b085      	sub	sp, #20
   1a260:	4675      	mov	r5, lr
   1a262:	9001      	str	r0, [sp, #4]
   1a264:	462b      	mov	r3, r5
   1a266:	4619      	mov	r1, r3
   1a268:	4838      	ldr	r0, [pc, #224]	; (1a34c <sync_fs+0xf0>)
   1a26a:	f7fc fb43 	bl	168f4 <__cyg_profile_func_enter>

	res = sync_window(fs);
	if (res == FR_OK) {
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {	/* FAT32: Update FSInfo sector if needed */
   1a26e:	9801      	ldr	r0, [sp, #4]
   1a270:	f7ff ff6a 	bl	1a148 <sync_window>
   1a274:	4603      	mov	r3, r0
   1a276:	f88d 300f 	strb.w	r3, [sp, #15]
			/* Create FSInfo structure */
   1a27a:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1a27e:	2b00      	cmp	r3, #0
   1a280:	d159      	bne.n	1a336 <sync_fs+0xda>
			mem_set(fs->win, 0, sizeof fs->win);
   1a282:	9b01      	ldr	r3, [sp, #4]
   1a284:	781b      	ldrb	r3, [r3, #0]
   1a286:	2b03      	cmp	r3, #3
   1a288:	d148      	bne.n	1a31c <sync_fs+0xc0>
   1a28a:	9b01      	ldr	r3, [sp, #4]
   1a28c:	791b      	ldrb	r3, [r3, #4]
   1a28e:	2b01      	cmp	r3, #1
   1a290:	d144      	bne.n	1a31c <sync_fs+0xc0>
			st_word(fs->win + BS_55AA, 0xAA55);
			st_dword(fs->win + FSI_LeadSig, 0x41615252);
   1a292:	9b01      	ldr	r3, [sp, #4]
   1a294:	3330      	adds	r3, #48	; 0x30
   1a296:	f44f 7200 	mov.w	r2, #512	; 0x200
   1a29a:	2100      	movs	r1, #0
   1a29c:	4618      	mov	r0, r3
   1a29e:	f7ff fe6b 	bl	19f78 <mem_set>
			st_dword(fs->win + FSI_StrucSig, 0x61417272);
   1a2a2:	9b01      	ldr	r3, [sp, #4]
   1a2a4:	3330      	adds	r3, #48	; 0x30
   1a2a6:	f503 73ff 	add.w	r3, r3, #510	; 0x1fe
   1a2aa:	f64a 2155 	movw	r1, #43605	; 0xaa55
   1a2ae:	4618      	mov	r0, r3
   1a2b0:	f7ff fdd8 	bl	19e64 <st_word>
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
   1a2b4:	9b01      	ldr	r3, [sp, #4]
   1a2b6:	3330      	adds	r3, #48	; 0x30
   1a2b8:	4925      	ldr	r1, [pc, #148]	; (1a350 <sync_fs+0xf4>)
   1a2ba:	4618      	mov	r0, r3
   1a2bc:	f7ff fdfc 	bl	19eb8 <st_dword>
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
   1a2c0:	9b01      	ldr	r3, [sp, #4]
   1a2c2:	3330      	adds	r3, #48	; 0x30
   1a2c4:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
   1a2c8:	4922      	ldr	r1, [pc, #136]	; (1a354 <sync_fs+0xf8>)
   1a2ca:	4618      	mov	r0, r3
   1a2cc:	f7ff fdf4 	bl	19eb8 <st_dword>
			/* Write it into the FSInfo sector */
   1a2d0:	9b01      	ldr	r3, [sp, #4]
   1a2d2:	3330      	adds	r3, #48	; 0x30
   1a2d4:	f503 72f4 	add.w	r2, r3, #488	; 0x1e8
   1a2d8:	9b01      	ldr	r3, [sp, #4]
   1a2da:	691b      	ldr	r3, [r3, #16]
   1a2dc:	4619      	mov	r1, r3
   1a2de:	4610      	mov	r0, r2
   1a2e0:	f7ff fdea 	bl	19eb8 <st_dword>
			fs->winsect = fs->volbase + 1;
   1a2e4:	9b01      	ldr	r3, [sp, #4]
   1a2e6:	3330      	adds	r3, #48	; 0x30
   1a2e8:	f503 72f6 	add.w	r2, r3, #492	; 0x1ec
   1a2ec:	9b01      	ldr	r3, [sp, #4]
   1a2ee:	68db      	ldr	r3, [r3, #12]
   1a2f0:	4619      	mov	r1, r3
   1a2f2:	4610      	mov	r0, r2
   1a2f4:	f7ff fde0 	bl	19eb8 <st_dword>
			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
			fs->fsi_flag = 0;
   1a2f8:	9b01      	ldr	r3, [sp, #4]
   1a2fa:	69db      	ldr	r3, [r3, #28]
   1a2fc:	1c5a      	adds	r2, r3, #1
   1a2fe:	9b01      	ldr	r3, [sp, #4]
   1a300:	62da      	str	r2, [r3, #44]	; 0x2c
		}
   1a302:	9b01      	ldr	r3, [sp, #4]
   1a304:	7858      	ldrb	r0, [r3, #1]
   1a306:	9b01      	ldr	r3, [sp, #4]
   1a308:	f103 0130 	add.w	r1, r3, #48	; 0x30
   1a30c:	9b01      	ldr	r3, [sp, #4]
   1a30e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1a310:	2301      	movs	r3, #1
   1a312:	f7ff fcd9 	bl	19cc8 <disk_write>
		/* Make sure that no pending write process in the lower layer */
   1a316:	9b01      	ldr	r3, [sp, #4]
   1a318:	2200      	movs	r2, #0
   1a31a:	711a      	strb	r2, [r3, #4]
		if (disk_ioctl(fs->pdrv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
	}

   1a31c:	9b01      	ldr	r3, [sp, #4]
   1a31e:	785b      	ldrb	r3, [r3, #1]
   1a320:	2200      	movs	r2, #0
   1a322:	2100      	movs	r1, #0
   1a324:	4618      	mov	r0, r3
   1a326:	f7ff fcf1 	bl	19d0c <disk_ioctl>
   1a32a:	4603      	mov	r3, r0
   1a32c:	2b00      	cmp	r3, #0
   1a32e:	d002      	beq.n	1a336 <sync_fs+0xda>
   1a330:	2301      	movs	r3, #1
   1a332:	f88d 300f 	strb.w	r3, [sp, #15]
	return res;
}

   1a336:	f89d 400f 	ldrb.w	r4, [sp, #15]
   1a33a:	462b      	mov	r3, r5
   1a33c:	4619      	mov	r1, r3
   1a33e:	4803      	ldr	r0, [pc, #12]	; (1a34c <sync_fs+0xf0>)
   1a340:	f7fc faec 	bl	1691c <__cyg_profile_func_exit>
   1a344:	4623      	mov	r3, r4
#endif
   1a346:	4618      	mov	r0, r3
   1a348:	b005      	add	sp, #20
   1a34a:	bd30      	pop	{r4, r5, pc}
   1a34c:	0001a25d 	.word	0x0001a25d
   1a350:	41615252 	.word	0x41615252
   1a354:	61417272 	.word	0x61417272

0001a358 <clst2sect>:
	FATFS* fs,		/* Filesystem object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;		/* Cluster number is origin from 2 */
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
   1a358:	b530      	push	{r4, r5, lr}
   1a35a:	b083      	sub	sp, #12
   1a35c:	4675      	mov	r5, lr
   1a35e:	9001      	str	r0, [sp, #4]
   1a360:	9100      	str	r1, [sp, #0]
   1a362:	462b      	mov	r3, r5
   1a364:	4619      	mov	r1, r3
   1a366:	4810      	ldr	r0, [pc, #64]	; (1a3a8 <clst2sect+0x50>)
   1a368:	f7fc fac4 	bl	168f4 <__cyg_profile_func_enter>
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
   1a36c:	9b00      	ldr	r3, [sp, #0]
   1a36e:	3b02      	subs	r3, #2
   1a370:	9300      	str	r3, [sp, #0]
}
   1a372:	9b01      	ldr	r3, [sp, #4]
   1a374:	695b      	ldr	r3, [r3, #20]
   1a376:	3b02      	subs	r3, #2
   1a378:	9a00      	ldr	r2, [sp, #0]
   1a37a:	429a      	cmp	r2, r3
   1a37c:	d301      	bcc.n	1a382 <clst2sect+0x2a>
   1a37e:	2400      	movs	r4, #0
   1a380:	e008      	b.n	1a394 <clst2sect+0x3c>

   1a382:	9b01      	ldr	r3, [sp, #4]
   1a384:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1a386:	9b01      	ldr	r3, [sp, #4]
   1a388:	895b      	ldrh	r3, [r3, #10]
   1a38a:	4619      	mov	r1, r3
   1a38c:	9b00      	ldr	r3, [sp, #0]
   1a38e:	fb03 f301 	mul.w	r3, r3, r1
   1a392:	18d4      	adds	r4, r2, r3
   1a394:	462b      	mov	r3, r5
   1a396:	4619      	mov	r1, r3
   1a398:	4803      	ldr	r0, [pc, #12]	; (1a3a8 <clst2sect+0x50>)
   1a39a:	f7fc fabf 	bl	1691c <__cyg_profile_func_exit>
   1a39e:	4623      	mov	r3, r4

   1a3a0:	4618      	mov	r0, r3
   1a3a2:	b003      	add	sp, #12
   1a3a4:	bd30      	pop	{r4, r5, pc}
   1a3a6:	bf00      	nop
   1a3a8:	0001a359 	.word	0x0001a359

0001a3ac <get_fat>:
	FFOBJID* obj,	/* Corresponding object */
	DWORD clst		/* Cluster number to get the value */
)
{
	UINT wc, bc;
	DWORD val;
   1a3ac:	b530      	push	{r4, r5, lr}
   1a3ae:	b087      	sub	sp, #28
   1a3b0:	4675      	mov	r5, lr
   1a3b2:	9001      	str	r0, [sp, #4]
   1a3b4:	9100      	str	r1, [sp, #0]
   1a3b6:	462b      	mov	r3, r5
   1a3b8:	4619      	mov	r1, r3
   1a3ba:	4854      	ldr	r0, [pc, #336]	; (1a50c <get_fat+0x160>)
   1a3bc:	f7fc fa9a 	bl	168f4 <__cyg_profile_func_enter>
	FATFS *fs = obj->fs;


   1a3c0:	9b01      	ldr	r3, [sp, #4]
   1a3c2:	681b      	ldr	r3, [r3, #0]
   1a3c4:	9304      	str	r3, [sp, #16]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		val = 1;	/* Internal error */

   1a3c6:	9b00      	ldr	r3, [sp, #0]
   1a3c8:	2b01      	cmp	r3, #1
   1a3ca:	d904      	bls.n	1a3d6 <get_fat+0x2a>
   1a3cc:	9b04      	ldr	r3, [sp, #16]
   1a3ce:	695b      	ldr	r3, [r3, #20]
   1a3d0:	9a00      	ldr	r2, [sp, #0]
   1a3d2:	429a      	cmp	r2, r3
   1a3d4:	d302      	bcc.n	1a3dc <get_fat+0x30>
	} else {
   1a3d6:	2301      	movs	r3, #1
   1a3d8:	9305      	str	r3, [sp, #20]
   1a3da:	e08c      	b.n	1a4f6 <get_fat+0x14a>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */

		switch (fs->fs_type) {
   1a3dc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1a3e0:	9305      	str	r3, [sp, #20]
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
   1a3e2:	9b04      	ldr	r3, [sp, #16]
   1a3e4:	781b      	ldrb	r3, [r3, #0]
   1a3e6:	2b02      	cmp	r3, #2
   1a3e8:	d045      	beq.n	1a476 <get_fat+0xca>
   1a3ea:	2b03      	cmp	r3, #3
   1a3ec:	d05d      	beq.n	1a4aa <get_fat+0xfe>
   1a3ee:	2b01      	cmp	r3, #1
   1a3f0:	d177      	bne.n	1a4e2 <get_fat+0x136>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
   1a3f2:	9b00      	ldr	r3, [sp, #0]
   1a3f4:	9303      	str	r3, [sp, #12]
   1a3f6:	9b03      	ldr	r3, [sp, #12]
   1a3f8:	085b      	lsrs	r3, r3, #1
   1a3fa:	9a03      	ldr	r2, [sp, #12]
   1a3fc:	4413      	add	r3, r2
   1a3fe:	9303      	str	r3, [sp, #12]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
   1a400:	9b04      	ldr	r3, [sp, #16]
   1a402:	6a1a      	ldr	r2, [r3, #32]
   1a404:	9b03      	ldr	r3, [sp, #12]
   1a406:	0a5b      	lsrs	r3, r3, #9
   1a408:	4413      	add	r3, r2
   1a40a:	4619      	mov	r1, r3
   1a40c:	9804      	ldr	r0, [sp, #16]
   1a40e:	f7ff fee7 	bl	1a1e0 <move_window>
   1a412:	4603      	mov	r3, r0
   1a414:	2b00      	cmp	r3, #0
   1a416:	d167      	bne.n	1a4e8 <get_fat+0x13c>
			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
   1a418:	9b03      	ldr	r3, [sp, #12]
   1a41a:	1c5a      	adds	r2, r3, #1
   1a41c:	9203      	str	r2, [sp, #12]
   1a41e:	f3c3 0308 	ubfx	r3, r3, #0, #9
   1a422:	9a04      	ldr	r2, [sp, #16]
   1a424:	4413      	add	r3, r2
   1a426:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
   1a42a:	9302      	str	r3, [sp, #8]
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
   1a42c:	9b04      	ldr	r3, [sp, #16]
   1a42e:	6a1a      	ldr	r2, [r3, #32]
   1a430:	9b03      	ldr	r3, [sp, #12]
   1a432:	0a5b      	lsrs	r3, r3, #9
   1a434:	4413      	add	r3, r2
   1a436:	4619      	mov	r1, r3
   1a438:	9804      	ldr	r0, [sp, #16]
   1a43a:	f7ff fed1 	bl	1a1e0 <move_window>
   1a43e:	4603      	mov	r3, r0
   1a440:	2b00      	cmp	r3, #0
   1a442:	d153      	bne.n	1a4ec <get_fat+0x140>
			break;
   1a444:	9b03      	ldr	r3, [sp, #12]
   1a446:	f3c3 0308 	ubfx	r3, r3, #0, #9
   1a44a:	9a04      	ldr	r2, [sp, #16]
   1a44c:	4413      	add	r3, r2
   1a44e:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
   1a452:	021b      	lsls	r3, r3, #8
   1a454:	461a      	mov	r2, r3
   1a456:	9b02      	ldr	r3, [sp, #8]
   1a458:	4313      	orrs	r3, r2
   1a45a:	9302      	str	r3, [sp, #8]

   1a45c:	9b00      	ldr	r3, [sp, #0]
   1a45e:	f003 0301 	and.w	r3, r3, #1
   1a462:	2b00      	cmp	r3, #0
   1a464:	d002      	beq.n	1a46c <get_fat+0xc0>
   1a466:	9b02      	ldr	r3, [sp, #8]
   1a468:	091b      	lsrs	r3, r3, #4
   1a46a:	e002      	b.n	1a472 <get_fat+0xc6>
   1a46c:	9b02      	ldr	r3, [sp, #8]
   1a46e:	f3c3 030b 	ubfx	r3, r3, #0, #12
   1a472:	9305      	str	r3, [sp, #20]
		case FS_FAT16 :
   1a474:	e03f      	b.n	1a4f6 <get_fat+0x14a>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
			val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
			break;
   1a476:	9b04      	ldr	r3, [sp, #16]
   1a478:	6a1a      	ldr	r2, [r3, #32]
   1a47a:	9b00      	ldr	r3, [sp, #0]
   1a47c:	0a1b      	lsrs	r3, r3, #8
   1a47e:	4413      	add	r3, r2
   1a480:	4619      	mov	r1, r3
   1a482:	9804      	ldr	r0, [sp, #16]
   1a484:	f7ff feac 	bl	1a1e0 <move_window>
   1a488:	4603      	mov	r3, r0
   1a48a:	2b00      	cmp	r3, #0
   1a48c:	d130      	bne.n	1a4f0 <get_fat+0x144>

   1a48e:	9b04      	ldr	r3, [sp, #16]
   1a490:	f103 0230 	add.w	r2, r3, #48	; 0x30
   1a494:	9b00      	ldr	r3, [sp, #0]
   1a496:	005b      	lsls	r3, r3, #1
   1a498:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
   1a49c:	4413      	add	r3, r2
   1a49e:	4618      	mov	r0, r3
   1a4a0:	f7ff fc8c 	bl	19dbc <ld_word>
   1a4a4:	4603      	mov	r3, r0
   1a4a6:	9305      	str	r3, [sp, #20]
		case FS_FAT32 :
   1a4a8:	e025      	b.n	1a4f6 <get_fat+0x14a>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
			break;
   1a4aa:	9b04      	ldr	r3, [sp, #16]
   1a4ac:	6a1a      	ldr	r2, [r3, #32]
   1a4ae:	9b00      	ldr	r3, [sp, #0]
   1a4b0:	09db      	lsrs	r3, r3, #7
   1a4b2:	4413      	add	r3, r2
   1a4b4:	4619      	mov	r1, r3
   1a4b6:	9804      	ldr	r0, [sp, #16]
   1a4b8:	f7ff fe92 	bl	1a1e0 <move_window>
   1a4bc:	4603      	mov	r3, r0
   1a4be:	2b00      	cmp	r3, #0
   1a4c0:	d118      	bne.n	1a4f4 <get_fat+0x148>
#if FF_FS_EXFAT
   1a4c2:	9b04      	ldr	r3, [sp, #16]
   1a4c4:	f103 0230 	add.w	r2, r3, #48	; 0x30
   1a4c8:	9b00      	ldr	r3, [sp, #0]
   1a4ca:	009b      	lsls	r3, r3, #2
   1a4cc:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
   1a4d0:	4413      	add	r3, r2
   1a4d2:	4618      	mov	r0, r3
   1a4d4:	f7ff fc98 	bl	19e08 <ld_dword>
   1a4d8:	4603      	mov	r3, r0
   1a4da:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
   1a4de:	9305      	str	r3, [sp, #20]
		case FS_EXFAT :
   1a4e0:	e009      	b.n	1a4f6 <get_fat+0x14a>
			/* go to default */
#endif
		default:
			val = 1;	/* Internal error */
		}
	}
   1a4e2:	2301      	movs	r3, #1
   1a4e4:	9305      	str	r3, [sp, #20]
   1a4e6:	e006      	b.n	1a4f6 <get_fat+0x14a>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
   1a4e8:	bf00      	nop
   1a4ea:	e004      	b.n	1a4f6 <get_fat+0x14a>
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
   1a4ec:	bf00      	nop
   1a4ee:	e002      	b.n	1a4f6 <get_fat+0x14a>
			break;
   1a4f0:	bf00      	nop
   1a4f2:	e000      	b.n	1a4f6 <get_fat+0x14a>
			break;
   1a4f4:	bf00      	nop

	return val;
}

   1a4f6:	9c05      	ldr	r4, [sp, #20]
   1a4f8:	462b      	mov	r3, r5
   1a4fa:	4619      	mov	r1, r3
   1a4fc:	4803      	ldr	r0, [pc, #12]	; (1a50c <get_fat+0x160>)
   1a4fe:	f7fc fa0d 	bl	1691c <__cyg_profile_func_exit>
   1a502:	4623      	mov	r3, r4

   1a504:	4618      	mov	r0, r3
   1a506:	b007      	add	sp, #28
   1a508:	bd30      	pop	{r4, r5, pc}
   1a50a:	bf00      	nop
   1a50c:	0001a3ad 	.word	0x0001a3ad

0001a510 <put_fat>:
	DWORD clst,		/* FAT index number (cluster number) to be changed */
	DWORD val		/* New value to be set to the entry */
)
{
	UINT bc;
	BYTE *p;
   1a510:	b530      	push	{r4, r5, lr}
   1a512:	b089      	sub	sp, #36	; 0x24
   1a514:	4675      	mov	r5, lr
   1a516:	9003      	str	r0, [sp, #12]
   1a518:	9102      	str	r1, [sp, #8]
   1a51a:	9201      	str	r2, [sp, #4]
   1a51c:	462b      	mov	r3, r5
   1a51e:	4619      	mov	r1, r3
   1a520:	4879      	ldr	r0, [pc, #484]	; (1a708 <put_fat+0x1f8>)
   1a522:	f7fc f9e7 	bl	168f4 <__cyg_profile_func_enter>
	FRESULT res = FR_INT_ERR;


   1a526:	2302      	movs	r3, #2
   1a528:	f88d 301f 	strb.w	r3, [sp, #31]
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
		switch (fs->fs_type) {
		case FS_FAT12 :
   1a52c:	9b02      	ldr	r3, [sp, #8]
   1a52e:	2b01      	cmp	r3, #1
   1a530:	f240 80de 	bls.w	1a6f0 <put_fat+0x1e0>
   1a534:	9b03      	ldr	r3, [sp, #12]
   1a536:	695b      	ldr	r3, [r3, #20]
   1a538:	9a02      	ldr	r2, [sp, #8]
   1a53a:	429a      	cmp	r2, r3
   1a53c:	f080 80d8 	bcs.w	1a6f0 <put_fat+0x1e0>
			bc = (UINT)clst; bc += bc / 2;	/* bc: byte offset of the entry */
   1a540:	9b03      	ldr	r3, [sp, #12]
   1a542:	781b      	ldrb	r3, [r3, #0]
   1a544:	2b02      	cmp	r3, #2
   1a546:	d077      	beq.n	1a638 <put_fat+0x128>
   1a548:	2b03      	cmp	r3, #3
   1a54a:	f000 8097 	beq.w	1a67c <put_fat+0x16c>
   1a54e:	2b01      	cmp	r3, #1
   1a550:	f040 80ce 	bne.w	1a6f0 <put_fat+0x1e0>
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
   1a554:	9b02      	ldr	r3, [sp, #8]
   1a556:	9306      	str	r3, [sp, #24]
   1a558:	9b06      	ldr	r3, [sp, #24]
   1a55a:	085b      	lsrs	r3, r3, #1
   1a55c:	9a06      	ldr	r2, [sp, #24]
   1a55e:	4413      	add	r3, r2
   1a560:	9306      	str	r3, [sp, #24]
			p = fs->win + bc++ % SS(fs);
   1a562:	9b03      	ldr	r3, [sp, #12]
   1a564:	6a1a      	ldr	r2, [r3, #32]
   1a566:	9b06      	ldr	r3, [sp, #24]
   1a568:	0a5b      	lsrs	r3, r3, #9
   1a56a:	4413      	add	r3, r2
   1a56c:	4619      	mov	r1, r3
   1a56e:	9803      	ldr	r0, [sp, #12]
   1a570:	f7ff fe36 	bl	1a1e0 <move_window>
   1a574:	4603      	mov	r3, r0
   1a576:	f88d 301f 	strb.w	r3, [sp, #31]
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
   1a57a:	f89d 301f 	ldrb.w	r3, [sp, #31]
   1a57e:	2b00      	cmp	r3, #0
   1a580:	f040 80af 	bne.w	1a6e2 <put_fat+0x1d2>
			fs->wflag = 1;
   1a584:	9b03      	ldr	r3, [sp, #12]
   1a586:	f103 0230 	add.w	r2, r3, #48	; 0x30
   1a58a:	9b06      	ldr	r3, [sp, #24]
   1a58c:	1c59      	adds	r1, r3, #1
   1a58e:	9106      	str	r1, [sp, #24]
   1a590:	f3c3 0308 	ubfx	r3, r3, #0, #9
   1a594:	4413      	add	r3, r2
   1a596:	9305      	str	r3, [sp, #20]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   1a598:	9b02      	ldr	r3, [sp, #8]
   1a59a:	f003 0301 	and.w	r3, r3, #1
   1a59e:	2b00      	cmp	r3, #0
   1a5a0:	d00d      	beq.n	1a5be <put_fat+0xae>
   1a5a2:	9b05      	ldr	r3, [sp, #20]
   1a5a4:	781b      	ldrb	r3, [r3, #0]
   1a5a6:	b25b      	sxtb	r3, r3
   1a5a8:	f003 030f 	and.w	r3, r3, #15
   1a5ac:	b25a      	sxtb	r2, r3
   1a5ae:	9b01      	ldr	r3, [sp, #4]
   1a5b0:	b2db      	uxtb	r3, r3
   1a5b2:	011b      	lsls	r3, r3, #4
   1a5b4:	b25b      	sxtb	r3, r3
   1a5b6:	4313      	orrs	r3, r2
   1a5b8:	b25b      	sxtb	r3, r3
   1a5ba:	b2db      	uxtb	r3, r3
   1a5bc:	e001      	b.n	1a5c2 <put_fat+0xb2>
   1a5be:	9b01      	ldr	r3, [sp, #4]
   1a5c0:	b2db      	uxtb	r3, r3
   1a5c2:	9a05      	ldr	r2, [sp, #20]
   1a5c4:	7013      	strb	r3, [r2, #0]
			if (res != FR_OK) break;
   1a5c6:	9b03      	ldr	r3, [sp, #12]
   1a5c8:	2201      	movs	r2, #1
   1a5ca:	70da      	strb	r2, [r3, #3]
			p = fs->win + bc % SS(fs);
   1a5cc:	9b03      	ldr	r3, [sp, #12]
   1a5ce:	6a1a      	ldr	r2, [r3, #32]
   1a5d0:	9b06      	ldr	r3, [sp, #24]
   1a5d2:	0a5b      	lsrs	r3, r3, #9
   1a5d4:	4413      	add	r3, r2
   1a5d6:	4619      	mov	r1, r3
   1a5d8:	9803      	ldr	r0, [sp, #12]
   1a5da:	f7ff fe01 	bl	1a1e0 <move_window>
   1a5de:	4603      	mov	r3, r0
   1a5e0:	f88d 301f 	strb.w	r3, [sp, #31]
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Put 2nd byte */
   1a5e4:	f89d 301f 	ldrb.w	r3, [sp, #31]
   1a5e8:	2b00      	cmp	r3, #0
   1a5ea:	d17c      	bne.n	1a6e6 <put_fat+0x1d6>
			fs->wflag = 1;
   1a5ec:	9b03      	ldr	r3, [sp, #12]
   1a5ee:	f103 0230 	add.w	r2, r3, #48	; 0x30
   1a5f2:	9b06      	ldr	r3, [sp, #24]
   1a5f4:	f3c3 0308 	ubfx	r3, r3, #0, #9
   1a5f8:	4413      	add	r3, r2
   1a5fa:	9305      	str	r3, [sp, #20]
			break;
   1a5fc:	9b02      	ldr	r3, [sp, #8]
   1a5fe:	f003 0301 	and.w	r3, r3, #1
   1a602:	2b00      	cmp	r3, #0
   1a604:	d003      	beq.n	1a60e <put_fat+0xfe>
   1a606:	9b01      	ldr	r3, [sp, #4]
   1a608:	091b      	lsrs	r3, r3, #4
   1a60a:	b2db      	uxtb	r3, r3
   1a60c:	e00e      	b.n	1a62c <put_fat+0x11c>
   1a60e:	9b05      	ldr	r3, [sp, #20]
   1a610:	781b      	ldrb	r3, [r3, #0]
   1a612:	b25b      	sxtb	r3, r3
   1a614:	f023 030f 	bic.w	r3, r3, #15
   1a618:	b25a      	sxtb	r2, r3
   1a61a:	9b01      	ldr	r3, [sp, #4]
   1a61c:	0a1b      	lsrs	r3, r3, #8
   1a61e:	b25b      	sxtb	r3, r3
   1a620:	f003 030f 	and.w	r3, r3, #15
   1a624:	b25b      	sxtb	r3, r3
   1a626:	4313      	orrs	r3, r2
   1a628:	b25b      	sxtb	r3, r3
   1a62a:	b2db      	uxtb	r3, r3
   1a62c:	9a05      	ldr	r2, [sp, #20]
   1a62e:	7013      	strb	r3, [r2, #0]

   1a630:	9b03      	ldr	r3, [sp, #12]
   1a632:	2201      	movs	r2, #1
   1a634:	70da      	strb	r2, [r3, #3]
		case FS_FAT16 :
   1a636:	e05b      	b.n	1a6f0 <put_fat+0x1e0>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
			if (res != FR_OK) break;
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
   1a638:	9b03      	ldr	r3, [sp, #12]
   1a63a:	6a1a      	ldr	r2, [r3, #32]
   1a63c:	9b02      	ldr	r3, [sp, #8]
   1a63e:	0a1b      	lsrs	r3, r3, #8
   1a640:	4413      	add	r3, r2
   1a642:	4619      	mov	r1, r3
   1a644:	9803      	ldr	r0, [sp, #12]
   1a646:	f7ff fdcb 	bl	1a1e0 <move_window>
   1a64a:	4603      	mov	r3, r0
   1a64c:	f88d 301f 	strb.w	r3, [sp, #31]
			fs->wflag = 1;
   1a650:	f89d 301f 	ldrb.w	r3, [sp, #31]
   1a654:	2b00      	cmp	r3, #0
   1a656:	d148      	bne.n	1a6ea <put_fat+0x1da>
			break;
   1a658:	9b03      	ldr	r3, [sp, #12]
   1a65a:	f103 0230 	add.w	r2, r3, #48	; 0x30
   1a65e:	9b02      	ldr	r3, [sp, #8]
   1a660:	005b      	lsls	r3, r3, #1
   1a662:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
   1a666:	4413      	add	r3, r2
   1a668:	9a01      	ldr	r2, [sp, #4]
   1a66a:	b292      	uxth	r2, r2
   1a66c:	4611      	mov	r1, r2
   1a66e:	4618      	mov	r0, r3
   1a670:	f7ff fbf8 	bl	19e64 <st_word>

   1a674:	9b03      	ldr	r3, [sp, #12]
   1a676:	2201      	movs	r2, #1
   1a678:	70da      	strb	r2, [r3, #3]
		case FS_FAT32 :
   1a67a:	e039      	b.n	1a6f0 <put_fat+0x1e0>
#if FF_FS_EXFAT
		case FS_EXFAT :
#endif
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
			if (res != FR_OK) break;
			if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
   1a67c:	9b03      	ldr	r3, [sp, #12]
   1a67e:	6a1a      	ldr	r2, [r3, #32]
   1a680:	9b02      	ldr	r3, [sp, #8]
   1a682:	09db      	lsrs	r3, r3, #7
   1a684:	4413      	add	r3, r2
   1a686:	4619      	mov	r1, r3
   1a688:	9803      	ldr	r0, [sp, #12]
   1a68a:	f7ff fda9 	bl	1a1e0 <move_window>
   1a68e:	4603      	mov	r3, r0
   1a690:	f88d 301f 	strb.w	r3, [sp, #31]
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
   1a694:	f89d 301f 	ldrb.w	r3, [sp, #31]
   1a698:	2b00      	cmp	r3, #0
   1a69a:	d128      	bne.n	1a6ee <put_fat+0x1de>
			}
			st_dword(fs->win + clst * 4 % SS(fs), val);
   1a69c:	9b01      	ldr	r3, [sp, #4]
   1a69e:	f023 4470 	bic.w	r4, r3, #4026531840	; 0xf0000000
   1a6a2:	9b03      	ldr	r3, [sp, #12]
   1a6a4:	f103 0230 	add.w	r2, r3, #48	; 0x30
   1a6a8:	9b02      	ldr	r3, [sp, #8]
   1a6aa:	009b      	lsls	r3, r3, #2
   1a6ac:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
   1a6b0:	4413      	add	r3, r2
   1a6b2:	4618      	mov	r0, r3
   1a6b4:	f7ff fba8 	bl	19e08 <ld_dword>
   1a6b8:	4603      	mov	r3, r0
   1a6ba:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
   1a6be:	4323      	orrs	r3, r4
   1a6c0:	9301      	str	r3, [sp, #4]
			fs->wflag = 1;
			break;
   1a6c2:	9b03      	ldr	r3, [sp, #12]
   1a6c4:	f103 0230 	add.w	r2, r3, #48	; 0x30
   1a6c8:	9b02      	ldr	r3, [sp, #8]
   1a6ca:	009b      	lsls	r3, r3, #2
   1a6cc:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
   1a6d0:	4413      	add	r3, r2
   1a6d2:	9901      	ldr	r1, [sp, #4]
   1a6d4:	4618      	mov	r0, r3
   1a6d6:	f7ff fbef 	bl	19eb8 <st_dword>
		}
   1a6da:	9b03      	ldr	r3, [sp, #12]
   1a6dc:	2201      	movs	r2, #1
   1a6de:	70da      	strb	r2, [r3, #3]
	}
   1a6e0:	e006      	b.n	1a6f0 <put_fat+0x1e0>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
   1a6e2:	bf00      	nop
   1a6e4:	e004      	b.n	1a6f0 <put_fat+0x1e0>
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Put 2nd byte */
   1a6e6:	bf00      	nop
   1a6e8:	e002      	b.n	1a6f0 <put_fat+0x1e0>
			fs->wflag = 1;
   1a6ea:	bf00      	nop
   1a6ec:	e000      	b.n	1a6f0 <put_fat+0x1e0>
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
   1a6ee:	bf00      	nop
	return res;
}

   1a6f0:	f89d 401f 	ldrb.w	r4, [sp, #31]
   1a6f4:	462b      	mov	r3, r5
   1a6f6:	4619      	mov	r1, r3
   1a6f8:	4803      	ldr	r0, [pc, #12]	; (1a708 <put_fat+0x1f8>)
   1a6fa:	f7fc f90f 	bl	1691c <__cyg_profile_func_exit>
   1a6fe:	4623      	mov	r3, r4
#endif /* !FF_FS_READONLY */
   1a700:	4618      	mov	r0, r3
   1a702:	b009      	add	sp, #36	; 0x24
   1a704:	bd30      	pop	{r4, r5, pc}
   1a706:	bf00      	nop
   1a708:	0001a511 	.word	0x0001a511

0001a70c <remove_chain>:
	DWORD clst,			/* Cluster to remove a chain from */
	DWORD pclst			/* Previous cluster of clst (0 if entire chain) */
)
{
	FRESULT res = FR_OK;
	DWORD nxt;
   1a70c:	b530      	push	{r4, r5, lr}
   1a70e:	b089      	sub	sp, #36	; 0x24
   1a710:	4675      	mov	r5, lr
   1a712:	9003      	str	r0, [sp, #12]
   1a714:	9102      	str	r1, [sp, #8]
   1a716:	9201      	str	r2, [sp, #4]
   1a718:	462b      	mov	r3, r5
   1a71a:	4619      	mov	r1, r3
   1a71c:	4836      	ldr	r0, [pc, #216]	; (1a7f8 <remove_chain+0xec>)
   1a71e:	f7fc f8e9 	bl	168f4 <__cyg_profile_func_enter>
	FATFS *fs = obj->fs;
   1a722:	2300      	movs	r3, #0
   1a724:	f88d 301f 	strb.w	r3, [sp, #31]
#if FF_FS_EXFAT || FF_USE_TRIM
	DWORD scl = clst, ecl = clst;
   1a728:	9b03      	ldr	r3, [sp, #12]
   1a72a:	681b      	ldr	r3, [r3, #0]
   1a72c:	9306      	str	r3, [sp, #24]
	DWORD rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */

	/* Mark the previous cluster 'EOC' on the FAT if it exists */
   1a72e:	9b02      	ldr	r3, [sp, #8]
   1a730:	2b01      	cmp	r3, #1
   1a732:	d904      	bls.n	1a73e <remove_chain+0x32>
   1a734:	9b06      	ldr	r3, [sp, #24]
   1a736:	695b      	ldr	r3, [r3, #20]
   1a738:	9a02      	ldr	r2, [sp, #8]
   1a73a:	429a      	cmp	r2, r3
   1a73c:	d301      	bcc.n	1a742 <remove_chain+0x36>
   1a73e:	2402      	movs	r4, #2
   1a740:	e051      	b.n	1a7e6 <remove_chain+0xda>
	if (pclst != 0 && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
		res = put_fat(fs, pclst, 0xFFFFFFFF);
		if (res != FR_OK) return res;
   1a742:	9b01      	ldr	r3, [sp, #4]
   1a744:	2b00      	cmp	r3, #0
   1a746:	d00f      	beq.n	1a768 <remove_chain+0x5c>
	}
   1a748:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1a74c:	9901      	ldr	r1, [sp, #4]
   1a74e:	9806      	ldr	r0, [sp, #24]
   1a750:	f7ff fede 	bl	1a510 <put_fat>
   1a754:	4603      	mov	r3, r0
   1a756:	f88d 301f 	strb.w	r3, [sp, #31]

   1a75a:	f89d 301f 	ldrb.w	r3, [sp, #31]
   1a75e:	2b00      	cmp	r3, #0
   1a760:	d002      	beq.n	1a768 <remove_chain+0x5c>
   1a762:	f89d 401f 	ldrb.w	r4, [sp, #31]
   1a766:	e03e      	b.n	1a7e6 <remove_chain+0xda>
	/* Remove the chain */
	do {
		nxt = get_fat(obj, clst);			/* Get cluster status */
		if (nxt == 0) break;				/* Empty cluster? */
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
   1a768:	9902      	ldr	r1, [sp, #8]
   1a76a:	9803      	ldr	r0, [sp, #12]
   1a76c:	f7ff fe1e 	bl	1a3ac <get_fat>
   1a770:	9005      	str	r0, [sp, #20]
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
   1a772:	9b05      	ldr	r3, [sp, #20]
   1a774:	2b00      	cmp	r3, #0
   1a776:	d034      	beq.n	1a7e2 <remove_chain+0xd6>
		if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
   1a778:	9b05      	ldr	r3, [sp, #20]
   1a77a:	2b01      	cmp	r3, #1
   1a77c:	d101      	bne.n	1a782 <remove_chain+0x76>
   1a77e:	2402      	movs	r4, #2
   1a780:	e031      	b.n	1a7e6 <remove_chain+0xda>
			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
   1a782:	9b05      	ldr	r3, [sp, #20]
   1a784:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   1a788:	d101      	bne.n	1a78e <remove_chain+0x82>
   1a78a:	2401      	movs	r4, #1
   1a78c:	e02b      	b.n	1a7e6 <remove_chain+0xda>
			if (res != FR_OK) return res;
		}
   1a78e:	2200      	movs	r2, #0
   1a790:	9902      	ldr	r1, [sp, #8]
   1a792:	9806      	ldr	r0, [sp, #24]
   1a794:	f7ff febc 	bl	1a510 <put_fat>
   1a798:	4603      	mov	r3, r0
   1a79a:	f88d 301f 	strb.w	r3, [sp, #31]
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
   1a79e:	f89d 301f 	ldrb.w	r3, [sp, #31]
   1a7a2:	2b00      	cmp	r3, #0
   1a7a4:	d002      	beq.n	1a7ac <remove_chain+0xa0>
   1a7a6:	f89d 401f 	ldrb.w	r4, [sp, #31]
   1a7aa:	e01c      	b.n	1a7e6 <remove_chain+0xda>
			fs->free_clst++;
			fs->fsi_flag |= 1;
   1a7ac:	9b06      	ldr	r3, [sp, #24]
   1a7ae:	691a      	ldr	r2, [r3, #16]
   1a7b0:	9b06      	ldr	r3, [sp, #24]
   1a7b2:	695b      	ldr	r3, [r3, #20]
   1a7b4:	3b02      	subs	r3, #2
   1a7b6:	429a      	cmp	r2, r3
   1a7b8:	d20b      	bcs.n	1a7d2 <remove_chain+0xc6>
		}
   1a7ba:	9b06      	ldr	r3, [sp, #24]
   1a7bc:	691b      	ldr	r3, [r3, #16]
   1a7be:	1c5a      	adds	r2, r3, #1
   1a7c0:	9b06      	ldr	r3, [sp, #24]
   1a7c2:	611a      	str	r2, [r3, #16]
#if FF_FS_EXFAT || FF_USE_TRIM
   1a7c4:	9b06      	ldr	r3, [sp, #24]
   1a7c6:	791b      	ldrb	r3, [r3, #4]
   1a7c8:	f043 0301 	orr.w	r3, r3, #1
   1a7cc:	b2da      	uxtb	r2, r3
   1a7ce:	9b06      	ldr	r3, [sp, #24]
   1a7d0:	711a      	strb	r2, [r3, #4]
			scl = ecl = nxt;
		}
#endif
		clst = nxt;					/* Next cluster */
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */

   1a7d2:	9b05      	ldr	r3, [sp, #20]
   1a7d4:	9302      	str	r3, [sp, #8]
#if FF_FS_EXFAT
   1a7d6:	9b06      	ldr	r3, [sp, #24]
   1a7d8:	695b      	ldr	r3, [r3, #20]
   1a7da:	9a02      	ldr	r2, [sp, #8]
   1a7dc:	429a      	cmp	r2, r3
   1a7de:	d3c3      	bcc.n	1a768 <remove_chain+0x5c>
   1a7e0:	e000      	b.n	1a7e4 <remove_chain+0xd8>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
   1a7e2:	bf00      	nop
		}
	}
#endif
	return FR_OK;
}

   1a7e4:	2400      	movs	r4, #0
   1a7e6:	462b      	mov	r3, r5
   1a7e8:	4619      	mov	r1, r3
   1a7ea:	4803      	ldr	r0, [pc, #12]	; (1a7f8 <remove_chain+0xec>)
   1a7ec:	f7fc f896 	bl	1691c <__cyg_profile_func_exit>
   1a7f0:	4623      	mov	r3, r4

   1a7f2:	4618      	mov	r0, r3
   1a7f4:	b009      	add	sp, #36	; 0x24
   1a7f6:	bd30      	pop	{r4, r5, pc}
   1a7f8:	0001a70d 	.word	0x0001a70d

0001a7fc <create_chain>:
	FFOBJID* obj,		/* Corresponding object */
	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
)
{
	DWORD cs, ncl, scl;
	FRESULT res;
   1a7fc:	b530      	push	{r4, r5, lr}
   1a7fe:	b089      	sub	sp, #36	; 0x24
   1a800:	4675      	mov	r5, lr
   1a802:	9001      	str	r0, [sp, #4]
   1a804:	9100      	str	r1, [sp, #0]
   1a806:	462b      	mov	r3, r5
   1a808:	4619      	mov	r1, r3
   1a80a:	486c      	ldr	r0, [pc, #432]	; (1a9bc <create_chain+0x1c0>)
   1a80c:	f7fc f872 	bl	168f4 <__cyg_profile_func_enter>
	FATFS *fs = obj->fs;


   1a810:	9b01      	ldr	r3, [sp, #4]
   1a812:	681b      	ldr	r3, [r3, #0]
   1a814:	9304      	str	r3, [sp, #16]
	if (clst == 0) {	/* Create a new chain */
		scl = fs->last_clst;				/* Suggested cluster to start to find */
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
   1a816:	9b00      	ldr	r3, [sp, #0]
   1a818:	2b00      	cmp	r3, #0
   1a81a:	d10d      	bne.n	1a838 <create_chain+0x3c>
	}
   1a81c:	9b04      	ldr	r3, [sp, #16]
   1a81e:	68db      	ldr	r3, [r3, #12]
   1a820:	9306      	str	r3, [sp, #24]
	else {				/* Stretch a chain */
   1a822:	9b06      	ldr	r3, [sp, #24]
   1a824:	2b00      	cmp	r3, #0
   1a826:	d004      	beq.n	1a832 <create_chain+0x36>
   1a828:	9b04      	ldr	r3, [sp, #16]
   1a82a:	695b      	ldr	r3, [r3, #20]
   1a82c:	9a06      	ldr	r2, [sp, #24]
   1a82e:	429a      	cmp	r2, r3
   1a830:	d31b      	bcc.n	1a86a <create_chain+0x6e>
   1a832:	2301      	movs	r3, #1
   1a834:	9306      	str	r3, [sp, #24]
   1a836:	e018      	b.n	1a86a <create_chain+0x6e>
		cs = get_fat(obj, clst);			/* Check the cluster status */
		if (cs < 2) return 1;				/* Test for insanity */
		if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
   1a838:	9900      	ldr	r1, [sp, #0]
   1a83a:	9801      	ldr	r0, [sp, #4]
   1a83c:	f7ff fdb6 	bl	1a3ac <get_fat>
   1a840:	9003      	str	r0, [sp, #12]
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
   1a842:	9b03      	ldr	r3, [sp, #12]
   1a844:	2b01      	cmp	r3, #1
   1a846:	d801      	bhi.n	1a84c <create_chain+0x50>
   1a848:	2401      	movs	r4, #1
   1a84a:	e0ae      	b.n	1a9aa <create_chain+0x1ae>
		scl = clst;							/* Cluster to start to find */
   1a84c:	9b03      	ldr	r3, [sp, #12]
   1a84e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   1a852:	d101      	bne.n	1a858 <create_chain+0x5c>
   1a854:	9c03      	ldr	r4, [sp, #12]
   1a856:	e0a8      	b.n	1a9aa <create_chain+0x1ae>
	}
   1a858:	9b04      	ldr	r3, [sp, #16]
   1a85a:	695b      	ldr	r3, [r3, #20]
   1a85c:	9a03      	ldr	r2, [sp, #12]
   1a85e:	429a      	cmp	r2, r3
   1a860:	d201      	bcs.n	1a866 <create_chain+0x6a>
   1a862:	9c03      	ldr	r4, [sp, #12]
   1a864:	e0a1      	b.n	1a9aa <create_chain+0x1ae>
	if (fs->free_clst == 0) return 0;		/* No free cluster */
   1a866:	9b00      	ldr	r3, [sp, #0]
   1a868:	9306      	str	r3, [sp, #24]

#if FF_FS_EXFAT
   1a86a:	9b04      	ldr	r3, [sp, #16]
   1a86c:	691b      	ldr	r3, [r3, #16]
   1a86e:	2b00      	cmp	r3, #0
   1a870:	d101      	bne.n	1a876 <create_chain+0x7a>
   1a872:	2400      	movs	r4, #0
   1a874:	e099      	b.n	1a9aa <create_chain+0x1ae>
	} else
#endif
	{	/* On the FAT/FAT32 volume */
		ncl = 0;
		if (scl == clst) {						/* Stretching an existing chain? */
			ncl = scl + 1;						/* Test if next cluster is free */
   1a876:	2300      	movs	r3, #0
   1a878:	9307      	str	r3, [sp, #28]
			if (ncl >= fs->n_fatent) ncl = 2;
   1a87a:	9a06      	ldr	r2, [sp, #24]
   1a87c:	9b00      	ldr	r3, [sp, #0]
   1a87e:	429a      	cmp	r2, r3
   1a880:	d129      	bne.n	1a8d6 <create_chain+0xda>
			cs = get_fat(obj, ncl);				/* Get next cluster status */
   1a882:	9b06      	ldr	r3, [sp, #24]
   1a884:	3301      	adds	r3, #1
   1a886:	9307      	str	r3, [sp, #28]
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
   1a888:	9b04      	ldr	r3, [sp, #16]
   1a88a:	695b      	ldr	r3, [r3, #20]
   1a88c:	9a07      	ldr	r2, [sp, #28]
   1a88e:	429a      	cmp	r2, r3
   1a890:	d301      	bcc.n	1a896 <create_chain+0x9a>
   1a892:	2302      	movs	r3, #2
   1a894:	9307      	str	r3, [sp, #28]
			if (cs != 0) {						/* Not free? */
   1a896:	9907      	ldr	r1, [sp, #28]
   1a898:	9801      	ldr	r0, [sp, #4]
   1a89a:	f7ff fd87 	bl	1a3ac <get_fat>
   1a89e:	9003      	str	r0, [sp, #12]
				cs = fs->last_clst;				/* Start at suggested cluster if it is valid */
   1a8a0:	9b03      	ldr	r3, [sp, #12]
   1a8a2:	2b01      	cmp	r3, #1
   1a8a4:	d003      	beq.n	1a8ae <create_chain+0xb2>
   1a8a6:	9b03      	ldr	r3, [sp, #12]
   1a8a8:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   1a8ac:	d101      	bne.n	1a8b2 <create_chain+0xb6>
   1a8ae:	9c03      	ldr	r4, [sp, #12]
   1a8b0:	e07b      	b.n	1a9aa <create_chain+0x1ae>
				if (cs >= 2 && cs < fs->n_fatent) scl = cs;
   1a8b2:	9b03      	ldr	r3, [sp, #12]
   1a8b4:	2b00      	cmp	r3, #0
   1a8b6:	d00e      	beq.n	1a8d6 <create_chain+0xda>
				ncl = 0;
   1a8b8:	9b04      	ldr	r3, [sp, #16]
   1a8ba:	68db      	ldr	r3, [r3, #12]
   1a8bc:	9303      	str	r3, [sp, #12]
			}
   1a8be:	9b03      	ldr	r3, [sp, #12]
   1a8c0:	2b01      	cmp	r3, #1
   1a8c2:	d906      	bls.n	1a8d2 <create_chain+0xd6>
   1a8c4:	9b04      	ldr	r3, [sp, #16]
   1a8c6:	695b      	ldr	r3, [r3, #20]
   1a8c8:	9a03      	ldr	r2, [sp, #12]
   1a8ca:	429a      	cmp	r2, r3
   1a8cc:	d201      	bcs.n	1a8d2 <create_chain+0xd6>
   1a8ce:	9b03      	ldr	r3, [sp, #12]
   1a8d0:	9306      	str	r3, [sp, #24]
		}
   1a8d2:	2300      	movs	r3, #0
   1a8d4:	9307      	str	r3, [sp, #28]
		if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
			ncl = scl;	/* Start cluster */
			for (;;) {
   1a8d6:	9b07      	ldr	r3, [sp, #28]
   1a8d8:	2b00      	cmp	r3, #0
   1a8da:	d129      	bne.n	1a930 <create_chain+0x134>
				ncl++;							/* Next cluster */
   1a8dc:	9b06      	ldr	r3, [sp, #24]
   1a8de:	9307      	str	r3, [sp, #28]
				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
					ncl = 2;
   1a8e0:	9b07      	ldr	r3, [sp, #28]
   1a8e2:	3301      	adds	r3, #1
   1a8e4:	9307      	str	r3, [sp, #28]
					if (ncl > scl) return 0;	/* No free cluster found? */
   1a8e6:	9b04      	ldr	r3, [sp, #16]
   1a8e8:	695b      	ldr	r3, [r3, #20]
   1a8ea:	9a07      	ldr	r2, [sp, #28]
   1a8ec:	429a      	cmp	r2, r3
   1a8ee:	d307      	bcc.n	1a900 <create_chain+0x104>
				}
   1a8f0:	2302      	movs	r3, #2
   1a8f2:	9307      	str	r3, [sp, #28]
				cs = get_fat(obj, ncl);			/* Get the cluster status */
   1a8f4:	9a07      	ldr	r2, [sp, #28]
   1a8f6:	9b06      	ldr	r3, [sp, #24]
   1a8f8:	429a      	cmp	r2, r3
   1a8fa:	d901      	bls.n	1a900 <create_chain+0x104>
   1a8fc:	2400      	movs	r4, #0
   1a8fe:	e054      	b.n	1a9aa <create_chain+0x1ae>
				if (cs == 0) break;				/* Found a free cluster? */
				if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
   1a900:	9907      	ldr	r1, [sp, #28]
   1a902:	9801      	ldr	r0, [sp, #4]
   1a904:	f7ff fd52 	bl	1a3ac <get_fat>
   1a908:	9003      	str	r0, [sp, #12]
				if (ncl == scl) return 0;		/* No free cluster found? */
   1a90a:	9b03      	ldr	r3, [sp, #12]
   1a90c:	2b00      	cmp	r3, #0
   1a90e:	d00e      	beq.n	1a92e <create_chain+0x132>
			}
   1a910:	9b03      	ldr	r3, [sp, #12]
   1a912:	2b01      	cmp	r3, #1
   1a914:	d003      	beq.n	1a91e <create_chain+0x122>
   1a916:	9b03      	ldr	r3, [sp, #12]
   1a918:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   1a91c:	d101      	bne.n	1a922 <create_chain+0x126>
   1a91e:	9c03      	ldr	r4, [sp, #12]
   1a920:	e043      	b.n	1a9aa <create_chain+0x1ae>
		}
   1a922:	9a07      	ldr	r2, [sp, #28]
   1a924:	9b06      	ldr	r3, [sp, #24]
   1a926:	429a      	cmp	r2, r3
   1a928:	d1da      	bne.n	1a8e0 <create_chain+0xe4>
   1a92a:	2400      	movs	r4, #0
   1a92c:	e03d      	b.n	1a9aa <create_chain+0x1ae>
				if (ncl == scl) return 0;		/* No free cluster found? */
   1a92e:	bf00      	nop
		res = put_fat(fs, ncl, 0xFFFFFFFF);		/* Mark the new cluster 'EOC' */
		if (res == FR_OK && clst != 0) {
			res = put_fat(fs, clst, ncl);		/* Link it from the previous one if needed */
   1a930:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1a934:	9907      	ldr	r1, [sp, #28]
   1a936:	9804      	ldr	r0, [sp, #16]
   1a938:	f7ff fdea 	bl	1a510 <put_fat>
   1a93c:	4603      	mov	r3, r0
   1a93e:	f88d 3017 	strb.w	r3, [sp, #23]
		}
   1a942:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1a946:	2b00      	cmp	r3, #0
   1a948:	d10a      	bne.n	1a960 <create_chain+0x164>
   1a94a:	9b00      	ldr	r3, [sp, #0]
   1a94c:	2b00      	cmp	r3, #0
   1a94e:	d007      	beq.n	1a960 <create_chain+0x164>
	}
   1a950:	9a07      	ldr	r2, [sp, #28]
   1a952:	9900      	ldr	r1, [sp, #0]
   1a954:	9804      	ldr	r0, [sp, #16]
   1a956:	f7ff fddb 	bl	1a510 <put_fat>
   1a95a:	4603      	mov	r3, r0
   1a95c:	f88d 3017 	strb.w	r3, [sp, #23]

	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
		fs->last_clst = ncl;
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
   1a960:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1a964:	2b00      	cmp	r3, #0
   1a966:	d116      	bne.n	1a996 <create_chain+0x19a>
		fs->fsi_flag |= 1;
   1a968:	9b04      	ldr	r3, [sp, #16]
   1a96a:	9a07      	ldr	r2, [sp, #28]
   1a96c:	60da      	str	r2, [r3, #12]
	} else {
   1a96e:	9b04      	ldr	r3, [sp, #16]
   1a970:	691a      	ldr	r2, [r3, #16]
   1a972:	9b04      	ldr	r3, [sp, #16]
   1a974:	695b      	ldr	r3, [r3, #20]
   1a976:	3b02      	subs	r3, #2
   1a978:	429a      	cmp	r2, r3
   1a97a:	d804      	bhi.n	1a986 <create_chain+0x18a>
   1a97c:	9b04      	ldr	r3, [sp, #16]
   1a97e:	691b      	ldr	r3, [r3, #16]
   1a980:	1e5a      	subs	r2, r3, #1
   1a982:	9b04      	ldr	r3, [sp, #16]
   1a984:	611a      	str	r2, [r3, #16]
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
   1a986:	9b04      	ldr	r3, [sp, #16]
   1a988:	791b      	ldrb	r3, [r3, #4]
   1a98a:	f043 0301 	orr.w	r3, r3, #1
   1a98e:	b2da      	uxtb	r2, r3
   1a990:	9b04      	ldr	r3, [sp, #16]
   1a992:	711a      	strb	r2, [r3, #4]
   1a994:	e008      	b.n	1a9a8 <create_chain+0x1ac>
	}

   1a996:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1a99a:	2b01      	cmp	r3, #1
   1a99c:	d102      	bne.n	1a9a4 <create_chain+0x1a8>
   1a99e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1a9a2:	e000      	b.n	1a9a6 <create_chain+0x1aa>
   1a9a4:	2301      	movs	r3, #1
   1a9a6:	9307      	str	r3, [sp, #28]
	return ncl;		/* Return new cluster number or error status */
}

   1a9a8:	9c07      	ldr	r4, [sp, #28]
   1a9aa:	462b      	mov	r3, r5
   1a9ac:	4619      	mov	r1, r3
   1a9ae:	4803      	ldr	r0, [pc, #12]	; (1a9bc <create_chain+0x1c0>)
   1a9b0:	f7fb ffb4 	bl	1691c <__cyg_profile_func_exit>
   1a9b4:	4623      	mov	r3, r4
#endif /* !FF_FS_READONLY */
   1a9b6:	4618      	mov	r0, r3
   1a9b8:	b009      	add	sp, #36	; 0x24
   1a9ba:	bd30      	pop	{r4, r5, pc}
   1a9bc:	0001a7fd 	.word	0x0001a7fd

0001a9c0 <dir_clear>:
	FATFS *fs,		/* Filesystem object */
	DWORD clst		/* Directory table to clear */
)
{
	DWORD sect;
	UINT n, szb;
   1a9c0:	b530      	push	{r4, r5, lr}
   1a9c2:	b087      	sub	sp, #28
   1a9c4:	4675      	mov	r5, lr
   1a9c6:	9001      	str	r0, [sp, #4]
   1a9c8:	9100      	str	r1, [sp, #0]
   1a9ca:	462b      	mov	r3, r5
   1a9cc:	4619      	mov	r1, r3
   1a9ce:	4826      	ldr	r0, [pc, #152]	; (1aa68 <dir_clear+0xa8>)
   1a9d0:	f7fb ff90 	bl	168f4 <__cyg_profile_func_enter>
	BYTE *ibuf;


	if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
	sect = clst2sect(fs, clst);		/* Top of the cluster */
	fs->winsect = sect;				/* Set window to top of the cluster */
   1a9d4:	9801      	ldr	r0, [sp, #4]
   1a9d6:	f7ff fbb7 	bl	1a148 <sync_window>
   1a9da:	4603      	mov	r3, r0
   1a9dc:	2b00      	cmp	r3, #0
   1a9de:	d001      	beq.n	1a9e4 <dir_clear+0x24>
   1a9e0:	2401      	movs	r4, #1
   1a9e2:	e037      	b.n	1aa54 <dir_clear+0x94>
	mem_set(fs->win, 0, sizeof fs->win);	/* Clear window buffer */
   1a9e4:	9900      	ldr	r1, [sp, #0]
   1a9e6:	9801      	ldr	r0, [sp, #4]
   1a9e8:	f7ff fcb6 	bl	1a358 <clst2sect>
   1a9ec:	9004      	str	r0, [sp, #16]
#if FF_USE_LFN == 3		/* Quick table clear by using multi-secter write */
   1a9ee:	9b01      	ldr	r3, [sp, #4]
   1a9f0:	9a04      	ldr	r2, [sp, #16]
   1a9f2:	62da      	str	r2, [r3, #44]	; 0x2c
	/* Allocate a temporary buffer */
   1a9f4:	9b01      	ldr	r3, [sp, #4]
   1a9f6:	3330      	adds	r3, #48	; 0x30
   1a9f8:	f44f 7200 	mov.w	r2, #512	; 0x200
   1a9fc:	2100      	movs	r1, #0
   1a9fe:	4618      	mov	r0, r3
   1aa00:	f7ff faba 	bl	19f78 <mem_set>
	} else
#endif
	{
		ibuf = fs->win; szb = 1;	/* Use window buffer (many single-sector writes may take a time) */
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
	}
   1aa04:	9b01      	ldr	r3, [sp, #4]
   1aa06:	3330      	adds	r3, #48	; 0x30
   1aa08:	9303      	str	r3, [sp, #12]
   1aa0a:	2301      	movs	r3, #1
   1aa0c:	9302      	str	r3, [sp, #8]
	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
   1aa0e:	2300      	movs	r3, #0
   1aa10:	9305      	str	r3, [sp, #20]
   1aa12:	e003      	b.n	1aa1c <dir_clear+0x5c>
   1aa14:	9a05      	ldr	r2, [sp, #20]
   1aa16:	9b02      	ldr	r3, [sp, #8]
   1aa18:	4413      	add	r3, r2
   1aa1a:	9305      	str	r3, [sp, #20]
   1aa1c:	9b01      	ldr	r3, [sp, #4]
   1aa1e:	895b      	ldrh	r3, [r3, #10]
   1aa20:	461a      	mov	r2, r3
   1aa22:	9b05      	ldr	r3, [sp, #20]
   1aa24:	4293      	cmp	r3, r2
   1aa26:	d20b      	bcs.n	1aa40 <dir_clear+0x80>
   1aa28:	9b01      	ldr	r3, [sp, #4]
   1aa2a:	7858      	ldrb	r0, [r3, #1]
   1aa2c:	9a04      	ldr	r2, [sp, #16]
   1aa2e:	9b05      	ldr	r3, [sp, #20]
   1aa30:	441a      	add	r2, r3
   1aa32:	9b02      	ldr	r3, [sp, #8]
   1aa34:	9903      	ldr	r1, [sp, #12]
   1aa36:	f7ff f947 	bl	19cc8 <disk_write>
   1aa3a:	4603      	mov	r3, r0
   1aa3c:	2b00      	cmp	r3, #0
   1aa3e:	d0e9      	beq.n	1aa14 <dir_clear+0x54>
}
#endif	/* !FF_FS_READONLY */
   1aa40:	9b01      	ldr	r3, [sp, #4]
   1aa42:	895b      	ldrh	r3, [r3, #10]
   1aa44:	461a      	mov	r2, r3
   1aa46:	9b05      	ldr	r3, [sp, #20]
   1aa48:	4293      	cmp	r3, r2
   1aa4a:	bf14      	ite	ne
   1aa4c:	2301      	movne	r3, #1
   1aa4e:	2300      	moveq	r3, #0
   1aa50:	b2db      	uxtb	r3, r3
   1aa52:	461c      	mov	r4, r3
   1aa54:	462b      	mov	r3, r5
   1aa56:	4619      	mov	r1, r3
   1aa58:	4803      	ldr	r0, [pc, #12]	; (1aa68 <dir_clear+0xa8>)
   1aa5a:	f7fb ff5f 	bl	1691c <__cyg_profile_func_exit>
   1aa5e:	4623      	mov	r3, r4

   1aa60:	4618      	mov	r0, r3
   1aa62:	b007      	add	sp, #28
   1aa64:	bd30      	pop	{r4, r5, pc}
   1aa66:	bf00      	nop
   1aa68:	0001a9c1 	.word	0x0001a9c1

0001aa6c <dir_sdi>:
	DIR* dp,		/* Pointer to directory object */
	DWORD ofs		/* Offset of directory table */
)
{
	DWORD csz, clst;
	FATFS *fs = dp->obj.fs;
   1aa6c:	b530      	push	{r4, r5, lr}
   1aa6e:	b087      	sub	sp, #28
   1aa70:	4675      	mov	r5, lr
   1aa72:	9001      	str	r0, [sp, #4]
   1aa74:	9100      	str	r1, [sp, #0]
   1aa76:	462b      	mov	r3, r5
   1aa78:	4619      	mov	r1, r3
   1aa7a:	483f      	ldr	r0, [pc, #252]	; (1ab78 <dir_sdi+0x10c>)
   1aa7c:	f7fb ff3a 	bl	168f4 <__cyg_profile_func_enter>


   1aa80:	9b01      	ldr	r3, [sp, #4]
   1aa82:	681b      	ldr	r3, [r3, #0]
   1aa84:	9304      	str	r3, [sp, #16]
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
		return FR_INT_ERR;
	}
   1aa86:	9b00      	ldr	r3, [sp, #0]
   1aa88:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
   1aa8c:	d204      	bcs.n	1aa98 <dir_sdi+0x2c>
   1aa8e:	9b00      	ldr	r3, [sp, #0]
   1aa90:	f003 031f 	and.w	r3, r3, #31
   1aa94:	2b00      	cmp	r3, #0
   1aa96:	d001      	beq.n	1aa9c <dir_sdi+0x30>
	dp->dptr = ofs;				/* Set current offset */
   1aa98:	2402      	movs	r4, #2
   1aa9a:	e063      	b.n	1ab64 <dir_sdi+0xf8>
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
   1aa9c:	9b01      	ldr	r3, [sp, #4]
   1aa9e:	9a00      	ldr	r2, [sp, #0]
   1aaa0:	611a      	str	r2, [r3, #16]
		clst = fs->dirbase;
   1aaa2:	9b01      	ldr	r3, [sp, #4]
   1aaa4:	689b      	ldr	r3, [r3, #8]
   1aaa6:	9305      	str	r3, [sp, #20]
		if (FF_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
   1aaa8:	9b05      	ldr	r3, [sp, #20]
   1aaaa:	2b00      	cmp	r3, #0
   1aaac:	d106      	bne.n	1aabc <dir_sdi+0x50>
   1aaae:	9b04      	ldr	r3, [sp, #16]
   1aab0:	781b      	ldrb	r3, [r3, #0]
   1aab2:	2b02      	cmp	r3, #2
   1aab4:	d902      	bls.n	1aabc <dir_sdi+0x50>
	}
   1aab6:	9b04      	ldr	r3, [sp, #16]
   1aab8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1aaba:	9305      	str	r3, [sp, #20]

	if (clst == 0) {	/* Static table (root-directory on the FAT volume) */
		if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
		dp->sect = fs->dirbase;
   1aabc:	9b05      	ldr	r3, [sp, #20]
   1aabe:	2b00      	cmp	r3, #0
   1aac0:	d10c      	bne.n	1aadc <dir_sdi+0x70>

   1aac2:	9b00      	ldr	r3, [sp, #0]
   1aac4:	095b      	lsrs	r3, r3, #5
   1aac6:	9a04      	ldr	r2, [sp, #16]
   1aac8:	8912      	ldrh	r2, [r2, #8]
   1aaca:	4293      	cmp	r3, r2
   1aacc:	d301      	bcc.n	1aad2 <dir_sdi+0x66>
   1aace:	2402      	movs	r4, #2
   1aad0:	e048      	b.n	1ab64 <dir_sdi+0xf8>
	} else {			/* Dynamic table (sub-directory or root-directory on the FAT32/exFAT volume) */
   1aad2:	9b04      	ldr	r3, [sp, #16]
   1aad4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   1aad6:	9b01      	ldr	r3, [sp, #4]
   1aad8:	619a      	str	r2, [r3, #24]
   1aada:	e029      	b.n	1ab30 <dir_sdi+0xc4>
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
		while (ofs >= csz) {				/* Follow cluster chain */
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
   1aadc:	9b04      	ldr	r3, [sp, #16]
   1aade:	895b      	ldrh	r3, [r3, #10]
   1aae0:	025b      	lsls	r3, r3, #9
   1aae2:	9303      	str	r3, [sp, #12]
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   1aae4:	e019      	b.n	1ab1a <dir_sdi+0xae>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
   1aae6:	9b01      	ldr	r3, [sp, #4]
   1aae8:	9905      	ldr	r1, [sp, #20]
   1aaea:	4618      	mov	r0, r3
   1aaec:	f7ff fc5e 	bl	1a3ac <get_fat>
   1aaf0:	9005      	str	r0, [sp, #20]
			ofs -= csz;
   1aaf2:	9b05      	ldr	r3, [sp, #20]
   1aaf4:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   1aaf8:	d101      	bne.n	1aafe <dir_sdi+0x92>
   1aafa:	2401      	movs	r4, #1
   1aafc:	e032      	b.n	1ab64 <dir_sdi+0xf8>
		}
   1aafe:	9b05      	ldr	r3, [sp, #20]
   1ab00:	2b01      	cmp	r3, #1
   1ab02:	d904      	bls.n	1ab0e <dir_sdi+0xa2>
   1ab04:	9b04      	ldr	r3, [sp, #16]
   1ab06:	695b      	ldr	r3, [r3, #20]
   1ab08:	9a05      	ldr	r2, [sp, #20]
   1ab0a:	429a      	cmp	r2, r3
   1ab0c:	d301      	bcc.n	1ab12 <dir_sdi+0xa6>
   1ab0e:	2402      	movs	r4, #2
   1ab10:	e028      	b.n	1ab64 <dir_sdi+0xf8>
		dp->sect = clst2sect(fs, clst);
   1ab12:	9a00      	ldr	r2, [sp, #0]
   1ab14:	9b03      	ldr	r3, [sp, #12]
   1ab16:	1ad3      	subs	r3, r2, r3
   1ab18:	9300      	str	r3, [sp, #0]
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   1ab1a:	9a00      	ldr	r2, [sp, #0]
   1ab1c:	9b03      	ldr	r3, [sp, #12]
   1ab1e:	429a      	cmp	r2, r3
   1ab20:	d2e1      	bcs.n	1aae6 <dir_sdi+0x7a>
	}
	dp->clust = clst;					/* Current cluster# */
   1ab22:	9905      	ldr	r1, [sp, #20]
   1ab24:	9804      	ldr	r0, [sp, #16]
   1ab26:	f7ff fc17 	bl	1a358 <clst2sect>
   1ab2a:	4602      	mov	r2, r0
   1ab2c:	9b01      	ldr	r3, [sp, #4]
   1ab2e:	619a      	str	r2, [r3, #24]
	if (dp->sect == 0) return FR_INT_ERR;
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
   1ab30:	9b01      	ldr	r3, [sp, #4]
   1ab32:	9a05      	ldr	r2, [sp, #20]
   1ab34:	615a      	str	r2, [r3, #20]
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
   1ab36:	9b01      	ldr	r3, [sp, #4]
   1ab38:	699b      	ldr	r3, [r3, #24]
   1ab3a:	2b00      	cmp	r3, #0
   1ab3c:	d101      	bne.n	1ab42 <dir_sdi+0xd6>
   1ab3e:	2402      	movs	r4, #2
   1ab40:	e010      	b.n	1ab64 <dir_sdi+0xf8>

   1ab42:	9b01      	ldr	r3, [sp, #4]
   1ab44:	699a      	ldr	r2, [r3, #24]
   1ab46:	9b00      	ldr	r3, [sp, #0]
   1ab48:	0a5b      	lsrs	r3, r3, #9
   1ab4a:	441a      	add	r2, r3
   1ab4c:	9b01      	ldr	r3, [sp, #4]
   1ab4e:	619a      	str	r2, [r3, #24]
	return FR_OK;
   1ab50:	9b04      	ldr	r3, [sp, #16]
   1ab52:	f103 0230 	add.w	r2, r3, #48	; 0x30
   1ab56:	9b00      	ldr	r3, [sp, #0]
   1ab58:	f3c3 0308 	ubfx	r3, r3, #0, #9
   1ab5c:	441a      	add	r2, r3
   1ab5e:	9b01      	ldr	r3, [sp, #4]
   1ab60:	61da      	str	r2, [r3, #28]
}

   1ab62:	2400      	movs	r4, #0
   1ab64:	462b      	mov	r3, r5
   1ab66:	4619      	mov	r1, r3
   1ab68:	4803      	ldr	r0, [pc, #12]	; (1ab78 <dir_sdi+0x10c>)
   1ab6a:	f7fb fed7 	bl	1691c <__cyg_profile_func_exit>
   1ab6e:	4623      	mov	r3, r4

   1ab70:	4618      	mov	r0, r3
   1ab72:	b007      	add	sp, #28
   1ab74:	bd30      	pop	{r4, r5, pc}
   1ab76:	bf00      	nop
   1ab78:	0001aa6d 	.word	0x0001aa6d

0001ab7c <dir_next>:
	DIR* dp,				/* Pointer to the directory object */
	int stretch				/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
	DWORD ofs, clst;
	FATFS *fs = dp->obj.fs;
   1ab7c:	b530      	push	{r4, r5, lr}
   1ab7e:	b087      	sub	sp, #28
   1ab80:	4675      	mov	r5, lr
   1ab82:	9001      	str	r0, [sp, #4]
   1ab84:	9100      	str	r1, [sp, #0]
   1ab86:	462b      	mov	r3, r5
   1ab88:	4619      	mov	r1, r3
   1ab8a:	484c      	ldr	r0, [pc, #304]	; (1acbc <dir_next+0x140>)
   1ab8c:	f7fb feb2 	bl	168f4 <__cyg_profile_func_enter>


   1ab90:	9b01      	ldr	r3, [sp, #4]
   1ab92:	681b      	ldr	r3, [r3, #0]
   1ab94:	9304      	str	r3, [sp, #16]
	ofs = dp->dptr + SZDIRE;	/* Next entry */
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
   1ab96:	9b01      	ldr	r3, [sp, #4]
   1ab98:	691b      	ldr	r3, [r3, #16]
   1ab9a:	3320      	adds	r3, #32
   1ab9c:	9303      	str	r3, [sp, #12]

   1ab9e:	9b03      	ldr	r3, [sp, #12]
   1aba0:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
   1aba4:	d302      	bcc.n	1abac <dir_next+0x30>
   1aba6:	9b01      	ldr	r3, [sp, #4]
   1aba8:	2200      	movs	r2, #0
   1abaa:	619a      	str	r2, [r3, #24]
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
   1abac:	9b01      	ldr	r3, [sp, #4]
   1abae:	699b      	ldr	r3, [r3, #24]
   1abb0:	2b00      	cmp	r3, #0
   1abb2:	d101      	bne.n	1abb8 <dir_next+0x3c>
   1abb4:	2404      	movs	r4, #4
   1abb6:	e078      	b.n	1acaa <dir_next+0x12e>
		dp->sect++;				/* Next sector */

   1abb8:	9b03      	ldr	r3, [sp, #12]
   1abba:	f3c3 0308 	ubfx	r3, r3, #0, #9
   1abbe:	2b00      	cmp	r3, #0
   1abc0:	d166      	bne.n	1ac90 <dir_next+0x114>
		if (dp->clust == 0) {	/* Static table */
   1abc2:	9b01      	ldr	r3, [sp, #4]
   1abc4:	699b      	ldr	r3, [r3, #24]
   1abc6:	1c5a      	adds	r2, r3, #1
   1abc8:	9b01      	ldr	r3, [sp, #4]
   1abca:	619a      	str	r2, [r3, #24]
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
				dp->sect = 0; return FR_NO_FILE;
   1abcc:	9b01      	ldr	r3, [sp, #4]
   1abce:	695b      	ldr	r3, [r3, #20]
   1abd0:	2b00      	cmp	r3, #0
   1abd2:	d10a      	bne.n	1abea <dir_next+0x6e>
			}
   1abd4:	9b03      	ldr	r3, [sp, #12]
   1abd6:	095b      	lsrs	r3, r3, #5
   1abd8:	9a04      	ldr	r2, [sp, #16]
   1abda:	8912      	ldrh	r2, [r2, #8]
   1abdc:	4293      	cmp	r3, r2
   1abde:	d357      	bcc.n	1ac90 <dir_next+0x114>
		}
   1abe0:	9b01      	ldr	r3, [sp, #4]
   1abe2:	2200      	movs	r2, #0
   1abe4:	619a      	str	r2, [r3, #24]
   1abe6:	2404      	movs	r4, #4
   1abe8:	e05f      	b.n	1acaa <dir_next+0x12e>
		else {					/* Dynamic table */
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
   1abea:	9b03      	ldr	r3, [sp, #12]
   1abec:	0a5b      	lsrs	r3, r3, #9
   1abee:	9a04      	ldr	r2, [sp, #16]
   1abf0:	8952      	ldrh	r2, [r2, #10]
   1abf2:	3a01      	subs	r2, #1
   1abf4:	4013      	ands	r3, r2
   1abf6:	2b00      	cmp	r3, #0
   1abf8:	d14a      	bne.n	1ac90 <dir_next+0x114>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   1abfa:	9a01      	ldr	r2, [sp, #4]
   1abfc:	9b01      	ldr	r3, [sp, #4]
   1abfe:	695b      	ldr	r3, [r3, #20]
   1ac00:	4619      	mov	r1, r3
   1ac02:	4610      	mov	r0, r2
   1ac04:	f7ff fbd2 	bl	1a3ac <get_fat>
   1ac08:	9005      	str	r0, [sp, #20]
				if (clst >= fs->n_fatent) {					/* It reached end of dynamic table */
   1ac0a:	9b05      	ldr	r3, [sp, #20]
   1ac0c:	2b01      	cmp	r3, #1
   1ac0e:	d801      	bhi.n	1ac14 <dir_next+0x98>
   1ac10:	2402      	movs	r4, #2
   1ac12:	e04a      	b.n	1acaa <dir_next+0x12e>
#if !FF_FS_READONLY
   1ac14:	9b05      	ldr	r3, [sp, #20]
   1ac16:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   1ac1a:	d101      	bne.n	1ac20 <dir_next+0xa4>
   1ac1c:	2401      	movs	r4, #1
   1ac1e:	e044      	b.n	1acaa <dir_next+0x12e>
					if (!stretch) {								/* If no stretch, report EOT */
   1ac20:	9b04      	ldr	r3, [sp, #16]
   1ac22:	695b      	ldr	r3, [r3, #20]
   1ac24:	9a05      	ldr	r2, [sp, #20]
   1ac26:	429a      	cmp	r2, r3
   1ac28:	d328      	bcc.n	1ac7c <dir_next+0x100>
						dp->sect = 0; return FR_NO_FILE;
					}
   1ac2a:	9b00      	ldr	r3, [sp, #0]
   1ac2c:	2b00      	cmp	r3, #0
   1ac2e:	d104      	bne.n	1ac3a <dir_next+0xbe>
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
   1ac30:	9b01      	ldr	r3, [sp, #4]
   1ac32:	2200      	movs	r2, #0
   1ac34:	619a      	str	r2, [r3, #24]
   1ac36:	2404      	movs	r4, #4
   1ac38:	e037      	b.n	1acaa <dir_next+0x12e>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
   1ac3a:	9a01      	ldr	r2, [sp, #4]
   1ac3c:	9b01      	ldr	r3, [sp, #4]
   1ac3e:	695b      	ldr	r3, [r3, #20]
   1ac40:	4619      	mov	r1, r3
   1ac42:	4610      	mov	r0, r2
   1ac44:	f7ff fdda 	bl	1a7fc <create_chain>
   1ac48:	9005      	str	r0, [sp, #20]
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   1ac4a:	9b05      	ldr	r3, [sp, #20]
   1ac4c:	2b00      	cmp	r3, #0
   1ac4e:	d101      	bne.n	1ac54 <dir_next+0xd8>
   1ac50:	2407      	movs	r4, #7
   1ac52:	e02a      	b.n	1acaa <dir_next+0x12e>
					if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;	/* Clean up the stretched table */
   1ac54:	9b05      	ldr	r3, [sp, #20]
   1ac56:	2b01      	cmp	r3, #1
   1ac58:	d101      	bne.n	1ac5e <dir_next+0xe2>
   1ac5a:	2402      	movs	r4, #2
   1ac5c:	e025      	b.n	1acaa <dir_next+0x12e>
					if (FF_FS_EXFAT) dp->obj.stat |= 4;			/* exFAT: The directory has been stretched */
   1ac5e:	9b05      	ldr	r3, [sp, #20]
   1ac60:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   1ac64:	d101      	bne.n	1ac6a <dir_next+0xee>
   1ac66:	2401      	movs	r4, #1
   1ac68:	e01f      	b.n	1acaa <dir_next+0x12e>
#else
   1ac6a:	9905      	ldr	r1, [sp, #20]
   1ac6c:	9804      	ldr	r0, [sp, #16]
   1ac6e:	f7ff fea7 	bl	1a9c0 <dir_clear>
   1ac72:	4603      	mov	r3, r0
   1ac74:	2b00      	cmp	r3, #0
   1ac76:	d001      	beq.n	1ac7c <dir_next+0x100>
   1ac78:	2401      	movs	r4, #1
   1ac7a:	e016      	b.n	1acaa <dir_next+0x12e>
					dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dp->clust = clst;		/* Initialize data for new cluster */
				dp->sect = clst2sect(fs, clst);
			}
   1ac7c:	9b01      	ldr	r3, [sp, #4]
   1ac7e:	9a05      	ldr	r2, [sp, #20]
   1ac80:	615a      	str	r2, [r3, #20]
		}
   1ac82:	9905      	ldr	r1, [sp, #20]
   1ac84:	9804      	ldr	r0, [sp, #16]
   1ac86:	f7ff fb67 	bl	1a358 <clst2sect>
   1ac8a:	4602      	mov	r2, r0
   1ac8c:	9b01      	ldr	r3, [sp, #4]
   1ac8e:	619a      	str	r2, [r3, #24]
	}
	dp->dptr = ofs;						/* Current entry */
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */

   1ac90:	9b01      	ldr	r3, [sp, #4]
   1ac92:	9a03      	ldr	r2, [sp, #12]
   1ac94:	611a      	str	r2, [r3, #16]
	return FR_OK;
   1ac96:	9b04      	ldr	r3, [sp, #16]
   1ac98:	f103 0230 	add.w	r2, r3, #48	; 0x30
   1ac9c:	9b03      	ldr	r3, [sp, #12]
   1ac9e:	f3c3 0308 	ubfx	r3, r3, #0, #9
   1aca2:	441a      	add	r2, r3
   1aca4:	9b01      	ldr	r3, [sp, #4]
   1aca6:	61da      	str	r2, [r3, #28]
}

   1aca8:	2400      	movs	r4, #0
   1acaa:	462b      	mov	r3, r5
   1acac:	4619      	mov	r1, r3
   1acae:	4803      	ldr	r0, [pc, #12]	; (1acbc <dir_next+0x140>)
   1acb0:	f7fb fe34 	bl	1691c <__cyg_profile_func_exit>
   1acb4:	4623      	mov	r3, r4

   1acb6:	4618      	mov	r0, r3
   1acb8:	b007      	add	sp, #28
   1acba:	bd30      	pop	{r4, r5, pc}
   1acbc:	0001ab7d 	.word	0x0001ab7d

0001acc0 <dir_alloc>:
	DIR* dp,				/* Pointer to the directory object */
	UINT nent				/* Number of contiguous entries to allocate */
)
{
	FRESULT res;
	UINT n;
   1acc0:	b530      	push	{r4, r5, lr}
   1acc2:	b087      	sub	sp, #28
   1acc4:	4675      	mov	r5, lr
   1acc6:	9001      	str	r0, [sp, #4]
   1acc8:	9100      	str	r1, [sp, #0]
   1acca:	462b      	mov	r3, r5
   1accc:	4619      	mov	r1, r3
   1acce:	4829      	ldr	r0, [pc, #164]	; (1ad74 <dir_alloc+0xb4>)
   1acd0:	f7fb fe10 	bl	168f4 <__cyg_profile_func_enter>
	FATFS *fs = dp->obj.fs;


   1acd4:	9b01      	ldr	r3, [sp, #4]
   1acd6:	681b      	ldr	r3, [r3, #0]
   1acd8:	9303      	str	r3, [sp, #12]
	res = dir_sdi(dp, 0);
	if (res == FR_OK) {
		n = 0;
   1acda:	2100      	movs	r1, #0
   1acdc:	9801      	ldr	r0, [sp, #4]
   1acde:	f7ff fec5 	bl	1aa6c <dir_sdi>
   1ace2:	4603      	mov	r3, r0
   1ace4:	f88d 3017 	strb.w	r3, [sp, #23]
		do {
   1ace8:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1acec:	2b00      	cmp	r3, #0
   1acee:	d12f      	bne.n	1ad50 <dir_alloc+0x90>
			res = move_window(fs, dp->sect);
   1acf0:	2300      	movs	r3, #0
   1acf2:	9304      	str	r3, [sp, #16]
			if (res != FR_OK) break;
#if FF_FS_EXFAT
   1acf4:	9b01      	ldr	r3, [sp, #4]
   1acf6:	699b      	ldr	r3, [r3, #24]
   1acf8:	4619      	mov	r1, r3
   1acfa:	9803      	ldr	r0, [sp, #12]
   1acfc:	f7ff fa70 	bl	1a1e0 <move_window>
   1ad00:	4603      	mov	r3, r0
   1ad02:	f88d 3017 	strb.w	r3, [sp, #23]
			if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {
   1ad06:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1ad0a:	2b00      	cmp	r3, #0
   1ad0c:	d11f      	bne.n	1ad4e <dir_alloc+0x8e>
#else
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
#endif
				if (++n == nent) break;	/* A block of contiguous free entries is found */
   1ad0e:	9b01      	ldr	r3, [sp, #4]
   1ad10:	69db      	ldr	r3, [r3, #28]
   1ad12:	781b      	ldrb	r3, [r3, #0]
   1ad14:	2be5      	cmp	r3, #229	; 0xe5
   1ad16:	d004      	beq.n	1ad22 <dir_alloc+0x62>
   1ad18:	9b01      	ldr	r3, [sp, #4]
   1ad1a:	69db      	ldr	r3, [r3, #28]
   1ad1c:	781b      	ldrb	r3, [r3, #0]
   1ad1e:	2b00      	cmp	r3, #0
   1ad20:	d107      	bne.n	1ad32 <dir_alloc+0x72>
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
   1ad22:	9b04      	ldr	r3, [sp, #16]
   1ad24:	3301      	adds	r3, #1
   1ad26:	9304      	str	r3, [sp, #16]
   1ad28:	9a04      	ldr	r2, [sp, #16]
   1ad2a:	9b00      	ldr	r3, [sp, #0]
   1ad2c:	429a      	cmp	r2, r3
   1ad2e:	d102      	bne.n	1ad36 <dir_alloc+0x76>
   1ad30:	e00e      	b.n	1ad50 <dir_alloc+0x90>
			}
			res = dir_next(dp, 1);
   1ad32:	2300      	movs	r3, #0
   1ad34:	9304      	str	r3, [sp, #16]
		} while (res == FR_OK);	/* Next entry with table stretch enabled */
	}
   1ad36:	2101      	movs	r1, #1
   1ad38:	9801      	ldr	r0, [sp, #4]
   1ad3a:	f7ff ff1f 	bl	1ab7c <dir_next>
   1ad3e:	4603      	mov	r3, r0
   1ad40:	f88d 3017 	strb.w	r3, [sp, #23]

   1ad44:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1ad48:	2b00      	cmp	r3, #0
   1ad4a:	d0d3      	beq.n	1acf4 <dir_alloc+0x34>
   1ad4c:	e000      	b.n	1ad50 <dir_alloc+0x90>
			if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {
   1ad4e:	bf00      	nop
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
	return res;
}
   1ad50:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1ad54:	2b04      	cmp	r3, #4
   1ad56:	d102      	bne.n	1ad5e <dir_alloc+0x9e>
   1ad58:	2307      	movs	r3, #7
   1ad5a:	f88d 3017 	strb.w	r3, [sp, #23]

   1ad5e:	f89d 4017 	ldrb.w	r4, [sp, #23]
   1ad62:	462b      	mov	r3, r5
   1ad64:	4619      	mov	r1, r3
   1ad66:	4803      	ldr	r0, [pc, #12]	; (1ad74 <dir_alloc+0xb4>)
   1ad68:	f7fb fdd8 	bl	1691c <__cyg_profile_func_exit>
   1ad6c:	4623      	mov	r3, r4
#endif	/* !FF_FS_READONLY */
   1ad6e:	4618      	mov	r0, r3
   1ad70:	b007      	add	sp, #28
   1ad72:	bd30      	pop	{r4, r5, pc}
   1ad74:	0001acc1 	.word	0x0001acc1

0001ad78 <ld_clust>:
	FATFS* fs,			/* Pointer to the fs object */
	const BYTE* dir		/* Pointer to the key entry */
)
{
	DWORD cl;

   1ad78:	b530      	push	{r4, r5, lr}
   1ad7a:	b085      	sub	sp, #20
   1ad7c:	4675      	mov	r5, lr
   1ad7e:	9001      	str	r0, [sp, #4]
   1ad80:	9100      	str	r1, [sp, #0]
   1ad82:	462b      	mov	r3, r5
   1ad84:	4619      	mov	r1, r3
   1ad86:	4811      	ldr	r0, [pc, #68]	; (1adcc <ld_clust+0x54>)
   1ad88:	f7fb fdb4 	bl	168f4 <__cyg_profile_func_enter>
	cl = ld_word(dir + DIR_FstClusLO);
	if (fs->fs_type == FS_FAT32) {
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
   1ad8c:	9b00      	ldr	r3, [sp, #0]
   1ad8e:	331a      	adds	r3, #26
   1ad90:	4618      	mov	r0, r3
   1ad92:	f7ff f813 	bl	19dbc <ld_word>
   1ad96:	4603      	mov	r3, r0
   1ad98:	9303      	str	r3, [sp, #12]
	}
   1ad9a:	9b01      	ldr	r3, [sp, #4]
   1ad9c:	781b      	ldrb	r3, [r3, #0]
   1ad9e:	2b03      	cmp	r3, #3
   1ada0:	d109      	bne.n	1adb6 <ld_clust+0x3e>

   1ada2:	9b00      	ldr	r3, [sp, #0]
   1ada4:	3314      	adds	r3, #20
   1ada6:	4618      	mov	r0, r3
   1ada8:	f7ff f808 	bl	19dbc <ld_word>
   1adac:	4603      	mov	r3, r0
   1adae:	041b      	lsls	r3, r3, #16
   1adb0:	9a03      	ldr	r2, [sp, #12]
   1adb2:	4313      	orrs	r3, r2
   1adb4:	9303      	str	r3, [sp, #12]
	return cl;
}

   1adb6:	9c03      	ldr	r4, [sp, #12]
   1adb8:	462b      	mov	r3, r5
   1adba:	4619      	mov	r1, r3
   1adbc:	4803      	ldr	r0, [pc, #12]	; (1adcc <ld_clust+0x54>)
   1adbe:	f7fb fdad 	bl	1691c <__cyg_profile_func_exit>
   1adc2:	4623      	mov	r3, r4

   1adc4:	4618      	mov	r0, r3
   1adc6:	b005      	add	sp, #20
   1adc8:	bd30      	pop	{r4, r5, pc}
   1adca:	bf00      	nop
   1adcc:	0001ad79 	.word	0x0001ad79

0001add0 <st_clust>:
	BYTE* dir,	/* Pointer to the key entry */
	DWORD cl	/* Value to be set */
)
{
	st_word(dir + DIR_FstClusLO, (WORD)cl);
	if (fs->fs_type == FS_FAT32) {
   1add0:	b510      	push	{r4, lr}
   1add2:	b084      	sub	sp, #16
   1add4:	4674      	mov	r4, lr
   1add6:	9003      	str	r0, [sp, #12]
   1add8:	9102      	str	r1, [sp, #8]
   1adda:	9201      	str	r2, [sp, #4]
   1addc:	4623      	mov	r3, r4
   1adde:	4619      	mov	r1, r3
   1ade0:	4810      	ldr	r0, [pc, #64]	; (1ae24 <st_clust+0x54>)
   1ade2:	f7fb fd87 	bl	168f4 <__cyg_profile_func_enter>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
   1ade6:	9b02      	ldr	r3, [sp, #8]
   1ade8:	331a      	adds	r3, #26
   1adea:	9a01      	ldr	r2, [sp, #4]
   1adec:	b292      	uxth	r2, r2
   1adee:	4611      	mov	r1, r2
   1adf0:	4618      	mov	r0, r3
   1adf2:	f7ff f837 	bl	19e64 <st_word>
	}
   1adf6:	9b03      	ldr	r3, [sp, #12]
   1adf8:	781b      	ldrb	r3, [r3, #0]
   1adfa:	2b03      	cmp	r3, #3
   1adfc:	d109      	bne.n	1ae12 <st_clust+0x42>
}
   1adfe:	9b02      	ldr	r3, [sp, #8]
   1ae00:	f103 0214 	add.w	r2, r3, #20
   1ae04:	9b01      	ldr	r3, [sp, #4]
   1ae06:	0c1b      	lsrs	r3, r3, #16
   1ae08:	b29b      	uxth	r3, r3
   1ae0a:	4619      	mov	r1, r3
   1ae0c:	4610      	mov	r0, r2
   1ae0e:	f7ff f829 	bl	19e64 <st_word>
   1ae12:	4623      	mov	r3, r4
   1ae14:	4619      	mov	r1, r3
   1ae16:	4803      	ldr	r0, [pc, #12]	; (1ae24 <st_clust+0x54>)
   1ae18:	f7fb fd80 	bl	1691c <__cyg_profile_func_exit>
#endif

   1ae1c:	bf00      	nop
   1ae1e:	b004      	add	sp, #16
   1ae20:	bd10      	pop	{r4, pc}
   1ae22:	bf00      	nop
   1ae24:	0001add1 	.word	0x0001add1

0001ae28 <dir_read>:
	DIR* dp,		/* Pointer to the directory object */
	int vol			/* Filtered by 0:file/directory or 1:volume label */
)
{
	FRESULT res = FR_NO_FILE;
	FATFS *fs = dp->obj.fs;
   1ae28:	b530      	push	{r4, r5, lr}
   1ae2a:	b087      	sub	sp, #28
   1ae2c:	4675      	mov	r5, lr
   1ae2e:	9001      	str	r0, [sp, #4]
   1ae30:	9100      	str	r1, [sp, #0]
   1ae32:	462b      	mov	r3, r5
   1ae34:	4619      	mov	r1, r3
   1ae36:	4838      	ldr	r0, [pc, #224]	; (1af18 <dir_read+0xf0>)
   1ae38:	f7fb fd5c 	bl	168f4 <__cyg_profile_func_enter>
	BYTE attr, b;
   1ae3c:	2304      	movs	r3, #4
   1ae3e:	f88d 3017 	strb.w	r3, [sp, #23]
#if FF_USE_LFN
   1ae42:	9b01      	ldr	r3, [sp, #4]
   1ae44:	681b      	ldr	r3, [r3, #0]
   1ae46:	9304      	str	r3, [sp, #16]
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	while (dp->sect) {
		res = move_window(fs, dp->sect);
		if (res != FR_OK) break;
   1ae48:	e049      	b.n	1aede <dir_read+0xb6>
		b = dp->dir[DIR_Name];	/* Test for the entry type */
   1ae4a:	9b01      	ldr	r3, [sp, #4]
   1ae4c:	699b      	ldr	r3, [r3, #24]
   1ae4e:	4619      	mov	r1, r3
   1ae50:	9804      	ldr	r0, [sp, #16]
   1ae52:	f7ff f9c5 	bl	1a1e0 <move_window>
   1ae56:	4603      	mov	r3, r0
   1ae58:	f88d 3017 	strb.w	r3, [sp, #23]
		if (b == 0) {
   1ae5c:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1ae60:	2b00      	cmp	r3, #0
   1ae62:	d141      	bne.n	1aee8 <dir_read+0xc0>
			res = FR_NO_FILE; break; /* Reached to end of the directory */
   1ae64:	9b01      	ldr	r3, [sp, #4]
   1ae66:	69db      	ldr	r3, [r3, #28]
   1ae68:	781b      	ldrb	r3, [r3, #0]
   1ae6a:	f88d 300f 	strb.w	r3, [sp, #15]
		}
   1ae6e:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1ae72:	2b00      	cmp	r3, #0
   1ae74:	d103      	bne.n	1ae7e <dir_read+0x56>
#if FF_FS_EXFAT
   1ae76:	2304      	movs	r3, #4
   1ae78:	f88d 3017 	strb.w	r3, [sp, #23]
   1ae7c:	e039      	b.n	1aef2 <dir_read+0xca>
		} else
#endif
		{	/* On the FAT/FAT32 volume */
			dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
#if FF_USE_LFN		/* LFN configuration */
			if (b == DDEM || b == '.' || (int)((attr & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
   1ae7e:	9b01      	ldr	r3, [sp, #4]
   1ae80:	69db      	ldr	r3, [r3, #28]
   1ae82:	330b      	adds	r3, #11
   1ae84:	781b      	ldrb	r3, [r3, #0]
   1ae86:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   1ae8a:	f88d 300e 	strb.w	r3, [sp, #14]
   1ae8e:	9b01      	ldr	r3, [sp, #4]
   1ae90:	f89d 200e 	ldrb.w	r2, [sp, #14]
   1ae94:	719a      	strb	r2, [r3, #6]
				}
			}
#else		/* Non LFN configuration */
			if (b != DDEM && b != '.' && attr != AM_LFN && (int)((attr & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
				break;
			}
   1ae96:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1ae9a:	2be5      	cmp	r3, #229	; 0xe5
   1ae9c:	d014      	beq.n	1aec8 <dir_read+0xa0>
   1ae9e:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1aea2:	2b2e      	cmp	r3, #46	; 0x2e
   1aea4:	d010      	beq.n	1aec8 <dir_read+0xa0>
   1aea6:	f89d 300e 	ldrb.w	r3, [sp, #14]
   1aeaa:	2b0f      	cmp	r3, #15
   1aeac:	d00c      	beq.n	1aec8 <dir_read+0xa0>
   1aeae:	f89d 300e 	ldrb.w	r3, [sp, #14]
   1aeb2:	f023 0320 	bic.w	r3, r3, #32
   1aeb6:	2b08      	cmp	r3, #8
   1aeb8:	bf0c      	ite	eq
   1aeba:	2301      	moveq	r3, #1
   1aebc:	2300      	movne	r3, #0
   1aebe:	b2db      	uxtb	r3, r3
   1aec0:	461a      	mov	r2, r3
   1aec2:	9b00      	ldr	r3, [sp, #0]
   1aec4:	4293      	cmp	r3, r2
   1aec6:	d011      	beq.n	1aeec <dir_read+0xc4>
#endif
		}
		res = dir_next(dp, 0);		/* Next entry */
		if (res != FR_OK) break;
	}
   1aec8:	2100      	movs	r1, #0
   1aeca:	9801      	ldr	r0, [sp, #4]
   1aecc:	f7ff fe56 	bl	1ab7c <dir_next>
   1aed0:	4603      	mov	r3, r0
   1aed2:	f88d 3017 	strb.w	r3, [sp, #23]

   1aed6:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1aeda:	2b00      	cmp	r3, #0
   1aedc:	d108      	bne.n	1aef0 <dir_read+0xc8>
		if (res != FR_OK) break;
   1aede:	9b01      	ldr	r3, [sp, #4]
   1aee0:	699b      	ldr	r3, [r3, #24]
   1aee2:	2b00      	cmp	r3, #0
   1aee4:	d1b1      	bne.n	1ae4a <dir_read+0x22>
   1aee6:	e004      	b.n	1aef2 <dir_read+0xca>
		if (b == 0) {
   1aee8:	bf00      	nop
   1aeea:	e002      	b.n	1aef2 <dir_read+0xca>
#endif
   1aeec:	bf00      	nop
   1aeee:	e000      	b.n	1aef2 <dir_read+0xca>

   1aef0:	bf00      	nop
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
	return res;
}
   1aef2:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1aef6:	2b00      	cmp	r3, #0
   1aef8:	d002      	beq.n	1af00 <dir_read+0xd8>
   1aefa:	9b01      	ldr	r3, [sp, #4]
   1aefc:	2200      	movs	r2, #0
   1aefe:	619a      	str	r2, [r3, #24]

   1af00:	f89d 4017 	ldrb.w	r4, [sp, #23]
   1af04:	462b      	mov	r3, r5
   1af06:	4619      	mov	r1, r3
   1af08:	4803      	ldr	r0, [pc, #12]	; (1af18 <dir_read+0xf0>)
   1af0a:	f7fb fd07 	bl	1691c <__cyg_profile_func_exit>
   1af0e:	4623      	mov	r3, r4
#endif	/* FF_FS_MINIMIZE <= 1 || FF_USE_LABEL || FF_FS_RPATH >= 2 */
   1af10:	4618      	mov	r0, r3
   1af12:	b007      	add	sp, #28
   1af14:	bd30      	pop	{r4, r5, pc}
   1af16:	bf00      	nop
   1af18:	0001ae29 	.word	0x0001ae29

0001af1c <dir_find>:
static FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp					/* Pointer to the directory object with the file name */
)
{
	FRESULT res;
	FATFS *fs = dp->obj.fs;
   1af1c:	b530      	push	{r4, r5, lr}
   1af1e:	b087      	sub	sp, #28
   1af20:	4675      	mov	r5, lr
   1af22:	9001      	str	r0, [sp, #4]
   1af24:	462b      	mov	r3, r5
   1af26:	4619      	mov	r1, r3
   1af28:	4831      	ldr	r0, [pc, #196]	; (1aff0 <dir_find+0xd4>)
   1af2a:	f7fb fce3 	bl	168f4 <__cyg_profile_func_enter>
	BYTE c;
#if FF_USE_LFN
   1af2e:	9b01      	ldr	r3, [sp, #4]
   1af30:	681b      	ldr	r3, [r3, #0]
   1af32:	9304      	str	r3, [sp, #16]
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
	if (res != FR_OK) return res;
#if FF_FS_EXFAT
   1af34:	2100      	movs	r1, #0
   1af36:	9801      	ldr	r0, [sp, #4]
   1af38:	f7ff fd98 	bl	1aa6c <dir_sdi>
   1af3c:	4603      	mov	r3, r0
   1af3e:	f88d 3017 	strb.w	r3, [sp, #23]
	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
   1af42:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1af46:	2b00      	cmp	r3, #0
   1af48:	d002      	beq.n	1af50 <dir_find+0x34>
   1af4a:	f89d 4017 	ldrb.w	r4, [sp, #23]
   1af4e:	e046      	b.n	1afde <dir_find+0xc2>
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
#endif
	do {
		res = move_window(fs, dp->sect);
		if (res != FR_OK) break;
		c = dp->dir[DIR_Name];
   1af50:	9b01      	ldr	r3, [sp, #4]
   1af52:	699b      	ldr	r3, [r3, #24]
   1af54:	4619      	mov	r1, r3
   1af56:	9804      	ldr	r0, [sp, #16]
   1af58:	f7ff f942 	bl	1a1e0 <move_window>
   1af5c:	4603      	mov	r3, r0
   1af5e:	f88d 3017 	strb.w	r3, [sp, #23]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   1af62:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1af66:	2b00      	cmp	r3, #0
   1af68:	d134      	bne.n	1afd4 <dir_find+0xb8>
#if FF_USE_LFN		/* LFN configuration */
   1af6a:	9b01      	ldr	r3, [sp, #4]
   1af6c:	69db      	ldr	r3, [r3, #28]
   1af6e:	781b      	ldrb	r3, [r3, #0]
   1af70:	f88d 300f 	strb.w	r3, [sp, #15]
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
   1af74:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1af78:	2b00      	cmp	r3, #0
   1af7a:	d103      	bne.n	1af84 <dir_find+0x68>
   1af7c:	2304      	movs	r3, #4
   1af7e:	f88d 3017 	strb.w	r3, [sp, #23]
   1af82:	e02a      	b.n	1afda <dir_find+0xbe>
			}
		}
#else		/* Non LFN configuration */
		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
#endif
   1af84:	9b01      	ldr	r3, [sp, #4]
   1af86:	69db      	ldr	r3, [r3, #28]
   1af88:	330b      	adds	r3, #11
   1af8a:	781b      	ldrb	r3, [r3, #0]
   1af8c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   1af90:	b2da      	uxtb	r2, r3
   1af92:	9b01      	ldr	r3, [sp, #4]
   1af94:	719a      	strb	r2, [r3, #6]
		res = dir_next(dp, 0);	/* Next entry */
   1af96:	9b01      	ldr	r3, [sp, #4]
   1af98:	69db      	ldr	r3, [r3, #28]
   1af9a:	330b      	adds	r3, #11
   1af9c:	781b      	ldrb	r3, [r3, #0]
   1af9e:	f003 0308 	and.w	r3, r3, #8
   1afa2:	2b00      	cmp	r3, #0
   1afa4:	d10a      	bne.n	1afbc <dir_find+0xa0>
   1afa6:	9b01      	ldr	r3, [sp, #4]
   1afa8:	69d8      	ldr	r0, [r3, #28]
   1afaa:	9b01      	ldr	r3, [sp, #4]
   1afac:	3320      	adds	r3, #32
   1afae:	220b      	movs	r2, #11
   1afb0:	4619      	mov	r1, r3
   1afb2:	f7ff f805 	bl	19fc0 <mem_cmp>
   1afb6:	4603      	mov	r3, r0
   1afb8:	2b00      	cmp	r3, #0
   1afba:	d00d      	beq.n	1afd8 <dir_find+0xbc>
	} while (res == FR_OK);

   1afbc:	2100      	movs	r1, #0
   1afbe:	9801      	ldr	r0, [sp, #4]
   1afc0:	f7ff fddc 	bl	1ab7c <dir_next>
   1afc4:	4603      	mov	r3, r0
   1afc6:	f88d 3017 	strb.w	r3, [sp, #23]
	return res;
   1afca:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1afce:	2b00      	cmp	r3, #0
   1afd0:	d0be      	beq.n	1af50 <dir_find+0x34>
   1afd2:	e002      	b.n	1afda <dir_find+0xbe>
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   1afd4:	bf00      	nop
   1afd6:	e000      	b.n	1afda <dir_find+0xbe>
		res = dir_next(dp, 0);	/* Next entry */
   1afd8:	bf00      	nop
}

   1afda:	f89d 4017 	ldrb.w	r4, [sp, #23]
   1afde:	462b      	mov	r3, r5
   1afe0:	4619      	mov	r1, r3
   1afe2:	4803      	ldr	r0, [pc, #12]	; (1aff0 <dir_find+0xd4>)
   1afe4:	f7fb fc9a 	bl	1691c <__cyg_profile_func_exit>
   1afe8:	4623      	mov	r3, r4

   1afea:	4618      	mov	r0, r3
   1afec:	b007      	add	sp, #28
   1afee:	bd30      	pop	{r4, r5, pc}
   1aff0:	0001af1d 	.word	0x0001af1d

0001aff4 <dir_register>:
static FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp						/* Target directory with object name to be created */
)
{
	FRESULT res;
	FATFS *fs = dp->obj.fs;
   1aff4:	b530      	push	{r4, r5, lr}
   1aff6:	b085      	sub	sp, #20
   1aff8:	4675      	mov	r5, lr
   1affa:	9001      	str	r0, [sp, #4]
   1affc:	462b      	mov	r3, r5
   1affe:	4619      	mov	r1, r3
   1b000:	481d      	ldr	r0, [pc, #116]	; (1b078 <dir_register+0x84>)
   1b002:	f7fb fc77 	bl	168f4 <__cyg_profile_func_enter>
#if FF_USE_LFN		/* LFN configuration */
	UINT n, nlen, nent;
   1b006:	9b01      	ldr	r3, [sp, #4]
   1b008:	681b      	ldr	r3, [r3, #0]
   1b00a:	9302      	str	r3, [sp, #8]
	}

#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */

#endif
   1b00c:	2101      	movs	r1, #1
   1b00e:	9801      	ldr	r0, [sp, #4]
   1b010:	f7ff fe56 	bl	1acc0 <dir_alloc>
   1b014:	4603      	mov	r3, r0
   1b016:	f88d 300f 	strb.w	r3, [sp, #15]

	/* Set SFN entry */
	if (res == FR_OK) {
		res = move_window(fs, dp->sect);
		if (res == FR_OK) {
   1b01a:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1b01e:	2b00      	cmp	r3, #0
   1b020:	d11e      	bne.n	1b060 <dir_register+0x6c>
			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
   1b022:	9b01      	ldr	r3, [sp, #4]
   1b024:	699b      	ldr	r3, [r3, #24]
   1b026:	4619      	mov	r1, r3
   1b028:	9802      	ldr	r0, [sp, #8]
   1b02a:	f7ff f8d9 	bl	1a1e0 <move_window>
   1b02e:	4603      	mov	r3, r0
   1b030:	f88d 300f 	strb.w	r3, [sp, #15]
			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
   1b034:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1b038:	2b00      	cmp	r3, #0
   1b03a:	d111      	bne.n	1b060 <dir_register+0x6c>
#if FF_USE_LFN
   1b03c:	9b01      	ldr	r3, [sp, #4]
   1b03e:	69db      	ldr	r3, [r3, #28]
   1b040:	2220      	movs	r2, #32
   1b042:	2100      	movs	r1, #0
   1b044:	4618      	mov	r0, r3
   1b046:	f7fe ff97 	bl	19f78 <mem_set>
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
   1b04a:	9b01      	ldr	r3, [sp, #4]
   1b04c:	69d8      	ldr	r0, [r3, #28]
   1b04e:	9b01      	ldr	r3, [sp, #4]
   1b050:	3320      	adds	r3, #32
   1b052:	220b      	movs	r2, #11
   1b054:	4619      	mov	r1, r3
   1b056:	f7fe ff65 	bl	19f24 <mem_cpy>
#endif
			fs->wflag = 1;
		}
	}
   1b05a:	9b02      	ldr	r3, [sp, #8]
   1b05c:	2201      	movs	r2, #1
   1b05e:	70da      	strb	r2, [r3, #3]

	return res;
}

   1b060:	f89d 400f 	ldrb.w	r4, [sp, #15]
   1b064:	462b      	mov	r3, r5
   1b066:	4619      	mov	r1, r3
   1b068:	4803      	ldr	r0, [pc, #12]	; (1b078 <dir_register+0x84>)
   1b06a:	f7fb fc57 	bl	1691c <__cyg_profile_func_exit>
   1b06e:	4623      	mov	r3, r4
#endif /* !FF_FS_READONLY */
   1b070:	4618      	mov	r0, r3
   1b072:	b005      	add	sp, #20
   1b074:	bd30      	pop	{r4, r5, pc}
   1b076:	bf00      	nop
   1b078:	0001aff5 	.word	0x0001aff5

0001b07c <get_fileinfo>:
	DIR* dp,			/* Pointer to the directory object */
	FILINFO* fno		/* Pointer to the file information to be filled */
)
{
	UINT si, di;
#if FF_USE_LFN
   1b07c:	b530      	push	{r4, r5, lr}
   1b07e:	b087      	sub	sp, #28
   1b080:	4675      	mov	r5, lr
   1b082:	9001      	str	r0, [sp, #4]
   1b084:	9100      	str	r1, [sp, #0]
   1b086:	462b      	mov	r3, r5
   1b088:	4619      	mov	r1, r3
   1b08a:	4836      	ldr	r0, [pc, #216]	; (1b164 <get_fileinfo+0xe8>)
   1b08c:	f7fb fc32 	bl	168f4 <__cyg_profile_func_enter>
#endif


	fno->fname[0] = 0;			/* Invaidate file info */
	if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */

   1b090:	9b00      	ldr	r3, [sp, #0]
   1b092:	2200      	movs	r2, #0
   1b094:	725a      	strb	r2, [r3, #9]
#if FF_USE_LFN		/* LFN configuration */
   1b096:	9b01      	ldr	r3, [sp, #4]
   1b098:	699b      	ldr	r3, [r3, #24]
   1b09a:	2b00      	cmp	r3, #0
   1b09c:	d101      	bne.n	1b0a2 <get_fileinfo+0x26>
   1b09e:	2400      	movs	r4, #0
   1b0a0:	e057      	b.n	1b152 <get_fileinfo+0xd6>
	}

#else	/* Non-LFN configuration */
	si = di = 0;
	while (si < 11) {		/* Copy name body and extension */
		c = (TCHAR)dp->dir[si++];
   1b0a2:	2300      	movs	r3, #0
   1b0a4:	9304      	str	r3, [sp, #16]
   1b0a6:	9b04      	ldr	r3, [sp, #16]
   1b0a8:	9305      	str	r3, [sp, #20]
		if (c == ' ') continue;		/* Skip padding spaces */
   1b0aa:	e026      	b.n	1b0fa <get_fileinfo+0x7e>
		if (c == RDDEM) c = DDEM;	/* Restore replaced DDEM character */
   1b0ac:	9b01      	ldr	r3, [sp, #4]
   1b0ae:	69da      	ldr	r2, [r3, #28]
   1b0b0:	9b05      	ldr	r3, [sp, #20]
   1b0b2:	1c59      	adds	r1, r3, #1
   1b0b4:	9105      	str	r1, [sp, #20]
   1b0b6:	4413      	add	r3, r2
   1b0b8:	781b      	ldrb	r3, [r3, #0]
   1b0ba:	f88d 300f 	strb.w	r3, [sp, #15]
		if (si == 9) fno->fname[di++] = '.';/* Insert a . if extension is exist */
   1b0be:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1b0c2:	2b20      	cmp	r3, #32
   1b0c4:	d100      	bne.n	1b0c8 <get_fileinfo+0x4c>
   1b0c6:	e018      	b.n	1b0fa <get_fileinfo+0x7e>
		fno->fname[di++] = c;
   1b0c8:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1b0cc:	2b05      	cmp	r3, #5
   1b0ce:	d102      	bne.n	1b0d6 <get_fileinfo+0x5a>
   1b0d0:	23e5      	movs	r3, #229	; 0xe5
   1b0d2:	f88d 300f 	strb.w	r3, [sp, #15]
	}
   1b0d6:	9b05      	ldr	r3, [sp, #20]
   1b0d8:	2b09      	cmp	r3, #9
   1b0da:	d106      	bne.n	1b0ea <get_fileinfo+0x6e>
   1b0dc:	9b04      	ldr	r3, [sp, #16]
   1b0de:	1c5a      	adds	r2, r3, #1
   1b0e0:	9204      	str	r2, [sp, #16]
   1b0e2:	9a00      	ldr	r2, [sp, #0]
   1b0e4:	4413      	add	r3, r2
   1b0e6:	222e      	movs	r2, #46	; 0x2e
   1b0e8:	725a      	strb	r2, [r3, #9]
	fno->fname[di] = 0;
   1b0ea:	9b04      	ldr	r3, [sp, #16]
   1b0ec:	1c5a      	adds	r2, r3, #1
   1b0ee:	9204      	str	r2, [sp, #16]
   1b0f0:	9a00      	ldr	r2, [sp, #0]
   1b0f2:	4413      	add	r3, r2
   1b0f4:	f89d 200f 	ldrb.w	r2, [sp, #15]
   1b0f8:	725a      	strb	r2, [r3, #9]
		if (c == ' ') continue;		/* Skip padding spaces */
   1b0fa:	9b05      	ldr	r3, [sp, #20]
   1b0fc:	2b0a      	cmp	r3, #10
   1b0fe:	d9d5      	bls.n	1b0ac <get_fileinfo+0x30>
#endif

   1b100:	9a00      	ldr	r2, [sp, #0]
   1b102:	9b04      	ldr	r3, [sp, #16]
   1b104:	4413      	add	r3, r2
   1b106:	3309      	adds	r3, #9
   1b108:	2200      	movs	r2, #0
   1b10a:	701a      	strb	r2, [r3, #0]
	fno->fattrib = dp->dir[DIR_Attr];					/* Attribute */
	fno->fsize = ld_dword(dp->dir + DIR_FileSize);		/* Size */
	fno->ftime = ld_word(dp->dir + DIR_ModTime + 0);	/* Time */
   1b10c:	9b01      	ldr	r3, [sp, #4]
   1b10e:	69db      	ldr	r3, [r3, #28]
   1b110:	7ada      	ldrb	r2, [r3, #11]
   1b112:	9b00      	ldr	r3, [sp, #0]
   1b114:	721a      	strb	r2, [r3, #8]
	fno->fdate = ld_word(dp->dir + DIR_ModTime + 2);	/* Date */
   1b116:	9b01      	ldr	r3, [sp, #4]
   1b118:	69db      	ldr	r3, [r3, #28]
   1b11a:	331c      	adds	r3, #28
   1b11c:	4618      	mov	r0, r3
   1b11e:	f7fe fe73 	bl	19e08 <ld_dword>
   1b122:	4602      	mov	r2, r0
   1b124:	9b00      	ldr	r3, [sp, #0]
   1b126:	601a      	str	r2, [r3, #0]
}
   1b128:	9b01      	ldr	r3, [sp, #4]
   1b12a:	69db      	ldr	r3, [r3, #28]
   1b12c:	3316      	adds	r3, #22
   1b12e:	4618      	mov	r0, r3
   1b130:	f7fe fe44 	bl	19dbc <ld_word>
   1b134:	4603      	mov	r3, r0
   1b136:	461a      	mov	r2, r3
   1b138:	9b00      	ldr	r3, [sp, #0]
   1b13a:	80da      	strh	r2, [r3, #6]

   1b13c:	9b01      	ldr	r3, [sp, #4]
   1b13e:	69db      	ldr	r3, [r3, #28]
   1b140:	3318      	adds	r3, #24
   1b142:	4618      	mov	r0, r3
   1b144:	f7fe fe3a 	bl	19dbc <ld_word>
   1b148:	4603      	mov	r3, r0
   1b14a:	461a      	mov	r2, r3
   1b14c:	9b00      	ldr	r3, [sp, #0]
   1b14e:	809a      	strh	r2, [r3, #4]
   1b150:	2401      	movs	r4, #1
   1b152:	462b      	mov	r3, r5
   1b154:	4619      	mov	r1, r3
   1b156:	4803      	ldr	r0, [pc, #12]	; (1b164 <get_fileinfo+0xe8>)
   1b158:	f7fb fbe0 	bl	1691c <__cyg_profile_func_exit>
   1b15c:	2c01      	cmp	r4, #1
#endif /* FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 */
   1b15e:	b007      	add	sp, #28
   1b160:	bd30      	pop	{r4, r5, pc}
   1b162:	bf00      	nop
   1b164:	0001b07d 	.word	0x0001b07d

0001b168 <create_name>:
	DIR* dp,					/* Pointer to the directory object */
	const TCHAR** path			/* Pointer to pointer to the segment in the path string */
)
{
#if FF_USE_LFN		/* LFN configuration */
	BYTE b, cf;
   1b168:	b530      	push	{r4, r5, lr}
   1b16a:	b08b      	sub	sp, #44	; 0x2c
   1b16c:	4675      	mov	r5, lr
   1b16e:	9001      	str	r0, [sp, #4]
   1b170:	9100      	str	r1, [sp, #0]
   1b172:	462b      	mov	r3, r5
   1b174:	4619      	mov	r1, r3
   1b176:	4863      	ldr	r0, [pc, #396]	; (1b304 <create_name+0x19c>)
   1b178:	f7fb fbbc 	bl	168f4 <__cyg_profile_func_enter>
	const char *p;

	/* Create file name in directory form */
	p = *path; sfn = dp->fn;
	mem_set(sfn, ' ', 11);
	si = i = 0; ni = 8;
   1b17c:	9b00      	ldr	r3, [sp, #0]
   1b17e:	681b      	ldr	r3, [r3, #0]
   1b180:	9305      	str	r3, [sp, #20]
   1b182:	9b01      	ldr	r3, [sp, #4]
   1b184:	3320      	adds	r3, #32
   1b186:	9304      	str	r3, [sp, #16]
#if FF_FS_RPATH != 0
   1b188:	220b      	movs	r2, #11
   1b18a:	2120      	movs	r1, #32
   1b18c:	9804      	ldr	r0, [sp, #16]
   1b18e:	f7fe fef3 	bl	19f78 <mem_set>
	if (p[si] == '.') { /* Is this a dot entry? */
   1b192:	2300      	movs	r3, #0
   1b194:	9306      	str	r3, [sp, #24]
   1b196:	9b06      	ldr	r3, [sp, #24]
   1b198:	9307      	str	r3, [sp, #28]
   1b19a:	2308      	movs	r3, #8
   1b19c:	9308      	str	r3, [sp, #32]
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];				/* Get a byte */
		if (c <= ' ') break; 			/* Break if end of the path name */
		if (c == '/' || c == '\\') {	/* Break if a separator is found */
   1b19e:	9b07      	ldr	r3, [sp, #28]
   1b1a0:	1c5a      	adds	r2, r3, #1
   1b1a2:	9207      	str	r2, [sp, #28]
   1b1a4:	9a05      	ldr	r2, [sp, #20]
   1b1a6:	4413      	add	r3, r2
   1b1a8:	781b      	ldrb	r3, [r3, #0]
   1b1aa:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
   1b1ae:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1b1b2:	2b20      	cmp	r3, #32
   1b1b4:	d97f      	bls.n	1b2b6 <create_name+0x14e>
			break;
   1b1b6:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1b1ba:	2b2f      	cmp	r3, #47	; 0x2f
   1b1bc:	d007      	beq.n	1b1ce <create_name+0x66>
   1b1be:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1b1c2:	2b5c      	cmp	r3, #92	; 0x5c
   1b1c4:	d110      	bne.n	1b1e8 <create_name+0x80>
		}
   1b1c6:	e002      	b.n	1b1ce <create_name+0x66>
   1b1c8:	9b07      	ldr	r3, [sp, #28]
   1b1ca:	3301      	adds	r3, #1
   1b1cc:	9307      	str	r3, [sp, #28]
   1b1ce:	9a05      	ldr	r2, [sp, #20]
   1b1d0:	9b07      	ldr	r3, [sp, #28]
   1b1d2:	4413      	add	r3, r2
   1b1d4:	781b      	ldrb	r3, [r3, #0]
   1b1d6:	2b2f      	cmp	r3, #47	; 0x2f
   1b1d8:	d0f6      	beq.n	1b1c8 <create_name+0x60>
   1b1da:	9a05      	ldr	r2, [sp, #20]
   1b1dc:	9b07      	ldr	r3, [sp, #28]
   1b1de:	4413      	add	r3, r2
   1b1e0:	781b      	ldrb	r3, [r3, #0]
   1b1e2:	2b5c      	cmp	r3, #92	; 0x5c
   1b1e4:	d0f0      	beq.n	1b1c8 <create_name+0x60>
		if (c == '.' || i >= ni) {		/* End of body or field overflow? */
   1b1e6:	e067      	b.n	1b2b8 <create_name+0x150>
			if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Field overflow or invalid dot? */
			i = 8; ni = 11;				/* Enter file extension field */
   1b1e8:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1b1ec:	2b2e      	cmp	r3, #46	; 0x2e
   1b1ee:	d003      	beq.n	1b1f8 <create_name+0x90>
   1b1f0:	9a06      	ldr	r2, [sp, #24]
   1b1f2:	9b08      	ldr	r3, [sp, #32]
   1b1f4:	429a      	cmp	r2, r3
   1b1f6:	d30d      	bcc.n	1b214 <create_name+0xac>
			continue;
   1b1f8:	9b08      	ldr	r3, [sp, #32]
   1b1fa:	2b0b      	cmp	r3, #11
   1b1fc:	d003      	beq.n	1b206 <create_name+0x9e>
   1b1fe:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1b202:	2b2e      	cmp	r3, #46	; 0x2e
   1b204:	d001      	beq.n	1b20a <create_name+0xa2>
   1b206:	2406      	movs	r4, #6
   1b208:	e072      	b.n	1b2f0 <create_name+0x188>
		}
   1b20a:	2308      	movs	r3, #8
   1b20c:	9306      	str	r3, [sp, #24]
   1b20e:	230b      	movs	r3, #11
   1b210:	9308      	str	r3, [sp, #32]
#if FF_CODE_PAGE == 0
   1b212:	e04f      	b.n	1b2b4 <create_name+0x14c>
			c = ExCvt[c & 0x7F];		/* To upper SBC extended character */
		}
#endif
		if (dbc_1st(c)) {				/* Check if it is a DBC 1st byte */
			d = (BYTE)p[si++];			/* Get 2nd byte */
			if (!dbc_2nd(d) || i >= ni - 1) return FR_INVALID_NAME;	/* Reject invalid DBC */
   1b214:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1b218:	4618      	mov	r0, r3
   1b21a:	f7fe ff29 	bl	1a070 <dbc_1st>
   1b21e:	4603      	mov	r3, r0
   1b220:	2b00      	cmp	r3, #0
   1b222:	d027      	beq.n	1b274 <create_name+0x10c>
			sfn[i++] = c;
   1b224:	9b07      	ldr	r3, [sp, #28]
   1b226:	1c5a      	adds	r2, r3, #1
   1b228:	9207      	str	r2, [sp, #28]
   1b22a:	9a05      	ldr	r2, [sp, #20]
   1b22c:	4413      	add	r3, r2
   1b22e:	781b      	ldrb	r3, [r3, #0]
   1b230:	f88d 300f 	strb.w	r3, [sp, #15]
			sfn[i++] = d;
   1b234:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1b238:	4618      	mov	r0, r3
   1b23a:	f7fe ff49 	bl	1a0d0 <dbc_2nd>
   1b23e:	4603      	mov	r3, r0
   1b240:	2b00      	cmp	r3, #0
   1b242:	d004      	beq.n	1b24e <create_name+0xe6>
   1b244:	9b08      	ldr	r3, [sp, #32]
   1b246:	3b01      	subs	r3, #1
   1b248:	9a06      	ldr	r2, [sp, #24]
   1b24a:	429a      	cmp	r2, r3
   1b24c:	d301      	bcc.n	1b252 <create_name+0xea>
   1b24e:	2406      	movs	r4, #6
   1b250:	e04e      	b.n	1b2f0 <create_name+0x188>
		} else {						/* SBC */
   1b252:	9b06      	ldr	r3, [sp, #24]
   1b254:	1c5a      	adds	r2, r3, #1
   1b256:	9206      	str	r2, [sp, #24]
   1b258:	9a04      	ldr	r2, [sp, #16]
   1b25a:	4413      	add	r3, r2
   1b25c:	f89d 2027 	ldrb.w	r2, [sp, #39]	; 0x27
   1b260:	701a      	strb	r2, [r3, #0]
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) return FR_INVALID_NAME;	/* Reject illegal chrs for SFN */
   1b262:	9b06      	ldr	r3, [sp, #24]
   1b264:	1c5a      	adds	r2, r3, #1
   1b266:	9206      	str	r2, [sp, #24]
   1b268:	9a04      	ldr	r2, [sp, #16]
   1b26a:	4413      	add	r3, r2
   1b26c:	f89d 200f 	ldrb.w	r2, [sp, #15]
   1b270:	701a      	strb	r2, [r3, #0]
   1b272:	e794      	b.n	1b19e <create_name+0x36>
			if (IsLower(c)) c -= 0x20;	/* To upper */
			sfn[i++] = c;
   1b274:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1b278:	4619      	mov	r1, r3
   1b27a:	4823      	ldr	r0, [pc, #140]	; (1b308 <create_name+0x1a0>)
   1b27c:	f7fe fed2 	bl	1a024 <chk_chr>
   1b280:	4603      	mov	r3, r0
   1b282:	2b00      	cmp	r3, #0
   1b284:	d001      	beq.n	1b28a <create_name+0x122>
   1b286:	2406      	movs	r4, #6
   1b288:	e032      	b.n	1b2f0 <create_name+0x188>
		}
   1b28a:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1b28e:	2b60      	cmp	r3, #96	; 0x60
   1b290:	d908      	bls.n	1b2a4 <create_name+0x13c>
   1b292:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1b296:	2b7a      	cmp	r3, #122	; 0x7a
   1b298:	d804      	bhi.n	1b2a4 <create_name+0x13c>
   1b29a:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1b29e:	3b20      	subs	r3, #32
   1b2a0:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
	}
   1b2a4:	9b06      	ldr	r3, [sp, #24]
   1b2a6:	1c5a      	adds	r2, r3, #1
   1b2a8:	9206      	str	r2, [sp, #24]
   1b2aa:	9a04      	ldr	r2, [sp, #16]
   1b2ac:	4413      	add	r3, r2
   1b2ae:	f89d 2027 	ldrb.w	r2, [sp, #39]	; 0x27
   1b2b2:	701a      	strb	r2, [r3, #0]
		if (c == '/' || c == '\\') {	/* Break if a separator is found */
   1b2b4:	e773      	b.n	1b19e <create_name+0x36>
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
   1b2b6:	bf00      	nop
	*path = p + si;						/* Return pointer to the next segment */
	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */

   1b2b8:	9a05      	ldr	r2, [sp, #20]
   1b2ba:	9b07      	ldr	r3, [sp, #28]
   1b2bc:	441a      	add	r2, r3
   1b2be:	9b00      	ldr	r3, [sp, #0]
   1b2c0:	601a      	str	r2, [r3, #0]
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
   1b2c2:	9b06      	ldr	r3, [sp, #24]
   1b2c4:	2b00      	cmp	r3, #0
   1b2c6:	d101      	bne.n	1b2cc <create_name+0x164>
   1b2c8:	2406      	movs	r4, #6
   1b2ca:	e011      	b.n	1b2f0 <create_name+0x188>
	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */

   1b2cc:	9b04      	ldr	r3, [sp, #16]
   1b2ce:	781b      	ldrb	r3, [r3, #0]
   1b2d0:	2be5      	cmp	r3, #229	; 0xe5
   1b2d2:	d102      	bne.n	1b2da <create_name+0x172>
   1b2d4:	9b04      	ldr	r3, [sp, #16]
   1b2d6:	2205      	movs	r2, #5
   1b2d8:	701a      	strb	r2, [r3, #0]
	return FR_OK;
   1b2da:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1b2de:	2b20      	cmp	r3, #32
   1b2e0:	d801      	bhi.n	1b2e6 <create_name+0x17e>
   1b2e2:	2204      	movs	r2, #4
   1b2e4:	e000      	b.n	1b2e8 <create_name+0x180>
   1b2e6:	2200      	movs	r2, #0
   1b2e8:	9b04      	ldr	r3, [sp, #16]
   1b2ea:	330b      	adds	r3, #11
   1b2ec:	701a      	strb	r2, [r3, #0]
#endif /* FF_USE_LFN */
}
   1b2ee:	2400      	movs	r4, #0
   1b2f0:	462b      	mov	r3, r5
   1b2f2:	4619      	mov	r1, r3
   1b2f4:	4803      	ldr	r0, [pc, #12]	; (1b304 <create_name+0x19c>)
   1b2f6:	f7fb fb11 	bl	1691c <__cyg_profile_func_exit>
   1b2fa:	4623      	mov	r3, r4


   1b2fc:	4618      	mov	r0, r3
   1b2fe:	b00b      	add	sp, #44	; 0x2c
   1b300:	bd30      	pop	{r4, r5, pc}
   1b302:	bf00      	nop
   1b304:	0001b169 	.word	0x0001b169
   1b308:	0001f520 	.word	0x0001f520

0001b30c <follow_path>:
	DIR* dp,					/* Directory object to return last directory and found object */
	const TCHAR* path			/* Full-path string to find a file or directory */
)
{
	FRESULT res;
	BYTE ns;
   1b30c:	b530      	push	{r4, r5, lr}
   1b30e:	b087      	sub	sp, #28
   1b310:	4675      	mov	r5, lr
   1b312:	9001      	str	r0, [sp, #4]
   1b314:	9100      	str	r1, [sp, #0]
   1b316:	462b      	mov	r3, r5
   1b318:	4619      	mov	r1, r3
   1b31a:	483f      	ldr	r0, [pc, #252]	; (1b418 <follow_path+0x10c>)
   1b31c:	f7fb faea 	bl	168f4 <__cyg_profile_func_enter>
	FATFS *fs = dp->obj.fs;


   1b320:	9b01      	ldr	r3, [sp, #4]
   1b322:	681b      	ldr	r3, [r3, #0]
   1b324:	9304      	str	r3, [sp, #16]
	} else
#endif
	{										/* With heading separator */
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
		dp->obj.sclust = 0;					/* Start from root directory */
	}
   1b326:	e002      	b.n	1b32e <follow_path+0x22>
   1b328:	9b00      	ldr	r3, [sp, #0]
   1b32a:	3301      	adds	r3, #1
   1b32c:	9300      	str	r3, [sp, #0]
   1b32e:	9b00      	ldr	r3, [sp, #0]
   1b330:	781b      	ldrb	r3, [r3, #0]
   1b332:	2b2f      	cmp	r3, #47	; 0x2f
   1b334:	d0f8      	beq.n	1b328 <follow_path+0x1c>
   1b336:	9b00      	ldr	r3, [sp, #0]
   1b338:	781b      	ldrb	r3, [r3, #0]
   1b33a:	2b5c      	cmp	r3, #92	; 0x5c
   1b33c:	d0f4      	beq.n	1b328 <follow_path+0x1c>
#if FF_FS_EXFAT
   1b33e:	9b01      	ldr	r3, [sp, #4]
   1b340:	2200      	movs	r2, #0
   1b342:	609a      	str	r2, [r3, #8]
#endif
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
		dp->fn[NSFLAG] = NS_NONAME;
		res = dir_sdi(dp, 0);
   1b344:	9b00      	ldr	r3, [sp, #0]
   1b346:	781b      	ldrb	r3, [r3, #0]
   1b348:	2b1f      	cmp	r3, #31
   1b34a:	d80b      	bhi.n	1b364 <follow_path+0x58>

   1b34c:	9b01      	ldr	r3, [sp, #4]
   1b34e:	2280      	movs	r2, #128	; 0x80
   1b350:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
	} else {								/* Follow path */
   1b354:	2100      	movs	r1, #0
   1b356:	9801      	ldr	r0, [sp, #4]
   1b358:	f7ff fb88 	bl	1aa6c <dir_sdi>
   1b35c:	4603      	mov	r3, r0
   1b35e:	f88d 3017 	strb.w	r3, [sp, #23]
   1b362:	e04d      	b.n	1b400 <follow_path+0xf4>
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the segment name */
   1b364:	466b      	mov	r3, sp
   1b366:	4619      	mov	r1, r3
   1b368:	9801      	ldr	r0, [sp, #4]
   1b36a:	f7ff fefd 	bl	1b168 <create_name>
   1b36e:	4603      	mov	r3, r0
   1b370:	f88d 3017 	strb.w	r3, [sp, #23]
			ns = dp->fn[NSFLAG];
   1b374:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1b378:	2b00      	cmp	r3, #0
   1b37a:	d13c      	bne.n	1b3f6 <follow_path+0xea>
			if (res != FR_OK) {				/* Failed to find the object */
   1b37c:	9801      	ldr	r0, [sp, #4]
   1b37e:	f7ff fdcd 	bl	1af1c <dir_find>
   1b382:	4603      	mov	r3, r0
   1b384:	f88d 3017 	strb.w	r3, [sp, #23]
				if (res == FR_NO_FILE) {	/* Object is not found */
   1b388:	9b01      	ldr	r3, [sp, #4]
   1b38a:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
   1b38e:	f88d 300f 	strb.w	r3, [sp, #15]
					if (FF_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
   1b392:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1b396:	2b00      	cmp	r3, #0
   1b398:	d00d      	beq.n	1b3b6 <follow_path+0xaa>
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
   1b39a:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1b39e:	2b04      	cmp	r3, #4
   1b3a0:	d12b      	bne.n	1b3fa <follow_path+0xee>
						dp->fn[NSFLAG] = NS_NONAME;
						res = FR_OK;
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
					}
				}
   1b3a2:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1b3a6:	f003 0304 	and.w	r3, r3, #4
   1b3aa:	2b00      	cmp	r3, #0
   1b3ac:	d125      	bne.n	1b3fa <follow_path+0xee>
   1b3ae:	2305      	movs	r3, #5
   1b3b0:	f88d 3017 	strb.w	r3, [sp, #23]
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
   1b3b4:	e021      	b.n	1b3fa <follow_path+0xee>
			/* Get into the sub-directory */
			if (!(dp->obj.attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
   1b3b6:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1b3ba:	f003 0304 	and.w	r3, r3, #4
   1b3be:	2b00      	cmp	r3, #0
   1b3c0:	d11d      	bne.n	1b3fe <follow_path+0xf2>
				res = FR_NO_PATH; break;
			}
   1b3c2:	9b01      	ldr	r3, [sp, #4]
   1b3c4:	799b      	ldrb	r3, [r3, #6]
   1b3c6:	f003 0310 	and.w	r3, r3, #16
   1b3ca:	2b00      	cmp	r3, #0
   1b3cc:	d103      	bne.n	1b3d6 <follow_path+0xca>
#if FF_FS_EXFAT
   1b3ce:	2305      	movs	r3, #5
   1b3d0:	f88d 3017 	strb.w	r3, [sp, #23]
   1b3d4:	e014      	b.n	1b400 <follow_path+0xf4>
			} else
#endif
			{
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
			}
		}
   1b3d6:	9b04      	ldr	r3, [sp, #16]
   1b3d8:	f103 0230 	add.w	r2, r3, #48	; 0x30
   1b3dc:	9b01      	ldr	r3, [sp, #4]
   1b3de:	691b      	ldr	r3, [r3, #16]
   1b3e0:	f3c3 0308 	ubfx	r3, r3, #0, #9
   1b3e4:	4413      	add	r3, r2
   1b3e6:	4619      	mov	r1, r3
   1b3e8:	9804      	ldr	r0, [sp, #16]
   1b3ea:	f7ff fcc5 	bl	1ad78 <ld_clust>
   1b3ee:	4602      	mov	r2, r0
   1b3f0:	9b01      	ldr	r3, [sp, #4]
   1b3f2:	609a      	str	r2, [r3, #8]
			res = dir_find(dp);				/* Find an object with the segment name */
   1b3f4:	e7b6      	b.n	1b364 <follow_path+0x58>
			ns = dp->fn[NSFLAG];
   1b3f6:	bf00      	nop
   1b3f8:	e002      	b.n	1b400 <follow_path+0xf4>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
   1b3fa:	bf00      	nop
   1b3fc:	e000      	b.n	1b400 <follow_path+0xf4>
			if (!(dp->obj.attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
   1b3fe:	bf00      	nop
	}

	return res;
}

   1b400:	f89d 4017 	ldrb.w	r4, [sp, #23]
   1b404:	462b      	mov	r3, r5
   1b406:	4619      	mov	r1, r3
   1b408:	4803      	ldr	r0, [pc, #12]	; (1b418 <follow_path+0x10c>)
   1b40a:	f7fb fa87 	bl	1691c <__cyg_profile_func_exit>
   1b40e:	4623      	mov	r3, r4

   1b410:	4618      	mov	r0, r3
   1b412:	b007      	add	sp, #28
   1b414:	bd30      	pop	{r4, r5, pc}
   1b416:	bf00      	nop
   1b418:	0001b30d 	.word	0x0001b30d

0001b41c <get_ldnumber>:
static int get_ldnumber (	/* Returns logical drive number (-1:invalid drive number or null pointer) */
	const TCHAR** path		/* Pointer to pointer to the path name */
)
{
	const TCHAR *tp, *tt;
	TCHAR tc;
   1b41c:	b530      	push	{r4, r5, lr}
   1b41e:	b089      	sub	sp, #36	; 0x24
   1b420:	4675      	mov	r5, lr
   1b422:	9001      	str	r0, [sp, #4]
   1b424:	462b      	mov	r3, r5
   1b426:	4619      	mov	r1, r3
   1b428:	4825      	ldr	r0, [pc, #148]	; (1b4c0 <get_ldnumber+0xa4>)
   1b42a:	f7fb fa63 	bl	168f4 <__cyg_profile_func_enter>
	int i, vol = -1;
#if FF_STR_VOLUME_ID		/* Find string volume ID */
	const char *sp;
   1b42e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1b432:	9305      	str	r3, [sp, #20]
	char c;
#endif

	tt = tp = *path;
	if (!tp) return vol;	/* Invalid path name? */
	do tc = *tt++; while ((UINT)tc >= (FF_USE_LFN ? ' ' : '!') && tc != ':');	/* Find a colon in the path */
   1b434:	9b01      	ldr	r3, [sp, #4]
   1b436:	681b      	ldr	r3, [r3, #0]
   1b438:	9304      	str	r3, [sp, #16]
   1b43a:	9b04      	ldr	r3, [sp, #16]
   1b43c:	9307      	str	r3, [sp, #28]

   1b43e:	9b04      	ldr	r3, [sp, #16]
   1b440:	2b00      	cmp	r3, #0
   1b442:	d101      	bne.n	1b448 <get_ldnumber+0x2c>
   1b444:	9c05      	ldr	r4, [sp, #20]
   1b446:	e031      	b.n	1b4ac <get_ldnumber+0x90>
	if (tc == ':') {	/* DOS/Windows style volume ID? */
   1b448:	9b07      	ldr	r3, [sp, #28]
   1b44a:	1c5a      	adds	r2, r3, #1
   1b44c:	9207      	str	r2, [sp, #28]
   1b44e:	781b      	ldrb	r3, [r3, #0]
   1b450:	f88d 300f 	strb.w	r3, [sp, #15]
   1b454:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1b458:	2b20      	cmp	r3, #32
   1b45a:	d903      	bls.n	1b464 <get_ldnumber+0x48>
   1b45c:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1b460:	2b3a      	cmp	r3, #58	; 0x3a
   1b462:	d1f1      	bne.n	1b448 <get_ldnumber+0x2c>
		i = FF_VOLUMES;
		if (IsDigit(*tp) && tp + 2 == tt) {	/* Is there a numeric volume ID + colon? */
   1b464:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1b468:	2b3a      	cmp	r3, #58	; 0x3a
   1b46a:	d11c      	bne.n	1b4a6 <get_ldnumber+0x8a>
			i = (int)*tp - '0';	/* Get the LD number */
   1b46c:	2301      	movs	r3, #1
   1b46e:	9306      	str	r3, [sp, #24]
		}
   1b470:	9b04      	ldr	r3, [sp, #16]
   1b472:	781b      	ldrb	r3, [r3, #0]
   1b474:	2b2f      	cmp	r3, #47	; 0x2f
   1b476:	d90c      	bls.n	1b492 <get_ldnumber+0x76>
   1b478:	9b04      	ldr	r3, [sp, #16]
   1b47a:	781b      	ldrb	r3, [r3, #0]
   1b47c:	2b39      	cmp	r3, #57	; 0x39
   1b47e:	d808      	bhi.n	1b492 <get_ldnumber+0x76>
   1b480:	9b04      	ldr	r3, [sp, #16]
   1b482:	3302      	adds	r3, #2
   1b484:	9a07      	ldr	r2, [sp, #28]
   1b486:	429a      	cmp	r2, r3
   1b488:	d103      	bne.n	1b492 <get_ldnumber+0x76>
#if FF_STR_VOLUME_ID == 1	/* Arbitrary string is enabled */
   1b48a:	9b04      	ldr	r3, [sp, #16]
   1b48c:	781b      	ldrb	r3, [r3, #0]
   1b48e:	3b30      	subs	r3, #48	; 0x30
   1b490:	9306      	str	r3, [sp, #24]
			} while ((c || tp != tt) && ++i < FF_VOLUMES);	/* Repeat for each id until pattern match */
		}
#endif
		if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
			vol = i;		/* Drive number */
			*path = tt;		/* Snip the drive prefix off */
   1b492:	9b06      	ldr	r3, [sp, #24]
   1b494:	2b00      	cmp	r3, #0
   1b496:	dc04      	bgt.n	1b4a2 <get_ldnumber+0x86>
		}
   1b498:	9b06      	ldr	r3, [sp, #24]
   1b49a:	9305      	str	r3, [sp, #20]
		return vol;
   1b49c:	9b01      	ldr	r3, [sp, #4]
   1b49e:	9a07      	ldr	r2, [sp, #28]
   1b4a0:	601a      	str	r2, [r3, #0]
	}
#if FF_STR_VOLUME_ID == 2		/* Unix style volume ID is enabled */
   1b4a2:	9c05      	ldr	r4, [sp, #20]
   1b4a4:	e002      	b.n	1b4ac <get_ldnumber+0x90>
#if FF_FS_RPATH != 0
	vol = CurrVol;	/* Default drive is current drive */
#else
	vol = 0;		/* Default drive is 0 */
#endif
	return vol;		/* Return the default drive */
   1b4a6:	2300      	movs	r3, #0
   1b4a8:	9305      	str	r3, [sp, #20]
}

   1b4aa:	9c05      	ldr	r4, [sp, #20]
   1b4ac:	462b      	mov	r3, r5
   1b4ae:	4619      	mov	r1, r3
   1b4b0:	4803      	ldr	r0, [pc, #12]	; (1b4c0 <get_ldnumber+0xa4>)
   1b4b2:	f7fb fa33 	bl	1691c <__cyg_profile_func_exit>
   1b4b6:	4623      	mov	r3, r4

   1b4b8:	4618      	mov	r0, r3
   1b4ba:	b009      	add	sp, #36	; 0x24
   1b4bc:	bd30      	pop	{r4, r5, pc}
   1b4be:	bf00      	nop
   1b4c0:	0001b41d 	.word	0x0001b41d

0001b4c4 <check_fs>:
	FATFS* fs,			/* Filesystem object */
	DWORD sect			/* Sector# (lba) to load and check if it is an FAT-VBR or not */
)
{
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
   1b4c4:	b530      	push	{r4, r5, lr}
   1b4c6:	b083      	sub	sp, #12
   1b4c8:	4675      	mov	r5, lr
   1b4ca:	9001      	str	r0, [sp, #4]
   1b4cc:	9100      	str	r1, [sp, #0]
   1b4ce:	462b      	mov	r3, r5
   1b4d0:	4619      	mov	r1, r3
   1b4d2:	482a      	ldr	r0, [pc, #168]	; (1b57c <check_fs+0xb8>)
   1b4d4:	f7fb fa0e 	bl	168f4 <__cyg_profile_func_enter>

   1b4d8:	9b01      	ldr	r3, [sp, #4]
   1b4da:	2200      	movs	r2, #0
   1b4dc:	70da      	strb	r2, [r3, #3]
   1b4de:	9b01      	ldr	r3, [sp, #4]
   1b4e0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1b4e4:	62da      	str	r2, [r3, #44]	; 0x2c
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always here regardless of the sector size) */
   1b4e6:	9900      	ldr	r1, [sp, #0]
   1b4e8:	9801      	ldr	r0, [sp, #4]
   1b4ea:	f7fe fe79 	bl	1a1e0 <move_window>
   1b4ee:	4603      	mov	r3, r0
   1b4f0:	2b00      	cmp	r3, #0
   1b4f2:	d001      	beq.n	1b4f8 <check_fs+0x34>
   1b4f4:	2404      	movs	r4, #4
   1b4f6:	e038      	b.n	1b56a <check_fs+0xa6>

#if FF_FS_EXFAT
   1b4f8:	9b01      	ldr	r3, [sp, #4]
   1b4fa:	3330      	adds	r3, #48	; 0x30
   1b4fc:	f503 73ff 	add.w	r3, r3, #510	; 0x1fe
   1b500:	4618      	mov	r0, r3
   1b502:	f7fe fc5b 	bl	19dbc <ld_word>
   1b506:	4603      	mov	r3, r0
   1b508:	461a      	mov	r2, r3
   1b50a:	f64a 2355 	movw	r3, #43605	; 0xaa55
   1b50e:	429a      	cmp	r2, r3
   1b510:	d001      	beq.n	1b516 <check_fs+0x52>
   1b512:	2403      	movs	r4, #3
   1b514:	e029      	b.n	1b56a <check_fs+0xa6>
	if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;	/* Check if exFAT VBR */
#endif
	if (fs->win[BS_JmpBoot] == 0xE9 || fs->win[BS_JmpBoot] == 0xEB || fs->win[BS_JmpBoot] == 0xE8) {	/* Valid JumpBoot code? */
		if (!mem_cmp(fs->win + BS_FilSysType, "FAT", 3)) return 0;		/* Is it an FAT VBR? */
		if (!mem_cmp(fs->win + BS_FilSysType32, "FAT32", 5)) return 0;	/* Is it an FAT32 VBR? */
   1b516:	9b01      	ldr	r3, [sp, #4]
   1b518:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
   1b51c:	2be9      	cmp	r3, #233	; 0xe9
   1b51e:	d009      	beq.n	1b534 <check_fs+0x70>
   1b520:	9b01      	ldr	r3, [sp, #4]
   1b522:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
   1b526:	2beb      	cmp	r3, #235	; 0xeb
   1b528:	d004      	beq.n	1b534 <check_fs+0x70>
   1b52a:	9b01      	ldr	r3, [sp, #4]
   1b52c:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
   1b530:	2be8      	cmp	r3, #232	; 0xe8
   1b532:	d119      	bne.n	1b568 <check_fs+0xa4>
	}
   1b534:	9b01      	ldr	r3, [sp, #4]
   1b536:	3330      	adds	r3, #48	; 0x30
   1b538:	3336      	adds	r3, #54	; 0x36
   1b53a:	2203      	movs	r2, #3
   1b53c:	4910      	ldr	r1, [pc, #64]	; (1b580 <check_fs+0xbc>)
   1b53e:	4618      	mov	r0, r3
   1b540:	f7fe fd3e 	bl	19fc0 <mem_cmp>
   1b544:	4603      	mov	r3, r0
   1b546:	2b00      	cmp	r3, #0
   1b548:	d101      	bne.n	1b54e <check_fs+0x8a>
   1b54a:	2400      	movs	r4, #0
   1b54c:	e00d      	b.n	1b56a <check_fs+0xa6>
	return 2;	/* Valid BS but not FAT */
   1b54e:	9b01      	ldr	r3, [sp, #4]
   1b550:	3330      	adds	r3, #48	; 0x30
   1b552:	3352      	adds	r3, #82	; 0x52
   1b554:	2205      	movs	r2, #5
   1b556:	490b      	ldr	r1, [pc, #44]	; (1b584 <check_fs+0xc0>)
   1b558:	4618      	mov	r0, r3
   1b55a:	f7fe fd31 	bl	19fc0 <mem_cmp>
   1b55e:	4603      	mov	r3, r0
   1b560:	2b00      	cmp	r3, #0
   1b562:	d101      	bne.n	1b568 <check_fs+0xa4>
   1b564:	2400      	movs	r4, #0
   1b566:	e000      	b.n	1b56a <check_fs+0xa6>
}

   1b568:	2402      	movs	r4, #2
   1b56a:	462b      	mov	r3, r5
   1b56c:	4619      	mov	r1, r3
   1b56e:	4803      	ldr	r0, [pc, #12]	; (1b57c <check_fs+0xb8>)
   1b570:	f7fb f9d4 	bl	1691c <__cyg_profile_func_exit>
   1b574:	4623      	mov	r3, r4

   1b576:	4618      	mov	r0, r3
   1b578:	b003      	add	sp, #12
   1b57a:	bd30      	pop	{r4, r5, pc}
   1b57c:	0001b4c5 	.word	0x0001b4c5
   1b580:	0001f530 	.word	0x0001f530
   1b584:	0001f534 	.word	0x0001f534

0001b588 <find_volume>:
	FATFS** rfs,				/* Pointer to pointer to the found filesystem object */
	BYTE mode					/* !=0: Check write protection for write access */
)
{
	BYTE fmt, *pt;
	int vol;
   1b588:	b530      	push	{r4, r5, lr}
   1b58a:	b097      	sub	sp, #92	; 0x5c
   1b58c:	4675      	mov	r5, lr
   1b58e:	9003      	str	r0, [sp, #12]
   1b590:	9102      	str	r1, [sp, #8]
   1b592:	4613      	mov	r3, r2
   1b594:	f88d 3007 	strb.w	r3, [sp, #7]
   1b598:	462b      	mov	r3, r5
   1b59a:	4619      	mov	r1, r3
   1b59c:	48ab      	ldr	r0, [pc, #684]	; (1b84c <find_volume+0x2c4>)
   1b59e:	f7fb f9a9 	bl	168f4 <__cyg_profile_func_enter>


	/* Get logical drive number */
	*rfs = 0;
	vol = get_ldnumber(path);
	if (vol < 0) return FR_INVALID_DRIVE;
   1b5a2:	9b02      	ldr	r3, [sp, #8]
   1b5a4:	2200      	movs	r2, #0
   1b5a6:	601a      	str	r2, [r3, #0]

   1b5a8:	9803      	ldr	r0, [sp, #12]
   1b5aa:	f7ff ff37 	bl	1b41c <get_ldnumber>
   1b5ae:	900f      	str	r0, [sp, #60]	; 0x3c
	/* Check if the filesystem object is valid or not */
   1b5b0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1b5b2:	2b00      	cmp	r3, #0
   1b5b4:	da01      	bge.n	1b5ba <find_volume+0x32>
   1b5b6:	240b      	movs	r4, #11
   1b5b8:	e240      	b.n	1ba3c <find_volume+0x4b4>
	fs = FatFs[vol];					/* Get pointer to the filesystem object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
#if FF_FS_REENTRANT
   1b5ba:	4aa5      	ldr	r2, [pc, #660]	; (1b850 <find_volume+0x2c8>)
   1b5bc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1b5be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1b5c2:	930e      	str	r3, [sp, #56]	; 0x38
	if (!lock_fs(fs)) return FR_TIMEOUT;	/* Lock the volume */
   1b5c4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b5c6:	2b00      	cmp	r3, #0
   1b5c8:	d101      	bne.n	1b5ce <find_volume+0x46>
   1b5ca:	240c      	movs	r4, #12
   1b5cc:	e236      	b.n	1ba3c <find_volume+0x4b4>
#endif
	*rfs = fs;							/* Return pointer to the filesystem object */

	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
   1b5ce:	9b02      	ldr	r3, [sp, #8]
   1b5d0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1b5d2:	601a      	str	r2, [r3, #0]
	if (fs->fs_type != 0) {				/* If the volume has been mounted */
		stat = disk_status(fs->pdrv);
   1b5d4:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1b5d8:	f023 0301 	bic.w	r3, r3, #1
   1b5dc:	f88d 3007 	strb.w	r3, [sp, #7]
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
   1b5e0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b5e2:	781b      	ldrb	r3, [r3, #0]
   1b5e4:	2b00      	cmp	r3, #0
   1b5e6:	d01b      	beq.n	1b620 <find_volume+0x98>
			if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
   1b5e8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b5ea:	785b      	ldrb	r3, [r3, #1]
   1b5ec:	4618      	mov	r0, r3
   1b5ee:	f7fe facf 	bl	19b90 <disk_status>
   1b5f2:	4603      	mov	r3, r0
   1b5f4:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
				return FR_WRITE_PROTECTED;
   1b5f8:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   1b5fc:	f003 0301 	and.w	r3, r3, #1
   1b600:	2b00      	cmp	r3, #0
   1b602:	d10d      	bne.n	1b620 <find_volume+0x98>
			}
   1b604:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1b608:	2b00      	cmp	r3, #0
   1b60a:	d007      	beq.n	1b61c <find_volume+0x94>
   1b60c:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   1b610:	f003 0304 	and.w	r3, r3, #4
   1b614:	2b00      	cmp	r3, #0
   1b616:	d001      	beq.n	1b61c <find_volume+0x94>
			return FR_OK;				/* The filesystem object is valid */
   1b618:	240a      	movs	r4, #10
   1b61a:	e20f      	b.n	1ba3c <find_volume+0x4b4>
		}
	}
   1b61c:	2400      	movs	r4, #0
   1b61e:	e20d      	b.n	1ba3c <find_volume+0x4b4>
	/* The filesystem object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the filesystem object) */

	fs->fs_type = 0;					/* Clear the filesystem object */
	fs->pdrv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->pdrv);	/* Initialize the physical drive */
   1b620:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b622:	2200      	movs	r2, #0
   1b624:	701a      	strb	r2, [r3, #0]
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
   1b626:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1b628:	b2da      	uxtb	r2, r3
   1b62a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b62c:	705a      	strb	r2, [r3, #1]
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
   1b62e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b630:	785b      	ldrb	r3, [r3, #1]
   1b632:	4618      	mov	r0, r3
   1b634:	f7fe faf2 	bl	19c1c <disk_initialize>
   1b638:	4603      	mov	r3, r0
   1b63a:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
	}
   1b63e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   1b642:	f003 0301 	and.w	r3, r3, #1
   1b646:	2b00      	cmp	r3, #0
   1b648:	d001      	beq.n	1b64e <find_volume+0xc6>
	if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
   1b64a:	2403      	movs	r4, #3
   1b64c:	e1f6      	b.n	1ba3c <find_volume+0x4b4>
		return FR_WRITE_PROTECTED;
	}
   1b64e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1b652:	2b00      	cmp	r3, #0
   1b654:	d007      	beq.n	1b666 <find_volume+0xde>
   1b656:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   1b65a:	f003 0304 	and.w	r3, r3, #4
   1b65e:	2b00      	cmp	r3, #0
   1b660:	d001      	beq.n	1b666 <find_volume+0xde>
#if FF_MAX_SS != FF_MIN_SS				/* Get sector size (multiple sector size cfg only) */
   1b662:	240a      	movs	r4, #10
   1b664:	e1ea      	b.n	1ba3c <find_volume+0x4b4>
#endif

	/* Find an FAT partition on the drive. Supports only generic partitioning rules, FDISK (MBR) and SFD (w/o partition). */
	bsect = 0;
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
   1b666:	2300      	movs	r3, #0
   1b668:	9314      	str	r3, [sp, #80]	; 0x50
		for (i = 0; i < 4; i++) {		/* Get partition offset */
   1b66a:	9914      	ldr	r1, [sp, #80]	; 0x50
   1b66c:	980e      	ldr	r0, [sp, #56]	; 0x38
   1b66e:	f7ff ff29 	bl	1b4c4 <check_fs>
   1b672:	4603      	mov	r3, r0
   1b674:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
			pt = fs->win + (MBR_Table + i * SZ_PTE);
   1b678:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
   1b67c:	2b02      	cmp	r3, #2
   1b67e:	d149      	bne.n	1b714 <find_volume+0x18c>
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
   1b680:	2300      	movs	r3, #0
   1b682:	9310      	str	r3, [sp, #64]	; 0x40
   1b684:	e01e      	b.n	1b6c4 <find_volume+0x13c>
		}
   1b686:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b688:	f103 0230 	add.w	r2, r3, #48	; 0x30
   1b68c:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1b68e:	011b      	lsls	r3, r3, #4
   1b690:	f503 73df 	add.w	r3, r3, #446	; 0x1be
   1b694:	4413      	add	r3, r2
   1b696:	930c      	str	r3, [sp, #48]	; 0x30
		i = LD2PT(vol);					/* Partition number: 0:auto, 1-4:forced */
   1b698:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1b69a:	3304      	adds	r3, #4
   1b69c:	781b      	ldrb	r3, [r3, #0]
   1b69e:	2b00      	cmp	r3, #0
   1b6a0:	d006      	beq.n	1b6b0 <find_volume+0x128>
   1b6a2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1b6a4:	3308      	adds	r3, #8
   1b6a6:	4618      	mov	r0, r3
   1b6a8:	f7fe fbae 	bl	19e08 <ld_dword>
   1b6ac:	4602      	mov	r2, r0
   1b6ae:	e000      	b.n	1b6b2 <find_volume+0x12a>
   1b6b0:	2200      	movs	r2, #0
   1b6b2:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1b6b4:	009b      	lsls	r3, r3, #2
   1b6b6:	a916      	add	r1, sp, #88	; 0x58
   1b6b8:	440b      	add	r3, r1
   1b6ba:	f843 2c44 	str.w	r2, [r3, #-68]
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
   1b6be:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1b6c0:	3301      	adds	r3, #1
   1b6c2:	9310      	str	r3, [sp, #64]	; 0x40
   1b6c4:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1b6c6:	2b03      	cmp	r3, #3
   1b6c8:	d9dd      	bls.n	1b686 <find_volume+0xfe>
		if (i != 0) i--;
		do {							/* Find an FAT volume */
   1b6ca:	2300      	movs	r3, #0
   1b6cc:	9310      	str	r3, [sp, #64]	; 0x40
			bsect = br[i];
   1b6ce:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1b6d0:	2b00      	cmp	r3, #0
   1b6d2:	d002      	beq.n	1b6da <find_volume+0x152>
   1b6d4:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1b6d6:	3b01      	subs	r3, #1
   1b6d8:	9310      	str	r3, [sp, #64]	; 0x40
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
   1b6da:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1b6dc:	009b      	lsls	r3, r3, #2
   1b6de:	aa16      	add	r2, sp, #88	; 0x58
   1b6e0:	4413      	add	r3, r2
   1b6e2:	f853 3c44 	ldr.w	r3, [r3, #-68]
   1b6e6:	9314      	str	r3, [sp, #80]	; 0x50
	}
   1b6e8:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1b6ea:	2b00      	cmp	r3, #0
   1b6ec:	d005      	beq.n	1b6fa <find_volume+0x172>
   1b6ee:	9914      	ldr	r1, [sp, #80]	; 0x50
   1b6f0:	980e      	ldr	r0, [sp, #56]	; 0x38
   1b6f2:	f7ff fee7 	bl	1b4c4 <check_fs>
   1b6f6:	4603      	mov	r3, r0
   1b6f8:	e000      	b.n	1b6fc <find_volume+0x174>
   1b6fa:	2303      	movs	r3, #3
   1b6fc:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
   1b700:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
   1b704:	2b01      	cmp	r3, #1
   1b706:	d905      	bls.n	1b714 <find_volume+0x18c>
   1b708:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1b70a:	3301      	adds	r3, #1
   1b70c:	9310      	str	r3, [sp, #64]	; 0x40
   1b70e:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1b710:	2b03      	cmp	r3, #3
   1b712:	d9e2      	bls.n	1b6da <find_volume+0x152>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */

   1b714:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
   1b718:	2b04      	cmp	r3, #4
   1b71a:	d101      	bne.n	1b720 <find_volume+0x198>
   1b71c:	2401      	movs	r4, #1
   1b71e:	e18d      	b.n	1ba3c <find_volume+0x4b4>
	/* An FAT volume is found (bsect). Following code initializes the filesystem object */
   1b720:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
   1b724:	2b01      	cmp	r3, #1
   1b726:	d901      	bls.n	1b72c <find_volume+0x1a4>
   1b728:	240d      	movs	r4, #13
   1b72a:	e187      	b.n	1ba3c <find_volume+0x4b4>
	} else
#endif	/* FF_FS_EXFAT */
	{
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */

		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
   1b72c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b72e:	3330      	adds	r3, #48	; 0x30
   1b730:	330b      	adds	r3, #11
   1b732:	4618      	mov	r0, r3
   1b734:	f7fe fb42 	bl	19dbc <ld_word>
   1b738:	4603      	mov	r3, r0
   1b73a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   1b73e:	d001      	beq.n	1b744 <find_volume+0x1bc>
   1b740:	240d      	movs	r4, #13
   1b742:	e17b      	b.n	1ba3c <find_volume+0x4b4>
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
		fs->fsize = fasize;
   1b744:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b746:	3330      	adds	r3, #48	; 0x30
   1b748:	3316      	adds	r3, #22
   1b74a:	4618      	mov	r0, r3
   1b74c:	f7fe fb36 	bl	19dbc <ld_word>
   1b750:	4603      	mov	r3, r0
   1b752:	9313      	str	r3, [sp, #76]	; 0x4c

   1b754:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1b756:	2b00      	cmp	r3, #0
   1b758:	d106      	bne.n	1b768 <find_volume+0x1e0>
   1b75a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b75c:	3330      	adds	r3, #48	; 0x30
   1b75e:	3324      	adds	r3, #36	; 0x24
   1b760:	4618      	mov	r0, r3
   1b762:	f7fe fb51 	bl	19e08 <ld_dword>
   1b766:	9013      	str	r0, [sp, #76]	; 0x4c
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
   1b768:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b76a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   1b76c:	619a      	str	r2, [r3, #24]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
   1b76e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b770:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
   1b774:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b776:	709a      	strb	r2, [r3, #2]

   1b778:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b77a:	789b      	ldrb	r3, [r3, #2]
   1b77c:	2b01      	cmp	r3, #1
   1b77e:	d005      	beq.n	1b78c <find_volume+0x204>
   1b780:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b782:	789b      	ldrb	r3, [r3, #2]
   1b784:	2b02      	cmp	r3, #2
   1b786:	d001      	beq.n	1b78c <find_volume+0x204>
   1b788:	240d      	movs	r4, #13
   1b78a:	e157      	b.n	1ba3c <find_volume+0x4b4>
		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
   1b78c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b78e:	789b      	ldrb	r3, [r3, #2]
   1b790:	461a      	mov	r2, r3
   1b792:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1b794:	fb02 f303 	mul.w	r3, r2, r3
   1b798:	9313      	str	r3, [sp, #76]	; 0x4c
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */

   1b79a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b79c:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
   1b7a0:	b29a      	uxth	r2, r3
   1b7a2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b7a4:	815a      	strh	r2, [r3, #10]
		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
   1b7a6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b7a8:	895b      	ldrh	r3, [r3, #10]
   1b7aa:	2b00      	cmp	r3, #0
   1b7ac:	d008      	beq.n	1b7c0 <find_volume+0x238>
   1b7ae:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b7b0:	895b      	ldrh	r3, [r3, #10]
   1b7b2:	461a      	mov	r2, r3
   1b7b4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b7b6:	895b      	ldrh	r3, [r3, #10]
   1b7b8:	3b01      	subs	r3, #1
   1b7ba:	4013      	ands	r3, r2
   1b7bc:	2b00      	cmp	r3, #0
   1b7be:	d001      	beq.n	1b7c4 <find_volume+0x23c>
   1b7c0:	240d      	movs	r4, #13
   1b7c2:	e13b      	b.n	1ba3c <find_volume+0x4b4>
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */

   1b7c4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b7c6:	3330      	adds	r3, #48	; 0x30
   1b7c8:	3311      	adds	r3, #17
   1b7ca:	4618      	mov	r0, r3
   1b7cc:	f7fe faf6 	bl	19dbc <ld_word>
   1b7d0:	4603      	mov	r3, r0
   1b7d2:	461a      	mov	r2, r3
   1b7d4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b7d6:	811a      	strh	r2, [r3, #8]
		tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
   1b7d8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b7da:	891b      	ldrh	r3, [r3, #8]
   1b7dc:	f003 030f 	and.w	r3, r3, #15
   1b7e0:	b29b      	uxth	r3, r3
   1b7e2:	2b00      	cmp	r3, #0
   1b7e4:	d001      	beq.n	1b7ea <find_volume+0x262>
   1b7e6:	240d      	movs	r4, #13
   1b7e8:	e128      	b.n	1ba3c <find_volume+0x4b4>
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);

   1b7ea:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b7ec:	3330      	adds	r3, #48	; 0x30
   1b7ee:	3313      	adds	r3, #19
   1b7f0:	4618      	mov	r0, r3
   1b7f2:	f7fe fae3 	bl	19dbc <ld_word>
   1b7f6:	4603      	mov	r3, r0
   1b7f8:	9312      	str	r3, [sp, #72]	; 0x48
		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);		/* Number of reserved sectors */
   1b7fa:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1b7fc:	2b00      	cmp	r3, #0
   1b7fe:	d106      	bne.n	1b80e <find_volume+0x286>
   1b800:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b802:	3330      	adds	r3, #48	; 0x30
   1b804:	3320      	adds	r3, #32
   1b806:	4618      	mov	r0, r3
   1b808:	f7fe fafe 	bl	19e08 <ld_dword>
   1b80c:	9012      	str	r0, [sp, #72]	; 0x48
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */

   1b80e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b810:	3330      	adds	r3, #48	; 0x30
   1b812:	330e      	adds	r3, #14
   1b814:	4618      	mov	r0, r3
   1b816:	f7fe fad1 	bl	19dbc <ld_word>
   1b81a:	4603      	mov	r3, r0
   1b81c:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
		/* Determine the FAT sub type */
   1b820:	f8bd 302e 	ldrh.w	r3, [sp, #46]	; 0x2e
   1b824:	2b00      	cmp	r3, #0
   1b826:	d101      	bne.n	1b82c <find_volume+0x2a4>
   1b828:	240d      	movs	r4, #13
   1b82a:	e107      	b.n	1ba3c <find_volume+0x4b4>
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
   1b82c:	f8bd 202e 	ldrh.w	r2, [sp, #46]	; 0x2e
   1b830:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1b832:	4413      	add	r3, r2
   1b834:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1b836:	8912      	ldrh	r2, [r2, #8]
   1b838:	0912      	lsrs	r2, r2, #4
   1b83a:	b292      	uxth	r2, r2
   1b83c:	4413      	add	r3, r2
   1b83e:	930a      	str	r3, [sp, #40]	; 0x28
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
   1b840:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1b842:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1b844:	429a      	cmp	r2, r3
   1b846:	d205      	bcs.n	1b854 <find_volume+0x2cc>
   1b848:	240d      	movs	r4, #13
   1b84a:	e0f7      	b.n	1ba3c <find_volume+0x4b4>
   1b84c:	0001b589 	.word	0x0001b589
   1b850:	100033f0 	.word	0x100033f0
		fmt = 0;
   1b854:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1b856:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1b858:	1ad3      	subs	r3, r2, r3
   1b85a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1b85c:	8952      	ldrh	r2, [r2, #10]
   1b85e:	fbb3 f3f2 	udiv	r3, r3, r2
   1b862:	9309      	str	r3, [sp, #36]	; 0x24
		if (nclst <= MAX_FAT32) fmt = FS_FAT32;
   1b864:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1b866:	2b00      	cmp	r3, #0
   1b868:	d101      	bne.n	1b86e <find_volume+0x2e6>
   1b86a:	240d      	movs	r4, #13
   1b86c:	e0e6      	b.n	1ba3c <find_volume+0x4b4>
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
   1b86e:	2300      	movs	r3, #0
   1b870:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
   1b874:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1b876:	4a76      	ldr	r2, [pc, #472]	; (1ba50 <find_volume+0x4c8>)
   1b878:	4293      	cmp	r3, r2
   1b87a:	d802      	bhi.n	1b882 <find_volume+0x2fa>
   1b87c:	2303      	movs	r3, #3
   1b87e:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
		if (fmt == 0) return FR_NO_FILESYSTEM;
   1b882:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1b884:	f64f 72f5 	movw	r2, #65525	; 0xfff5
   1b888:	4293      	cmp	r3, r2
   1b88a:	d802      	bhi.n	1b892 <find_volume+0x30a>
   1b88c:	2302      	movs	r3, #2
   1b88e:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57

   1b892:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1b894:	f640 72f5 	movw	r2, #4085	; 0xff5
   1b898:	4293      	cmp	r3, r2
   1b89a:	d802      	bhi.n	1b8a2 <find_volume+0x31a>
   1b89c:	2301      	movs	r3, #1
   1b89e:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
		/* Boundaries and Limits */
   1b8a2:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
   1b8a6:	2b00      	cmp	r3, #0
   1b8a8:	d101      	bne.n	1b8ae <find_volume+0x326>
   1b8aa:	240d      	movs	r4, #13
   1b8ac:	e0c6      	b.n	1ba3c <find_volume+0x4b4>
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
		fs->volbase = bsect;							/* Volume start sector */
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
   1b8ae:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1b8b0:	1c9a      	adds	r2, r3, #2
   1b8b2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b8b4:	615a      	str	r2, [r3, #20]
		fs->database = bsect + sysect;					/* Data start sector */
   1b8b6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b8b8:	9a14      	ldr	r2, [sp, #80]	; 0x50
   1b8ba:	61da      	str	r2, [r3, #28]
		if (fmt == FS_FAT32) {
   1b8bc:	f8bd 202e 	ldrh.w	r2, [sp, #46]	; 0x2e
   1b8c0:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1b8c2:	441a      	add	r2, r3
   1b8c4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b8c6:	621a      	str	r2, [r3, #32]
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
   1b8c8:	9a14      	ldr	r2, [sp, #80]	; 0x50
   1b8ca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1b8cc:	441a      	add	r2, r3
   1b8ce:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b8d0:	629a      	str	r2, [r3, #40]	; 0x28
			if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
   1b8d2:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
   1b8d6:	2b03      	cmp	r3, #3
   1b8d8:	d11e      	bne.n	1b918 <find_volume+0x390>
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
   1b8da:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b8dc:	3330      	adds	r3, #48	; 0x30
   1b8de:	332a      	adds	r3, #42	; 0x2a
   1b8e0:	4618      	mov	r0, r3
   1b8e2:	f7fe fa6b 	bl	19dbc <ld_word>
   1b8e6:	4603      	mov	r3, r0
   1b8e8:	2b00      	cmp	r3, #0
   1b8ea:	d001      	beq.n	1b8f0 <find_volume+0x368>
   1b8ec:	240d      	movs	r4, #13
   1b8ee:	e0a5      	b.n	1ba3c <find_volume+0x4b4>
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
   1b8f0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b8f2:	891b      	ldrh	r3, [r3, #8]
   1b8f4:	2b00      	cmp	r3, #0
   1b8f6:	d001      	beq.n	1b8fc <find_volume+0x374>
   1b8f8:	240d      	movs	r4, #13
   1b8fa:	e09f      	b.n	1ba3c <find_volume+0x4b4>
		} else {
   1b8fc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b8fe:	3330      	adds	r3, #48	; 0x30
   1b900:	332c      	adds	r3, #44	; 0x2c
   1b902:	4618      	mov	r0, r3
   1b904:	f7fe fa80 	bl	19e08 <ld_dword>
   1b908:	4602      	mov	r2, r0
   1b90a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b90c:	625a      	str	r2, [r3, #36]	; 0x24
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
   1b90e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b910:	695b      	ldr	r3, [r3, #20]
   1b912:	009b      	lsls	r3, r3, #2
   1b914:	9311      	str	r3, [sp, #68]	; 0x44
   1b916:	e01f      	b.n	1b958 <find_volume+0x3d0>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
   1b918:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b91a:	891b      	ldrh	r3, [r3, #8]
   1b91c:	2b00      	cmp	r3, #0
   1b91e:	d101      	bne.n	1b924 <find_volume+0x39c>
   1b920:	240d      	movs	r4, #13
   1b922:	e08b      	b.n	1ba3c <find_volume+0x4b4>
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
   1b924:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b926:	6a1a      	ldr	r2, [r3, #32]
   1b928:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1b92a:	441a      	add	r2, r3
   1b92c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b92e:	625a      	str	r2, [r3, #36]	; 0x24
		}
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
   1b930:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
   1b934:	2b02      	cmp	r3, #2
   1b936:	d103      	bne.n	1b940 <find_volume+0x3b8>
   1b938:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b93a:	695b      	ldr	r3, [r3, #20]
   1b93c:	005b      	lsls	r3, r3, #1
   1b93e:	e00a      	b.n	1b956 <find_volume+0x3ce>
   1b940:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b942:	695a      	ldr	r2, [r3, #20]
   1b944:	4613      	mov	r3, r2
   1b946:	005b      	lsls	r3, r3, #1
   1b948:	4413      	add	r3, r2
   1b94a:	085a      	lsrs	r2, r3, #1
   1b94c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b94e:	695b      	ldr	r3, [r3, #20]
   1b950:	f003 0301 	and.w	r3, r3, #1
   1b954:	4413      	add	r3, r2
		}
   1b956:	9311      	str	r3, [sp, #68]	; 0x44

#if !FF_FS_READONLY
   1b958:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b95a:	699a      	ldr	r2, [r3, #24]
   1b95c:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1b95e:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
   1b962:	0a5b      	lsrs	r3, r3, #9
   1b964:	429a      	cmp	r2, r3
   1b966:	d201      	bcs.n	1b96c <find_volume+0x3e4>
   1b968:	240d      	movs	r4, #13
   1b96a:	e067      	b.n	1ba3c <find_volume+0x4b4>
		/* Get FSInfo if available */
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
		fs->fsi_flag = 0x80;
#if (FF_FS_NOFSINFO & 3) != 3
   1b96c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b96e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1b972:	611a      	str	r2, [r3, #16]
   1b974:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b976:	691a      	ldr	r2, [r3, #16]
   1b978:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b97a:	60da      	str	r2, [r3, #12]
		if (fmt == FS_FAT32				/* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
   1b97c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b97e:	2280      	movs	r2, #128	; 0x80
   1b980:	711a      	strb	r2, [r3, #4]
			&& ld_word(fs->win + BPB_FSInfo32) == 1
			&& move_window(fs, bsect + 1) == FR_OK)
   1b982:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
   1b986:	2b03      	cmp	r3, #3
   1b988:	d149      	bne.n	1ba1e <find_volume+0x496>
		{
   1b98a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b98c:	3330      	adds	r3, #48	; 0x30
   1b98e:	3330      	adds	r3, #48	; 0x30
   1b990:	4618      	mov	r0, r3
   1b992:	f7fe fa13 	bl	19dbc <ld_word>
   1b996:	4603      	mov	r3, r0
   1b998:	2b01      	cmp	r3, #1
   1b99a:	d140      	bne.n	1ba1e <find_volume+0x496>
			fs->fsi_flag = 0;
   1b99c:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1b99e:	3301      	adds	r3, #1
   1b9a0:	4619      	mov	r1, r3
   1b9a2:	980e      	ldr	r0, [sp, #56]	; 0x38
   1b9a4:	f7fe fc1c 	bl	1a1e0 <move_window>
   1b9a8:	4603      	mov	r3, r0
   1b9aa:	2b00      	cmp	r3, #0
   1b9ac:	d137      	bne.n	1ba1e <find_volume+0x496>
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
   1b9ae:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b9b0:	2200      	movs	r2, #0
   1b9b2:	711a      	strb	r2, [r3, #4]
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
   1b9b4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b9b6:	3330      	adds	r3, #48	; 0x30
   1b9b8:	f503 73ff 	add.w	r3, r3, #510	; 0x1fe
   1b9bc:	4618      	mov	r0, r3
   1b9be:	f7fe f9fd 	bl	19dbc <ld_word>
   1b9c2:	4603      	mov	r3, r0
   1b9c4:	461a      	mov	r2, r3
   1b9c6:	f64a 2355 	movw	r3, #43605	; 0xaa55
   1b9ca:	429a      	cmp	r2, r3
   1b9cc:	d127      	bne.n	1ba1e <find_volume+0x496>
			{
   1b9ce:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b9d0:	3330      	adds	r3, #48	; 0x30
   1b9d2:	4618      	mov	r0, r3
   1b9d4:	f7fe fa18 	bl	19e08 <ld_dword>
   1b9d8:	4602      	mov	r2, r0
   1b9da:	4b1e      	ldr	r3, [pc, #120]	; (1ba54 <find_volume+0x4cc>)
   1b9dc:	429a      	cmp	r2, r3
   1b9de:	d11e      	bne.n	1ba1e <find_volume+0x496>
#if (FF_FS_NOFSINFO & 1) == 0
   1b9e0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b9e2:	3330      	adds	r3, #48	; 0x30
   1b9e4:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
   1b9e8:	4618      	mov	r0, r3
   1b9ea:	f7fe fa0d 	bl	19e08 <ld_dword>
   1b9ee:	4602      	mov	r2, r0
   1b9f0:	4b19      	ldr	r3, [pc, #100]	; (1ba58 <find_volume+0x4d0>)
   1b9f2:	429a      	cmp	r2, r3
   1b9f4:	d113      	bne.n	1ba1e <find_volume+0x496>
				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
#endif
#if (FF_FS_NOFSINFO & 2) == 0
   1b9f6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b9f8:	3330      	adds	r3, #48	; 0x30
   1b9fa:	f503 73f4 	add.w	r3, r3, #488	; 0x1e8
   1b9fe:	4618      	mov	r0, r3
   1ba00:	f7fe fa02 	bl	19e08 <ld_dword>
   1ba04:	4602      	mov	r2, r0
   1ba06:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1ba08:	611a      	str	r2, [r3, #16]
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
#endif
			}
   1ba0a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1ba0c:	3330      	adds	r3, #48	; 0x30
   1ba0e:	f503 73f6 	add.w	r3, r3, #492	; 0x1ec
   1ba12:	4618      	mov	r0, r3
   1ba14:	f7fe f9f8 	bl	19e08 <ld_dword>
   1ba18:	4602      	mov	r2, r0
   1ba1a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1ba1c:	60da      	str	r2, [r3, #12]
#endif	/* !FF_FS_READONLY */
	}

	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* Volume mount ID */
#if FF_USE_LFN == 1
   1ba1e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1ba20:	f89d 2057 	ldrb.w	r2, [sp, #87]	; 0x57
   1ba24:	701a      	strb	r2, [r3, #0]
	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
   1ba26:	4b0d      	ldr	r3, [pc, #52]	; (1ba5c <find_volume+0x4d4>)
   1ba28:	881b      	ldrh	r3, [r3, #0]
   1ba2a:	3301      	adds	r3, #1
   1ba2c:	b29a      	uxth	r2, r3
   1ba2e:	4b0b      	ldr	r3, [pc, #44]	; (1ba5c <find_volume+0x4d4>)
   1ba30:	801a      	strh	r2, [r3, #0]
   1ba32:	4b0a      	ldr	r3, [pc, #40]	; (1ba5c <find_volume+0x4d4>)
   1ba34:	881a      	ldrh	r2, [r3, #0]
   1ba36:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1ba38:	80da      	strh	r2, [r3, #6]
#if FF_FS_LOCK != 0			/* Clear file lock semaphores */
	clear_lock(fs);
#endif
	return FR_OK;
}

   1ba3a:	2400      	movs	r4, #0
   1ba3c:	462b      	mov	r3, r5
   1ba3e:	4619      	mov	r1, r3
   1ba40:	4807      	ldr	r0, [pc, #28]	; (1ba60 <find_volume+0x4d8>)
   1ba42:	f7fa ff6b 	bl	1691c <__cyg_profile_func_exit>
   1ba46:	4623      	mov	r3, r4

   1ba48:	4618      	mov	r0, r3
   1ba4a:	b017      	add	sp, #92	; 0x5c
   1ba4c:	bd30      	pop	{r4, r5, pc}
   1ba4e:	bf00      	nop
   1ba50:	0ffffff5 	.word	0x0ffffff5
   1ba54:	41615252 	.word	0x41615252
   1ba58:	61417272 	.word	0x61417272
   1ba5c:	100033f4 	.word	0x100033f4
   1ba60:	0001b589 	.word	0x0001b589

0001ba64 <validate>:
	FFOBJID* obj,			/* Pointer to the FFOBJID, the 1st member in the FIL/DIR object, to check validity */
	FATFS** rfs				/* Pointer to pointer to the owner filesystem object to return */
)
{
	FRESULT res = FR_INVALID_OBJECT;

   1ba64:	b530      	push	{r4, r5, lr}
   1ba66:	b085      	sub	sp, #20
   1ba68:	4675      	mov	r5, lr
   1ba6a:	9001      	str	r0, [sp, #4]
   1ba6c:	9100      	str	r1, [sp, #0]
   1ba6e:	462b      	mov	r3, r5
   1ba70:	4619      	mov	r1, r3
   1ba72:	481e      	ldr	r0, [pc, #120]	; (1baec <validate+0x88>)
   1ba74:	f7fa ff3e 	bl	168f4 <__cyg_profile_func_enter>

   1ba78:	2309      	movs	r3, #9
   1ba7a:	f88d 300f 	strb.w	r3, [sp, #15]
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
#if FF_FS_REENTRANT
		if (lock_fs(obj->fs)) {	/* Obtain the filesystem object */
   1ba7e:	9b01      	ldr	r3, [sp, #4]
   1ba80:	2b00      	cmp	r3, #0
   1ba82:	d01d      	beq.n	1bac0 <validate+0x5c>
   1ba84:	9b01      	ldr	r3, [sp, #4]
   1ba86:	681b      	ldr	r3, [r3, #0]
   1ba88:	2b00      	cmp	r3, #0
   1ba8a:	d019      	beq.n	1bac0 <validate+0x5c>
   1ba8c:	9b01      	ldr	r3, [sp, #4]
   1ba8e:	681b      	ldr	r3, [r3, #0]
   1ba90:	781b      	ldrb	r3, [r3, #0]
   1ba92:	2b00      	cmp	r3, #0
   1ba94:	d014      	beq.n	1bac0 <validate+0x5c>
   1ba96:	9b01      	ldr	r3, [sp, #4]
   1ba98:	889a      	ldrh	r2, [r3, #4]
   1ba9a:	9b01      	ldr	r3, [sp, #4]
   1ba9c:	681b      	ldr	r3, [r3, #0]
   1ba9e:	88db      	ldrh	r3, [r3, #6]
   1baa0:	429a      	cmp	r2, r3
   1baa2:	d10d      	bne.n	1bac0 <validate+0x5c>
			res = FR_TIMEOUT;
		}
#else
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
			res = FR_OK;
		}
   1baa4:	9b01      	ldr	r3, [sp, #4]
   1baa6:	681b      	ldr	r3, [r3, #0]
   1baa8:	785b      	ldrb	r3, [r3, #1]
   1baaa:	4618      	mov	r0, r3
   1baac:	f7fe f870 	bl	19b90 <disk_status>
   1bab0:	4603      	mov	r3, r0
   1bab2:	f003 0301 	and.w	r3, r3, #1
   1bab6:	2b00      	cmp	r3, #0
   1bab8:	d102      	bne.n	1bac0 <validate+0x5c>
#endif
   1baba:	2300      	movs	r3, #0
   1babc:	f88d 300f 	strb.w	r3, [sp, #15]
	}
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
	return res;
}
   1bac0:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1bac4:	2b00      	cmp	r3, #0
   1bac6:	d102      	bne.n	1bace <validate+0x6a>
   1bac8:	9b01      	ldr	r3, [sp, #4]
   1baca:	681b      	ldr	r3, [r3, #0]
   1bacc:	e000      	b.n	1bad0 <validate+0x6c>
   1bace:	2300      	movs	r3, #0
   1bad0:	9a00      	ldr	r2, [sp, #0]
   1bad2:	6013      	str	r3, [r2, #0]

   1bad4:	f89d 400f 	ldrb.w	r4, [sp, #15]
   1bad8:	462b      	mov	r3, r5
   1bada:	4619      	mov	r1, r3
   1badc:	4803      	ldr	r0, [pc, #12]	; (1baec <validate+0x88>)
   1bade:	f7fa ff1d 	bl	1691c <__cyg_profile_func_exit>
   1bae2:	4623      	mov	r3, r4

   1bae4:	4618      	mov	r0, r3
   1bae6:	b005      	add	sp, #20
   1bae8:	bd30      	pop	{r4, r5, pc}
   1baea:	bf00      	nop
   1baec:	0001ba65 	.word	0x0001ba65

0001baf0 <f_mount>:
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
	FATFS *cfs;
	int vol;
   1baf0:	b530      	push	{r4, r5, lr}
   1baf2:	b089      	sub	sp, #36	; 0x24
   1baf4:	4675      	mov	r5, lr
   1baf6:	9003      	str	r0, [sp, #12]
   1baf8:	9102      	str	r1, [sp, #8]
   1bafa:	4613      	mov	r3, r2
   1bafc:	f88d 3007 	strb.w	r3, [sp, #7]
   1bb00:	462b      	mov	r3, r5
   1bb02:	4619      	mov	r1, r3
   1bb04:	481f      	ldr	r0, [pc, #124]	; (1bb84 <f_mount+0x94>)
   1bb06:	f7fa fef5 	bl	168f4 <__cyg_profile_func_enter>
	FRESULT res;
	const TCHAR *rp = path;


   1bb0a:	9b02      	ldr	r3, [sp, #8]
   1bb0c:	9304      	str	r3, [sp, #16]
	/* Get logical drive number */
	vol = get_ldnumber(&rp);
	if (vol < 0) return FR_INVALID_DRIVE;
	cfs = FatFs[vol];					/* Pointer to fs object */
   1bb0e:	ab04      	add	r3, sp, #16
   1bb10:	4618      	mov	r0, r3
   1bb12:	f7ff fc83 	bl	1b41c <get_ldnumber>
   1bb16:	9007      	str	r0, [sp, #28]

   1bb18:	9b07      	ldr	r3, [sp, #28]
   1bb1a:	2b00      	cmp	r3, #0
   1bb1c:	da01      	bge.n	1bb22 <f_mount+0x32>
   1bb1e:	240b      	movs	r4, #11
   1bb20:	e026      	b.n	1bb70 <f_mount+0x80>
	if (cfs) {
   1bb22:	4a19      	ldr	r2, [pc, #100]	; (1bb88 <f_mount+0x98>)
   1bb24:	9b07      	ldr	r3, [sp, #28]
   1bb26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1bb2a:	9306      	str	r3, [sp, #24]
#if FF_FS_LOCK != 0
		clear_lock(cfs);
   1bb2c:	9b06      	ldr	r3, [sp, #24]
   1bb2e:	2b00      	cmp	r3, #0
   1bb30:	d002      	beq.n	1bb38 <f_mount+0x48>
#if FF_FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
	}

   1bb32:	9b06      	ldr	r3, [sp, #24]
   1bb34:	2200      	movs	r2, #0
   1bb36:	701a      	strb	r2, [r3, #0]
	if (fs) {
		fs->fs_type = 0;				/* Clear new fs object */
#if FF_FS_REENTRANT						/* Create sync object for the new volume */
   1bb38:	9b03      	ldr	r3, [sp, #12]
   1bb3a:	2b00      	cmp	r3, #0
   1bb3c:	d002      	beq.n	1bb44 <f_mount+0x54>
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
   1bb3e:	9b03      	ldr	r3, [sp, #12]
   1bb40:	2200      	movs	r2, #0
   1bb42:	701a      	strb	r2, [r3, #0]
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */

	if (opt == 0) return FR_OK;			/* Do not mount now, it will be mounted later */
   1bb44:	9a03      	ldr	r2, [sp, #12]
   1bb46:	4910      	ldr	r1, [pc, #64]	; (1bb88 <f_mount+0x98>)
   1bb48:	9b07      	ldr	r3, [sp, #28]
   1bb4a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
   1bb4e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1bb52:	2b00      	cmp	r3, #0
   1bb54:	d101      	bne.n	1bb5a <f_mount+0x6a>
   1bb56:	2400      	movs	r4, #0
   1bb58:	e00a      	b.n	1bb70 <f_mount+0x80>
	LEAVE_FF(fs, res);
}
   1bb5a:	a903      	add	r1, sp, #12
   1bb5c:	ab02      	add	r3, sp, #8
   1bb5e:	2200      	movs	r2, #0
   1bb60:	4618      	mov	r0, r3
   1bb62:	f7ff fd11 	bl	1b588 <find_volume>
   1bb66:	4603      	mov	r3, r0
   1bb68:	f88d 3017 	strb.w	r3, [sp, #23]

   1bb6c:	f89d 4017 	ldrb.w	r4, [sp, #23]
   1bb70:	462b      	mov	r3, r5
   1bb72:	4619      	mov	r1, r3
   1bb74:	4803      	ldr	r0, [pc, #12]	; (1bb84 <f_mount+0x94>)
   1bb76:	f7fa fed1 	bl	1691c <__cyg_profile_func_exit>
   1bb7a:	4623      	mov	r3, r4

   1bb7c:	4618      	mov	r0, r3
   1bb7e:	b009      	add	sp, #36	; 0x24
   1bb80:	bd30      	pop	{r4, r5, pc}
   1bb82:	bf00      	nop
   1bb84:	0001baf1 	.word	0x0001baf1
   1bb88:	100033f0 	.word	0x100033f0

0001bb8c <f_open>:
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
	FRESULT res;
	DIR dj;
   1bb8c:	b530      	push	{r4, r5, lr}
   1bb8e:	b099      	sub	sp, #100	; 0x64
   1bb90:	4675      	mov	r5, lr
   1bb92:	9003      	str	r0, [sp, #12]
   1bb94:	9102      	str	r1, [sp, #8]
   1bb96:	4613      	mov	r3, r2
   1bb98:	f88d 3007 	strb.w	r3, [sp, #7]
   1bb9c:	462b      	mov	r3, r5
   1bb9e:	4619      	mov	r1, r3
   1bba0:	48b1      	ldr	r0, [pc, #708]	; (1be68 <f_open+0x2dc>)
   1bba2:	f7fa fea7 	bl	168f4 <__cyg_profile_func_enter>
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;

	/* Get logical drive number */
   1bba6:	9b03      	ldr	r3, [sp, #12]
   1bba8:	2b00      	cmp	r3, #0
   1bbaa:	d101      	bne.n	1bbb0 <f_open+0x24>
   1bbac:	2409      	movs	r4, #9
   1bbae:	e17e      	b.n	1beae <f_open+0x322>
	mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND;
	res = find_volume(&path, &fs, mode);
	if (res == FR_OK) {
   1bbb0:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1bbb4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   1bbb8:	f88d 3007 	strb.w	r3, [sp, #7]
		dj.obj.fs = fs;
   1bbbc:	f89d 2007 	ldrb.w	r2, [sp, #7]
   1bbc0:	a905      	add	r1, sp, #20
   1bbc2:	ab02      	add	r3, sp, #8
   1bbc4:	4618      	mov	r0, r3
   1bbc6:	f7ff fcdf 	bl	1b588 <find_volume>
   1bbca:	4603      	mov	r3, r0
   1bbcc:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
		INIT_NAMBUF(fs);
   1bbd0:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   1bbd4:	2b00      	cmp	r3, #0
   1bbd6:	f040 8161 	bne.w	1be9c <f_open+0x310>
		res = follow_path(&dj, path);	/* Follow the file path */
   1bbda:	9b05      	ldr	r3, [sp, #20]
   1bbdc:	9306      	str	r3, [sp, #24]
#if !FF_FS_READONLY	/* Read/Write configuration */
		if (res == FR_OK) {
   1bbde:	9a02      	ldr	r2, [sp, #8]
   1bbe0:	ab06      	add	r3, sp, #24
   1bbe2:	4611      	mov	r1, r2
   1bbe4:	4618      	mov	r0, r3
   1bbe6:	f7ff fb91 	bl	1b30c <follow_path>
   1bbea:	4603      	mov	r3, r0
   1bbec:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
				res = FR_INVALID_NAME;
   1bbf0:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   1bbf4:	2b00      	cmp	r3, #0
   1bbf6:	d107      	bne.n	1bc08 <f_open+0x7c>
			}
   1bbf8:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
   1bbfc:	b25b      	sxtb	r3, r3
   1bbfe:	2b00      	cmp	r3, #0
   1bc00:	da02      	bge.n	1bc08 <f_open+0x7c>
#if FF_FS_LOCK != 0
   1bc02:	2306      	movs	r3, #6
   1bc04:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
			if (res != FR_OK) {					/* No file, create new */
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
   1bc08:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1bc0c:	f003 031c 	and.w	r3, r3, #28
   1bc10:	2b00      	cmp	r3, #0
   1bc12:	d072      	beq.n	1bcfa <f_open+0x16e>
#if FF_FS_LOCK != 0
   1bc14:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   1bc18:	2b00      	cmp	r3, #0
   1bc1a:	d011      	beq.n	1bc40 <f_open+0xb4>
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
   1bc1c:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   1bc20:	2b04      	cmp	r3, #4
   1bc22:	d106      	bne.n	1bc32 <f_open+0xa6>
#else
					res = dir_register(&dj);
#endif
				}
   1bc24:	ab06      	add	r3, sp, #24
   1bc26:	4618      	mov	r0, r3
   1bc28:	f7ff f9e4 	bl	1aff4 <dir_register>
   1bc2c:	4603      	mov	r3, r0
   1bc2e:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
				mode |= FA_CREATE_ALWAYS;		/* File is created */
			}
			else {								/* Any object with the same name is already existing */
   1bc32:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1bc36:	f043 0308 	orr.w	r3, r3, #8
   1bc3a:	f88d 3007 	strb.w	r3, [sp, #7]
   1bc3e:	e012      	b.n	1bc66 <f_open+0xda>
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
					res = FR_DENIED;
				} else {
   1bc40:	f89d 301e 	ldrb.w	r3, [sp, #30]
   1bc44:	f003 0311 	and.w	r3, r3, #17
   1bc48:	2b00      	cmp	r3, #0
   1bc4a:	d003      	beq.n	1bc54 <f_open+0xc8>
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
   1bc4c:	2307      	movs	r3, #7
   1bc4e:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
   1bc52:	e008      	b.n	1bc66 <f_open+0xda>
				}
			}
   1bc54:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1bc58:	f003 0304 	and.w	r3, r3, #4
   1bc5c:	2b00      	cmp	r3, #0
   1bc5e:	d002      	beq.n	1bc66 <f_open+0xda>
   1bc60:	2308      	movs	r3, #8
   1bc62:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
#if FF_FS_EXFAT
				if (fs->fs_type == FS_EXFAT) {
   1bc66:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   1bc6a:	2b00      	cmp	r3, #0
   1bc6c:	d162      	bne.n	1bd34 <f_open+0x1a8>
   1bc6e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1bc72:	f003 0308 	and.w	r3, r3, #8
   1bc76:	2b00      	cmp	r3, #0
   1bc78:	d05c      	beq.n	1bd34 <f_open+0x1a8>
#endif
				{
					/* Set directory entry initial state */
					cl = ld_clust(fs, dj.dir);			/* Get current cluster chain */
					st_dword(dj.dir + DIR_CrtTime, GET_FATTIME());	/* Set created time */
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
   1bc7a:	9b05      	ldr	r3, [sp, #20]
   1bc7c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1bc7e:	4611      	mov	r1, r2
   1bc80:	4618      	mov	r0, r3
   1bc82:	f7ff f879 	bl	1ad78 <ld_clust>
   1bc86:	9014      	str	r0, [sp, #80]	; 0x50
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
   1bc88:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1bc8a:	330e      	adds	r3, #14
   1bc8c:	4977      	ldr	r1, [pc, #476]	; (1be6c <f_open+0x2e0>)
   1bc8e:	4618      	mov	r0, r3
   1bc90:	f7fe f912 	bl	19eb8 <st_dword>
					st_dword(dj.dir + DIR_FileSize, 0);
   1bc94:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1bc96:	330b      	adds	r3, #11
   1bc98:	2220      	movs	r2, #32
   1bc9a:	701a      	strb	r2, [r3, #0]
					fs->wflag = 1;
   1bc9c:	9b05      	ldr	r3, [sp, #20]
   1bc9e:	990d      	ldr	r1, [sp, #52]	; 0x34
   1bca0:	2200      	movs	r2, #0
   1bca2:	4618      	mov	r0, r3
   1bca4:	f7ff f894 	bl	1add0 <st_clust>
					if (cl != 0) {						/* Remove the cluster chain if exist */
   1bca8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1bcaa:	331c      	adds	r3, #28
   1bcac:	2100      	movs	r1, #0
   1bcae:	4618      	mov	r0, r3
   1bcb0:	f7fe f902 	bl	19eb8 <st_dword>
						dw = fs->winsect;
   1bcb4:	9b05      	ldr	r3, [sp, #20]
   1bcb6:	2201      	movs	r2, #1
   1bcb8:	70da      	strb	r2, [r3, #3]
						res = remove_chain(&dj.obj, cl, 0);
   1bcba:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1bcbc:	2b00      	cmp	r3, #0
   1bcbe:	d039      	beq.n	1bd34 <f_open+0x1a8>
						if (res == FR_OK) {
   1bcc0:	9b05      	ldr	r3, [sp, #20]
   1bcc2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1bcc4:	9313      	str	r3, [sp, #76]	; 0x4c
							res = move_window(fs, dw);
   1bcc6:	ab06      	add	r3, sp, #24
   1bcc8:	2200      	movs	r2, #0
   1bcca:	9914      	ldr	r1, [sp, #80]	; 0x50
   1bccc:	4618      	mov	r0, r3
   1bcce:	f7fe fd1d 	bl	1a70c <remove_chain>
   1bcd2:	4603      	mov	r3, r0
   1bcd4:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
   1bcd8:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   1bcdc:	2b00      	cmp	r3, #0
   1bcde:	d129      	bne.n	1bd34 <f_open+0x1a8>
						}
   1bce0:	9b05      	ldr	r3, [sp, #20]
   1bce2:	9913      	ldr	r1, [sp, #76]	; 0x4c
   1bce4:	4618      	mov	r0, r3
   1bce6:	f7fe fa7b 	bl	1a1e0 <move_window>
   1bcea:	4603      	mov	r3, r0
   1bcec:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
					}
   1bcf0:	9b05      	ldr	r3, [sp, #20]
   1bcf2:	9a14      	ldr	r2, [sp, #80]	; 0x50
   1bcf4:	3a01      	subs	r2, #1
   1bcf6:	60da      	str	r2, [r3, #12]
   1bcf8:	e01c      	b.n	1bd34 <f_open+0x1a8>
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Is the object exsiting? */
				if (dj.obj.attr & AM_DIR) {		/* File open against a directory */
					res = FR_NO_FILE;
   1bcfa:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   1bcfe:	2b00      	cmp	r3, #0
   1bd00:	d118      	bne.n	1bd34 <f_open+0x1a8>
				} else {
   1bd02:	f89d 301e 	ldrb.w	r3, [sp, #30]
   1bd06:	f003 0310 	and.w	r3, r3, #16
   1bd0a:	2b00      	cmp	r3, #0
   1bd0c:	d003      	beq.n	1bd16 <f_open+0x18a>
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* Write mode open against R/O file */
   1bd0e:	2304      	movs	r3, #4
   1bd10:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
   1bd14:	e00e      	b.n	1bd34 <f_open+0x1a8>
						res = FR_DENIED;
					}
   1bd16:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1bd1a:	f003 0302 	and.w	r3, r3, #2
   1bd1e:	2b00      	cmp	r3, #0
   1bd20:	d008      	beq.n	1bd34 <f_open+0x1a8>
   1bd22:	f89d 301e 	ldrb.w	r3, [sp, #30]
   1bd26:	f003 0301 	and.w	r3, r3, #1
   1bd2a:	2b00      	cmp	r3, #0
   1bd2c:	d002      	beq.n	1bd34 <f_open+0x1a8>
				}
   1bd2e:	2307      	movs	r3, #7
   1bd30:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
   1bd34:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   1bd38:	2b00      	cmp	r3, #0
   1bd3a:	d112      	bne.n	1bd62 <f_open+0x1d6>
			fp->dir_ptr = dj.dir;
   1bd3c:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1bd40:	f003 0308 	and.w	r3, r3, #8
   1bd44:	2b00      	cmp	r3, #0
   1bd46:	d005      	beq.n	1bd54 <f_open+0x1c8>
   1bd48:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1bd4c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1bd50:	f88d 3007 	strb.w	r3, [sp, #7]
#if FF_FS_LOCK != 0
   1bd54:	9b05      	ldr	r3, [sp, #20]
   1bd56:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1bd58:	9b03      	ldr	r3, [sp, #12]
   1bd5a:	621a      	str	r2, [r3, #32]
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);	/* Lock the file for this session */
   1bd5c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1bd5e:	9b03      	ldr	r3, [sp, #12]
   1bd60:	625a      	str	r2, [r3, #36]	; 0x24
		}
#endif

		if (res == FR_OK) {
#if FF_FS_EXFAT
			if (fs->fs_type == FS_EXFAT) {
   1bd62:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   1bd66:	2b00      	cmp	r3, #0
   1bd68:	f040 8098 	bne.w	1be9c <f_open+0x310>
			} else
#endif
			{
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
			}
   1bd6c:	9b05      	ldr	r3, [sp, #20]
   1bd6e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1bd70:	4611      	mov	r1, r2
   1bd72:	4618      	mov	r0, r3
   1bd74:	f7ff f800 	bl	1ad78 <ld_clust>
   1bd78:	4602      	mov	r2, r0
   1bd7a:	9b03      	ldr	r3, [sp, #12]
   1bd7c:	609a      	str	r2, [r3, #8]
#if FF_USE_FASTSEEK
   1bd7e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1bd80:	331c      	adds	r3, #28
   1bd82:	4618      	mov	r0, r3
   1bd84:	f7fe f840 	bl	19e08 <ld_dword>
   1bd88:	4602      	mov	r2, r0
   1bd8a:	9b03      	ldr	r3, [sp, #12]
   1bd8c:	60da      	str	r2, [r3, #12]
			fp->cltbl = 0;			/* Disable fast seek mode */
#endif
			fp->obj.fs = fs;	 	/* Validate the file object */
			fp->obj.id = fs->id;
			fp->flag = mode;		/* Set file access mode */
   1bd8e:	9a05      	ldr	r2, [sp, #20]
   1bd90:	9b03      	ldr	r3, [sp, #12]
   1bd92:	601a      	str	r2, [r3, #0]
			fp->err = 0;			/* Clear error flag */
   1bd94:	9b05      	ldr	r3, [sp, #20]
   1bd96:	88da      	ldrh	r2, [r3, #6]
   1bd98:	9b03      	ldr	r3, [sp, #12]
   1bd9a:	809a      	strh	r2, [r3, #4]
			fp->sect = 0;			/* Invalidate current data sector */
   1bd9c:	9b03      	ldr	r3, [sp, #12]
   1bd9e:	f89d 2007 	ldrb.w	r2, [sp, #7]
   1bda2:	741a      	strb	r2, [r3, #16]
			fp->fptr = 0;			/* Set file pointer top of the file */
   1bda4:	9b03      	ldr	r3, [sp, #12]
   1bda6:	2200      	movs	r2, #0
   1bda8:	745a      	strb	r2, [r3, #17]
#if !FF_FS_READONLY
   1bdaa:	9b03      	ldr	r3, [sp, #12]
   1bdac:	2200      	movs	r2, #0
   1bdae:	61da      	str	r2, [r3, #28]
#if !FF_FS_TINY
   1bdb0:	9b03      	ldr	r3, [sp, #12]
   1bdb2:	2200      	movs	r2, #0
   1bdb4:	615a      	str	r2, [r3, #20]
			mem_set(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
#endif
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
   1bdb6:	9b03      	ldr	r3, [sp, #12]
   1bdb8:	3328      	adds	r3, #40	; 0x28
   1bdba:	f44f 7200 	mov.w	r2, #512	; 0x200
   1bdbe:	2100      	movs	r1, #0
   1bdc0:	4618      	mov	r0, r3
   1bdc2:	f7fe f8d9 	bl	19f78 <mem_set>
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
   1bdc6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1bdca:	f003 0320 	and.w	r3, r3, #32
   1bdce:	2b00      	cmp	r3, #0
   1bdd0:	d064      	beq.n	1be9c <f_open+0x310>
   1bdd2:	9b03      	ldr	r3, [sp, #12]
   1bdd4:	68db      	ldr	r3, [r3, #12]
   1bdd6:	2b00      	cmp	r3, #0
   1bdd8:	d060      	beq.n	1be9c <f_open+0x310>
				clst = fp->obj.sclust;				/* Follow the cluster chain */
   1bdda:	9b03      	ldr	r3, [sp, #12]
   1bddc:	68da      	ldr	r2, [r3, #12]
   1bdde:	9b03      	ldr	r3, [sp, #12]
   1bde0:	615a      	str	r2, [r3, #20]
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
   1bde2:	9b05      	ldr	r3, [sp, #20]
   1bde4:	895b      	ldrh	r3, [r3, #10]
   1bde6:	025b      	lsls	r3, r3, #9
   1bde8:	9312      	str	r3, [sp, #72]	; 0x48
					clst = get_fat(&fp->obj, clst);
   1bdea:	9b03      	ldr	r3, [sp, #12]
   1bdec:	689b      	ldr	r3, [r3, #8]
   1bdee:	9316      	str	r3, [sp, #88]	; 0x58
					if (clst <= 1) res = FR_INT_ERR;
   1bdf0:	9b03      	ldr	r3, [sp, #12]
   1bdf2:	68db      	ldr	r3, [r3, #12]
   1bdf4:	9315      	str	r3, [sp, #84]	; 0x54
   1bdf6:	e016      	b.n	1be26 <f_open+0x29a>
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
   1bdf8:	9b03      	ldr	r3, [sp, #12]
   1bdfa:	9916      	ldr	r1, [sp, #88]	; 0x58
   1bdfc:	4618      	mov	r0, r3
   1bdfe:	f7fe fad5 	bl	1a3ac <get_fat>
   1be02:	9016      	str	r0, [sp, #88]	; 0x58
				}
   1be04:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1be06:	2b01      	cmp	r3, #1
   1be08:	d802      	bhi.n	1be10 <f_open+0x284>
   1be0a:	2302      	movs	r3, #2
   1be0c:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
				fp->clust = clst;
   1be10:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1be12:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   1be16:	d102      	bne.n	1be1e <f_open+0x292>
   1be18:	2301      	movs	r3, #1
   1be1a:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
					if (clst <= 1) res = FR_INT_ERR;
   1be1e:	9a15      	ldr	r2, [sp, #84]	; 0x54
   1be20:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1be22:	1ad3      	subs	r3, r2, r3
   1be24:	9315      	str	r3, [sp, #84]	; 0x54
   1be26:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   1be2a:	2b00      	cmp	r3, #0
   1be2c:	d103      	bne.n	1be36 <f_open+0x2aa>
   1be2e:	9a15      	ldr	r2, [sp, #84]	; 0x54
   1be30:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1be32:	429a      	cmp	r2, r3
   1be34:	d8e0      	bhi.n	1bdf8 <f_open+0x26c>
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
					if ((sc = clst2sect(fs, clst)) == 0) {
   1be36:	9b03      	ldr	r3, [sp, #12]
   1be38:	9a16      	ldr	r2, [sp, #88]	; 0x58
   1be3a:	619a      	str	r2, [r3, #24]
						res = FR_INT_ERR;
   1be3c:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   1be40:	2b00      	cmp	r3, #0
   1be42:	d12b      	bne.n	1be9c <f_open+0x310>
   1be44:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1be46:	f3c3 0308 	ubfx	r3, r3, #0, #9
   1be4a:	2b00      	cmp	r3, #0
   1be4c:	d026      	beq.n	1be9c <f_open+0x310>
					} else {
   1be4e:	9b05      	ldr	r3, [sp, #20]
   1be50:	9916      	ldr	r1, [sp, #88]	; 0x58
   1be52:	4618      	mov	r0, r3
   1be54:	f7fe fa80 	bl	1a358 <clst2sect>
   1be58:	9011      	str	r0, [sp, #68]	; 0x44
   1be5a:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1be5c:	2b00      	cmp	r3, #0
   1be5e:	d107      	bne.n	1be70 <f_open+0x2e4>
						fp->sect = sc + (DWORD)(ofs / SS(fs));
   1be60:	2302      	movs	r3, #2
   1be62:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
   1be66:	e019      	b.n	1be9c <f_open+0x310>
   1be68:	0001bb8d 	.word	0x0001bb8d
   1be6c:	4e210000 	.word	0x4e210000
#if !FF_FS_TINY
						if (disk_read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
   1be70:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1be72:	0a5a      	lsrs	r2, r3, #9
   1be74:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1be76:	441a      	add	r2, r3
   1be78:	9b03      	ldr	r3, [sp, #12]
   1be7a:	61da      	str	r2, [r3, #28]
#endif
					}
   1be7c:	9b05      	ldr	r3, [sp, #20]
   1be7e:	7858      	ldrb	r0, [r3, #1]
   1be80:	9b03      	ldr	r3, [sp, #12]
   1be82:	f103 0128 	add.w	r1, r3, #40	; 0x28
   1be86:	9b03      	ldr	r3, [sp, #12]
   1be88:	69da      	ldr	r2, [r3, #28]
   1be8a:	2301      	movs	r3, #1
   1be8c:	f7fd fefa 	bl	19c84 <disk_read>
   1be90:	4603      	mov	r3, r0
   1be92:	2b00      	cmp	r3, #0
   1be94:	d002      	beq.n	1be9c <f_open+0x310>
   1be96:	2301      	movs	r3, #1
   1be98:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
		FREE_NAMBUF();
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */

	LEAVE_FF(fs, res);
   1be9c:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   1bea0:	2b00      	cmp	r3, #0
   1bea2:	d002      	beq.n	1beaa <f_open+0x31e>
   1bea4:	9b03      	ldr	r3, [sp, #12]
   1bea6:	2200      	movs	r2, #0
   1bea8:	601a      	str	r2, [r3, #0]
}

   1beaa:	f89d 405f 	ldrb.w	r4, [sp, #95]	; 0x5f
   1beae:	462b      	mov	r3, r5
   1beb0:	4619      	mov	r1, r3
   1beb2:	4803      	ldr	r0, [pc, #12]	; (1bec0 <f_open+0x334>)
   1beb4:	f7fa fd32 	bl	1691c <__cyg_profile_func_exit>
   1beb8:	4623      	mov	r3, r4

   1beba:	4618      	mov	r0, r3
   1bebc:	b019      	add	sp, #100	; 0x64
   1bebe:	bd30      	pop	{r4, r5, pc}
   1bec0:	0001bb8d 	.word	0x0001bb8d

0001bec4 <f_read>:
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
	FRESULT res;
	FATFS *fs;
   1bec4:	b530      	push	{r4, r5, lr}
   1bec6:	b08f      	sub	sp, #60	; 0x3c
   1bec8:	4675      	mov	r5, lr
   1beca:	9003      	str	r0, [sp, #12]
   1becc:	9102      	str	r1, [sp, #8]
   1bece:	9201      	str	r2, [sp, #4]
   1bed0:	9300      	str	r3, [sp, #0]
   1bed2:	462b      	mov	r3, r5
   1bed4:	4619      	mov	r1, r3
   1bed6:	4899      	ldr	r0, [pc, #612]	; (1c13c <f_read+0x278>)
   1bed8:	f7fa fd0c 	bl	168f4 <__cyg_profile_func_enter>
	DWORD clst, sect;
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;


   1bedc:	9b02      	ldr	r3, [sp, #8]
   1bede:	9309      	str	r3, [sp, #36]	; 0x24
	*br = 0;	/* Clear read byte counter */
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
   1bee0:	9b00      	ldr	r3, [sp, #0]
   1bee2:	2200      	movs	r2, #0
   1bee4:	601a      	str	r2, [r3, #0]
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
   1bee6:	9b03      	ldr	r3, [sp, #12]
   1bee8:	aa05      	add	r2, sp, #20
   1beea:	4611      	mov	r1, r2
   1beec:	4618      	mov	r0, r3
   1beee:	f7ff fdb9 	bl	1ba64 <validate>
   1bef2:	4603      	mov	r3, r0
   1bef4:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
	remain = fp->obj.objsize - fp->fptr;
   1bef8:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   1befc:	2b00      	cmp	r3, #0
   1befe:	d107      	bne.n	1bf10 <f_read+0x4c>
   1bf00:	9b03      	ldr	r3, [sp, #12]
   1bf02:	7c5b      	ldrb	r3, [r3, #17]
   1bf04:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
   1bf08:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   1bf0c:	2b00      	cmp	r3, #0
   1bf0e:	d002      	beq.n	1bf16 <f_read+0x52>
   1bf10:	f89d 4037 	ldrb.w	r4, [sp, #55]	; 0x37
   1bf14:	e109      	b.n	1c12a <f_read+0x266>
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
   1bf16:	9b03      	ldr	r3, [sp, #12]
   1bf18:	7c1b      	ldrb	r3, [r3, #16]
   1bf1a:	f003 0301 	and.w	r3, r3, #1
   1bf1e:	2b00      	cmp	r3, #0
   1bf20:	d101      	bne.n	1bf26 <f_read+0x62>
   1bf22:	2407      	movs	r4, #7
   1bf24:	e101      	b.n	1c12a <f_read+0x266>

   1bf26:	9b03      	ldr	r3, [sp, #12]
   1bf28:	68da      	ldr	r2, [r3, #12]
   1bf2a:	9b03      	ldr	r3, [sp, #12]
   1bf2c:	695b      	ldr	r3, [r3, #20]
   1bf2e:	1ad3      	subs	r3, r2, r3
   1bf30:	9308      	str	r3, [sp, #32]
	for ( ;  btr;								/* Repeat until btr bytes read */
   1bf32:	9a01      	ldr	r2, [sp, #4]
   1bf34:	9b08      	ldr	r3, [sp, #32]
   1bf36:	429a      	cmp	r2, r3
   1bf38:	f240 80f2 	bls.w	1c120 <f_read+0x25c>
   1bf3c:	9b08      	ldr	r3, [sp, #32]
   1bf3e:	9301      	str	r3, [sp, #4]
		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
   1bf40:	e0ee      	b.n	1c120 <f_read+0x25c>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
			if (csect == 0) {					/* On the cluster boundary? */
   1bf42:	9b03      	ldr	r3, [sp, #12]
   1bf44:	695b      	ldr	r3, [r3, #20]
   1bf46:	f3c3 0308 	ubfx	r3, r3, #0, #9
   1bf4a:	2b00      	cmp	r3, #0
   1bf4c:	f040 80ba 	bne.w	1c0c4 <f_read+0x200>
				if (fp->fptr == 0) {			/* On the top of the file? */
   1bf50:	9b03      	ldr	r3, [sp, #12]
   1bf52:	695b      	ldr	r3, [r3, #20]
   1bf54:	0a5b      	lsrs	r3, r3, #9
   1bf56:	9a05      	ldr	r2, [sp, #20]
   1bf58:	8952      	ldrh	r2, [r2, #10]
   1bf5a:	3a01      	subs	r2, #1
   1bf5c:	4013      	ands	r3, r2
   1bf5e:	9307      	str	r3, [sp, #28]
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
   1bf60:	9b07      	ldr	r3, [sp, #28]
   1bf62:	2b00      	cmp	r3, #0
   1bf64:	d123      	bne.n	1bfae <f_read+0xea>
				} else {						/* Middle or end of the file */
   1bf66:	9b03      	ldr	r3, [sp, #12]
   1bf68:	695b      	ldr	r3, [r3, #20]
   1bf6a:	2b00      	cmp	r3, #0
   1bf6c:	d103      	bne.n	1bf76 <f_read+0xb2>
#if FF_USE_FASTSEEK
   1bf6e:	9b03      	ldr	r3, [sp, #12]
   1bf70:	689b      	ldr	r3, [r3, #8]
   1bf72:	930c      	str	r3, [sp, #48]	; 0x30
   1bf74:	e007      	b.n	1bf86 <f_read+0xc2>
					} else
#endif
					{
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
					}
				}
   1bf76:	9a03      	ldr	r2, [sp, #12]
   1bf78:	9b03      	ldr	r3, [sp, #12]
   1bf7a:	699b      	ldr	r3, [r3, #24]
   1bf7c:	4619      	mov	r1, r3
   1bf7e:	4610      	mov	r0, r2
   1bf80:	f7fe fa14 	bl	1a3ac <get_fat>
   1bf84:	900c      	str	r0, [sp, #48]	; 0x30
				if (clst < 2) ABORT(fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
   1bf86:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1bf88:	2b01      	cmp	r3, #1
   1bf8a:	d804      	bhi.n	1bf96 <f_read+0xd2>
   1bf8c:	9b03      	ldr	r3, [sp, #12]
   1bf8e:	2202      	movs	r2, #2
   1bf90:	745a      	strb	r2, [r3, #17]
   1bf92:	2402      	movs	r4, #2
   1bf94:	e0c9      	b.n	1c12a <f_read+0x266>
			}
   1bf96:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1bf98:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   1bf9c:	d104      	bne.n	1bfa8 <f_read+0xe4>
   1bf9e:	9b03      	ldr	r3, [sp, #12]
   1bfa0:	2201      	movs	r2, #1
   1bfa2:	745a      	strb	r2, [r3, #17]
   1bfa4:	2401      	movs	r4, #1
   1bfa6:	e0c0      	b.n	1c12a <f_read+0x266>
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
   1bfa8:	9b03      	ldr	r3, [sp, #12]
   1bfaa:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1bfac:	619a      	str	r2, [r3, #24]
			if (sect == 0) ABORT(fs, FR_INT_ERR);
			sect += csect;
   1bfae:	9a05      	ldr	r2, [sp, #20]
   1bfb0:	9b03      	ldr	r3, [sp, #12]
   1bfb2:	699b      	ldr	r3, [r3, #24]
   1bfb4:	4619      	mov	r1, r3
   1bfb6:	4610      	mov	r0, r2
   1bfb8:	f7fe f9ce 	bl	1a358 <clst2sect>
   1bfbc:	9006      	str	r0, [sp, #24]
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
   1bfbe:	9b06      	ldr	r3, [sp, #24]
   1bfc0:	2b00      	cmp	r3, #0
   1bfc2:	d104      	bne.n	1bfce <f_read+0x10a>
   1bfc4:	9b03      	ldr	r3, [sp, #12]
   1bfc6:	2202      	movs	r2, #2
   1bfc8:	745a      	strb	r2, [r3, #17]
   1bfca:	2402      	movs	r4, #2
   1bfcc:	e0ad      	b.n	1c12a <f_read+0x266>
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
   1bfce:	9a06      	ldr	r2, [sp, #24]
   1bfd0:	9b07      	ldr	r3, [sp, #28]
   1bfd2:	4413      	add	r3, r2
   1bfd4:	9306      	str	r3, [sp, #24]
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
   1bfd6:	9b01      	ldr	r3, [sp, #4]
   1bfd8:	0a5b      	lsrs	r3, r3, #9
   1bfda:	930a      	str	r3, [sp, #40]	; 0x28
					cc = fs->csize - csect;
   1bfdc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1bfde:	2b00      	cmp	r3, #0
   1bfe0:	d039      	beq.n	1c056 <f_read+0x192>
				}
   1bfe2:	9a07      	ldr	r2, [sp, #28]
   1bfe4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1bfe6:	4413      	add	r3, r2
   1bfe8:	9a05      	ldr	r2, [sp, #20]
   1bfea:	8952      	ldrh	r2, [r2, #10]
   1bfec:	4293      	cmp	r3, r2
   1bfee:	d905      	bls.n	1bffc <f_read+0x138>
				if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
   1bff0:	9b05      	ldr	r3, [sp, #20]
   1bff2:	895b      	ldrh	r3, [r3, #10]
   1bff4:	461a      	mov	r2, r3
   1bff6:	9b07      	ldr	r3, [sp, #28]
   1bff8:	1ad3      	subs	r3, r2, r3
   1bffa:	930a      	str	r3, [sp, #40]	; 0x28
#if !FF_FS_READONLY && FF_FS_MINIMIZE <= 2		/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if FF_FS_TINY
   1bffc:	9b05      	ldr	r3, [sp, #20]
   1bffe:	7858      	ldrb	r0, [r3, #1]
   1c000:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1c002:	9a06      	ldr	r2, [sp, #24]
   1c004:	9909      	ldr	r1, [sp, #36]	; 0x24
   1c006:	f7fd fe3d 	bl	19c84 <disk_read>
   1c00a:	4603      	mov	r3, r0
   1c00c:	2b00      	cmp	r3, #0
   1c00e:	d004      	beq.n	1c01a <f_read+0x156>
   1c010:	9b03      	ldr	r3, [sp, #12]
   1c012:	2201      	movs	r2, #1
   1c014:	745a      	strb	r2, [r3, #17]
   1c016:	2401      	movs	r4, #1
   1c018:	e087      	b.n	1c12a <f_read+0x266>
					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
				}
#else
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
				}
   1c01a:	9b03      	ldr	r3, [sp, #12]
   1c01c:	7c1b      	ldrb	r3, [r3, #16]
   1c01e:	b25b      	sxtb	r3, r3
   1c020:	2b00      	cmp	r3, #0
   1c022:	da14      	bge.n	1c04e <f_read+0x18a>
   1c024:	9b03      	ldr	r3, [sp, #12]
   1c026:	69da      	ldr	r2, [r3, #28]
   1c028:	9b06      	ldr	r3, [sp, #24]
   1c02a:	1ad3      	subs	r3, r2, r3
   1c02c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1c02e:	429a      	cmp	r2, r3
   1c030:	d90d      	bls.n	1c04e <f_read+0x18a>
#endif
   1c032:	9b03      	ldr	r3, [sp, #12]
   1c034:	69da      	ldr	r2, [r3, #28]
   1c036:	9b06      	ldr	r3, [sp, #24]
   1c038:	1ad3      	subs	r3, r2, r3
   1c03a:	025b      	lsls	r3, r3, #9
   1c03c:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1c03e:	18d0      	adds	r0, r2, r3
   1c040:	9b03      	ldr	r3, [sp, #12]
   1c042:	3328      	adds	r3, #40	; 0x28
   1c044:	f44f 7200 	mov.w	r2, #512	; 0x200
   1c048:	4619      	mov	r1, r3
   1c04a:	f7fd ff6b 	bl	19f24 <mem_cpy>
#endif
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
				continue;
			}
   1c04e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1c050:	025b      	lsls	r3, r3, #9
   1c052:	930b      	str	r3, [sp, #44]	; 0x2c
#if !FF_FS_TINY
   1c054:	e050      	b.n	1c0f8 <f_read+0x234>
			if (fp->sect != sect) {			/* Load data sector if not in cache */
#if !FF_FS_READONLY
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
   1c056:	9b03      	ldr	r3, [sp, #12]
   1c058:	69db      	ldr	r3, [r3, #28]
   1c05a:	9a06      	ldr	r2, [sp, #24]
   1c05c:	429a      	cmp	r2, r3
   1c05e:	d02e      	beq.n	1c0be <f_read+0x1fa>
					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
					fp->flag &= (BYTE)~FA_DIRTY;
   1c060:	9b03      	ldr	r3, [sp, #12]
   1c062:	7c1b      	ldrb	r3, [r3, #16]
   1c064:	b25b      	sxtb	r3, r3
   1c066:	2b00      	cmp	r3, #0
   1c068:	da18      	bge.n	1c09c <f_read+0x1d8>
				}
   1c06a:	9b05      	ldr	r3, [sp, #20]
   1c06c:	7858      	ldrb	r0, [r3, #1]
   1c06e:	9b03      	ldr	r3, [sp, #12]
   1c070:	f103 0128 	add.w	r1, r3, #40	; 0x28
   1c074:	9b03      	ldr	r3, [sp, #12]
   1c076:	69da      	ldr	r2, [r3, #28]
   1c078:	2301      	movs	r3, #1
   1c07a:	f7fd fe25 	bl	19cc8 <disk_write>
   1c07e:	4603      	mov	r3, r0
   1c080:	2b00      	cmp	r3, #0
   1c082:	d004      	beq.n	1c08e <f_read+0x1ca>
   1c084:	9b03      	ldr	r3, [sp, #12]
   1c086:	2201      	movs	r2, #1
   1c088:	745a      	strb	r2, [r3, #17]
   1c08a:	2401      	movs	r4, #1
   1c08c:	e04d      	b.n	1c12a <f_read+0x266>
#endif
   1c08e:	9b03      	ldr	r3, [sp, #12]
   1c090:	7c1b      	ldrb	r3, [r3, #16]
   1c092:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   1c096:	b2da      	uxtb	r2, r3
   1c098:	9b03      	ldr	r3, [sp, #12]
   1c09a:	741a      	strb	r2, [r3, #16]
				if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
			}
#endif
   1c09c:	9b05      	ldr	r3, [sp, #20]
   1c09e:	7858      	ldrb	r0, [r3, #1]
   1c0a0:	9b03      	ldr	r3, [sp, #12]
   1c0a2:	f103 0128 	add.w	r1, r3, #40	; 0x28
   1c0a6:	2301      	movs	r3, #1
   1c0a8:	9a06      	ldr	r2, [sp, #24]
   1c0aa:	f7fd fdeb 	bl	19c84 <disk_read>
   1c0ae:	4603      	mov	r3, r0
   1c0b0:	2b00      	cmp	r3, #0
   1c0b2:	d004      	beq.n	1c0be <f_read+0x1fa>
   1c0b4:	9b03      	ldr	r3, [sp, #12]
   1c0b6:	2201      	movs	r2, #1
   1c0b8:	745a      	strb	r2, [r3, #17]
   1c0ba:	2401      	movs	r4, #1
   1c0bc:	e035      	b.n	1c12a <f_read+0x266>
			fp->sect = sect;
		}
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
   1c0be:	9b03      	ldr	r3, [sp, #12]
   1c0c0:	9a06      	ldr	r2, [sp, #24]
   1c0c2:	61da      	str	r2, [r3, #28]
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
#if FF_FS_TINY
   1c0c4:	9b03      	ldr	r3, [sp, #12]
   1c0c6:	695b      	ldr	r3, [r3, #20]
   1c0c8:	f3c3 0308 	ubfx	r3, r3, #0, #9
   1c0cc:	f5c3 7300 	rsb	r3, r3, #512	; 0x200
   1c0d0:	930b      	str	r3, [sp, #44]	; 0x2c
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
   1c0d2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1c0d4:	9b01      	ldr	r3, [sp, #4]
   1c0d6:	429a      	cmp	r2, r3
   1c0d8:	d901      	bls.n	1c0de <f_read+0x21a>
   1c0da:	9b01      	ldr	r3, [sp, #4]
   1c0dc:	930b      	str	r3, [sp, #44]	; 0x2c
		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#else
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#endif
	}
   1c0de:	9b03      	ldr	r3, [sp, #12]
   1c0e0:	f103 0228 	add.w	r2, r3, #40	; 0x28
   1c0e4:	9b03      	ldr	r3, [sp, #12]
   1c0e6:	695b      	ldr	r3, [r3, #20]
   1c0e8:	f3c3 0308 	ubfx	r3, r3, #0, #9
   1c0ec:	4413      	add	r3, r2
   1c0ee:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1c0f0:	4619      	mov	r1, r3
   1c0f2:	9809      	ldr	r0, [sp, #36]	; 0x24
   1c0f4:	f7fd ff16 	bl	19f24 <mem_cpy>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
   1c0f8:	9a01      	ldr	r2, [sp, #4]
   1c0fa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1c0fc:	1ad3      	subs	r3, r2, r3
   1c0fe:	9301      	str	r3, [sp, #4]
   1c100:	9b00      	ldr	r3, [sp, #0]
   1c102:	681a      	ldr	r2, [r3, #0]
   1c104:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1c106:	441a      	add	r2, r3
   1c108:	9b00      	ldr	r3, [sp, #0]
   1c10a:	601a      	str	r2, [r3, #0]
   1c10c:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1c10e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1c110:	4413      	add	r3, r2
   1c112:	9309      	str	r3, [sp, #36]	; 0x24
   1c114:	9b03      	ldr	r3, [sp, #12]
   1c116:	695a      	ldr	r2, [r3, #20]
   1c118:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1c11a:	441a      	add	r2, r3
   1c11c:	9b03      	ldr	r3, [sp, #12]
   1c11e:	615a      	str	r2, [r3, #20]
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
   1c120:	9b01      	ldr	r3, [sp, #4]
   1c122:	2b00      	cmp	r3, #0
   1c124:	f47f af0d 	bne.w	1bf42 <f_read+0x7e>

	LEAVE_FF(fs, FR_OK);
}

   1c128:	2400      	movs	r4, #0
   1c12a:	462b      	mov	r3, r5
   1c12c:	4619      	mov	r1, r3
   1c12e:	4803      	ldr	r0, [pc, #12]	; (1c13c <f_read+0x278>)
   1c130:	f7fa fbf4 	bl	1691c <__cyg_profile_func_exit>
   1c134:	4623      	mov	r3, r4

   1c136:	4618      	mov	r0, r3
   1c138:	b00f      	add	sp, #60	; 0x3c
   1c13a:	bd30      	pop	{r4, r5, pc}
   1c13c:	0001bec5 	.word	0x0001bec5

0001c140 <f_sync>:
FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
	FRESULT res;
	FATFS *fs;
   1c140:	b530      	push	{r4, r5, lr}
   1c142:	b087      	sub	sp, #28
   1c144:	4675      	mov	r5, lr
   1c146:	9001      	str	r0, [sp, #4]
   1c148:	462b      	mov	r3, r5
   1c14a:	4619      	mov	r1, r3
   1c14c:	4842      	ldr	r0, [pc, #264]	; (1c258 <f_sync+0x118>)
   1c14e:	f7fa fbd1 	bl	168f4 <__cyg_profile_func_enter>
	BYTE *dir;


	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
	if (res == FR_OK) {
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
   1c152:	9b01      	ldr	r3, [sp, #4]
   1c154:	aa02      	add	r2, sp, #8
   1c156:	4611      	mov	r1, r2
   1c158:	4618      	mov	r0, r3
   1c15a:	f7ff fc83 	bl	1ba64 <validate>
   1c15e:	4603      	mov	r3, r0
   1c160:	f88d 3017 	strb.w	r3, [sp, #23]
#if !FF_FS_TINY
   1c164:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1c168:	2b00      	cmp	r3, #0
   1c16a:	d16a      	bne.n	1c242 <f_sync+0x102>
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
   1c16c:	9b01      	ldr	r3, [sp, #4]
   1c16e:	7c1b      	ldrb	r3, [r3, #16]
   1c170:	f003 0340 	and.w	r3, r3, #64	; 0x40
   1c174:	2b00      	cmp	r3, #0
   1c176:	d064      	beq.n	1c242 <f_sync+0x102>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
				fp->flag &= (BYTE)~FA_DIRTY;
   1c178:	9b01      	ldr	r3, [sp, #4]
   1c17a:	7c1b      	ldrb	r3, [r3, #16]
   1c17c:	b25b      	sxtb	r3, r3
   1c17e:	2b00      	cmp	r3, #0
   1c180:	da15      	bge.n	1c1ae <f_sync+0x6e>
			}
   1c182:	9b02      	ldr	r3, [sp, #8]
   1c184:	7858      	ldrb	r0, [r3, #1]
   1c186:	9b01      	ldr	r3, [sp, #4]
   1c188:	f103 0128 	add.w	r1, r3, #40	; 0x28
   1c18c:	9b01      	ldr	r3, [sp, #4]
   1c18e:	69da      	ldr	r2, [r3, #28]
   1c190:	2301      	movs	r3, #1
   1c192:	f7fd fd99 	bl	19cc8 <disk_write>
   1c196:	4603      	mov	r3, r0
   1c198:	2b00      	cmp	r3, #0
   1c19a:	d001      	beq.n	1c1a0 <f_sync+0x60>
   1c19c:	2401      	movs	r4, #1
   1c19e:	e052      	b.n	1c246 <f_sync+0x106>
#endif
   1c1a0:	9b01      	ldr	r3, [sp, #4]
   1c1a2:	7c1b      	ldrb	r3, [r3, #16]
   1c1a4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   1c1a8:	b2da      	uxtb	r2, r3
   1c1aa:	9b01      	ldr	r3, [sp, #4]
   1c1ac:	741a      	strb	r2, [r3, #16]
			/* Update the directory entry */
			tm = GET_FATTIME();				/* Modified time */
#if FF_FS_EXFAT
			if (fs->fs_type == FS_EXFAT) {
   1c1ae:	4b2b      	ldr	r3, [pc, #172]	; (1c25c <f_sync+0x11c>)
   1c1b0:	9304      	str	r3, [sp, #16]
			} else
#endif
			{
				res = move_window(fs, fp->dir_sect);
				if (res == FR_OK) {
					dir = fp->dir_ptr;
   1c1b2:	9a02      	ldr	r2, [sp, #8]
   1c1b4:	9b01      	ldr	r3, [sp, #4]
   1c1b6:	6a1b      	ldr	r3, [r3, #32]
   1c1b8:	4619      	mov	r1, r3
   1c1ba:	4610      	mov	r0, r2
   1c1bc:	f7fe f810 	bl	1a1e0 <move_window>
   1c1c0:	4603      	mov	r3, r0
   1c1c2:	f88d 3017 	strb.w	r3, [sp, #23]
					dir[DIR_Attr] |= AM_ARC;						/* Set archive attribute to indicate that the file has been changed */
   1c1c6:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1c1ca:	2b00      	cmp	r3, #0
   1c1cc:	d139      	bne.n	1c242 <f_sync+0x102>
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation information  */
   1c1ce:	9b01      	ldr	r3, [sp, #4]
   1c1d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1c1d2:	9303      	str	r3, [sp, #12]
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
   1c1d4:	9b03      	ldr	r3, [sp, #12]
   1c1d6:	330b      	adds	r3, #11
   1c1d8:	781a      	ldrb	r2, [r3, #0]
   1c1da:	9b03      	ldr	r3, [sp, #12]
   1c1dc:	330b      	adds	r3, #11
   1c1de:	f042 0220 	orr.w	r2, r2, #32
   1c1e2:	b2d2      	uxtb	r2, r2
   1c1e4:	701a      	strb	r2, [r3, #0]
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
   1c1e6:	9b01      	ldr	r3, [sp, #4]
   1c1e8:	6818      	ldr	r0, [r3, #0]
   1c1ea:	9b01      	ldr	r3, [sp, #4]
   1c1ec:	689b      	ldr	r3, [r3, #8]
   1c1ee:	461a      	mov	r2, r3
   1c1f0:	9903      	ldr	r1, [sp, #12]
   1c1f2:	f7fe fded 	bl	1add0 <st_clust>
					st_word(dir + DIR_LstAccDate, 0);
   1c1f6:	9b03      	ldr	r3, [sp, #12]
   1c1f8:	f103 021c 	add.w	r2, r3, #28
   1c1fc:	9b01      	ldr	r3, [sp, #4]
   1c1fe:	68db      	ldr	r3, [r3, #12]
   1c200:	4619      	mov	r1, r3
   1c202:	4610      	mov	r0, r2
   1c204:	f7fd fe58 	bl	19eb8 <st_dword>
					fs->wflag = 1;
   1c208:	9b03      	ldr	r3, [sp, #12]
   1c20a:	3316      	adds	r3, #22
   1c20c:	9904      	ldr	r1, [sp, #16]
   1c20e:	4618      	mov	r0, r3
   1c210:	f7fd fe52 	bl	19eb8 <st_dword>
					res = sync_fs(fs);					/* Restore it to the directory */
   1c214:	9b03      	ldr	r3, [sp, #12]
   1c216:	3312      	adds	r3, #18
   1c218:	2100      	movs	r1, #0
   1c21a:	4618      	mov	r0, r3
   1c21c:	f7fd fe22 	bl	19e64 <st_word>
					fp->flag &= (BYTE)~FA_MODIFIED;
   1c220:	9b02      	ldr	r3, [sp, #8]
   1c222:	2201      	movs	r2, #1
   1c224:	70da      	strb	r2, [r3, #3]
				}
   1c226:	9b02      	ldr	r3, [sp, #8]
   1c228:	4618      	mov	r0, r3
   1c22a:	f7fe f817 	bl	1a25c <sync_fs>
   1c22e:	4603      	mov	r3, r0
   1c230:	f88d 3017 	strb.w	r3, [sp, #23]
			}
   1c234:	9b01      	ldr	r3, [sp, #4]
   1c236:	7c1b      	ldrb	r3, [r3, #16]
   1c238:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   1c23c:	b2da      	uxtb	r2, r3
   1c23e:	9b01      	ldr	r3, [sp, #4]
   1c240:	741a      	strb	r2, [r3, #16]
		}
	}

	LEAVE_FF(fs, res);
}

   1c242:	f89d 4017 	ldrb.w	r4, [sp, #23]
   1c246:	462b      	mov	r3, r5
   1c248:	4619      	mov	r1, r3
   1c24a:	4803      	ldr	r0, [pc, #12]	; (1c258 <f_sync+0x118>)
   1c24c:	f7fa fb66 	bl	1691c <__cyg_profile_func_exit>
   1c250:	4623      	mov	r3, r4
#endif /* !FF_FS_READONLY */
   1c252:	4618      	mov	r0, r3
   1c254:	b007      	add	sp, #28
   1c256:	bd30      	pop	{r4, r5, pc}
   1c258:	0001c141 	.word	0x0001c141
   1c25c:	4e210000 	.word	0x4e210000

0001c260 <f_close>:
FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
	FRESULT res;
	FATFS *fs;
   1c260:	b530      	push	{r4, r5, lr}
   1c262:	b085      	sub	sp, #20
   1c264:	4675      	mov	r5, lr
   1c266:	9001      	str	r0, [sp, #4]
   1c268:	462b      	mov	r3, r5
   1c26a:	4619      	mov	r1, r3
   1c26c:	4813      	ldr	r0, [pc, #76]	; (1c2bc <f_close+0x5c>)
   1c26e:	f7fa fb41 	bl	168f4 <__cyg_profile_func_enter>

#if !FF_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
	if (res == FR_OK)
#endif
   1c272:	9801      	ldr	r0, [sp, #4]
   1c274:	f7ff ff64 	bl	1c140 <f_sync>
   1c278:	4603      	mov	r3, r0
   1c27a:	f88d 300f 	strb.w	r3, [sp, #15]
	{
   1c27e:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1c282:	2b00      	cmp	r3, #0
   1c284:	d10f      	bne.n	1c2a6 <f_close+0x46>
		res = validate(&fp->obj, &fs);	/* Lock volume */
		if (res == FR_OK) {
#if FF_FS_LOCK != 0
   1c286:	9b01      	ldr	r3, [sp, #4]
   1c288:	aa02      	add	r2, sp, #8
   1c28a:	4611      	mov	r1, r2
   1c28c:	4618      	mov	r0, r3
   1c28e:	f7ff fbe9 	bl	1ba64 <validate>
   1c292:	4603      	mov	r3, r0
   1c294:	f88d 300f 	strb.w	r3, [sp, #15]
			res = dec_lock(fp->obj.lockid);		/* Decrement file open counter */
   1c298:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1c29c:	2b00      	cmp	r3, #0
   1c29e:	d102      	bne.n	1c2a6 <f_close+0x46>
			if (res == FR_OK) fp->obj.fs = 0;	/* Invalidate file object */
#else
			fp->obj.fs = 0;	/* Invalidate file object */
#endif
#if FF_FS_REENTRANT
   1c2a0:	9b01      	ldr	r3, [sp, #4]
   1c2a2:	2200      	movs	r2, #0
   1c2a4:	601a      	str	r2, [r3, #0]
#endif
		}
	}
	return res;
}

   1c2a6:	f89d 400f 	ldrb.w	r4, [sp, #15]
   1c2aa:	462b      	mov	r3, r5
   1c2ac:	4619      	mov	r1, r3
   1c2ae:	4803      	ldr	r0, [pc, #12]	; (1c2bc <f_close+0x5c>)
   1c2b0:	f7fa fb34 	bl	1691c <__cyg_profile_func_exit>
   1c2b4:	4623      	mov	r3, r4

   1c2b6:	4618      	mov	r0, r3
   1c2b8:	b005      	add	sp, #20
   1c2ba:	bd30      	pop	{r4, r5, pc}
   1c2bc:	0001c261 	.word	0x0001c261

0001c2c0 <f_opendir>:
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
	FRESULT res;
	FATFS *fs;
   1c2c0:	b530      	push	{r4, r5, lr}
   1c2c2:	b085      	sub	sp, #20
   1c2c4:	4675      	mov	r5, lr
   1c2c6:	9001      	str	r0, [sp, #4]
   1c2c8:	9100      	str	r1, [sp, #0]
   1c2ca:	462b      	mov	r3, r5
   1c2cc:	4619      	mov	r1, r3
   1c2ce:	4833      	ldr	r0, [pc, #204]	; (1c39c <f_opendir+0xdc>)
   1c2d0:	f7fa fb10 	bl	168f4 <__cyg_profile_func_enter>
	DEF_NAMBUF


	if (!dp) return FR_INVALID_OBJECT;

	/* Get logical drive */
   1c2d4:	9b01      	ldr	r3, [sp, #4]
   1c2d6:	2b00      	cmp	r3, #0
   1c2d8:	d101      	bne.n	1c2de <f_opendir+0x1e>
   1c2da:	2409      	movs	r4, #9
   1c2dc:	e054      	b.n	1c388 <f_opendir+0xc8>
	res = find_volume(&path, &fs, 0);
	if (res == FR_OK) {
		dp->obj.fs = fs;
   1c2de:	a902      	add	r1, sp, #8
   1c2e0:	466b      	mov	r3, sp
   1c2e2:	2200      	movs	r2, #0
   1c2e4:	4618      	mov	r0, r3
   1c2e6:	f7ff f94f 	bl	1b588 <find_volume>
   1c2ea:	4603      	mov	r3, r0
   1c2ec:	f88d 300f 	strb.w	r3, [sp, #15]
		INIT_NAMBUF(fs);
   1c2f0:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1c2f4:	2b00      	cmp	r3, #0
   1c2f6:	d13e      	bne.n	1c376 <f_opendir+0xb6>
		res = follow_path(dp, path);			/* Follow the path to the directory */
   1c2f8:	9a02      	ldr	r2, [sp, #8]
   1c2fa:	9b01      	ldr	r3, [sp, #4]
   1c2fc:	601a      	str	r2, [r3, #0]
		if (res == FR_OK) {						/* Follow completed */
			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
   1c2fe:	9b00      	ldr	r3, [sp, #0]
   1c300:	4619      	mov	r1, r3
   1c302:	9801      	ldr	r0, [sp, #4]
   1c304:	f7ff f802 	bl	1b30c <follow_path>
   1c308:	4603      	mov	r3, r0
   1c30a:	f88d 300f 	strb.w	r3, [sp, #15]
				if (dp->obj.attr & AM_DIR) {		/* This object is a sub-directory */
   1c30e:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1c312:	2b00      	cmp	r3, #0
   1c314:	d128      	bne.n	1c368 <f_opendir+0xa8>
#if FF_FS_EXFAT
   1c316:	9b01      	ldr	r3, [sp, #4]
   1c318:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
   1c31c:	b25b      	sxtb	r3, r3
   1c31e:	2b00      	cmp	r3, #0
   1c320:	db13      	blt.n	1c34a <f_opendir+0x8a>
					if (fs->fs_type == FS_EXFAT) {
   1c322:	9b01      	ldr	r3, [sp, #4]
   1c324:	799b      	ldrb	r3, [r3, #6]
   1c326:	f003 0310 	and.w	r3, r3, #16
   1c32a:	2b00      	cmp	r3, #0
   1c32c:	d00a      	beq.n	1c344 <f_opendir+0x84>
					} else
#endif
					{
						dp->obj.sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
					}
				} else {						/* This object is a file */
   1c32e:	9a02      	ldr	r2, [sp, #8]
   1c330:	9b01      	ldr	r3, [sp, #4]
   1c332:	69db      	ldr	r3, [r3, #28]
   1c334:	4619      	mov	r1, r3
   1c336:	4610      	mov	r0, r2
   1c338:	f7fe fd1e 	bl	1ad78 <ld_clust>
   1c33c:	4602      	mov	r2, r0
   1c33e:	9b01      	ldr	r3, [sp, #4]
   1c340:	609a      	str	r2, [r3, #8]
   1c342:	e002      	b.n	1c34a <f_opendir+0x8a>
					res = FR_NO_PATH;
				}
			}
   1c344:	2305      	movs	r3, #5
   1c346:	f88d 300f 	strb.w	r3, [sp, #15]
			if (res == FR_OK) {
				dp->obj.id = fs->id;
				res = dir_sdi(dp, 0);			/* Rewind directory */
   1c34a:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1c34e:	2b00      	cmp	r3, #0
   1c350:	d10a      	bne.n	1c368 <f_opendir+0xa8>
#if FF_FS_LOCK != 0
   1c352:	9b02      	ldr	r3, [sp, #8]
   1c354:	88da      	ldrh	r2, [r3, #6]
   1c356:	9b01      	ldr	r3, [sp, #4]
   1c358:	809a      	strh	r2, [r3, #4]
				if (res == FR_OK) {
   1c35a:	2100      	movs	r1, #0
   1c35c:	9801      	ldr	r0, [sp, #4]
   1c35e:	f7fe fb85 	bl	1aa6c <dir_sdi>
   1c362:	4603      	mov	r3, r0
   1c364:	f88d 300f 	strb.w	r3, [sp, #15]
			}
		}
		FREE_NAMBUF();
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) dp->obj.fs = 0;		/* Invalidate the directory object if function faild */
   1c368:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1c36c:	2b04      	cmp	r3, #4
   1c36e:	d102      	bne.n	1c376 <f_opendir+0xb6>
   1c370:	2305      	movs	r3, #5
   1c372:	f88d 300f 	strb.w	r3, [sp, #15]

	LEAVE_FF(fs, res);
   1c376:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1c37a:	2b00      	cmp	r3, #0
   1c37c:	d002      	beq.n	1c384 <f_opendir+0xc4>
   1c37e:	9b01      	ldr	r3, [sp, #4]
   1c380:	2200      	movs	r2, #0
   1c382:	601a      	str	r2, [r3, #0]
}

   1c384:	f89d 400f 	ldrb.w	r4, [sp, #15]
   1c388:	462b      	mov	r3, r5
   1c38a:	4619      	mov	r1, r3
   1c38c:	4803      	ldr	r0, [pc, #12]	; (1c39c <f_opendir+0xdc>)
   1c38e:	f7fa fac5 	bl	1691c <__cyg_profile_func_exit>
   1c392:	4623      	mov	r3, r4

   1c394:	4618      	mov	r0, r3
   1c396:	b005      	add	sp, #20
   1c398:	bd30      	pop	{r4, r5, pc}
   1c39a:	bf00      	nop
   1c39c:	0001c2c1 	.word	0x0001c2c1

0001c3a0 <f_closedir>:
FRESULT f_closedir (
	DIR *dp		/* Pointer to the directory object to be closed */
)
{
	FRESULT res;
	FATFS *fs;
   1c3a0:	b530      	push	{r4, r5, lr}
   1c3a2:	b085      	sub	sp, #20
   1c3a4:	4675      	mov	r5, lr
   1c3a6:	9001      	str	r0, [sp, #4]
   1c3a8:	462b      	mov	r3, r5
   1c3aa:	4619      	mov	r1, r3
   1c3ac:	480e      	ldr	r0, [pc, #56]	; (1c3e8 <f_closedir+0x48>)
   1c3ae:	f7fa faa1 	bl	168f4 <__cyg_profile_func_enter>


	res = validate(&dp->obj, &fs);	/* Check validity of the file object */
	if (res == FR_OK) {
#if FF_FS_LOCK != 0
   1c3b2:	9b01      	ldr	r3, [sp, #4]
   1c3b4:	aa02      	add	r2, sp, #8
   1c3b6:	4611      	mov	r1, r2
   1c3b8:	4618      	mov	r0, r3
   1c3ba:	f7ff fb53 	bl	1ba64 <validate>
   1c3be:	4603      	mov	r3, r0
   1c3c0:	f88d 300f 	strb.w	r3, [sp, #15]
		if (dp->obj.lockid) res = dec_lock(dp->obj.lockid);	/* Decrement sub-directory open counter */
   1c3c4:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1c3c8:	2b00      	cmp	r3, #0
   1c3ca:	d102      	bne.n	1c3d2 <f_closedir+0x32>
		if (res == FR_OK) dp->obj.fs = 0;	/* Invalidate directory object */
#else
		dp->obj.fs = 0;	/* Invalidate directory object */
#endif
#if FF_FS_REENTRANT
   1c3cc:	9b01      	ldr	r3, [sp, #4]
   1c3ce:	2200      	movs	r2, #0
   1c3d0:	601a      	str	r2, [r3, #0]
		unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
	}
	return res;
}

   1c3d2:	f89d 400f 	ldrb.w	r4, [sp, #15]
   1c3d6:	462b      	mov	r3, r5
   1c3d8:	4619      	mov	r1, r3
   1c3da:	4803      	ldr	r0, [pc, #12]	; (1c3e8 <f_closedir+0x48>)
   1c3dc:	f7fa fa9e 	bl	1691c <__cyg_profile_func_exit>
   1c3e0:	4623      	mov	r3, r4

   1c3e2:	4618      	mov	r0, r3
   1c3e4:	b005      	add	sp, #20
   1c3e6:	bd30      	pop	{r4, r5, pc}
   1c3e8:	0001c3a1 	.word	0x0001c3a1

0001c3ec <f_readdir>:
	DIR* dp,			/* Pointer to the open directory object */
	FILINFO* fno		/* Pointer to file information to return */
)
{
	FRESULT res;
	FATFS *fs;
   1c3ec:	b530      	push	{r4, r5, lr}
   1c3ee:	b085      	sub	sp, #20
   1c3f0:	4675      	mov	r5, lr
   1c3f2:	9001      	str	r0, [sp, #4]
   1c3f4:	9100      	str	r1, [sp, #0]
   1c3f6:	462b      	mov	r3, r5
   1c3f8:	4619      	mov	r1, r3
   1c3fa:	4825      	ldr	r0, [pc, #148]	; (1c490 <f_readdir+0xa4>)
   1c3fc:	f7fa fa7a 	bl	168f4 <__cyg_profile_func_enter>
	DEF_NAMBUF


	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
	if (res == FR_OK) {
		if (!fno) {
   1c400:	9b01      	ldr	r3, [sp, #4]
   1c402:	aa02      	add	r2, sp, #8
   1c404:	4611      	mov	r1, r2
   1c406:	4618      	mov	r0, r3
   1c408:	f7ff fb2c 	bl	1ba64 <validate>
   1c40c:	4603      	mov	r3, r0
   1c40e:	f88d 300f 	strb.w	r3, [sp, #15]
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
   1c412:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1c416:	2b00      	cmp	r3, #0
   1c418:	d12e      	bne.n	1c478 <f_readdir+0x8c>
		} else {
   1c41a:	9b00      	ldr	r3, [sp, #0]
   1c41c:	2b00      	cmp	r3, #0
   1c41e:	d107      	bne.n	1c430 <f_readdir+0x44>
			INIT_NAMBUF(fs);
   1c420:	2100      	movs	r1, #0
   1c422:	9801      	ldr	r0, [sp, #4]
   1c424:	f7fe fb22 	bl	1aa6c <dir_sdi>
   1c428:	4603      	mov	r3, r0
   1c42a:	f88d 300f 	strb.w	r3, [sp, #15]
   1c42e:	e023      	b.n	1c478 <f_readdir+0x8c>
			res = DIR_READ_FILE(dp);		/* Read an item */
			if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
			if (res == FR_OK) {				/* A valid entry is found */
   1c430:	2100      	movs	r1, #0
   1c432:	9801      	ldr	r0, [sp, #4]
   1c434:	f7fe fcf8 	bl	1ae28 <dir_read>
   1c438:	4603      	mov	r3, r0
   1c43a:	f88d 300f 	strb.w	r3, [sp, #15]
				get_fileinfo(dp, fno);		/* Get the object information */
   1c43e:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1c442:	2b04      	cmp	r3, #4
   1c444:	d102      	bne.n	1c44c <f_readdir+0x60>
   1c446:	2300      	movs	r3, #0
   1c448:	f88d 300f 	strb.w	r3, [sp, #15]
				res = dir_next(dp, 0);		/* Increment index for next */
   1c44c:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1c450:	2b00      	cmp	r3, #0
   1c452:	d111      	bne.n	1c478 <f_readdir+0x8c>
				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
   1c454:	9900      	ldr	r1, [sp, #0]
   1c456:	9801      	ldr	r0, [sp, #4]
   1c458:	f7fe fe10 	bl	1b07c <get_fileinfo>
			}
   1c45c:	2100      	movs	r1, #0
   1c45e:	9801      	ldr	r0, [sp, #4]
   1c460:	f7fe fb8c 	bl	1ab7c <dir_next>
   1c464:	4603      	mov	r3, r0
   1c466:	f88d 300f 	strb.w	r3, [sp, #15]
			FREE_NAMBUF();
   1c46a:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1c46e:	2b04      	cmp	r3, #4
   1c470:	d102      	bne.n	1c478 <f_readdir+0x8c>
   1c472:	2300      	movs	r3, #0
   1c474:	f88d 300f 	strb.w	r3, [sp, #15]
		}
	}
	LEAVE_FF(fs, res);
}

   1c478:	f89d 400f 	ldrb.w	r4, [sp, #15]
   1c47c:	462b      	mov	r3, r5
   1c47e:	4619      	mov	r1, r3
   1c480:	4803      	ldr	r0, [pc, #12]	; (1c490 <f_readdir+0xa4>)
   1c482:	f7fa fa4b 	bl	1691c <__cyg_profile_func_exit>
   1c486:	4623      	mov	r3, r4

   1c488:	4618      	mov	r0, r3
   1c48a:	b005      	add	sp, #20
   1c48c:	bd30      	pop	{r4, r5, pc}
   1c48e:	bf00      	nop
   1c490:	0001c3ed 	.word	0x0001c3ed

0001c494 <__cxa_pure_virtual>:
   1c494:	b508      	push	{r3, lr}
   1c496:	f000 f80d 	bl	1c4b4 <std::terminate()>

0001c49a <__cxxabiv1::__terminate(void (*)())>:
   1c49a:	b508      	push	{r3, lr}
   1c49c:	4780      	blx	r0
   1c49e:	f000 fa0f 	bl	1c8c0 <abort>
   1c4a2:	Address 0x000000000001c4a2 is out of bounds.


0001c4a4 <std::get_terminate()>:
   1c4a4:	4b02      	ldr	r3, [pc, #8]	; (1c4b0 <std::get_terminate()+0xc>)
   1c4a6:	6818      	ldr	r0, [r3, #0]
   1c4a8:	f3bf 8f5b 	dmb	ish
   1c4ac:	4770      	bx	lr
   1c4ae:	bf00      	nop
   1c4b0:	10000654 	.word	0x10000654

0001c4b4 <std::terminate()>:
   1c4b4:	b508      	push	{r3, lr}
   1c4b6:	f7ff fff5 	bl	1c4a4 <std::get_terminate()>
   1c4ba:	f7ff ffee 	bl	1c49a <__cxxabiv1::__terminate(void (*)())>
   1c4be:	Address 0x000000000001c4be is out of bounds.


0001c4c0 <roundf>:
   1c4c0:	b082      	sub	sp, #8
   1c4c2:	ed8d 0a01 	vstr	s0, [sp, #4]
   1c4c6:	9901      	ldr	r1, [sp, #4]
   1c4c8:	f3c1 53c7 	ubfx	r3, r1, #23, #8
   1c4cc:	f1a3 027f 	sub.w	r2, r3, #127	; 0x7f
   1c4d0:	2a16      	cmp	r2, #22
   1c4d2:	dc0c      	bgt.n	1c4ee <roundf+0x2e>
   1c4d4:	2a00      	cmp	r2, #0
   1c4d6:	db10      	blt.n	1c4fa <roundf+0x3a>
   1c4d8:	4810      	ldr	r0, [pc, #64]	; (1c51c <roundf+0x5c>)
   1c4da:	4110      	asrs	r0, r2
   1c4dc:	4201      	tst	r1, r0
   1c4de:	d008      	beq.n	1c4f2 <roundf+0x32>
   1c4e0:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   1c4e4:	4113      	asrs	r3, r2
   1c4e6:	440b      	add	r3, r1
   1c4e8:	ea23 0300 	bic.w	r3, r3, r0
   1c4ec:	e00b      	b.n	1c506 <roundf+0x46>
   1c4ee:	2a80      	cmp	r2, #128	; 0x80
   1c4f0:	d00d      	beq.n	1c50e <roundf+0x4e>
   1c4f2:	ed9d 0a01 	vldr	s0, [sp, #4]
   1c4f6:	b002      	add	sp, #8
   1c4f8:	4770      	bx	lr
   1c4fa:	3201      	adds	r2, #1
   1c4fc:	f001 4300 	and.w	r3, r1, #2147483648	; 0x80000000
   1c500:	d101      	bne.n	1c506 <roundf+0x46>
   1c502:	f043 537e 	orr.w	r3, r3, #1065353216	; 0x3f800000
   1c506:	ee00 3a10 	vmov	s0, r3
   1c50a:	b002      	add	sp, #8
   1c50c:	4770      	bx	lr
   1c50e:	eddd 7a01 	vldr	s15, [sp, #4]
   1c512:	ee37 0aa7 	vadd.f32	s0, s15, s15
   1c516:	b002      	add	sp, #8
   1c518:	4770      	bx	lr
   1c51a:	bf00      	nop
   1c51c:	007fffff 	.word	0x007fffff

0001c520 <__aeabi_d2f>:
   1c520:	ea4f 0241 	mov.w	r2, r1, lsl #1
   1c524:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
   1c528:	bf24      	itt	cs
   1c52a:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
   1c52e:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
   1c532:	d90d      	bls.n	1c550 <__aeabi_d2f+0x30>
   1c534:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   1c538:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   1c53c:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
   1c540:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   1c544:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
   1c548:	bf08      	it	eq
   1c54a:	f020 0001 	biceq.w	r0, r0, #1
   1c54e:	4770      	bx	lr
   1c550:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
   1c554:	d121      	bne.n	1c59a <__aeabi_d2f+0x7a>
   1c556:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
   1c55a:	bfbc      	itt	lt
   1c55c:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
   1c560:	4770      	bxlt	lr
   1c562:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   1c566:	ea4f 5252 	mov.w	r2, r2, lsr #21
   1c56a:	f1c2 0218 	rsb	r2, r2, #24
   1c56e:	f1c2 0c20 	rsb	ip, r2, #32
   1c572:	fa10 f30c 	lsls.w	r3, r0, ip
   1c576:	fa20 f002 	lsr.w	r0, r0, r2
   1c57a:	bf18      	it	ne
   1c57c:	f040 0001 	orrne.w	r0, r0, #1
   1c580:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1c584:	ea4f 23d3 	mov.w	r3, r3, lsr #11
   1c588:	fa03 fc0c 	lsl.w	ip, r3, ip
   1c58c:	ea40 000c 	orr.w	r0, r0, ip
   1c590:	fa23 f302 	lsr.w	r3, r3, r2
   1c594:	ea4f 0343 	mov.w	r3, r3, lsl #1
   1c598:	e7cc      	b.n	1c534 <__aeabi_d2f+0x14>
   1c59a:	ea7f 5362 	mvns.w	r3, r2, asr #21
   1c59e:	d107      	bne.n	1c5b0 <__aeabi_d2f+0x90>
   1c5a0:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
   1c5a4:	bf1e      	ittt	ne
   1c5a6:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
   1c5aa:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
   1c5ae:	4770      	bxne	lr
   1c5b0:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
   1c5b4:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   1c5b8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   1c5bc:	4770      	bx	lr
   1c5be:	bf00      	nop

0001c5c0 <__aeabi_uldivmod>:
   1c5c0:	b953      	cbnz	r3, 1c5d8 <__aeabi_uldivmod+0x18>
   1c5c2:	b94a      	cbnz	r2, 1c5d8 <__aeabi_uldivmod+0x18>
   1c5c4:	2900      	cmp	r1, #0
   1c5c6:	bf08      	it	eq
   1c5c8:	2800      	cmpeq	r0, #0
   1c5ca:	bf1c      	itt	ne
   1c5cc:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   1c5d0:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   1c5d4:	f000 b972 	b.w	1c8bc <__aeabi_idiv0>
   1c5d8:	f1ad 0c08 	sub.w	ip, sp, #8
   1c5dc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   1c5e0:	f000 f806 	bl	1c5f0 <__udivmoddi4>
   1c5e4:	f8dd e004 	ldr.w	lr, [sp, #4]
   1c5e8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   1c5ec:	b004      	add	sp, #16
   1c5ee:	4770      	bx	lr

0001c5f0 <__udivmoddi4>:
   1c5f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1c5f4:	9e08      	ldr	r6, [sp, #32]
   1c5f6:	4604      	mov	r4, r0
   1c5f8:	4688      	mov	r8, r1
   1c5fa:	2b00      	cmp	r3, #0
   1c5fc:	d14b      	bne.n	1c696 <__udivmoddi4+0xa6>
   1c5fe:	428a      	cmp	r2, r1
   1c600:	4615      	mov	r5, r2
   1c602:	d967      	bls.n	1c6d4 <__udivmoddi4+0xe4>
   1c604:	fab2 f282 	clz	r2, r2
   1c608:	b14a      	cbz	r2, 1c61e <__udivmoddi4+0x2e>
   1c60a:	f1c2 0720 	rsb	r7, r2, #32
   1c60e:	fa01 f302 	lsl.w	r3, r1, r2
   1c612:	fa20 f707 	lsr.w	r7, r0, r7
   1c616:	4095      	lsls	r5, r2
   1c618:	ea47 0803 	orr.w	r8, r7, r3
   1c61c:	4094      	lsls	r4, r2
   1c61e:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1c622:	0c23      	lsrs	r3, r4, #16
   1c624:	fbb8 f7fe 	udiv	r7, r8, lr
   1c628:	fa1f fc85 	uxth.w	ip, r5
   1c62c:	fb0e 8817 	mls	r8, lr, r7, r8
   1c630:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   1c634:	fb07 f10c 	mul.w	r1, r7, ip
   1c638:	4299      	cmp	r1, r3
   1c63a:	d909      	bls.n	1c650 <__udivmoddi4+0x60>
   1c63c:	18eb      	adds	r3, r5, r3
   1c63e:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
   1c642:	f080 811b 	bcs.w	1c87c <__udivmoddi4+0x28c>
   1c646:	4299      	cmp	r1, r3
   1c648:	f240 8118 	bls.w	1c87c <__udivmoddi4+0x28c>
   1c64c:	3f02      	subs	r7, #2
   1c64e:	442b      	add	r3, r5
   1c650:	1a5b      	subs	r3, r3, r1
   1c652:	b2a4      	uxth	r4, r4
   1c654:	fbb3 f0fe 	udiv	r0, r3, lr
   1c658:	fb0e 3310 	mls	r3, lr, r0, r3
   1c65c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   1c660:	fb00 fc0c 	mul.w	ip, r0, ip
   1c664:	45a4      	cmp	ip, r4
   1c666:	d909      	bls.n	1c67c <__udivmoddi4+0x8c>
   1c668:	192c      	adds	r4, r5, r4
   1c66a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   1c66e:	f080 8107 	bcs.w	1c880 <__udivmoddi4+0x290>
   1c672:	45a4      	cmp	ip, r4
   1c674:	f240 8104 	bls.w	1c880 <__udivmoddi4+0x290>
   1c678:	3802      	subs	r0, #2
   1c67a:	442c      	add	r4, r5
   1c67c:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
   1c680:	eba4 040c 	sub.w	r4, r4, ip
   1c684:	2700      	movs	r7, #0
   1c686:	b11e      	cbz	r6, 1c690 <__udivmoddi4+0xa0>
   1c688:	40d4      	lsrs	r4, r2
   1c68a:	2300      	movs	r3, #0
   1c68c:	e9c6 4300 	strd	r4, r3, [r6]
   1c690:	4639      	mov	r1, r7
   1c692:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1c696:	428b      	cmp	r3, r1
   1c698:	d909      	bls.n	1c6ae <__udivmoddi4+0xbe>
   1c69a:	2e00      	cmp	r6, #0
   1c69c:	f000 80eb 	beq.w	1c876 <__udivmoddi4+0x286>
   1c6a0:	2700      	movs	r7, #0
   1c6a2:	e9c6 0100 	strd	r0, r1, [r6]
   1c6a6:	4638      	mov	r0, r7
   1c6a8:	4639      	mov	r1, r7
   1c6aa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1c6ae:	fab3 f783 	clz	r7, r3
   1c6b2:	2f00      	cmp	r7, #0
   1c6b4:	d147      	bne.n	1c746 <__udivmoddi4+0x156>
   1c6b6:	428b      	cmp	r3, r1
   1c6b8:	d302      	bcc.n	1c6c0 <__udivmoddi4+0xd0>
   1c6ba:	4282      	cmp	r2, r0
   1c6bc:	f200 80fa 	bhi.w	1c8b4 <__udivmoddi4+0x2c4>
   1c6c0:	1a84      	subs	r4, r0, r2
   1c6c2:	eb61 0303 	sbc.w	r3, r1, r3
   1c6c6:	2001      	movs	r0, #1
   1c6c8:	4698      	mov	r8, r3
   1c6ca:	2e00      	cmp	r6, #0
   1c6cc:	d0e0      	beq.n	1c690 <__udivmoddi4+0xa0>
   1c6ce:	e9c6 4800 	strd	r4, r8, [r6]
   1c6d2:	e7dd      	b.n	1c690 <__udivmoddi4+0xa0>
   1c6d4:	b902      	cbnz	r2, 1c6d8 <__udivmoddi4+0xe8>
   1c6d6:	deff      	udf	#255	; 0xff
   1c6d8:	fab2 f282 	clz	r2, r2
   1c6dc:	2a00      	cmp	r2, #0
   1c6de:	f040 808f 	bne.w	1c800 <__udivmoddi4+0x210>
   1c6e2:	1b49      	subs	r1, r1, r5
   1c6e4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1c6e8:	fa1f f885 	uxth.w	r8, r5
   1c6ec:	2701      	movs	r7, #1
   1c6ee:	fbb1 fcfe 	udiv	ip, r1, lr
   1c6f2:	0c23      	lsrs	r3, r4, #16
   1c6f4:	fb0e 111c 	mls	r1, lr, ip, r1
   1c6f8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   1c6fc:	fb08 f10c 	mul.w	r1, r8, ip
   1c700:	4299      	cmp	r1, r3
   1c702:	d907      	bls.n	1c714 <__udivmoddi4+0x124>
   1c704:	18eb      	adds	r3, r5, r3
   1c706:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   1c70a:	d202      	bcs.n	1c712 <__udivmoddi4+0x122>
   1c70c:	4299      	cmp	r1, r3
   1c70e:	f200 80cd 	bhi.w	1c8ac <__udivmoddi4+0x2bc>
   1c712:	4684      	mov	ip, r0
   1c714:	1a59      	subs	r1, r3, r1
   1c716:	b2a3      	uxth	r3, r4
   1c718:	fbb1 f0fe 	udiv	r0, r1, lr
   1c71c:	fb0e 1410 	mls	r4, lr, r0, r1
   1c720:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
   1c724:	fb08 f800 	mul.w	r8, r8, r0
   1c728:	45a0      	cmp	r8, r4
   1c72a:	d907      	bls.n	1c73c <__udivmoddi4+0x14c>
   1c72c:	192c      	adds	r4, r5, r4
   1c72e:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   1c732:	d202      	bcs.n	1c73a <__udivmoddi4+0x14a>
   1c734:	45a0      	cmp	r8, r4
   1c736:	f200 80b6 	bhi.w	1c8a6 <__udivmoddi4+0x2b6>
   1c73a:	4618      	mov	r0, r3
   1c73c:	eba4 0408 	sub.w	r4, r4, r8
   1c740:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   1c744:	e79f      	b.n	1c686 <__udivmoddi4+0x96>
   1c746:	f1c7 0c20 	rsb	ip, r7, #32
   1c74a:	40bb      	lsls	r3, r7
   1c74c:	fa22 fe0c 	lsr.w	lr, r2, ip
   1c750:	ea4e 0e03 	orr.w	lr, lr, r3
   1c754:	fa01 f407 	lsl.w	r4, r1, r7
   1c758:	fa20 f50c 	lsr.w	r5, r0, ip
   1c75c:	fa21 f30c 	lsr.w	r3, r1, ip
   1c760:	ea4f 481e 	mov.w	r8, lr, lsr #16
   1c764:	4325      	orrs	r5, r4
   1c766:	fbb3 f9f8 	udiv	r9, r3, r8
   1c76a:	0c2c      	lsrs	r4, r5, #16
   1c76c:	fb08 3319 	mls	r3, r8, r9, r3
   1c770:	fa1f fa8e 	uxth.w	sl, lr
   1c774:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
   1c778:	fb09 f40a 	mul.w	r4, r9, sl
   1c77c:	429c      	cmp	r4, r3
   1c77e:	fa02 f207 	lsl.w	r2, r2, r7
   1c782:	fa00 f107 	lsl.w	r1, r0, r7
   1c786:	d90b      	bls.n	1c7a0 <__udivmoddi4+0x1b0>
   1c788:	eb1e 0303 	adds.w	r3, lr, r3
   1c78c:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
   1c790:	f080 8087 	bcs.w	1c8a2 <__udivmoddi4+0x2b2>
   1c794:	429c      	cmp	r4, r3
   1c796:	f240 8084 	bls.w	1c8a2 <__udivmoddi4+0x2b2>
   1c79a:	f1a9 0902 	sub.w	r9, r9, #2
   1c79e:	4473      	add	r3, lr
   1c7a0:	1b1b      	subs	r3, r3, r4
   1c7a2:	b2ad      	uxth	r5, r5
   1c7a4:	fbb3 f0f8 	udiv	r0, r3, r8
   1c7a8:	fb08 3310 	mls	r3, r8, r0, r3
   1c7ac:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
   1c7b0:	fb00 fa0a 	mul.w	sl, r0, sl
   1c7b4:	45a2      	cmp	sl, r4
   1c7b6:	d908      	bls.n	1c7ca <__udivmoddi4+0x1da>
   1c7b8:	eb1e 0404 	adds.w	r4, lr, r4
   1c7bc:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   1c7c0:	d26b      	bcs.n	1c89a <__udivmoddi4+0x2aa>
   1c7c2:	45a2      	cmp	sl, r4
   1c7c4:	d969      	bls.n	1c89a <__udivmoddi4+0x2aa>
   1c7c6:	3802      	subs	r0, #2
   1c7c8:	4474      	add	r4, lr
   1c7ca:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
   1c7ce:	fba0 8902 	umull	r8, r9, r0, r2
   1c7d2:	eba4 040a 	sub.w	r4, r4, sl
   1c7d6:	454c      	cmp	r4, r9
   1c7d8:	46c2      	mov	sl, r8
   1c7da:	464b      	mov	r3, r9
   1c7dc:	d354      	bcc.n	1c888 <__udivmoddi4+0x298>
   1c7de:	d051      	beq.n	1c884 <__udivmoddi4+0x294>
   1c7e0:	2e00      	cmp	r6, #0
   1c7e2:	d069      	beq.n	1c8b8 <__udivmoddi4+0x2c8>
   1c7e4:	ebb1 050a 	subs.w	r5, r1, sl
   1c7e8:	eb64 0403 	sbc.w	r4, r4, r3
   1c7ec:	fa04 fc0c 	lsl.w	ip, r4, ip
   1c7f0:	40fd      	lsrs	r5, r7
   1c7f2:	40fc      	lsrs	r4, r7
   1c7f4:	ea4c 0505 	orr.w	r5, ip, r5
   1c7f8:	e9c6 5400 	strd	r5, r4, [r6]
   1c7fc:	2700      	movs	r7, #0
   1c7fe:	e747      	b.n	1c690 <__udivmoddi4+0xa0>
   1c800:	f1c2 0320 	rsb	r3, r2, #32
   1c804:	fa20 f703 	lsr.w	r7, r0, r3
   1c808:	4095      	lsls	r5, r2
   1c80a:	fa01 f002 	lsl.w	r0, r1, r2
   1c80e:	fa21 f303 	lsr.w	r3, r1, r3
   1c812:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1c816:	4338      	orrs	r0, r7
   1c818:	0c01      	lsrs	r1, r0, #16
   1c81a:	fbb3 f7fe 	udiv	r7, r3, lr
   1c81e:	fa1f f885 	uxth.w	r8, r5
   1c822:	fb0e 3317 	mls	r3, lr, r7, r3
   1c826:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   1c82a:	fb07 f308 	mul.w	r3, r7, r8
   1c82e:	428b      	cmp	r3, r1
   1c830:	fa04 f402 	lsl.w	r4, r4, r2
   1c834:	d907      	bls.n	1c846 <__udivmoddi4+0x256>
   1c836:	1869      	adds	r1, r5, r1
   1c838:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
   1c83c:	d22f      	bcs.n	1c89e <__udivmoddi4+0x2ae>
   1c83e:	428b      	cmp	r3, r1
   1c840:	d92d      	bls.n	1c89e <__udivmoddi4+0x2ae>
   1c842:	3f02      	subs	r7, #2
   1c844:	4429      	add	r1, r5
   1c846:	1acb      	subs	r3, r1, r3
   1c848:	b281      	uxth	r1, r0
   1c84a:	fbb3 f0fe 	udiv	r0, r3, lr
   1c84e:	fb0e 3310 	mls	r3, lr, r0, r3
   1c852:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   1c856:	fb00 f308 	mul.w	r3, r0, r8
   1c85a:	428b      	cmp	r3, r1
   1c85c:	d907      	bls.n	1c86e <__udivmoddi4+0x27e>
   1c85e:	1869      	adds	r1, r5, r1
   1c860:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
   1c864:	d217      	bcs.n	1c896 <__udivmoddi4+0x2a6>
   1c866:	428b      	cmp	r3, r1
   1c868:	d915      	bls.n	1c896 <__udivmoddi4+0x2a6>
   1c86a:	3802      	subs	r0, #2
   1c86c:	4429      	add	r1, r5
   1c86e:	1ac9      	subs	r1, r1, r3
   1c870:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
   1c874:	e73b      	b.n	1c6ee <__udivmoddi4+0xfe>
   1c876:	4637      	mov	r7, r6
   1c878:	4630      	mov	r0, r6
   1c87a:	e709      	b.n	1c690 <__udivmoddi4+0xa0>
   1c87c:	4607      	mov	r7, r0
   1c87e:	e6e7      	b.n	1c650 <__udivmoddi4+0x60>
   1c880:	4618      	mov	r0, r3
   1c882:	e6fb      	b.n	1c67c <__udivmoddi4+0x8c>
   1c884:	4541      	cmp	r1, r8
   1c886:	d2ab      	bcs.n	1c7e0 <__udivmoddi4+0x1f0>
   1c888:	ebb8 0a02 	subs.w	sl, r8, r2
   1c88c:	eb69 020e 	sbc.w	r2, r9, lr
   1c890:	3801      	subs	r0, #1
   1c892:	4613      	mov	r3, r2
   1c894:	e7a4      	b.n	1c7e0 <__udivmoddi4+0x1f0>
   1c896:	4660      	mov	r0, ip
   1c898:	e7e9      	b.n	1c86e <__udivmoddi4+0x27e>
   1c89a:	4618      	mov	r0, r3
   1c89c:	e795      	b.n	1c7ca <__udivmoddi4+0x1da>
   1c89e:	4667      	mov	r7, ip
   1c8a0:	e7d1      	b.n	1c846 <__udivmoddi4+0x256>
   1c8a2:	4681      	mov	r9, r0
   1c8a4:	e77c      	b.n	1c7a0 <__udivmoddi4+0x1b0>
   1c8a6:	3802      	subs	r0, #2
   1c8a8:	442c      	add	r4, r5
   1c8aa:	e747      	b.n	1c73c <__udivmoddi4+0x14c>
   1c8ac:	f1ac 0c02 	sub.w	ip, ip, #2
   1c8b0:	442b      	add	r3, r5
   1c8b2:	e72f      	b.n	1c714 <__udivmoddi4+0x124>
   1c8b4:	4638      	mov	r0, r7
   1c8b6:	e708      	b.n	1c6ca <__udivmoddi4+0xda>
   1c8b8:	4637      	mov	r7, r6
   1c8ba:	e6e9      	b.n	1c690 <__udivmoddi4+0xa0>

0001c8bc <__aeabi_idiv0>:
   1c8bc:	4770      	bx	lr
   1c8be:	bf00      	nop

0001c8c0 <abort>:
   1c8c0:	b508      	push	{r3, lr}
   1c8c2:	2006      	movs	r0, #6
   1c8c4:	f000 f920 	bl	1cb08 <raise>
   1c8c8:	2001      	movs	r0, #1
   1c8ca:	f7f9 ff47 	bl	1675c <_exit>
   1c8ce:	Address 0x000000000001c8ce is out of bounds.


0001c8d0 <__libc_init_array>:
   1c8d0:	b570      	push	{r4, r5, r6, lr}
   1c8d2:	4e0d      	ldr	r6, [pc, #52]	; (1c908 <__libc_init_array+0x38>)
   1c8d4:	4c0d      	ldr	r4, [pc, #52]	; (1c90c <__libc_init_array+0x3c>)
   1c8d6:	1ba4      	subs	r4, r4, r6
   1c8d8:	10a4      	asrs	r4, r4, #2
   1c8da:	2500      	movs	r5, #0
   1c8dc:	42a5      	cmp	r5, r4
   1c8de:	d109      	bne.n	1c8f4 <__libc_init_array+0x24>
   1c8e0:	4e0b      	ldr	r6, [pc, #44]	; (1c910 <__libc_init_array+0x40>)
   1c8e2:	4c0c      	ldr	r4, [pc, #48]	; (1c914 <__libc_init_array+0x44>)
   1c8e4:	f7f3 fd0c 	bl	10300 <_init>
   1c8e8:	1ba4      	subs	r4, r4, r6
   1c8ea:	10a4      	asrs	r4, r4, #2
   1c8ec:	2500      	movs	r5, #0
   1c8ee:	42a5      	cmp	r5, r4
   1c8f0:	d105      	bne.n	1c8fe <__libc_init_array+0x2e>
   1c8f2:	bd70      	pop	{r4, r5, r6, pc}
   1c8f4:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   1c8f8:	4798      	blx	r3
   1c8fa:	3501      	adds	r5, #1
   1c8fc:	e7ee      	b.n	1c8dc <__libc_init_array+0xc>
   1c8fe:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   1c902:	4798      	blx	r3
   1c904:	3501      	adds	r5, #1
   1c906:	e7f2      	b.n	1c8ee <__libc_init_array+0x1e>
   1c908:	0001030c 	.word	0x0001030c
   1c90c:	0001030c 	.word	0x0001030c
   1c910:	0001030c 	.word	0x0001030c
   1c914:	00010320 	.word	0x00010320

0001c918 <malloc>:
   1c918:	4b02      	ldr	r3, [pc, #8]	; (1c924 <malloc+0xc>)
   1c91a:	4601      	mov	r1, r0
   1c91c:	6818      	ldr	r0, [r3, #0]
   1c91e:	f000 b861 	b.w	1c9e4 <_malloc_r>
   1c922:	bf00      	nop
   1c924:	10000658 	.word	0x10000658

0001c928 <free>:
   1c928:	4b02      	ldr	r3, [pc, #8]	; (1c934 <free+0xc>)
   1c92a:	4601      	mov	r1, r0
   1c92c:	6818      	ldr	r0, [r3, #0]
   1c92e:	f000 b80b 	b.w	1c948 <_free_r>
   1c932:	bf00      	nop
   1c934:	10000658 	.word	0x10000658

0001c938 <memset>:
   1c938:	4402      	add	r2, r0
   1c93a:	4603      	mov	r3, r0
   1c93c:	4293      	cmp	r3, r2
   1c93e:	d100      	bne.n	1c942 <memset+0xa>
   1c940:	4770      	bx	lr
   1c942:	f803 1b01 	strb.w	r1, [r3], #1
   1c946:	e7f9      	b.n	1c93c <memset+0x4>

0001c948 <_free_r>:
   1c948:	b538      	push	{r3, r4, r5, lr}
   1c94a:	4605      	mov	r5, r0
   1c94c:	2900      	cmp	r1, #0
   1c94e:	d045      	beq.n	1c9dc <_free_r+0x94>
   1c950:	f851 3c04 	ldr.w	r3, [r1, #-4]
   1c954:	1f0c      	subs	r4, r1, #4
   1c956:	2b00      	cmp	r3, #0
   1c958:	bfb8      	it	lt
   1c95a:	18e4      	addlt	r4, r4, r3
   1c95c:	f000 f900 	bl	1cb60 <__malloc_lock>
   1c960:	4a1f      	ldr	r2, [pc, #124]	; (1c9e0 <_free_r+0x98>)
   1c962:	6813      	ldr	r3, [r2, #0]
   1c964:	4610      	mov	r0, r2
   1c966:	b933      	cbnz	r3, 1c976 <_free_r+0x2e>
   1c968:	6063      	str	r3, [r4, #4]
   1c96a:	6014      	str	r4, [r2, #0]
   1c96c:	4628      	mov	r0, r5
   1c96e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1c972:	f000 b8f6 	b.w	1cb62 <__malloc_unlock>
   1c976:	42a3      	cmp	r3, r4
   1c978:	d90c      	bls.n	1c994 <_free_r+0x4c>
   1c97a:	6821      	ldr	r1, [r4, #0]
   1c97c:	1862      	adds	r2, r4, r1
   1c97e:	4293      	cmp	r3, r2
   1c980:	bf04      	itt	eq
   1c982:	681a      	ldreq	r2, [r3, #0]
   1c984:	685b      	ldreq	r3, [r3, #4]
   1c986:	6063      	str	r3, [r4, #4]
   1c988:	bf04      	itt	eq
   1c98a:	1852      	addeq	r2, r2, r1
   1c98c:	6022      	streq	r2, [r4, #0]
   1c98e:	6004      	str	r4, [r0, #0]
   1c990:	e7ec      	b.n	1c96c <_free_r+0x24>
   1c992:	4613      	mov	r3, r2
   1c994:	685a      	ldr	r2, [r3, #4]
   1c996:	b10a      	cbz	r2, 1c99c <_free_r+0x54>
   1c998:	42a2      	cmp	r2, r4
   1c99a:	d9fa      	bls.n	1c992 <_free_r+0x4a>
   1c99c:	6819      	ldr	r1, [r3, #0]
   1c99e:	1858      	adds	r0, r3, r1
   1c9a0:	42a0      	cmp	r0, r4
   1c9a2:	d10b      	bne.n	1c9bc <_free_r+0x74>
   1c9a4:	6820      	ldr	r0, [r4, #0]
   1c9a6:	4401      	add	r1, r0
   1c9a8:	1858      	adds	r0, r3, r1
   1c9aa:	4282      	cmp	r2, r0
   1c9ac:	6019      	str	r1, [r3, #0]
   1c9ae:	d1dd      	bne.n	1c96c <_free_r+0x24>
   1c9b0:	6810      	ldr	r0, [r2, #0]
   1c9b2:	6852      	ldr	r2, [r2, #4]
   1c9b4:	605a      	str	r2, [r3, #4]
   1c9b6:	4401      	add	r1, r0
   1c9b8:	6019      	str	r1, [r3, #0]
   1c9ba:	e7d7      	b.n	1c96c <_free_r+0x24>
   1c9bc:	d902      	bls.n	1c9c4 <_free_r+0x7c>
   1c9be:	230c      	movs	r3, #12
   1c9c0:	602b      	str	r3, [r5, #0]
   1c9c2:	e7d3      	b.n	1c96c <_free_r+0x24>
   1c9c4:	6820      	ldr	r0, [r4, #0]
   1c9c6:	1821      	adds	r1, r4, r0
   1c9c8:	428a      	cmp	r2, r1
   1c9ca:	bf04      	itt	eq
   1c9cc:	6811      	ldreq	r1, [r2, #0]
   1c9ce:	6852      	ldreq	r2, [r2, #4]
   1c9d0:	6062      	str	r2, [r4, #4]
   1c9d2:	bf04      	itt	eq
   1c9d4:	1809      	addeq	r1, r1, r0
   1c9d6:	6021      	streq	r1, [r4, #0]
   1c9d8:	605c      	str	r4, [r3, #4]
   1c9da:	e7c7      	b.n	1c96c <_free_r+0x24>
   1c9dc:	bd38      	pop	{r3, r4, r5, pc}
   1c9de:	bf00      	nop
   1c9e0:	100033f8 	.word	0x100033f8

0001c9e4 <_malloc_r>:
   1c9e4:	b570      	push	{r4, r5, r6, lr}
   1c9e6:	1ccd      	adds	r5, r1, #3
   1c9e8:	f025 0503 	bic.w	r5, r5, #3
   1c9ec:	3508      	adds	r5, #8
   1c9ee:	2d0c      	cmp	r5, #12
   1c9f0:	bf38      	it	cc
   1c9f2:	250c      	movcc	r5, #12
   1c9f4:	2d00      	cmp	r5, #0
   1c9f6:	4606      	mov	r6, r0
   1c9f8:	db01      	blt.n	1c9fe <_malloc_r+0x1a>
   1c9fa:	42a9      	cmp	r1, r5
   1c9fc:	d903      	bls.n	1ca06 <_malloc_r+0x22>
   1c9fe:	230c      	movs	r3, #12
   1ca00:	6033      	str	r3, [r6, #0]
   1ca02:	2000      	movs	r0, #0
   1ca04:	bd70      	pop	{r4, r5, r6, pc}
   1ca06:	f000 f8ab 	bl	1cb60 <__malloc_lock>
   1ca0a:	4a21      	ldr	r2, [pc, #132]	; (1ca90 <_malloc_r+0xac>)
   1ca0c:	6814      	ldr	r4, [r2, #0]
   1ca0e:	4621      	mov	r1, r4
   1ca10:	b991      	cbnz	r1, 1ca38 <_malloc_r+0x54>
   1ca12:	4c20      	ldr	r4, [pc, #128]	; (1ca94 <_malloc_r+0xb0>)
   1ca14:	6823      	ldr	r3, [r4, #0]
   1ca16:	b91b      	cbnz	r3, 1ca20 <_malloc_r+0x3c>
   1ca18:	4630      	mov	r0, r6
   1ca1a:	f000 f83d 	bl	1ca98 <_sbrk_r>
   1ca1e:	6020      	str	r0, [r4, #0]
   1ca20:	4629      	mov	r1, r5
   1ca22:	4630      	mov	r0, r6
   1ca24:	f000 f838 	bl	1ca98 <_sbrk_r>
   1ca28:	1c43      	adds	r3, r0, #1
   1ca2a:	d124      	bne.n	1ca76 <_malloc_r+0x92>
   1ca2c:	230c      	movs	r3, #12
   1ca2e:	6033      	str	r3, [r6, #0]
   1ca30:	4630      	mov	r0, r6
   1ca32:	f000 f896 	bl	1cb62 <__malloc_unlock>
   1ca36:	e7e4      	b.n	1ca02 <_malloc_r+0x1e>
   1ca38:	680b      	ldr	r3, [r1, #0]
   1ca3a:	1b5b      	subs	r3, r3, r5
   1ca3c:	d418      	bmi.n	1ca70 <_malloc_r+0x8c>
   1ca3e:	2b0b      	cmp	r3, #11
   1ca40:	d90f      	bls.n	1ca62 <_malloc_r+0x7e>
   1ca42:	600b      	str	r3, [r1, #0]
   1ca44:	50cd      	str	r5, [r1, r3]
   1ca46:	18cc      	adds	r4, r1, r3
   1ca48:	4630      	mov	r0, r6
   1ca4a:	f000 f88a 	bl	1cb62 <__malloc_unlock>
   1ca4e:	f104 000b 	add.w	r0, r4, #11
   1ca52:	1d23      	adds	r3, r4, #4
   1ca54:	f020 0007 	bic.w	r0, r0, #7
   1ca58:	1ac3      	subs	r3, r0, r3
   1ca5a:	d0d3      	beq.n	1ca04 <_malloc_r+0x20>
   1ca5c:	425a      	negs	r2, r3
   1ca5e:	50e2      	str	r2, [r4, r3]
   1ca60:	e7d0      	b.n	1ca04 <_malloc_r+0x20>
   1ca62:	428c      	cmp	r4, r1
   1ca64:	684b      	ldr	r3, [r1, #4]
   1ca66:	bf16      	itet	ne
   1ca68:	6063      	strne	r3, [r4, #4]
   1ca6a:	6013      	streq	r3, [r2, #0]
   1ca6c:	460c      	movne	r4, r1
   1ca6e:	e7eb      	b.n	1ca48 <_malloc_r+0x64>
   1ca70:	460c      	mov	r4, r1
   1ca72:	6849      	ldr	r1, [r1, #4]
   1ca74:	e7cc      	b.n	1ca10 <_malloc_r+0x2c>
   1ca76:	1cc4      	adds	r4, r0, #3
   1ca78:	f024 0403 	bic.w	r4, r4, #3
   1ca7c:	42a0      	cmp	r0, r4
   1ca7e:	d005      	beq.n	1ca8c <_malloc_r+0xa8>
   1ca80:	1a21      	subs	r1, r4, r0
   1ca82:	4630      	mov	r0, r6
   1ca84:	f000 f808 	bl	1ca98 <_sbrk_r>
   1ca88:	3001      	adds	r0, #1
   1ca8a:	d0cf      	beq.n	1ca2c <_malloc_r+0x48>
   1ca8c:	6025      	str	r5, [r4, #0]
   1ca8e:	e7db      	b.n	1ca48 <_malloc_r+0x64>
   1ca90:	100033f8 	.word	0x100033f8
   1ca94:	100033fc 	.word	0x100033fc

0001ca98 <_sbrk_r>:
   1ca98:	b538      	push	{r3, r4, r5, lr}
   1ca9a:	4c06      	ldr	r4, [pc, #24]	; (1cab4 <_sbrk_r+0x1c>)
   1ca9c:	2300      	movs	r3, #0
   1ca9e:	4605      	mov	r5, r0
   1caa0:	4608      	mov	r0, r1
   1caa2:	6023      	str	r3, [r4, #0]
   1caa4:	f7f9 fe90 	bl	167c8 <_sbrk>
   1caa8:	1c43      	adds	r3, r0, #1
   1caaa:	d102      	bne.n	1cab2 <_sbrk_r+0x1a>
   1caac:	6823      	ldr	r3, [r4, #0]
   1caae:	b103      	cbz	r3, 1cab2 <_sbrk_r+0x1a>
   1cab0:	602b      	str	r3, [r5, #0]
   1cab2:	bd38      	pop	{r3, r4, r5, pc}
   1cab4:	10003400 	.word	0x10003400

0001cab8 <_raise_r>:
   1cab8:	291f      	cmp	r1, #31
   1caba:	b538      	push	{r3, r4, r5, lr}
   1cabc:	4604      	mov	r4, r0
   1cabe:	460d      	mov	r5, r1
   1cac0:	d904      	bls.n	1cacc <_raise_r+0x14>
   1cac2:	2316      	movs	r3, #22
   1cac4:	6003      	str	r3, [r0, #0]
   1cac6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1caca:	bd38      	pop	{r3, r4, r5, pc}
   1cacc:	6c42      	ldr	r2, [r0, #68]	; 0x44
   1cace:	b112      	cbz	r2, 1cad6 <_raise_r+0x1e>
   1cad0:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   1cad4:	b94b      	cbnz	r3, 1caea <_raise_r+0x32>
   1cad6:	4620      	mov	r0, r4
   1cad8:	f000 f830 	bl	1cb3c <_getpid_r>
   1cadc:	462a      	mov	r2, r5
   1cade:	4601      	mov	r1, r0
   1cae0:	4620      	mov	r0, r4
   1cae2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1cae6:	f000 b817 	b.w	1cb18 <_kill_r>
   1caea:	2b01      	cmp	r3, #1
   1caec:	d00a      	beq.n	1cb04 <_raise_r+0x4c>
   1caee:	1c59      	adds	r1, r3, #1
   1caf0:	d103      	bne.n	1cafa <_raise_r+0x42>
   1caf2:	2316      	movs	r3, #22
   1caf4:	6003      	str	r3, [r0, #0]
   1caf6:	2001      	movs	r0, #1
   1caf8:	e7e7      	b.n	1caca <_raise_r+0x12>
   1cafa:	2400      	movs	r4, #0
   1cafc:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
   1cb00:	4628      	mov	r0, r5
   1cb02:	4798      	blx	r3
   1cb04:	2000      	movs	r0, #0
   1cb06:	e7e0      	b.n	1caca <_raise_r+0x12>

0001cb08 <raise>:
   1cb08:	4b02      	ldr	r3, [pc, #8]	; (1cb14 <raise+0xc>)
   1cb0a:	4601      	mov	r1, r0
   1cb0c:	6818      	ldr	r0, [r3, #0]
   1cb0e:	f7ff bfd3 	b.w	1cab8 <_raise_r>
   1cb12:	bf00      	nop
   1cb14:	10000658 	.word	0x10000658

0001cb18 <_kill_r>:
   1cb18:	b538      	push	{r3, r4, r5, lr}
   1cb1a:	4c07      	ldr	r4, [pc, #28]	; (1cb38 <_kill_r+0x20>)
   1cb1c:	2300      	movs	r3, #0
   1cb1e:	4605      	mov	r5, r0
   1cb20:	4608      	mov	r0, r1
   1cb22:	4611      	mov	r1, r2
   1cb24:	6023      	str	r3, [r4, #0]
   1cb26:	f7f9 fe37 	bl	16798 <_kill>
   1cb2a:	1c43      	adds	r3, r0, #1
   1cb2c:	d102      	bne.n	1cb34 <_kill_r+0x1c>
   1cb2e:	6823      	ldr	r3, [r4, #0]
   1cb30:	b103      	cbz	r3, 1cb34 <_kill_r+0x1c>
   1cb32:	602b      	str	r3, [r5, #0]
   1cb34:	bd38      	pop	{r3, r4, r5, pc}
   1cb36:	bf00      	nop
   1cb38:	10003400 	.word	0x10003400

0001cb3c <_getpid_r>:
   1cb3c:	f7f9 be1a 	b.w	16774 <_getpid>

0001cb40 <strcpy>:
   1cb40:	4603      	mov	r3, r0
   1cb42:	f811 2b01 	ldrb.w	r2, [r1], #1
   1cb46:	f803 2b01 	strb.w	r2, [r3], #1
   1cb4a:	2a00      	cmp	r2, #0
   1cb4c:	d1f9      	bne.n	1cb42 <strcpy+0x2>
   1cb4e:	4770      	bx	lr

0001cb50 <strlen>:
   1cb50:	4603      	mov	r3, r0
   1cb52:	f813 2b01 	ldrb.w	r2, [r3], #1
   1cb56:	2a00      	cmp	r2, #0
   1cb58:	d1fb      	bne.n	1cb52 <strlen+0x2>
   1cb5a:	1a18      	subs	r0, r3, r0
   1cb5c:	3801      	subs	r0, #1
   1cb5e:	4770      	bx	lr

0001cb60 <__malloc_lock>:
   1cb60:	4770      	bx	lr

0001cb62 <__malloc_unlock>:
   1cb62:	4770      	bx	lr
   1cb64:	4002c048 	.word	0x4002c048
   1cb68:	4002c044 	.word	0x4002c044
   1cb6c:	4002c03c 	.word	0x4002c03c
   1cb70:	4002c024 	.word	0x4002c024
   1cb74:	4002c020 	.word	0x4002c020
   1cb78:	4002c01c 	.word	0x4002c01c
   1cb7c:	4002c084 	.word	0x4002c084
   1cb80:	4002c080 	.word	0x4002c080
   1cb84:	4002c090 	.word	0x4002c090
   1cb88:	00000002 	.word	0x00000002
   1cb8c:	00000002 	.word	0x00000002
   1cb90:	00000004 	.word	0x00000004
   1cb94:	00000015 	.word	0x00000015
   1cb98:	0000000a 	.word	0x0000000a
   1cb9c:	00000014 	.word	0x00000014
   1cba0:	0073252f 	.word	0x0073252f
   1cba4:	252f7325 	.word	0x252f7325
   1cba8:	ff000a73 	.word	0xff000a73
   1cbac:	74746553 	.word	0x74746553
   1cbb0:	20676e69 	.word	0x20676e69
   1cbb4:	53204e4f 	.word	0x53204e4f
   1cbb8:	75255053 	.word	0x75255053
   1cbbc:	00000a2e 	.word	0x00000a2e
   1cbc0:	74746553 	.word	0x74746553
   1cbc4:	20676e69 	.word	0x20676e69
   1cbc8:	636f6c63 	.word	0x636f6c63
   1cbcc:	6172206b 	.word	0x6172206b
   1cbd0:	002e6574 	.word	0x002e6574
   1cbd4:	74746553 	.word	0x74746553
   1cbd8:	20676e69 	.word	0x20676e69
   1cbdc:	206e6970 	.word	0x206e6970
   1cbe0:	65646f6d 	.word	0x65646f6d
   1cbe4:	206f7420 	.word	0x206f7420
   1cbe8:	2e505353 	.word	0x2e505353
   1cbec:	00000000 	.word	0x00000000
   1cbf0:	74746553 	.word	0x74746553
   1cbf4:	20676e69 	.word	0x20676e69
   1cbf8:	61746164 	.word	0x61746164
   1cbfc:	7a69735f 	.word	0x7a69735f
   1cc00:	65735f65 	.word	0x65735f65
   1cc04:	7463656c 	.word	0x7463656c
   1cc08:	206f7420 	.word	0x206f7420
   1cc0c:	0a2e7525 	.word	0x0a2e7525
   1cc10:	74746553 	.word	0x74746553
   1cc14:	20676e69 	.word	0x20676e69
   1cc18:	6d726f66 	.word	0x6d726f66
   1cc1c:	74207461 	.word	0x74207461
   1cc20:	5053206f 	.word	0x5053206f
   1cc24:	6f6d2049 	.word	0x6f6d2049
   1cc28:	0a2e6564 	.word	0x0a2e6564
   1cc2c:	62616e45 	.word	0x62616e45
   1cc30:	676e696c 	.word	0x676e696c
   1cc34:	76656420 	.word	0x76656420
   1cc38:	2e656369 	.word	0x2e656369
   1cc3c:	ffff000a 	.word	0xffff000a
   1cc40:	63617453 	.word	0x63617453
   1cc44:	6544206b 	.word	0x6544206b
   1cc48:	20687470 	.word	0x20687470
   1cc4c:	7a25203d 	.word	0x7a25203d
   1cc50:	00000a64 	.word	0x00000a64
   1cc54:	25232020 	.word	0x25232020
   1cc58:	203a757a 	.word	0x203a757a
   1cc5c:	70257830 	.word	0x70257830
   1cc60:	0000000a 	.word	0x0000000a
   1cc64:	6e75520a 	.word	0x6e75520a
   1cc68:	6874203a 	.word	0x6874203a
   1cc6c:	6f662065 	.word	0x6f662065
   1cc70:	776f6c6c 	.word	0x776f6c6c
   1cc74:	20676e69 	.word	0x20676e69
   1cc78:	6d6d6f63 	.word	0x6d6d6f63
   1cc7c:	20646e61 	.word	0x20646e61
   1cc80:	79206e69 	.word	0x79206e69
   1cc84:	2072756f 	.word	0x2072756f
   1cc88:	6a6f7270 	.word	0x6a6f7270
   1cc8c:	20746365 	.word	0x20746365
   1cc90:	65726964 	.word	0x65726964
   1cc94:	726f7463 	.word	0x726f7463
   1cc98:	00000079 	.word	0x00000079
   1cc9c:	1b20200a 	.word	0x1b20200a
   1cca0:	333b315b 	.word	0x333b315b
   1cca4:	616d6d37 	.word	0x616d6d37
   1cca8:	7320656b 	.word	0x7320656b
   1ccac:	6b636174 	.word	0x6b636174
   1ccb0:	63617274 	.word	0x63617274
   1ccb4:	73252d65 	.word	0x73252d65
   1ccb8:	41525420 	.word	0x41525420
   1ccbc:	3d534543 	.word	0x3d534543
   1ccc0:	00000022 	.word	0x00000022
   1ccc4:	70257830 	.word	0x70257830
   1ccc8:	00000000 	.word	0x00000000
   1cccc:	25783020 	.word	0x25783020
   1ccd0:	00000070 	.word	0x00000070
   1ccd4:	5b1b0a22 	.word	0x5b1b0a22
   1ccd8:	00006d30 	.word	0x00006d30
   1ccdc:	73696854 	.word	0x73696854
   1cce0:	6c697720 	.word	0x6c697720
   1cce4:	6572206c 	.word	0x6572206c
   1cce8:	74726f70 	.word	0x74726f70
   1ccec:	65687420 	.word	0x65687420
   1ccf0:	6c696620 	.word	0x6c696620
   1ccf4:	6e612065 	.word	0x6e612065
   1ccf8:	696c2064 	.word	0x696c2064
   1ccfc:	6e20656e 	.word	0x6e20656e
   1cd00:	65626d75 	.word	0x65626d75
   1cd04:	68742072 	.word	0x68742072
   1cd08:	6c207461 	.word	0x6c207461
   1cd0c:	74206465 	.word	0x74206465
   1cd10:	6874206f 	.word	0x6874206f
   1cd14:	66207369 	.word	0x66207369
   1cd18:	74636e75 	.word	0x74636e75
   1cd1c:	206e6f69 	.word	0x206e6f69
   1cd20:	6e696562 	.word	0x6e696562
   1cd24:	61632067 	.word	0x61632067
   1cd28:	64656c6c 	.word	0x64656c6c
   1cd2c:	0000002e 	.word	0x0000002e
   1cd30:	6c707061 	.word	0x6c707061
   1cd34:	74616369 	.word	0x74616369
   1cd38:	006e6f69 	.word	0x006e6f69
   1cd3c:	31345b1b 	.word	0x31345b1b
   1cd40:	4952436d 	.word	0x4952436d
   1cd44:	41434954 	.word	0x41434954
   1cd48:	305b1b4c 	.word	0x305b1b4c
   1cd4c:	6d34393b 	.word	0x6d34393b
   1cd50:	3a73253a 	.word	0x3a73253a
   1cd54:	3b305b1b 	.word	0x3b305b1b
   1cd58:	256d3239 	.word	0x256d3239
   1cd5c:	5b1b3a73 	.word	0x5b1b3a73
   1cd60:	33393b30 	.word	0x33393b30
   1cd64:	3e64256d 	.word	0x3e64256d
   1cd68:	305b1b20 	.word	0x305b1b20
   1cd6c:	6d37333b 	.word	0x6d37333b
   1cd70:	65737341 	.word	0x65737341
   1cd74:	6f697472 	.word	0x6f697472
   1cd78:	6146206e 	.word	0x6146206e
   1cd7c:	72756c69 	.word	0x72756c69
   1cd80:	43202c65 	.word	0x43202c65
   1cd84:	69646e6f 	.word	0x69646e6f
   1cd88:	6e6f6974 	.word	0x6e6f6974
   1cd8c:	73655420 	.word	0x73655420
   1cd90:	3a646574 	.word	0x3a646574
   1cd94:	65702820 	.word	0x65702820
   1cd98:	68706972 	.word	0x68706972
   1cd9c:	6c617265 	.word	0x6c617265
   1cda0:	7669645f 	.word	0x7669645f
   1cda4:	72656469 	.word	0x72656469
   1cda8:	203d3c20 	.word	0x203d3c20
   1cdac:	200a2934 	.word	0x200a2934
   1cdb0:	20202020 	.word	0x20202020
   1cdb4:	20202020 	.word	0x20202020
   1cdb8:	76694420 	.word	0x76694420
   1cdbc:	72656469 	.word	0x72656469
   1cdc0:	73756d20 	.word	0x73756d20
   1cdc4:	74276e74 	.word	0x74276e74
   1cdc8:	63786520 	.word	0x63786520
   1cdcc:	20646565 	.word	0x20646565
   1cdd0:	5b1b3233 	.word	0x5b1b3233
   1cdd4:	5b1b6d30 	.word	0x5b1b6d30
   1cdd8:	000a6d30 	.word	0x000a6d30
   1cddc:	6972500a 	.word	0x6972500a
   1cde0:	6e69746e 	.word	0x6e69746e
   1cde4:	74532067 	.word	0x74532067
   1cde8:	206b6361 	.word	0x206b6361
   1cdec:	63617254 	.word	0x63617254
   1cdf0:	000a3a65 	.word	0x000a3a65
   1cdf4:	31345b1b 	.word	0x31345b1b
   1cdf8:	4952436d 	.word	0x4952436d
   1cdfc:	41434954 	.word	0x41434954
   1ce00:	305b1b4c 	.word	0x305b1b4c
   1ce04:	6d34393b 	.word	0x6d34393b
   1ce08:	3a73253a 	.word	0x3a73253a
   1ce0c:	3b305b1b 	.word	0x3b305b1b
   1ce10:	256d3239 	.word	0x256d3239
   1ce14:	5b1b3a73 	.word	0x5b1b3a73
   1ce18:	33393b30 	.word	0x33393b30
   1ce1c:	3e64256d 	.word	0x3e64256d
   1ce20:	305b1b20 	.word	0x305b1b20
   1ce24:	6d37333b 	.word	0x6d37333b
   1ce28:	65737341 	.word	0x65737341
   1ce2c:	6f697472 	.word	0x6f697472
   1ce30:	6146206e 	.word	0x6146206e
   1ce34:	72756c69 	.word	0x72756c69
   1ce38:	43202c65 	.word	0x43202c65
   1ce3c:	69646e6f 	.word	0x69646e6f
   1ce40:	6e6f6974 	.word	0x6e6f6974
   1ce44:	73655420 	.word	0x73655420
   1ce48:	3a646574 	.word	0x3a646574
   1ce4c:	65642820 	.word	0x65642820
   1ce50:	65726973 	.word	0x65726973
   1ce54:	70735f64 	.word	0x70735f64
   1ce58:	5f646565 	.word	0x5f646565
   1ce5c:	6d5f6e69 	.word	0x6d5f6e69
   1ce60:	3c207a68 	.word	0x3c207a68
   1ce64:	34383320 	.word	0x34383320
   1ce68:	20262620 	.word	0x20262620
   1ce6c:	69736564 	.word	0x69736564
   1ce70:	5f646572 	.word	0x5f646572
   1ce74:	65657073 	.word	0x65657073
   1ce78:	6e695f64 	.word	0x6e695f64
   1ce7c:	7a686d5f 	.word	0x7a686d5f
   1ce80:	31203e20 	.word	0x31203e20
   1ce84:	200a2932 	.word	0x200a2932
   1ce88:	20202020 	.word	0x20202020
   1ce8c:	20202020 	.word	0x20202020
   1ce90:	65724620 	.word	0x65724620
   1ce94:	6e657571 	.word	0x6e657571
   1ce98:	6d207963 	.word	0x6d207963
   1ce9c:	20747375 	.word	0x20747375
   1cea0:	6c206562 	.word	0x6c206562
   1cea4:	7265776f 	.word	0x7265776f
   1cea8:	61687420 	.word	0x61687420
   1ceac:	3833206e 	.word	0x3833206e
   1ceb0:	484d2034 	.word	0x484d2034
   1ceb4:	646e617a 	.word	0x646e617a
   1ceb8:	65726720 	.word	0x65726720
   1cebc:	72657461 	.word	0x72657461
   1cec0:	61687420 	.word	0x61687420
   1cec4:	726f206e 	.word	0x726f206e
   1cec8:	75716520 	.word	0x75716520
   1cecc:	74206c61 	.word	0x74206c61
   1ced0:	3231206f 	.word	0x3231206f
   1ced4:	7a484d20 	.word	0x7a484d20
   1ced8:	6d305b1b 	.word	0x6d305b1b
   1cedc:	6d305b1b 	.word	0x6d305b1b
   1cee0:	0000000a 	.word	0x0000000a
   1cee4:	31345b1b 	.word	0x31345b1b
   1cee8:	4952436d 	.word	0x4952436d
   1ceec:	41434954 	.word	0x41434954
   1cef0:	305b1b4c 	.word	0x305b1b4c
   1cef4:	6d34393b 	.word	0x6d34393b
   1cef8:	3a73253a 	.word	0x3a73253a
   1cefc:	3b305b1b 	.word	0x3b305b1b
   1cf00:	256d3239 	.word	0x256d3239
   1cf04:	5b1b3a73 	.word	0x5b1b3a73
   1cf08:	33393b30 	.word	0x33393b30
   1cf0c:	3e64256d 	.word	0x3e64256d
   1cf10:	305b1b20 	.word	0x305b1b20
   1cf14:	6d37333b 	.word	0x6d37333b
   1cf18:	65737341 	.word	0x65737341
   1cf1c:	6f697472 	.word	0x6f697472
   1cf20:	6146206e 	.word	0x6146206e
   1cf24:	72756c69 	.word	0x72756c69
   1cf28:	43202c65 	.word	0x43202c65
   1cf2c:	69646e6f 	.word	0x69646e6f
   1cf30:	6e6f6974 	.word	0x6e6f6974
   1cf34:	73655420 	.word	0x73655420
   1cf38:	3a646574 	.word	0x3a646574
   1cf3c:	69642820 	.word	0x69642820
   1cf40:	65646976 	.word	0x65646976
   1cf44:	61765f72 	.word	0x61765f72
   1cf48:	2065756c 	.word	0x2065756c
   1cf4c:	2938203c 	.word	0x2938203c
   1cf50:	2020200a 	.word	0x2020200a
   1cf54:	20202020 	.word	0x20202020
   1cf58:	50202020 	.word	0x50202020
   1cf5c:	64204c4c 	.word	0x64204c4c
   1cf60:	64697669 	.word	0x64697669
   1cf64:	76207265 	.word	0x76207265
   1cf68:	65756c61 	.word	0x65756c61
   1cf6c:	6e657720 	.word	0x6e657720
   1cf70:	756f2074 	.word	0x756f2074
   1cf74:	666f2074 	.word	0x666f2074
   1cf78:	756f6220 	.word	0x756f6220
   1cf7c:	1b73646e 	.word	0x1b73646e
   1cf80:	1b6d305b 	.word	0x1b6d305b
   1cf84:	0a6d305b 	.word	0x0a6d305b
   1cf88:	00000000 	.word	0x00000000
   1cf8c:	31345b1b 	.word	0x31345b1b
   1cf90:	4952436d 	.word	0x4952436d
   1cf94:	41434954 	.word	0x41434954
   1cf98:	305b1b4c 	.word	0x305b1b4c
   1cf9c:	6d34393b 	.word	0x6d34393b
   1cfa0:	3a73253a 	.word	0x3a73253a
   1cfa4:	3b305b1b 	.word	0x3b305b1b
   1cfa8:	256d3239 	.word	0x256d3239
   1cfac:	5b1b3a73 	.word	0x5b1b3a73
   1cfb0:	33393b30 	.word	0x33393b30
   1cfb4:	3e64256d 	.word	0x3e64256d
   1cfb8:	305b1b20 	.word	0x305b1b20
   1cfbc:	6d37333b 	.word	0x6d37333b
   1cfc0:	65737341 	.word	0x65737341
   1cfc4:	6f697472 	.word	0x6f697472
   1cfc8:	6146206e 	.word	0x6146206e
   1cfcc:	72756c69 	.word	0x72756c69
   1cfd0:	43202c65 	.word	0x43202c65
   1cfd4:	69646e6f 	.word	0x69646e6f
   1cfd8:	6e6f6974 	.word	0x6e6f6974
   1cfdc:	73655420 	.word	0x73655420
   1cfe0:	3a646574 	.word	0x3a646574
   1cfe4:	61662820 	.word	0x61662820
   1cfe8:	2965736c 	.word	0x2965736c
   1cfec:	2020200a 	.word	0x2020200a
   1cff0:	20202020 	.word	0x20202020
   1cff4:	50202020 	.word	0x50202020
   1cff8:	6c204c4c 	.word	0x6c204c4c
   1cffc:	206b636f 	.word	0x206b636f
   1d000:	6c756f63 	.word	0x6c756f63
   1d004:	6f6e2064 	.word	0x6f6e2064
   1d008:	65622074 	.word	0x65622074
   1d00c:	74736520 	.word	0x74736520
   1d010:	696c6261 	.word	0x696c6261
   1d014:	64656873 	.word	0x64656873
   1d018:	66656220 	.word	0x66656220
   1d01c:	2065726f 	.word	0x2065726f
   1d020:	656d6974 	.word	0x656d6974
   1d024:	1b74756f 	.word	0x1b74756f
   1d028:	1b6d305b 	.word	0x1b6d305b
   1d02c:	0a6d305b 	.word	0x0a6d305b
   1d030:	00000000 	.word	0x00000000
   1d034:	31345b1b 	.word	0x31345b1b
   1d038:	4952436d 	.word	0x4952436d
   1d03c:	41434954 	.word	0x41434954
   1d040:	305b1b4c 	.word	0x305b1b4c
   1d044:	6d34393b 	.word	0x6d34393b
   1d048:	3a73253a 	.word	0x3a73253a
   1d04c:	3b305b1b 	.word	0x3b305b1b
   1d050:	256d3239 	.word	0x256d3239
   1d054:	5b1b3a73 	.word	0x5b1b3a73
   1d058:	33393b30 	.word	0x33393b30
   1d05c:	3e64256d 	.word	0x3e64256d
   1d060:	305b1b20 	.word	0x305b1b20
   1d064:	6d37333b 	.word	0x6d37333b
   1d068:	65737341 	.word	0x65737341
   1d06c:	6f697472 	.word	0x6f697472
   1d070:	6146206e 	.word	0x6146206e
   1d074:	72756c69 	.word	0x72756c69
   1d078:	43202c65 	.word	0x43202c65
   1d07c:	69646e6f 	.word	0x69646e6f
   1d080:	6e6f6974 	.word	0x6e6f6974
   1d084:	73655420 	.word	0x73655420
   1d088:	3a646574 	.word	0x3a646574
   1d08c:	70632820 	.word	0x70632820
   1d090:	69645f75 	.word	0x69645f75
   1d094:	65646976 	.word	0x65646976
   1d098:	203c2072 	.word	0x203c2072
   1d09c:	0a293233 	.word	0x0a293233
   1d0a0:	20202020 	.word	0x20202020
   1d0a4:	20202020 	.word	0x20202020
   1d0a8:	69442020 	.word	0x69442020
   1d0ac:	65646976 	.word	0x65646976
   1d0b0:	756d2072 	.word	0x756d2072
   1d0b4:	276e7473 	.word	0x276e7473
   1d0b8:	78652074 	.word	0x78652074
   1d0bc:	64656563 	.word	0x64656563
   1d0c0:	1b323320 	.word	0x1b323320
   1d0c4:	1b6d305b 	.word	0x1b6d305b
   1d0c8:	0a6d305b 	.word	0x0a6d305b
   1d0cc:	00000000 	.word	0x00000000
   1d0d0:	31345b1b 	.word	0x31345b1b
   1d0d4:	4952436d 	.word	0x4952436d
   1d0d8:	41434954 	.word	0x41434954
   1d0dc:	305b1b4c 	.word	0x305b1b4c
   1d0e0:	6d34393b 	.word	0x6d34393b
   1d0e4:	3a73253a 	.word	0x3a73253a
   1d0e8:	3b305b1b 	.word	0x3b305b1b
   1d0ec:	256d3239 	.word	0x256d3239
   1d0f0:	5b1b3a73 	.word	0x5b1b3a73
   1d0f4:	33393b30 	.word	0x33393b30
   1d0f8:	3e64256d 	.word	0x3e64256d
   1d0fc:	305b1b20 	.word	0x305b1b20
   1d100:	6d37333b 	.word	0x6d37333b
   1d104:	65737341 	.word	0x65737341
   1d108:	6f697472 	.word	0x6f697472
   1d10c:	6146206e 	.word	0x6146206e
   1d110:	72756c69 	.word	0x72756c69
   1d114:	43202c65 	.word	0x43202c65
   1d118:	69646e6f 	.word	0x69646e6f
   1d11c:	6e6f6974 	.word	0x6e6f6974
   1d120:	73655420 	.word	0x73655420
   1d124:	3a646574 	.word	0x3a646574
   1d128:	72662820 	.word	0x72662820
   1d12c:	65757165 	.word	0x65757165
   1d130:	2079636e 	.word	0x2079636e
   1d134:	30203d21 	.word	0x30203d21
   1d138:	20200a29 	.word	0x20200a29
   1d13c:	20202020 	.word	0x20202020
   1d140:	20202020 	.word	0x20202020
   1d144:	6e6e6143 	.word	0x6e6e6143
   1d148:	6820746f 	.word	0x6820746f
   1d14c:	20657661 	.word	0x20657661
   1d150:	6f72657a 	.word	0x6f72657a
   1d154:	63697420 	.word	0x63697420
   1d158:	7020736b 	.word	0x7020736b
   1d15c:	6d207265 	.word	0x6d207265
   1d160:	6f726369 	.word	0x6f726369
   1d164:	6f636573 	.word	0x6f636573
   1d168:	202c646e 	.word	0x202c646e
   1d16c:	61656c70 	.word	0x61656c70
   1d170:	63206573 	.word	0x63206573
   1d174:	736f6f68 	.word	0x736f6f68
   1d178:	20312065 	.word	0x20312065
   1d17c:	6d20726f 	.word	0x6d20726f
   1d180:	2e65726f 	.word	0x2e65726f
   1d184:	6d305b1b 	.word	0x6d305b1b
   1d188:	6d305b1b 	.word	0x6d305b1b
   1d18c:	0000000a 	.word	0x0000000a
   1d190:	33345b1b 	.word	0x33345b1b
   1d194:	4157206d 	.word	0x4157206d
   1d198:	4e494e52 	.word	0x4e494e52
   1d19c:	305b1b47 	.word	0x305b1b47
   1d1a0:	6d34393b 	.word	0x6d34393b
   1d1a4:	3a73253a 	.word	0x3a73253a
   1d1a8:	3b305b1b 	.word	0x3b305b1b
   1d1ac:	256d3239 	.word	0x256d3239
   1d1b0:	5b1b3a73 	.word	0x5b1b3a73
   1d1b4:	33393b30 	.word	0x33393b30
   1d1b8:	3e64256d 	.word	0x3e64256d
   1d1bc:	305b1b20 	.word	0x305b1b20
   1d1c0:	6d37333b 	.word	0x6d37333b
   1d1c4:	74726f50 	.word	0x74726f50
   1d1c8:	20642520 	.word	0x20642520
   1d1cc:	6e6e6163 	.word	0x6e6e6163
   1d1d0:	6220746f 	.word	0x6220746f
   1d1d4:	73752065 	.word	0x73752065
   1d1d8:	66206465 	.word	0x66206465
   1d1dc:	4520726f 	.word	0x4520726f
   1d1e0:	72657478 	.word	0x72657478
   1d1e4:	206c616e 	.word	0x206c616e
   1d1e8:	65746e49 	.word	0x65746e49
   1d1ec:	70757272 	.word	0x70757272
   1d1f0:	202e7374 	.word	0x202e7374
   1d1f4:	6465654e 	.word	0x6465654e
   1d1f8:	206f7420 	.word	0x206f7420
   1d1fc:	20657375 	.word	0x20657375
   1d200:	4f495047 	.word	0x4f495047
   1d204:	206e6f20 	.word	0x206e6f20
   1d208:	74726f50 	.word	0x74726f50
   1d20c:	6f203020 	.word	0x6f203020
   1d210:	2e322072 	.word	0x2e322072
   1d214:	6d305b1b 	.word	0x6d305b1b
   1d218:	6d305b1b 	.word	0x6d305b1b
   1d21c:	0000000a 	.word	0x0000000a
   1d220:	33345b1b 	.word	0x33345b1b
   1d224:	4157206d 	.word	0x4157206d
   1d228:	4e494e52 	.word	0x4e494e52
   1d22c:	305b1b47 	.word	0x305b1b47
   1d230:	6d34393b 	.word	0x6d34393b
   1d234:	3a73253a 	.word	0x3a73253a
   1d238:	3b305b1b 	.word	0x3b305b1b
   1d23c:	256d3239 	.word	0x256d3239
   1d240:	5b1b3a73 	.word	0x5b1b3a73
   1d244:	33393b30 	.word	0x33393b30
   1d248:	3e64256d 	.word	0x3e64256d
   1d24c:	305b1b20 	.word	0x305b1b20
   1d250:	6d37333b 	.word	0x6d37333b
   1d254:	65676445 	.word	0x65676445
   1d258:	20642520 	.word	0x20642520
   1d25c:	6e6e6163 	.word	0x6e6e6163
   1d260:	6220746f 	.word	0x6220746f
   1d264:	73752065 	.word	0x73752065
   1d268:	66206465 	.word	0x66206465
   1d26c:	4520726f 	.word	0x4520726f
   1d270:	72657478 	.word	0x72657478
   1d274:	206c616e 	.word	0x206c616e
   1d278:	65746e49 	.word	0x65746e49
   1d27c:	70757272 	.word	0x70757272
   1d280:	4e2e7374 	.word	0x4e2e7374
   1d284:	20646565 	.word	0x20646565
   1d288:	75206f74 	.word	0x75206f74
   1d28c:	61206573 	.word	0x61206573
   1d290:	73697220 	.word	0x73697220
   1d294:	2c676e69 	.word	0x2c676e69
   1d298:	6c616620 	.word	0x6c616620
   1d29c:	676e696c 	.word	0x676e696c
   1d2a0:	726f202c 	.word	0x726f202c
   1d2a4:	746f6220 	.word	0x746f6220
   1d2a8:	6f632068 	.word	0x6f632068
   1d2ac:	6769666e 	.word	0x6769666e
   1d2b0:	74617275 	.word	0x74617275
   1d2b4:	2e6e6f69 	.word	0x2e6e6f69
   1d2b8:	6d305b1b 	.word	0x6d305b1b
   1d2bc:	0000000a 	.word	0x0000000a
   1d2c0:	31345b1b 	.word	0x31345b1b
   1d2c4:	4952436d 	.word	0x4952436d
   1d2c8:	41434954 	.word	0x41434954
   1d2cc:	305b1b4c 	.word	0x305b1b4c
   1d2d0:	6d34393b 	.word	0x6d34393b
   1d2d4:	3a73253a 	.word	0x3a73253a
   1d2d8:	3b305b1b 	.word	0x3b305b1b
   1d2dc:	256d3239 	.word	0x256d3239
   1d2e0:	5b1b3a73 	.word	0x5b1b3a73
   1d2e4:	33393b30 	.word	0x33393b30
   1d2e8:	3e64256d 	.word	0x3e64256d
   1d2ec:	305b1b20 	.word	0x305b1b20
   1d2f0:	6d37333b 	.word	0x6d37333b
   1d2f4:	65737341 	.word	0x65737341
   1d2f8:	6f697472 	.word	0x6f697472
   1d2fc:	6146206e 	.word	0x6146206e
   1d300:	72756c69 	.word	0x72756c69
   1d304:	43202c65 	.word	0x43202c65
   1d308:	69646e6f 	.word	0x69646e6f
   1d30c:	6e6f6974 	.word	0x6e6f6974
   1d310:	73655420 	.word	0x73655420
   1d314:	3a646574 	.word	0x3a646574
   1d318:	656c2820 	.word	0x656c2820
   1d31c:	756e5f64 	.word	0x756e5f64
   1d320:	7265626d 	.word	0x7265626d
   1d324:	34203c20 	.word	0x34203c20
   1d328:	20200a29 	.word	0x20200a29
   1d32c:	20202020 	.word	0x20202020
   1d330:	20202020 	.word	0x20202020
   1d334:	75706e49 	.word	0x75706e49
   1d338:	654c2074 	.word	0x654c2074
   1d33c:	756e2064 	.word	0x756e2064
   1d340:	7265626d 	.word	0x7265626d
   1d344:	6e616320 	.word	0x6e616320
   1d348:	62207427 	.word	0x62207427
   1d34c:	72672065 	.word	0x72672065
   1d350:	65746165 	.word	0x65746165
   1d354:	68742072 	.word	0x68742072
   1d358:	33206e61 	.word	0x33206e61
   1d35c:	6e69202c 	.word	0x6e69202c
   1d360:	20747570 	.word	0x20747570
   1d364:	6425203d 	.word	0x6425203d
   1d368:	5b1b0a2e 	.word	0x5b1b0a2e
   1d36c:	5b1b6d30 	.word	0x5b1b6d30
   1d370:	000a6d30 	.word	0x000a6d30
   1d374:	756c6f56 	.word	0x756c6f56
   1d378:	6320656d 	.word	0x6320656d
   1d37c:	72746e6f 	.word	0x72746e6f
   1d380:	73206c6f 	.word	0x73206c6f
   1d384:	65746174 	.word	0x65746174
   1d388:	0000000a 	.word	0x0000000a
   1d38c:	79616c50 	.word	0x79616c50
   1d390:	6b636162 	.word	0x6b636162
   1d394:	6e6f6320 	.word	0x6e6f6320
   1d398:	6c6f7274 	.word	0x6c6f7274
   1d39c:	61747320 	.word	0x61747320
   1d3a0:	000a6574 	.word	0x000a6574
   1d3a4:	63617254 	.word	0x63617254
   1d3a8:	6f63206b 	.word	0x6f63206b
   1d3ac:	6f72746e 	.word	0x6f72746e
   1d3b0:	7473206c 	.word	0x7473206c
   1d3b4:	0a657461 	.word	0x0a657461
   1d3b8:	00000000 	.word	0x00000000
   1d3bc:	79616c50 	.word	0x79616c50
   1d3c0:	3a676e69 	.word	0x3a676e69
   1d3c4:	73250a20 	.word	0x73250a20
   1d3c8:	00000a0a 	.word	0x00000a0a
   1d3cc:	79616c50 	.word	0x79616c50
   1d3d0:	3a676e69 	.word	0x3a676e69
   1d3d4:	73250a20 	.word	0x73250a20
   1d3d8:	0000000a 	.word	0x0000000a
   1d3dc:	00000000 	.word	0x00000000
   1d3e0:	79616c70 	.word	0x79616c70
   1d3e4:	00000000 	.word	0x00000000
   1d3e8:	6e65704f 	.word	0x6e65704f
   1d3ec:	74206465 	.word	0x74206465
   1d3f0:	6b636172 	.word	0x6b636172
   1d3f4:	63757320 	.word	0x63757320
   1d3f8:	73736563 	.word	0x73736563
   1d3fc:	6c6c7566 	.word	0x6c6c7566
   1d400:	ff002179 	.word	0xff002179

0001d404 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::file>:
   1d404:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   1d414:	70682e72 ffff0070                       r.hpp...

0001d41c <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file>:
   1d41c:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   1d42c:	70682e72 ffff0070                       r.hpp...

0001d434 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file>:
   1d434:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   1d444:	70682e72 ffff0070                       r.hpp...

0001d44c <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::file>:
   1d44c:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   1d45c:	70682e72 ffff0070                       r.hpp...

0001d464 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::file>:
   1d464:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   1d474:	70682e72 ffff0070                       r.hpp...

0001d47c <Timer::kPowerbit>:
   1d47c:	00000001 00000002 00000016 00000017     ................

0001d48c <Timer::kTimerIrq>:
   1d48c:	04030201                                ....

0001d490 <Timer::kTimerIsr>:
   1d490:	00014be9 00014c25 00014c61 00014c9d     .K..%L..aL...L..

0001d4a0 <Timer::Initialize(unsigned long, void (*)(), long)::file>:
   1d4a0:	656d6974 70682e72 ffff0070              timer.hpp...

0001d4ac <Gpio::ValidPortCheck()::file>:
   1d4ac:	6f697067 7070682e ffffff00              gpio.hpp....

0001d4b8 <Gpio::SetInterruptEdge(GpioInterface::Edge)::file>:
   1d4b8:	6f697067 7070682e ffffff00              gpio.hpp....

0001d4c4 <Gpio::ClearInterruptEdge(GpioInterface::Edge)::file>:
   1d4c4:	6f697067 7070682e ffffff00              gpio.hpp....

0001d4d0 <OnBoardLed::On(unsigned char)::file>:
   1d4d0:	6f626e6f 5f647261 2e64656c 00707068     onboard_led.hpp.

0001d4e0 <OnBoardLed::Off(unsigned char)::file>:
   1d4e0:	6f626e6f 5f647261 2e64656c 00707068     onboard_led.hpp.

0001d4f0 <OnBoardLed::Set(unsigned char, OnBoardLedInterface::LightState)::file>:
   1d4f0:	6f626e6f 5f647261 2e64656c 00707068     onboard_led.hpp.

0001d500 <OnBoardLed::Toggle(unsigned char)::file>:
   1d500:	6f626e6f 5f647261 2e64656c 00707068     onboard_led.hpp.

0001d510 <Ssp::kPinSelect>:
   1d510:	ff040202                                ....

0001d514 <Ssp::kSspPinMatrix>:
   1d514:	0001d728 00001200 0001d728 00001100     (.......(.......
   1d524:	0001d728 00000f00 0001d728 00000900     (.......(.......
   1d534:	0001d728 00000800 0001d728 00000700     (.......(.......
   1d544:	0001d728 00000101 0001d728 00000401     (.......(.......
   1d554:	0001d728 00000001                       (.......

0001d55c <Ssp::kPowerBit>:
   1d55c:	00000015 0000000a 00000014              ............

0001d568 <vtable for Ssd1306>:
	...
   1d570:	00013d01 00013d2d 00013d59 00013eb1     .=..-=..Y=...>..
   1d580:	00013bc1 00013be9 00013f89 00013fc1     .;...;...?...?..
   1d590:	00014055                                U@..

0001d594 <vtable for PixelDisplayInterface>:
	...
   1d59c:	0001c495 0001c495 0001c495 0001c495     ................
   1d5ac:	00013bc1 00013be9 0001c495 0001c495     .;...;..........
   1d5bc:	00013c11                                .<..

0001d5c0 <vtable for Ssp>:
	...
   1d5c8:	00013219 00010729 000107a1 000132fd     .2..)........2..
   1d5d8:	000133e9 000135f5 00013755 00013941     .3...5..U7..A9..
   1d5e8:	fffffffc 00000000 000115dd 0001166d     ............m...
   1d5f8:	000116c5 000116dd 000116f1 00011731     ............1...
   1d608:	00011761                                a...

0001d60c <vtable for SspInterface>:
	...
   1d614:	0001c495 0001c495 0001c495 0001c495     ................
   1d624:	0001c495 0001c495 0001c495 0001c495     ................

0001d634 <vtable for OnBoardLed>:
	...
   1d63c:	00012cf1 00012d61 00012de1 00012e61     .,..a-...-..a...
   1d64c:	00012efd 00012f7d 00012ffd              ....}/.../..

0001d658 <vtable for Gpio>:
	...
   1d660:	00012551 000125cd 00012649 000105f1     Q%...%..I&......
   1d670:	00010655 000106b9 0001268d 000126f9     U........&...&..
   1d680:	00012771 000127e1 00012a79 00012ac1     q'...'..y*...*..
   1d690:	00012889 000128e5 00012969 000129f1     .(...(..i)...)..

0001d6a0 <vtable for GpioInterface>:
	...
   1d6a8:	0001c495 0001c495 0001c495 0001c495     ................
   1d6b8:	0001c495 0001c495 0001c495 0001c495     ................
   1d6c8:	0001c495 0001c495 0001c495 0001c495     ................
   1d6d8:	0001c495 0001c495 0001c495 0001c495     ................

0001d6e8 <vtable for Timer>:
	...
   1d6f0:	00012209 0001236d 00012465 fffffffc     ."..m#..e$......
   1d700:	00000000 000115dd 0001166d 000116c5     ........m.......
   1d710:	000116dd 000116f1 00011731 00011761     ........1...a...

0001d720 <vtable for Pin>:
	...
   1d728:	00011bf9 00011c71 00011cf1 00011d65     ....q.......e...
   1d738:	00011dd9 00011e55 00011ed1 00011f45     ....U.......E...
   1d748:	00011fc1 00012035 000120a9 00012181     ....5 ... ...!..
   1d758:	000121ad                                .!..

0001d75c <vtable for PinInterface>:
	...
   1d764:	0001c495 0001c495 0001c495 0001c495     ................
   1d774:	0001c495 0001c495 0001c495 0001c495     ................
   1d784:	0001c495 0001c495 0001c495 0001c495     ................
   1d794:	0001c495                                ....

0001d798 <vtable for Lpc40xxSystemController>:
	...
   1d7a0:	000115dd 0001166d 000116c5 000116dd     ....m...........
   1d7b0:	000116f1 00011731 00011761              ....1...a...

0001d7bc <vtable for SystemControllerInterface>:
	...
   1d7c4:	0001c495 0001c495 0001c495 0001c495     ................
   1d7d4:	0001c495 0001c495 0001c495              ............

0001d7e0 <Gpio::ClearInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__>:
   1d7e0:	74726976 206c6175 64696f76 69704720     virtual void Gpi
   1d7f0:	433a3a6f 7261656c 65746e49 70757272     o::ClearInterrup
   1d800:	67644574 70472865 6e496f69 66726574     tEdge(GpioInterf
   1d810:	3a656361 6764453a ff002965              ace::Edge)..

0001d81c <Gpio::ValidPortCheck()::__PRETTY_FUNCTION__>:
   1d81c:	6c6f6f62 69704720 563a3a6f 64696c61     bool Gpio::Valid
   1d82c:	74726f50 63656843 0029286b              PortCheck().

0001d838 <Gpio::SetInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__>:
   1d838:	74726976 206c6175 64696f76 69704720     virtual void Gpi
   1d848:	533a3a6f 6e497465 72726574 45747075     o::SetInterruptE
   1d858:	28656764 6f697047 65746e49 63616672     dge(GpioInterfac
   1d868:	453a3a65 29656764 ffffff00              e::Edge)....

0001d874 <OnBoardLed::Toggle(unsigned char)::__PRETTY_FUNCTION__>:
   1d874:	74726976 206c6175 64696f76 426e4f20     virtual void OnB
   1d884:	6472616f 3a64654c 676f543a 28656c67     oardLed::Toggle(
   1d894:	746e6975 29745f38 ffffff00              uint8_t)....

0001d8a0 <OnBoardLed::Set(unsigned char, OnBoardLedInterface::LightState)::__PRETTY_FUNCTION__>:
   1d8a0:	74726976 206c6175 64696f76 426e4f20     virtual void OnB
   1d8b0:	6472616f 3a64654c 7465533a 6e697528     oardLed::Set(uin
   1d8c0:	745f3874 6e4f202c 72616f42 64654c64     t8_t, OnBoardLed
   1d8d0:	65746e49 63616672 4c3a3a65 74686769     Interface::Light
   1d8e0:	74617453 ff002965                       State)..

0001d8e8 <OnBoardLed::Off(unsigned char)::__PRETTY_FUNCTION__>:
   1d8e8:	74726976 206c6175 64696f76 426e4f20     virtual void OnB
   1d8f8:	6472616f 3a64654c 66664f3a 6e697528     oardLed::Off(uin
   1d908:	745f3874 ffff0029                       t8_t)...

0001d910 <OnBoardLed::On(unsigned char)::__PRETTY_FUNCTION__>:
   1d910:	74726976 206c6175 64696f76 426e4f20     virtual void OnB
   1d920:	6472616f 3a64654c 286e4f3a 746e6975     oardLed::On(uint
   1d930:	29745f38 ffffff00                       8_t)....

0001d938 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::__PRETTY_FUNCTION__>:
   1d938:	74726976 206c6175 64696f76 63704c20     virtual void Lpc
   1d948:	78783034 74737953 6f436d65 6f72746e     40xxSystemContro
   1d958:	72656c6c 65533a3a 72655074 65687069     ller::SetPeriphe
   1d968:	436c6172 6b636f6c 69766944 28726564     ralClockDivider(
   1d978:	746e6975 29745f38 ffffff00              uint8_t)....

0001d984 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__>:
   1d984:	746e6975 745f3233 63704c20 78783034     uint32_t Lpc40xx
   1d994:	74737953 6f436d65 6f72746e 72656c6c     SystemController
   1d9a4:	65533a3a 69614d74 6c6c506e 63704c28     ::SetMainPll(Lpc
   1d9b4:	78783034 74737953 6f436d65 6f72746e     40xxSystemContro
   1d9c4:	72656c6c 6c503a3a 706e496c 202c7475     ller::PllInput, 
   1d9d4:	746e6975 745f3631 ffff0029              uint16_t)...

0001d9e0 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__>:
   1d9e0:	746e6975 745f3233 63704c20 78783034     uint32_t Lpc40xx
   1d9f0:	74737953 6f436d65 6f72746e 72656c6c     SystemController
   1da00:	61433a3a 6c75636c 50657461 4c286c6c     ::CalculatePll(L
   1da10:	30346370 79537878 6d657473 746e6f43     pc40xxSystemCont
   1da20:	6c6c6f72 3a3a7265 496c6c50 7475706e     roller::PllInput
   1da30:	6975202c 3631746e 0029745f              , uint16_t).

0001da3c <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::__PRETTY_FUNCTION__>:
   1da3c:	64696f76 63704c20 78783034 74737953     void Lpc40xxSyst
   1da4c:	6f436d65 6f72746e 72656c6c 65533a3a     emController::Se
   1da5c:	75704374 636f6c43 7669446b 72656469     tCpuClockDivider
   1da6c:	6e697528 745f3874 ffff0029              (uint8_t)...

0001da78 <Timer::Initialize(unsigned long, void (*)(), long)::__PRETTY_FUNCTION__>:
   1da78:	74726976 206c6175 64696f76 6d695420     virtual void Tim
   1da88:	3a3a7265 74696e49 696c6169 7528657a     er::Initialize(u
   1da98:	33746e69 2c745f32 72734920 6e696f50     int32_t, IsrPoin
   1daa8:	2c726574 746e6920 745f3233 ffff0029     ter, int32_t)...
   1dab8:	63617453 6544206b 20687470 7a25203d     Stack Depth = %z
   1dac8:	00000a64 25232020 203a757a 70257830     d...  #%zu: 0x%p
   1dad8:	0000000a 6e75520a 6874203a 6f662065     .....Run: the fo
   1dae8:	776f6c6c 20676e69 6d6d6f63 20646e61     llowing command 
   1daf8:	79206e69 2072756f 6a6f7270 20746365     in your project 
   1db08:	65726964 726f7463 00000079 1b20200a     directory....  .
   1db18:	333b315b 616d6d37 7320656b 6b636174     [1;37mmake stack
   1db28:	63617274 73252d65 41525420 3d534543     trace-%s TRACES=
   1db38:	00000022 70257830 00000000 25783020     "...0x%p.... 0x%
   1db48:	00000070 5b1b0a22 00006d30 73696854     p..."..[0m..This
   1db58:	6c697720 6572206c 74726f70 65687420      will report the
   1db68:	6c696620 6e612065 696c2064 6e20656e      file and line n
   1db78:	65626d75 68742072 6c207461 74206465     umber that led t
   1db88:	6874206f 66207369 74636e75 206e6f69     o this function 
   1db98:	6e696562 61632067 64656c6c 0000002e     being called....
   1dba8:	6c707061 74616369 006e6f69 31345b1b     application..[41
   1dbb8:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   1dbc8:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1dbd8:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1dbe8:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   1dbf8:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   1dc08:	3a646574 65702820 68706972 6c617265     ted: (peripheral
   1dc18:	7669645f 72656469 203d3c20 200a2934     _divider <= 4). 
   1dc28:	20202020 20202020 76694420 72656469              Divider
   1dc38:	73756d20 74276e74 63786520 20646565      mustn't exceed 
   1dc48:	5b1b3233 5b1b6d30 000a6d30 6972500a     32.[0m.[0m...Pri
   1dc58:	6e69746e 74532067 206b6361 63617254     nting Stack Trac
   1dc68:	000a3a65 31345b1b 4952436d 41434954     e:...[41mCRITICA
   1dc78:	305b1b4c 6d34393b 3a73253a 3b305b1b     L.[0;94m:%s:.[0;
   1dc88:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1dc98:	305b1b20 6d37333b 65737341 6f697472      .[0;37mAssertio
   1dca8:	6146206e 72756c69 43202c65 69646e6f     n Failure, Condi
   1dcb8:	6e6f6974 73655420 3a646574 65642820     tion Tested: (de
   1dcc8:	65726973 70735f64 5f646565 6d5f6e69     sired_speed_in_m
   1dcd8:	3c207a68 34383320 20262620 69736564     hz < 384 && desi
   1dce8:	5f646572 65657073 6e695f64 7a686d5f     red_speed_in_mhz
   1dcf8:	31203e20 200a2932 20202020 20202020      > 12).         
   1dd08:	65724620 6e657571 6d207963 20747375      Frequency must 
   1dd18:	6c206562 7265776f 61687420 3833206e     be lower than 38
   1dd28:	484d2034 646e617a 65726720 72657461     4 MHzand greater
   1dd38:	61687420 726f206e 75716520 74206c61      than or equal t
   1dd48:	3231206f 7a484d20 6d305b1b 6d305b1b     o 12 MHz.[0m.[0m
   1dd58:	0000000a 31345b1b 4952436d 41434954     .....[41mCRITICA
   1dd68:	305b1b4c 6d34393b 3a73253a 3b305b1b     L.[0;94m:%s:.[0;
   1dd78:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1dd88:	305b1b20 6d37333b 65737341 6f697472      .[0;37mAssertio
   1dd98:	6146206e 72756c69 43202c65 69646e6f     n Failure, Condi
   1dda8:	6e6f6974 73655420 3a646574 69642820     tion Tested: (di
   1ddb8:	65646976 61765f72 2065756c 2938203c     vider_value < 8)
   1ddc8:	2020200a 20202020 50202020 64204c4c     .          PLL d
   1ddd8:	64697669 76207265 65756c61 6e657720     ivider value wen
   1dde8:	756f2074 666f2074 756f6220 1b73646e     t out of bounds.
   1ddf8:	1b6d305b 0a6d305b 00000000 31345b1b     [0m.[0m......[41
   1de08:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   1de18:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1de28:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1de38:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   1de48:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   1de58:	3a646574 61662820 2965736c 2020200a     ted: (false).   
   1de68:	20202020 50202020 6c204c4c 206b636f            PLL lock 
   1de78:	6c756f63 6f6e2064 65622074 74736520     could not be est
   1de88:	696c6261 64656873 66656220 2065726f     ablished before 
   1de98:	656d6974 1b74756f 1b6d305b 0a6d305b     timeout.[0m.[0m.
   1dea8:	00000000 31345b1b 4952436d 41434954     .....[41mCRITICA
   1deb8:	305b1b4c 6d34393b 3a73253a 3b305b1b     L.[0;94m:%s:.[0;
   1dec8:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1ded8:	305b1b20 6d37333b 65737341 6f697472      .[0;37mAssertio
   1dee8:	6146206e 72756c69 43202c65 69646e6f     n Failure, Condi
   1def8:	6e6f6974 73655420 3a646574 70632820     tion Tested: (cp
   1df08:	69645f75 65646976 203c2072 0a293233     u_divider < 32).
   1df18:	20202020 20202020 69442020 65646976               Divide
   1df28:	756d2072 276e7473 78652074 64656563     r mustn't exceed
   1df38:	1b323320 1b6d305b 0a6d305b 00000000      32.[0m.[0m.....
   1df48:	31345b1b 4952436d 41434954 305b1b4c     .[41mCRITICAL.[0
   1df58:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1df68:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1df78:	6d37333b 65737341 6f697472 6146206e     ;37mAssertion Fa
   1df88:	72756c69 43202c65 69646e6f 6e6f6974     ilure, Condition
   1df98:	73655420 3a646574 72662820 65757165      Tested: (freque
   1dfa8:	2079636e 30203d21 20200a29 20202020     ncy != 0).      
   1dfb8:	20202020 6e6e6143 6820746f 20657661         Cannot have 
   1dfc8:	6f72657a 63697420 7020736b 6d207265     zero ticks per m
   1dfd8:	6f726369 6f636573 202c646e 61656c70     icrosecond, plea
   1dfe8:	63206573 736f6f68 20312065 6d20726f     se choose 1 or m
   1dff8:	2e65726f 6d305b1b 6d305b1b 0000000a     ore..[0m.[0m....
   1e008:	33345b1b 4157206d 4e494e52 305b1b47     .[43m WARNING.[0
   1e018:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1e028:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1e038:	6d37333b 74737953 54206d65 72656d69     ;37mSystem Timer
   1e048:	73616820 49414620 2044454c 73206f74      has FAILED to s
   1e058:	74726174 305b1b21 305b1b6d ff000a6d     tart!.[0m.[0m...

0001e068 <Uart::kTxUartPortFunction>:
   1e068:	05020201                                ....

0001e06c <Uart::kRxUartPortFunction>:
   1e06c:	03020201                                ....

0001e070 <Uart::kPowerbit>:
   1e070:	00000003 00000018 00000019 00000008     ................

0001e080 <LowLevelInit()::file>:
   1e080:	72617473 2e707574 00707063              startup.cpp.

0001e08c <vtable for Uart>:
	...
   1e094:	00015891 0001595d 00015a8d 00015bc1     .X..]Y...Z...[..
   1e0a4:	fffffffc 00000000 000115dd 0001166d     ............m...
   1e0b4:	000116c5 000116dd 000116f1 00011731     ............1...
   1e0c4:	00011761                                a...

0001e0c8 <vtable for SystemTimer>:
	...
   1e0d0:	0001570d 00015741 000157dd fffffffc     .W..AW...W......
   1e0e0:	00000000 000115dd 0001166d 000116c5     ........m.......
   1e0f0:	000116dd 000116f1 00011731 00011761     ........1...a...

0001e100 <LowLevelInit()::__PRETTY_FUNCTION__>:
   1e100:	64696f76 776f4c20 6576654c 696e496c     void LowLevelIni
   1e110:	00292874 63617453 6544206b 20687470     t().Stack Depth 
   1e120:	7a25203d 00000a64 25232020 203a757a     = %zd...  #%zu: 
   1e130:	70257830 0000000a 6e75520a 6874203a     0x%p.....Run: th
   1e140:	6f662065 776f6c6c 20676e69 6d6d6f63     e following comm
   1e150:	20646e61 79206e69 2072756f 6a6f7270     and in your proj
   1e160:	20746365 65726964 726f7463 00000079     ect directory...
   1e170:	1b20200a 333b315b 616d6d37 7320656b     .  .[1;37mmake s
   1e180:	6b636174 63617274 73252d65 41525420     tacktrace-%s TRA
   1e190:	3d534543 00000022 70257830 00000000     CES="...0x%p....
   1e1a0:	25783020 00000070 5b1b0a22 00006d30      0x%p..."..[0m..
   1e1b0:	73696854 6c697720 6572206c 74726f70     This will report
   1e1c0:	65687420 6c696620 6e612065 696c2064      the file and li
   1e1d0:	6e20656e 65626d75 68742072 6c207461     ne number that l
   1e1e0:	74206465 6874206f 66207369 74636e75     ed to this funct
   1e1f0:	206e6f69 6e696562 61632067 64656c6c     ion being called
   1e200:	0000002e 6c707061 74616369 006e6f69     ....application.
   1e210:	31345b1b 4952436d 41434954 305b1b4c     .[41mCRITICAL.[0
   1e220:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1e230:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1e240:	6d37333b 65737341 6f697472 6146206e     ;37mAssertion Fa
   1e250:	72756c69 43202c65 69646e6f 6e6f6974     ilure, Condition
   1e260:	73655420 3a646574 73692820 3d212072      Tested: (isr !=
   1e270:	746e4920 75727265 6f4c7470 70756b6f      InterruptLookup
   1e280:	646e6148 2972656c 2020200a 20202020     Handler).       
   1e290:	4e202020 5349206f 6f662052 20646e75        No ISR found 
   1e2a0:	20726f66 20656874 74636576 2520726f     for the vector %
   1e2b0:	305b1b75 305b1b6d 00000a6d 6972500a     u.[0m.[0m....Pri
   1e2c0:	6e69746e 74532067 206b6361 63617254     nting Stack Trac
   1e2d0:	000a3a65 31345b1b 7261486d 61462064     e:...[41mHard Fa
   1e2e0:	20746c75 65637845 6f697470 634f206e     ult Exception Oc
   1e2f0:	72727563 0a216465 6d305b1b 00000000     curred!..[0m....
   1e300:	203a3072 30257830 2c586c38 3a317220     r0: 0x%08lX, r1:
   1e310:	25783020 586c3830 3272202c 7830203a      0x%08lX, r2: 0x
   1e320:	6c383025 72202c58 30203a33 38302578     %08lX, r3: 0x%08
   1e330:	000a586c 3a323172 25783020 586c3830     lX..r12: 0x%08lX
   1e340:	726c202c 7830203a 6c383025 70202c58     , lr: 0x%08lX, p
   1e350:	30203a63 38302578 202c586c 3a727370     c: 0x%08lX, psr:
   1e360:	25783020 586c3830 ffff000a               0x%08lX....

0001e36c <InterruptLookupHandler::file>:
   1e36c:	65746e69 70757272 70632e74 ffff0070     interrupt.cpp...

0001e37c <InterruptLookupHandler::__PRETTY_FUNCTION__>:
   1e37c:	64696f76 746e4920 75727265 6f4c7470     void InterruptLo
   1e38c:	70756b6f 646e6148 2872656c ffff0029     okupHandler()...
   1e39c:	454c4449 00000000 09632509 25097525     IDLE.....%c.%u.%
   1e3ac:	75250975 00000a0d 09752509 25752509     u.%u.....%u..%u%
   1e3bc:	000a0d25 09752509 25313c09 000a0d25     %....%u..<1%%...

0001e3cc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)::pow10>:
   1e3cc:	3f800000 41200000 42c80000 447a0000     ...?.. A...B..zD
   1e3dc:	461c4000 47c35000 49742400 4b189680     .@.F.P.G.$tI...K
   1e3ec:	4cbebc20 4e6e6b28 63617453 6544206b      ..L(knNStack De
   1e3fc:	20687470 7a25203d 00000a64 25232020     pth = %zd...  #%
   1e40c:	203a757a 70257830 0000000a 6e75520a     zu: 0x%p.....Run
   1e41c:	6874203a 6f662065 776f6c6c 20676e69     : the following 
   1e42c:	6d6d6f63 20646e61 79206e69 2072756f     command in your 
   1e43c:	6a6f7270 20746365 65726964 726f7463     project director
   1e44c:	00000079 1b20200a 333b315b 616d6d37     y....  .[1;37mma
   1e45c:	7320656b 6b636174 63617274 73252d65     ke stacktrace-%s
   1e46c:	41525420 3d534543 00000022 70257830      TRACES="...0x%p
   1e47c:	00000000 25783020 00000070 5b1b0a22     .... 0x%p..."..[
   1e48c:	00006d30 73696854 6c697720 6572206c     0m..This will re
   1e49c:	74726f70 65687420 6c696620 6e612065     port the file an
   1e4ac:	696c2064 6e20656e 65626d75 68742072     d line number th
   1e4bc:	6c207461 74206465 6874206f 66207369     at led to this f
   1e4cc:	74636e75 206e6f69 6e696562 61632067     unction being ca
   1e4dc:	64656c6c 0000002e 6c707061 74616369     lled....applicat
   1e4ec:	006e6f69 33345b1b 4157206d 4e494e52     ion..[43m WARNIN
   1e4fc:	305b1b47 6d34393b 3a73253a 3b305b1b     G.[0;94m:%s:.[0;
   1e50c:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1e51c:	305b1b20 6d37333b 74726f50 20642520      .[0;37mPort %d 
   1e52c:	6e6e6163 6220746f 73752065 66206465     cannot be used f
   1e53c:	4520726f 72657478 206c616e 65746e49     or External Inte
   1e54c:	70757272 202e7374 6465654e 206f7420     rrupts. Need to 
   1e55c:	20657375 4f495047 206e6f20 74726f50     use GPIO on Port
   1e56c:	6f203020 2e322072 6d305b1b 6d305b1b      0 or 2..[0m.[0m
   1e57c:	0000000a 33345b1b 4157206d 4e494e52     .....[43m WARNIN
   1e58c:	305b1b47 6d34393b 3a73253a 3b305b1b     G.[0;94m:%s:.[0;
   1e59c:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1e5ac:	305b1b20 6d37333b 65676445 20642520      .[0;37mEdge %d 
   1e5bc:	6e6e6163 6220746f 73752065 66206465     cannot be used f
   1e5cc:	4520726f 72657478 206c616e 65746e49     or External Inte
   1e5dc:	70757272 4e2e7374 20646565 75206f74     rrupts.Need to u
   1e5ec:	61206573 73697220 2c676e69 6c616620     se a rising, fal
   1e5fc:	676e696c 726f202c 746f6220 6f632068     ling, or both co
   1e60c:	6769666e 74617275 2e6e6f69 6d305b1b     nfiguration..[0m
   1e61c:	0000000a 31345b1b 4952436d 41434954     .....[41mCRITICA
   1e62c:	305b1b4c 6d34393b 3a73253a 3b305b1b     L.[0;94m:%s:.[0;
   1e63c:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1e64c:	305b1b20 6d37333b 65737341 6f697472      .[0;37mAssertio
   1e65c:	6146206e 72756c69 43202c65 69646e6f     n Failure, Condi
   1e66c:	6e6f6974 73655420 3a646574 65702820     tion Tested: (pe
   1e67c:	68706972 6c617265 7669645f 72656469     ripheral_divider
   1e68c:	203d3c20 200a2934 20202020 20202020      <= 4).         
   1e69c:	76694420 72656469 73756d20 74276e74      Divider mustn't
   1e6ac:	63786520 20646565 5b1b3233 5b1b6d30      exceed 32.[0m.[
   1e6bc:	000a6d30 6972500a 6e69746e 74532067     0m...Printing St
   1e6cc:	206b6361 63617254 000a3a65 31345b1b     ack Trace:...[41
   1e6dc:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   1e6ec:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1e6fc:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1e70c:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   1e71c:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   1e72c:	3a646574 65642820 65726973 70735f64     ted: (desired_sp
   1e73c:	5f646565 6d5f6e69 3c207a68 34383320     eed_in_mhz < 384
   1e74c:	20262620 69736564 5f646572 65657073      && desired_spee
   1e75c:	6e695f64 7a686d5f 31203e20 200a2932     d_in_mhz > 12). 
   1e76c:	20202020 20202020 65724620 6e657571              Frequen
   1e77c:	6d207963 20747375 6c206562 7265776f     cy must be lower
   1e78c:	61687420 3833206e 484d2034 646e617a      than 384 MHzand
   1e79c:	65726720 72657461 61687420 726f206e      greater than or
   1e7ac:	75716520 74206c61 3231206f 7a484d20      equal to 12 MHz
   1e7bc:	6d305b1b 6d305b1b 0000000a 31345b1b     .[0m.[0m.....[41
   1e7cc:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   1e7dc:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1e7ec:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1e7fc:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   1e80c:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   1e81c:	3a646574 69642820 65646976 61765f72     ted: (divider_va
   1e82c:	2065756c 2938203c 2020200a 20202020     lue < 8).       
   1e83c:	50202020 64204c4c 64697669 76207265        PLL divider v
   1e84c:	65756c61 6e657720 756f2074 666f2074     alue went out of
   1e85c:	756f6220 1b73646e 1b6d305b 0a6d305b      bounds.[0m.[0m.
   1e86c:	00000000 31345b1b 4952436d 41434954     .....[41mCRITICA
   1e87c:	305b1b4c 6d34393b 3a73253a 3b305b1b     L.[0;94m:%s:.[0;
   1e88c:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1e89c:	305b1b20 6d37333b 65737341 6f697472      .[0;37mAssertio
   1e8ac:	6146206e 72756c69 43202c65 69646e6f     n Failure, Condi
   1e8bc:	6e6f6974 73655420 3a646574 61662820     tion Tested: (fa
   1e8cc:	2965736c 2020200a 20202020 50202020     lse).          P
   1e8dc:	6c204c4c 206b636f 6c756f63 6f6e2064     LL lock could no
   1e8ec:	65622074 74736520 696c6261 64656873     t be established
   1e8fc:	66656220 2065726f 656d6974 1b74756f      before timeout.
   1e90c:	1b6d305b 0a6d305b 00000000 31345b1b     [0m.[0m......[41
   1e91c:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   1e92c:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1e93c:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1e94c:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   1e95c:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   1e96c:	3a646574 70632820 69645f75 65646976     ted: (cpu_divide
   1e97c:	203c2072 0a293233 20202020 20202020     r < 32).        
   1e98c:	69442020 65646976 756d2072 276e7473       Divider mustn'
   1e99c:	78652074 64656563 1b323320 1b6d305b     t exceed 32.[0m.
   1e9ac:	0a6d305b 00000000 35345b1b 2020206d     [0m......[45m   
   1e9bc:	4f525245 305b1b52 6d34393b 3a73253a     ERROR.[0;94m:%s:
   1e9cc:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1e9dc:	3e64256d 305b1b20 6d37333b 6c696146     m%d> .[0;37mFail
   1e9ec:	74206465 6e69206f 61697469 53206574     ed to initiate S
   1e9fc:	6d204950 2065646f 68746977 74206e69     PI mode within t
   1ea0c:	6f656d69 202e7475 726f6241 676e6974     imeout. Aborting
   1ea1c:	305b1b21 00000a6d 35345b1b 2020206d     !.[0m....[45m   
   1ea2c:	4f525245 305b1b52 6d34393b 3a73253a     ERROR.[0;94m:%s:
   1ea3c:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1ea4c:	3e64256d 305b1b20 6d37333b 70736552     m%d> .[0;37mResp
   1ea5c:	65736e6f 746e6920 69726765 63207974     onse integrity c
   1ea6c:	6b636568 69616620 2e64656c 6f624120     heck failed. Abo
   1ea7c:	6e697472 5b1b2167 000a6d30 35345b1b     rting!.[0m...[45
   1ea8c:	2020206d 4f525245 305b1b52 6d34393b     m   ERROR.[0;94m
   1ea9c:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1eaac:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1eabc:	75736e55 726f7070 20646574 746c6f76     Unsupported volt
   1eacc:	20656761 75206e69 202e6573 726f6241     age in use. Abor
   1eadc:	676e6974 305b1b21 00000a6d 35345b1b     ting!.[0m....[45
   1eaec:	2020206d 4f525245 305b1b52 6d34393b     m   ERROR.[0;94m
   1eafc:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1eb0c:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1eb1c:	43204453 20647261 656d6974 756f2064     SD Card timed ou
   1eb2c:	41202e74 74726f62 21676e69 6d305b1b     t. Aborting!.[0m
   1eb3c:	0000000a 65757274 00000000 736c6166     ....true....fals
   1eb4c:	00000065 35345b1b 2020206d 4f525245     e....[45m   ERRO
   1eb5c:	305b1b52 6d34393b 3a73253a 3b305b1b     R.[0;94m:%s:.[0;
   1eb6c:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1eb7c:	305b1b20 6d37333b 6c696857 65522065      .[0;37mWhile Re
   1eb8c:	6e696461 6c422067 206b636f 20642523     ading Block #%d 
   1eb9c:	31435243 5b1b3a36 000a6d30 35345b1b     CRC16:.[0m...[45
   1ebac:	2020206d 4f525245 305b1b52 6d34393b     m   ERROR.[0;94m
   1ebbc:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1ebcc:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1ebdc:	65707845 64657463 78302720 58343025     Expected '0x%04X
   1ebec:	305b1b27 00000a6d 35345b1b 2020206d     '.[0m....[45m   
   1ebfc:	4f525245 305b1b52 6d34393b 3a73253a     ERROR.[0;94m:%s:
   1ec0c:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1ec1c:	3e64256d 305b1b20 6d37333b 20746f47     m%d> .[0;37mGot 
   1ec2c:	25783027 27583430 6d305b1b 0000000a     '0x%04X'.[0m....
   1ec3c:	35345b1b 2020206d 4f525245 305b1b52     .[45m   ERROR.[0
   1ec4c:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1ec5c:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1ec6c:	6d37333b 64616552 646d4320 73617720     ;37mRead Cmd was
   1ec7c:	746f6e20 6b636120 6c776f6e 65676465      not acknowledge
   1ec8c:	72702064 7265706f 1b21796c 0a6d305b     d properly!.[0m.
   1ec9c:	00000000 35345b1b 2020206d 4f525245     .....[45m   ERRO
   1ecac:	305b1b52 6d34393b 3a73253a 3b305b1b     R.[0;94m:%s:.[0;
   1ecbc:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1eccc:	305b1b20 6d37333b 61726150 6574656d      .[0;37mParamete
   1ecdc:	72452072 25203a72 305b1b73 00000a6d     r Err: %s.[0m...
   1ecec:	35345b1b 2020206d 4f525245 305b1b52     .[45m   ERROR.[0
   1ecfc:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1ed0c:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1ed1c:	6d37333b 72646441 72724520 7325203a     ;37mAddr Err: %s
   1ed2c:	6d305b1b 0000000a 35345b1b 2020206d     .[0m.....[45m   
   1ed3c:	4f525245 305b1b52 6d34393b 3a73253a     ERROR.[0;94m:%s:
   1ed4c:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1ed5c:	3e64256d 305b1b20 6d37333b 73617245     m%d> .[0;37mEras
   1ed6c:	65532065 72452071 25203a72 305b1b73     e Seq Err: %s.[0
   1ed7c:	00000a6d 35345b1b 2020206d 4f525245     m....[45m   ERRO
   1ed8c:	305b1b52 6d34393b 3a73253a 3b305b1b     R.[0;94m:%s:.[0;
   1ed9c:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1edac:	305b1b20 6d37333b 206d6f43 20435243      .[0;37mCom CRC 
   1edbc:	3a727245 1b732520 0a6d305b 00000000     Err: %s.[0m.....
   1edcc:	35345b1b 2020206d 4f525245 305b1b52     .[45m   ERROR.[0
   1eddc:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1edec:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1edfc:	6d37333b 656c6c49 206c6167 20646d43     ;37mIllegal Cmd 
   1ee0c:	3a727245 1b732520 0a6d305b 00000000     Err: %s.[0m.....
   1ee1c:	35345b1b 2020206d 4f525245 305b1b52     .[45m   ERROR.[0
   1ee2c:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1ee3c:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1ee4c:	6d37333b 73617245 65522065 3a746573     ;37mErase Reset:
   1ee5c:	1b732520 0a6d305b 00000000 35345b1b      %s.[0m......[45
   1ee6c:	2020206d 4f525245 305b1b52 6d34393b     m   ERROR.[0;94m
   1ee7c:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1ee8c:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1ee9c:	49206e49 3a656c64 1b732520 0a6d305b     In Idle: %s.[0m.
   1eeac:	00000000 35345b1b 2020206d 4f525245     .....[45m   ERRO
   1eebc:	305b1b52 6d34393b 3a73253a 3b305b1b     R.[0;94m:%s:.[0;
   1eecc:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1eedc:	305b1b20 6d37333b 6c696146 74206465      .[0;37mFailed t
   1eeec:	6573206f 74532074 20747261 72646441     o set Start Addr
   1eefc:	21737365 6d305b1b 0000000a 35345b1b     ess!.[0m.....[45
   1ef0c:	2020206d 4f525245 305b1b52 6d34393b     m   ERROR.[0;94m
   1ef1c:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1ef2c:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1ef3c:	6c696146 74206465 6573206f 6e452074     Failed to set En
   1ef4c:	64412064 73657264 5b1b2173 000a6d30     d Address!.[0m..
   1ef5c:	35345b1b 2020206d 4f525245 305b1b52     .[45m   ERROR.[0
   1ef6c:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1ef7c:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1ef8c:	6d37333b 6e6b6e55 206e776f 70736572     ;37mUnknown resp
   1ef9c:	65736e6f 70797420 41202e65 74726f62     onse type. Abort
   1efac:	21676e69 6d305b1b 0000000a 35345b1b     ing!.[0m.....[45
   1efbc:	2020206d 4f525245 305b1b52 6d34393b     m   ERROR.[0;94m
   1efcc:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1efdc:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1efec:	70736552 65736e6f 736e7520 6f707075     Response unsuppo
   1effc:	64657472 206e6920 20495053 65646f6d     rted in SPI mode
   1f00c:	6241202e 6974726f 1b21676e 0a6d305b     . Aborting!.[0m.
   1f01c:	ffffff00                                ....

0001f020 <Sd::kCrcTable8>:
   1f020:	1b120900 3f362d24 535a4148 777e656c     ....$-6?HAZSle~w
   1f030:	020b1019 262f343d 4a435851 6e677c75     ....=4/&QXCJu|gn
   1f040:	29203b32 0d041f16 6168737a 454c575e     2; )....zsha^WLE
   1f050:	3039222b 141d060f 78716a63 5c554e47     +"90....cjqxGNU\
   1f060:	7f766d64 5b524940 373e252c 131a0108     dmv.@IR[,%>7....
   1f070:	666f747d 424b5059 2e273c35 0a031811     }tofYPKB5<'.....
   1f080:	4d445f56 69607b72 050c171e 2128333a     V_DMr{`i....:3(!
   1f090:	545d464f 7079626b 1c150e07 38312a23     OF]Tkbyp....#*18
   1f0a0:	5a534841 7e776c65 121b0009 363f242d     AHSZelw~....-$?6
   1f0b0:	434a5158 676e757c 0b021910 2f263d34     XQJC|ung....4=&/
   1f0c0:	68617a73 4c455e57 2029323b 040d161f     szahW^EL;2) ....
   1f0d0:	7178636a 555c474e 39302b22 1d140f06     jcxqNG\U"+09....
   1f0e0:	3e372c25 1a130801 767f646d 525b4049     %,7>....md.vI@[R
   1f0f0:	272e353c 030a1118 6f667d74 4b425950     <5.'....t}foPYBK
   1f100:	0c051e17 28213a33 444d565f 6069727b     ....3:!(_VMD{ri`
   1f110:	151c070e 3138232a 5d544f46 00706b62     ....*#81FOT]bkp.

0001f120 <Sd::kCrcTable16>:
   1f120:	10210000 30632042 50a54084 70e760c6     ..!.B c0.@.P.`.p
   1f130:	91298108 b16ba14a d1adc18c f1efe1ce     ..).J.k.........
   1f140:	02101231 22523273 429452b5 62d672f7     1...s2R".R.B.r.b
   1f150:	83189339 a35ab37b c39cd3bd e3def3ff     9...{.Z.........
   1f160:	34432462 14010420 74c764e6 548544a4     b$C4 ....d.t.D.T
   1f170:	b54ba56a 95098528 f5cfe5ee d58dc5ac     j.K.(...........
   1f180:	26723653 06301611 66f676d7 46b45695     S6r&..0..v.f.V.F
   1f190:	a77ab75b 87389719 e7fef7df c7bcd79d     [.z...8.........
   1f1a0:	58e548c4 78a76886 18610840 38232802     .H.X.h.x@.a..(#8
   1f1b0:	d9edc9cc f9afe98e 99698948 b92ba90a     ........H.i...+.
   1f1c0:	4ad45af5 6a967ab7 0a501a71 2a123a33     .Z.J.z.jq.P.3:.*
   1f1d0:	cbdcdbfd eb9efbbf 8b589b79 ab1abb3b     ........y.X.;...
   1f1e0:	7c876ca6 5cc54ce4 3c032c22 1c410c60     .l.|.L.\",.<`.A.
   1f1f0:	fd8fedae ddcdcdec bd0bad2a 9d498d68     ........*...h.I.
   1f200:	6eb67e97 4ef45ed5 2e323e13 0e701e51     .~.n.^.N.>2.Q.p.
   1f210:	efbeff9f cffcdfdd af3abf1b 8f789f59     ..........:.Y.x.
   1f220:	81a99188 a1ebb1ca c12dd10c e16ff14e     ..........-.N.o.
   1f230:	00a11080 20e330c2 40255004 60677046     .....0. .P%@Fpg`
   1f240:	939883b9 b3daa3fb d31cc33d f35ee37f     ........=.....^.
   1f250:	129002b1 32d222f3 52144235 72566277     .....".25B.RwbVr
   1f260:	a5cbb5ea 858995a8 e54ff56e c50dd52c     ........n.O.,...
   1f270:	24c334e2 048114a0 64477466 44055424     .4.$....ftGd$T.D
   1f280:	b7faa7db 97b88799 f77ee75f d73cc71d     ........_.~...<.
   1f290:	36f226d3 16b00691 76766657 56344615     .&.6....Wfvv.F4V
   1f2a0:	c96dd94c e92ff90e 89e999c8 a9abb98a     L.m.../.........
   1f2b0:	48655844 68277806 08e118c0 28a33882     DXeH.x'h.....8.(
   1f2c0:	db5ccb7d fb1eeb3f 9bd88bf9 bb9aabbb     }.\.?...........
   1f2d0:	5a544a75 7a166a37 1ad00af1 3a922ab3     uJTZ7j.z.....*.:
   1f2e0:	ed0ffd2e cd4ddd6c ad8bbdaa 8dc99de8     ....l.M.........
   1f2f0:	6c077c26 4c455c64 2c833ca2 0cc11ce0     &|.ld\EL.<.,....
   1f300:	ff3eef1f df7ccf5d bfbaaf9b 9ff88fd9     ..>.].|.........
   1f310:	7e366e17 5e744e55 3eb22e93 1ef00ed1     .n6~UNt^...>....

0001f320 <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1f320:	682e6473 ff007070                       sd.hpp..

0001f328 <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1f328:	682e6473 ff007070                       sd.hpp..

0001f330 <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1f330:	682e6473 ff007070                       sd.hpp..

0001f338 <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1f338:	682e6473 ff007070                       sd.hpp..

0001f340 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1f340:	682e6473 ff007070                       sd.hpp..

0001f348 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1f348:	682e6473 ff007070                       sd.hpp..

0001f350 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1f350:	682e6473 ff007070                       sd.hpp..

0001f358 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1f358:	682e6473 ff007070                       sd.hpp..

0001f360 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1f360:	682e6473 ff007070                       sd.hpp..

0001f368 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1f368:	682e6473 ff007070                       sd.hpp..

0001f370 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1f370:	682e6473 ff007070                       sd.hpp..

0001f378 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1f378:	682e6473 ff007070                       sd.hpp..

0001f380 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1f380:	682e6473 ff007070                       sd.hpp..

0001f388 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1f388:	682e6473 ff007070                       sd.hpp..

0001f390 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1f390:	682e6473 ff007070                       sd.hpp..

0001f398 <Sd::DeleteBlock(unsigned long, unsigned long)::file>:
   1f398:	682e6473 ff007070                       sd.hpp..

0001f3a0 <Sd::DeleteBlock(unsigned long, unsigned long)::file>:
   1f3a0:	682e6473 ff007070                       sd.hpp..

0001f3a8 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file>:
   1f3a8:	682e6473 ff007070                       sd.hpp..

0001f3b0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file>:
   1f3b0:	682e6473 ff007070                       sd.hpp..

0001f3b8 <vtable for Sd>:
	...
   1f3c0:	0001953d 00018995 00018a45 00018e59     =.......E...Y...
   1f3d0:	00019271 0001941d 000199dd 00019a25     q...........%...
   1f3e0:	00019a95                                ....

0001f3e4 <vtable for SdInterface>:
	...
   1f3ec:	0001c495 0001c495 0001c495 0001c495     ................
   1f3fc:	0001c495 0001c495 0001c495 0001c495     ................
   1f40c:	0001c495                                ....

0001f410 <Sd::Mount(SdInterface::CardInfo_t*)::__PRETTY_FUNCTION__>:
   1f410:	74726976 206c6175 6c6f6f62 3a645320     virtual bool Sd:
   1f420:	756f4d3a 5328746e 746e4964 61667265     :Mount(SdInterfa
   1f430:	3a3a6563 64726143 6f666e49 292a745f     ce::CardInfo_t*)
   1f440:	ffffff00                                ....

0001f444 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::__PRETTY_FUNCTION__>:
   1f444:	74726976 206c6175 746e6975 20745f38     virtual uint8_t 
   1f454:	3a3a6453 64616552 636f6c42 6975286b     Sd::ReadBlock(ui
   1f464:	3233746e 202c745f 746e6975 2a745f38     nt32_t, uint8_t*
   1f474:	6975202c 3233746e 0029745f              , uint32_t).

0001f480 <Sd::DeleteBlock(unsigned long, unsigned long)::__PRETTY_FUNCTION__>:
   1f480:	74726976 206c6175 746e6975 20745f38     virtual uint8_t 
   1f490:	3a3a6453 656c6544 6c426574 286b636f     Sd::DeleteBlock(
   1f4a0:	746e6975 745f3233 6975202c 3233746e     uint32_t, uint32
   1f4b0:	0029745f                                _t).

0001f4b4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::__PRETTY_FUNCTION__>:
   1f4b4:	74726976 206c6175 746e6975 745f3233     virtual uint32_t
   1f4c4:	3a645320 6e65533a 646d4364 49645328      Sd::SendCmd(SdI
   1f4d4:	7265746e 65636166 6f433a3a 6e616d6d     nterface::Comman
   1f4e4:	75202c64 33746e69 2c745f32 6e697520     d, uint32_t, uin
   1f4f4:	745f3874 75202c2a 33746e69 2c745f32     t8_t*, uint32_t,
   1f504:	49645320 7265746e 65636166 654b3a3a      SdInterface::Ke
   1f514:	6c417065 29657669 ffffff00 2c2b2a22     epAlive)...."*+,
   1f524:	3d3c3b3a 5d5b3f3e 00007f7c 00544146     :;<=>?[]|...FAT.
   1f534:	33544146 ffff0032                       FAT32...

0001f53c <__sf_fake_stderr>:
	...

0001f55c <__sf_fake_stdin>:
	...

0001f57c <__sf_fake_stdout>:
	...
